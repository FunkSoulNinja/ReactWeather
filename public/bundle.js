/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(4);
	module.exports = __webpack_require__(6);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2)(__webpack_require__(3))

/***/ },
/* 2 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(src) {
		if (typeof execScript === "function")
			execScript(src);
		else
			eval.call(null, src);
	}

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = "\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! jQuery v2.2.1 | (c) jQuery Foundation | jquery.org/license */\n!function (a, b) {\n  \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) && \"object\" == _typeof(module.exports) ? module.exports = a.document ? b(a, !0) : function (a) {\n    if (!a.document) throw new Error(\"jQuery requires a window with a document\");return b(a);\n  } : b(a);\n}(\"undefined\" != typeof window ? window : undefined, function (a, b) {\n  var c = [],\n      d = a.document,\n      e = c.slice,\n      f = c.concat,\n      g = c.push,\n      h = c.indexOf,\n      i = {},\n      j = i.toString,\n      k = i.hasOwnProperty,\n      l = {},\n      m = \"2.2.1\",\n      n = function n(a, b) {\n    return new n.fn.init(a, b);\n  },\n      o = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n      p = /^-ms-/,\n      q = /-([\\da-z])/gi,\n      r = function r(a, b) {\n    return b.toUpperCase();\n  };n.fn = n.prototype = { jquery: m, constructor: n, selector: \"\", length: 0, toArray: function toArray() {\n      return e.call(this);\n    }, get: function get(a) {\n      return null != a ? 0 > a ? this[a + this.length] : this[a] : e.call(this);\n    }, pushStack: function pushStack(a) {\n      var b = n.merge(this.constructor(), a);return b.prevObject = this, b.context = this.context, b;\n    }, each: function each(a) {\n      return n.each(this, a);\n    }, map: function map(a) {\n      return this.pushStack(n.map(this, function (b, c) {\n        return a.call(b, c, b);\n      }));\n    }, slice: function slice() {\n      return this.pushStack(e.apply(this, arguments));\n    }, first: function first() {\n      return this.eq(0);\n    }, last: function last() {\n      return this.eq(-1);\n    }, eq: function eq(a) {\n      var b = this.length,\n          c = +a + (0 > a ? b : 0);return this.pushStack(c >= 0 && b > c ? [this[c]] : []);\n    }, end: function end() {\n      return this.prevObject || this.constructor();\n    }, push: g, sort: c.sort, splice: c.splice }, n.extend = n.fn.extend = function () {\n    var a,\n        b,\n        c,\n        d,\n        e,\n        f,\n        g = arguments[0] || {},\n        h = 1,\n        i = arguments.length,\n        j = !1;for (\"boolean\" == typeof g && (j = g, g = arguments[h] || {}, h++), \"object\" == (typeof g === \"undefined\" ? \"undefined\" : _typeof(g)) || n.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++) {\n      if (null != (a = arguments[h])) for (b in a) {\n        c = g[b], d = a[b], g !== d && (j && d && (n.isPlainObject(d) || (e = n.isArray(d))) ? (e ? (e = !1, f = c && n.isArray(c) ? c : []) : f = c && n.isPlainObject(c) ? c : {}, g[b] = n.extend(j, f, d)) : void 0 !== d && (g[b] = d));\n      }\n    }return g;\n  }, n.extend({ expando: \"jQuery\" + (m + Math.random()).replace(/\\D/g, \"\"), isReady: !0, error: function error(a) {\n      throw new Error(a);\n    }, noop: function noop() {}, isFunction: function isFunction(a) {\n      return \"function\" === n.type(a);\n    }, isArray: Array.isArray, isWindow: function isWindow(a) {\n      return null != a && a === a.window;\n    }, isNumeric: function isNumeric(a) {\n      var b = a && a.toString();return !n.isArray(a) && b - parseFloat(b) + 1 >= 0;\n    }, isPlainObject: function isPlainObject(a) {\n      return \"object\" !== n.type(a) || a.nodeType || n.isWindow(a) ? !1 : a.constructor && !k.call(a.constructor.prototype, \"isPrototypeOf\") ? !1 : !0;\n    }, isEmptyObject: function isEmptyObject(a) {\n      var b;for (b in a) {\n        return !1;\n      }return !0;\n    }, type: function type(a) {\n      return null == a ? a + \"\" : \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) || \"function\" == typeof a ? i[j.call(a)] || \"object\" : typeof a === \"undefined\" ? \"undefined\" : _typeof(a);\n    }, globalEval: function globalEval(a) {\n      var b,\n          c = eval;a = n.trim(a), a && (1 === a.indexOf(\"use strict\") ? (b = d.createElement(\"script\"), b.text = a, d.head.appendChild(b).parentNode.removeChild(b)) : c(a));\n    }, camelCase: function camelCase(a) {\n      return a.replace(p, \"ms-\").replace(q, r);\n    }, nodeName: function nodeName(a, b) {\n      return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();\n    }, each: function each(a, b) {\n      var c,\n          d = 0;if (s(a)) {\n        for (c = a.length; c > d; d++) {\n          if (b.call(a[d], d, a[d]) === !1) break;\n        }\n      } else for (d in a) {\n        if (b.call(a[d], d, a[d]) === !1) break;\n      }return a;\n    }, trim: function trim(a) {\n      return null == a ? \"\" : (a + \"\").replace(o, \"\");\n    }, makeArray: function makeArray(a, b) {\n      var c = b || [];return null != a && (s(Object(a)) ? n.merge(c, \"string\" == typeof a ? [a] : a) : g.call(c, a)), c;\n    }, inArray: function inArray(a, b, c) {\n      return null == b ? -1 : h.call(b, a, c);\n    }, merge: function merge(a, b) {\n      for (var c = +b.length, d = 0, e = a.length; c > d; d++) {\n        a[e++] = b[d];\n      }return a.length = e, a;\n    }, grep: function grep(a, b, c) {\n      for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) {\n        d = !b(a[f], f), d !== h && e.push(a[f]);\n      }return e;\n    }, map: function map(a, b, c) {\n      var d,\n          e,\n          g = 0,\n          h = [];if (s(a)) for (d = a.length; d > g; g++) {\n        e = b(a[g], g, c), null != e && h.push(e);\n      } else for (g in a) {\n        e = b(a[g], g, c), null != e && h.push(e);\n      }return f.apply([], h);\n    }, guid: 1, proxy: function proxy(a, b) {\n      var c, d, f;return \"string\" == typeof b && (c = a[b], b = a, a = c), n.isFunction(a) ? (d = e.call(arguments, 2), f = function f() {\n        return a.apply(b || this, d.concat(e.call(arguments)));\n      }, f.guid = a.guid = a.guid || n.guid++, f) : void 0;\n    }, now: Date.now, support: l }), \"function\" == typeof Symbol && (n.fn[Symbol.iterator] = c[Symbol.iterator]), n.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function (a, b) {\n    i[\"[object \" + b + \"]\"] = b.toLowerCase();\n  });function s(a) {\n    var b = !!a && \"length\" in a && a.length,\n        c = n.type(a);return \"function\" === c || n.isWindow(a) ? !1 : \"array\" === c || 0 === b || \"number\" == typeof b && b > 0 && b - 1 in a;\n  }var t = function (a) {\n    var b,\n        c,\n        d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        j,\n        k,\n        l,\n        m,\n        n,\n        o,\n        p,\n        q,\n        r,\n        s,\n        t,\n        u = \"sizzle\" + 1 * new Date(),\n        v = a.document,\n        w = 0,\n        x = 0,\n        y = ga(),\n        z = ga(),\n        A = ga(),\n        B = function B(a, b) {\n      return a === b && (l = !0), 0;\n    },\n        C = 1 << 31,\n        D = {}.hasOwnProperty,\n        E = [],\n        F = E.pop,\n        G = E.push,\n        H = E.push,\n        I = E.slice,\n        J = function J(a, b) {\n      for (var c = 0, d = a.length; d > c; c++) {\n        if (a[c] === b) return c;\n      }return -1;\n    },\n        K = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n        L = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n        M = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n        N = \"\\\\[\" + L + \"*(\" + M + \")(?:\" + L + \"*([*^$|!~]?=)\" + L + \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + M + \"))|)\" + L + \"*\\\\]\",\n        O = \":(\" + M + \")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + N + \")*)|.*)\\\\)|)\",\n        P = new RegExp(L + \"+\", \"g\"),\n        Q = new RegExp(\"^\" + L + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + L + \"+$\", \"g\"),\n        R = new RegExp(\"^\" + L + \"*,\" + L + \"*\"),\n        S = new RegExp(\"^\" + L + \"*([>+~]|\" + L + \")\" + L + \"*\"),\n        T = new RegExp(\"=\" + L + \"*([^\\\\]'\\\"]*?)\" + L + \"*\\\\]\", \"g\"),\n        U = new RegExp(O),\n        V = new RegExp(\"^\" + M + \"$\"),\n        W = { ID: new RegExp(\"^#(\" + M + \")\"), CLASS: new RegExp(\"^\\\\.(\" + M + \")\"), TAG: new RegExp(\"^(\" + M + \"|[*])\"), ATTR: new RegExp(\"^\" + N), PSEUDO: new RegExp(\"^\" + O), CHILD: new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + L + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + L + \"*(?:([+-]|)\" + L + \"*(\\\\d+)|))\" + L + \"*\\\\)|)\", \"i\"), bool: new RegExp(\"^(?:\" + K + \")$\", \"i\"), needsContext: new RegExp(\"^\" + L + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + L + \"*((?:-\\\\d)?\\\\d*)\" + L + \"*\\\\)|)(?=[^-]|$)\", \"i\") },\n        X = /^(?:input|select|textarea|button)$/i,\n        Y = /^h\\d$/i,\n        Z = /^[^{]+\\{\\s*\\[native \\w/,\n        $ = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n        _ = /[+~]/,\n        aa = /'|\\\\/g,\n        ba = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + L + \"?|(\" + L + \")|.)\", \"ig\"),\n        ca = function ca(a, b, c) {\n      var d = \"0x\" + b - 65536;return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320);\n    },\n        da = function da() {\n      m();\n    };try {\n      H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType;\n    } catch (ea) {\n      H = { apply: E.length ? function (a, b) {\n          G.apply(a, I.call(b));\n        } : function (a, b) {\n          var c = a.length,\n              d = 0;while (a[c++] = b[d++]) {}a.length = c - 1;\n        } };\n    }function fa(a, b, d, e) {\n      var f,\n          h,\n          j,\n          k,\n          l,\n          o,\n          r,\n          s,\n          w = b && b.ownerDocument,\n          x = b ? b.nodeType : 9;if (d = d || [], \"string\" != typeof a || !a || 1 !== x && 9 !== x && 11 !== x) return d;if (!e && ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, p)) {\n        if (11 !== x && (o = $.exec(a))) if (f = o[1]) {\n          if (9 === x) {\n            if (!(j = b.getElementById(f))) return d;if (j.id === f) return d.push(j), d;\n          } else if (w && (j = w.getElementById(f)) && t(b, j) && j.id === f) return d.push(j), d;\n        } else {\n          if (o[2]) return H.apply(d, b.getElementsByTagName(a)), d;if ((f = o[3]) && c.getElementsByClassName && b.getElementsByClassName) return H.apply(d, b.getElementsByClassName(f)), d;\n        }if (c.qsa && !A[a + \" \"] && (!q || !q.test(a))) {\n          if (1 !== x) w = b, s = a;else if (\"object\" !== b.nodeName.toLowerCase()) {\n            (k = b.getAttribute(\"id\")) ? k = k.replace(aa, \"\\\\$&\") : b.setAttribute(\"id\", k = u), r = g(a), h = r.length, l = V.test(k) ? \"#\" + k : \"[id='\" + k + \"']\";while (h--) {\n              r[h] = l + \" \" + qa(r[h]);\n            }s = r.join(\",\"), w = _.test(a) && oa(b.parentNode) || b;\n          }if (s) try {\n            return H.apply(d, w.querySelectorAll(s)), d;\n          } catch (y) {} finally {\n            k === u && b.removeAttribute(\"id\");\n          }\n        }\n      }return i(a.replace(Q, \"$1\"), b, d, e);\n    }function ga() {\n      var a = [];function b(c, e) {\n        return a.push(c + \" \") > d.cacheLength && delete b[a.shift()], b[c + \" \"] = e;\n      }return b;\n    }function ha(a) {\n      return a[u] = !0, a;\n    }function ia(a) {\n      var b = n.createElement(\"div\");try {\n        return !!a(b);\n      } catch (c) {\n        return !1;\n      } finally {\n        b.parentNode && b.parentNode.removeChild(b), b = null;\n      }\n    }function ja(a, b) {\n      var c = a.split(\"|\"),\n          e = c.length;while (e--) {\n        d.attrHandle[c[e]] = b;\n      }\n    }function ka(a, b) {\n      var c = b && a,\n          d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C);if (d) return d;if (c) while (c = c.nextSibling) {\n        if (c === b) return -1;\n      }return a ? 1 : -1;\n    }function la(a) {\n      return function (b) {\n        var c = b.nodeName.toLowerCase();return \"input\" === c && b.type === a;\n      };\n    }function ma(a) {\n      return function (b) {\n        var c = b.nodeName.toLowerCase();return (\"input\" === c || \"button\" === c) && b.type === a;\n      };\n    }function na(a) {\n      return ha(function (b) {\n        return b = +b, ha(function (c, d) {\n          var e,\n              f = a([], c.length, b),\n              g = f.length;while (g--) {\n            c[e = f[g]] && (c[e] = !(d[e] = c[e]));\n          }\n        });\n      });\n    }function oa(a) {\n      return a && \"undefined\" != typeof a.getElementsByTagName && a;\n    }c = fa.support = {}, f = fa.isXML = function (a) {\n      var b = a && (a.ownerDocument || a).documentElement;return b ? \"HTML\" !== b.nodeName : !1;\n    }, m = fa.setDocument = function (a) {\n      var b,\n          e,\n          g = a ? a.ownerDocument || a : v;return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = n.documentElement, p = !f(n), (e = n.defaultView) && e.top !== e && (e.addEventListener ? e.addEventListener(\"unload\", da, !1) : e.attachEvent && e.attachEvent(\"onunload\", da)), c.attributes = ia(function (a) {\n        return a.className = \"i\", !a.getAttribute(\"className\");\n      }), c.getElementsByTagName = ia(function (a) {\n        return a.appendChild(n.createComment(\"\")), !a.getElementsByTagName(\"*\").length;\n      }), c.getElementsByClassName = Z.test(n.getElementsByClassName), c.getById = ia(function (a) {\n        return o.appendChild(a).id = u, !n.getElementsByName || !n.getElementsByName(u).length;\n      }), c.getById ? (d.find.ID = function (a, b) {\n        if (\"undefined\" != typeof b.getElementById && p) {\n          var c = b.getElementById(a);return c ? [c] : [];\n        }\n      }, d.filter.ID = function (a) {\n        var b = a.replace(ba, ca);return function (a) {\n          return a.getAttribute(\"id\") === b;\n        };\n      }) : (delete d.find.ID, d.filter.ID = function (a) {\n        var b = a.replace(ba, ca);return function (a) {\n          var c = \"undefined\" != typeof a.getAttributeNode && a.getAttributeNode(\"id\");return c && c.value === b;\n        };\n      }), d.find.TAG = c.getElementsByTagName ? function (a, b) {\n        return \"undefined\" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0;\n      } : function (a, b) {\n        var c,\n            d = [],\n            e = 0,\n            f = b.getElementsByTagName(a);if (\"*\" === a) {\n          while (c = f[e++]) {\n            1 === c.nodeType && d.push(c);\n          }return d;\n        }return f;\n      }, d.find.CLASS = c.getElementsByClassName && function (a, b) {\n        return \"undefined\" != typeof b.getElementsByClassName && p ? b.getElementsByClassName(a) : void 0;\n      }, r = [], q = [], (c.qsa = Z.test(n.querySelectorAll)) && (ia(function (a) {\n        o.appendChild(a).innerHTML = \"<a id='\" + u + \"'></a><select id='\" + u + \"-\\r\\\\' msallowcapture=''><option selected=''></option></select>\", a.querySelectorAll(\"[msallowcapture^='']\").length && q.push(\"[*^$]=\" + L + \"*(?:''|\\\"\\\")\"), a.querySelectorAll(\"[selected]\").length || q.push(\"\\\\[\" + L + \"*(?:value|\" + K + \")\"), a.querySelectorAll(\"[id~=\" + u + \"-]\").length || q.push(\"~=\"), a.querySelectorAll(\":checked\").length || q.push(\":checked\"), a.querySelectorAll(\"a#\" + u + \"+*\").length || q.push(\".#.+[+~]\");\n      }), ia(function (a) {\n        var b = n.createElement(\"input\");b.setAttribute(\"type\", \"hidden\"), a.appendChild(b).setAttribute(\"name\", \"D\"), a.querySelectorAll(\"[name=d]\").length && q.push(\"name\" + L + \"*[*^$|!~]?=\"), a.querySelectorAll(\":enabled\").length || q.push(\":enabled\", \":disabled\"), a.querySelectorAll(\"*,:x\"), q.push(\",.*:\");\n      })), (c.matchesSelector = Z.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ia(function (a) {\n        c.disconnectedMatch = s.call(a, \"div\"), s.call(a, \"[s!='']:x\"), r.push(\"!=\", O);\n      }), q = q.length && new RegExp(q.join(\"|\")), r = r.length && new RegExp(r.join(\"|\")), b = Z.test(o.compareDocumentPosition), t = b || Z.test(o.contains) ? function (a, b) {\n        var c = 9 === a.nodeType ? a.documentElement : a,\n            d = b && b.parentNode;return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)));\n      } : function (a, b) {\n        if (b) while (b = b.parentNode) {\n          if (b === a) return !0;\n        }return !1;\n      }, B = b ? function (a, b) {\n        if (a === b) return l = !0, 0;var d = !a.compareDocumentPosition - !b.compareDocumentPosition;return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === n || a.ownerDocument === v && t(v, a) ? -1 : b === n || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1);\n      } : function (a, b) {\n        if (a === b) return l = !0, 0;var c,\n            d = 0,\n            e = a.parentNode,\n            f = b.parentNode,\n            g = [a],\n            h = [b];if (!e || !f) return a === n ? -1 : b === n ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0;if (e === f) return ka(a, b);c = a;while (c = c.parentNode) {\n          g.unshift(c);\n        }c = b;while (c = c.parentNode) {\n          h.unshift(c);\n        }while (g[d] === h[d]) {\n          d++;\n        }return d ? ka(g[d], h[d]) : g[d] === v ? -1 : h[d] === v ? 1 : 0;\n      }, n) : n;\n    }, fa.matches = function (a, b) {\n      return fa(a, null, null, b);\n    }, fa.matchesSelector = function (a, b) {\n      if ((a.ownerDocument || a) !== n && m(a), b = b.replace(T, \"='$1']\"), c.matchesSelector && p && !A[b + \" \"] && (!r || !r.test(b)) && (!q || !q.test(b))) try {\n        var d = s.call(a, b);if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;\n      } catch (e) {}return fa(b, n, null, [a]).length > 0;\n    }, fa.contains = function (a, b) {\n      return (a.ownerDocument || a) !== n && m(a), t(a, b);\n    }, fa.attr = function (a, b) {\n      (a.ownerDocument || a) !== n && m(a);var e = d.attrHandle[b.toLowerCase()],\n          f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null;\n    }, fa.error = function (a) {\n      throw new Error(\"Syntax error, unrecognized expression: \" + a);\n    }, fa.uniqueSort = function (a) {\n      var b,\n          d = [],\n          e = 0,\n          f = 0;if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {\n        while (b = a[f++]) {\n          b === a[f] && (e = d.push(f));\n        }while (e--) {\n          a.splice(d[e], 1);\n        }\n      }return k = null, a;\n    }, e = fa.getText = function (a) {\n      var b,\n          c = \"\",\n          d = 0,\n          f = a.nodeType;if (f) {\n        if (1 === f || 9 === f || 11 === f) {\n          if (\"string\" == typeof a.textContent) return a.textContent;for (a = a.firstChild; a; a = a.nextSibling) {\n            c += e(a);\n          }\n        } else if (3 === f || 4 === f) return a.nodeValue;\n      } else while (b = a[d++]) {\n        c += e(b);\n      }return c;\n    }, d = fa.selectors = { cacheLength: 50, createPseudo: ha, match: W, attrHandle: {}, find: {}, relative: { \">\": { dir: \"parentNode\", first: !0 }, \" \": { dir: \"parentNode\" }, \"+\": { dir: \"previousSibling\", first: !0 }, \"~\": { dir: \"previousSibling\" } }, preFilter: { ATTR: function ATTR(a) {\n          return a[1] = a[1].replace(ba, ca), a[3] = (a[3] || a[4] || a[5] || \"\").replace(ba, ca), \"~=\" === a[2] && (a[3] = \" \" + a[3] + \" \"), a.slice(0, 4);\n        }, CHILD: function CHILD(a) {\n          return a[1] = a[1].toLowerCase(), \"nth\" === a[1].slice(0, 3) ? (a[3] || fa.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * (\"even\" === a[3] || \"odd\" === a[3])), a[5] = +(a[7] + a[8] || \"odd\" === a[3])) : a[3] && fa.error(a[0]), a;\n        }, PSEUDO: function PSEUDO(a) {\n          var b,\n              c = !a[6] && a[2];return W.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || \"\" : c && U.test(c) && (b = g(c, !0)) && (b = c.indexOf(\")\", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3));\n        } }, filter: { TAG: function TAG(a) {\n          var b = a.replace(ba, ca).toLowerCase();return \"*\" === a ? function () {\n            return !0;\n          } : function (a) {\n            return a.nodeName && a.nodeName.toLowerCase() === b;\n          };\n        }, CLASS: function CLASS(a) {\n          var b = y[a + \" \"];return b || (b = new RegExp(\"(^|\" + L + \")\" + a + \"(\" + L + \"|$)\")) && y(a, function (a) {\n            return b.test(\"string\" == typeof a.className && a.className || \"undefined\" != typeof a.getAttribute && a.getAttribute(\"class\") || \"\");\n          });\n        }, ATTR: function ATTR(a, b, c) {\n          return function (d) {\n            var e = fa.attr(d, a);return null == e ? \"!=\" === b : b ? (e += \"\", \"=\" === b ? e === c : \"!=\" === b ? e !== c : \"^=\" === b ? c && 0 === e.indexOf(c) : \"*=\" === b ? c && e.indexOf(c) > -1 : \"$=\" === b ? c && e.slice(-c.length) === c : \"~=\" === b ? (\" \" + e.replace(P, \" \") + \" \").indexOf(c) > -1 : \"|=\" === b ? e === c || e.slice(0, c.length + 1) === c + \"-\" : !1) : !0;\n          };\n        }, CHILD: function CHILD(a, b, c, d, e) {\n          var f = \"nth\" !== a.slice(0, 3),\n              g = \"last\" !== a.slice(-4),\n              h = \"of-type\" === b;return 1 === d && 0 === e ? function (a) {\n            return !!a.parentNode;\n          } : function (b, c, i) {\n            var j,\n                k,\n                l,\n                m,\n                n,\n                o,\n                p = f !== g ? \"nextSibling\" : \"previousSibling\",\n                q = b.parentNode,\n                r = h && b.nodeName.toLowerCase(),\n                s = !i && !h,\n                t = !1;if (q) {\n              if (f) {\n                while (p) {\n                  m = b;while (m = m[p]) {\n                    if (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) return !1;\n                  }o = p = \"only\" === a && !o && \"nextSibling\";\n                }return !0;\n              }if (o = [g ? q.firstChild : q.lastChild], g && s) {\n                m = q, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n && j[2], m = n && q.childNodes[n];while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) {\n                  if (1 === m.nodeType && ++t && m === b) {\n                    k[a] = [w, n, t];break;\n                  }\n                }\n              } else if (s && (m = b, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n), t === !1) while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) {\n                if ((h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) && ++t && (s && (l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), k[a] = [w, t]), m === b)) break;\n              }return t -= e, t === d || t % d === 0 && t / d >= 0;\n            }\n          };\n        }, PSEUDO: function PSEUDO(a, b) {\n          var c,\n              e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || fa.error(\"unsupported pseudo: \" + a);return e[u] ? e(b) : e.length > 1 ? (c = [a, a, \"\", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ha(function (a, c) {\n            var d,\n                f = e(a, b),\n                g = f.length;while (g--) {\n              d = J(a, f[g]), a[d] = !(c[d] = f[g]);\n            }\n          }) : function (a) {\n            return e(a, 0, c);\n          }) : e;\n        } }, pseudos: { not: ha(function (a) {\n          var b = [],\n              c = [],\n              d = h(a.replace(Q, \"$1\"));return d[u] ? ha(function (a, b, c, e) {\n            var f,\n                g = d(a, null, e, []),\n                h = a.length;while (h--) {\n              (f = g[h]) && (a[h] = !(b[h] = f));\n            }\n          }) : function (a, e, f) {\n            return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop();\n          };\n        }), has: ha(function (a) {\n          return function (b) {\n            return fa(a, b).length > 0;\n          };\n        }), contains: ha(function (a) {\n          return a = a.replace(ba, ca), function (b) {\n            return (b.textContent || b.innerText || e(b)).indexOf(a) > -1;\n          };\n        }), lang: ha(function (a) {\n          return V.test(a || \"\") || fa.error(\"unsupported lang: \" + a), a = a.replace(ba, ca).toLowerCase(), function (b) {\n            var c;do {\n              if (c = p ? b.lang : b.getAttribute(\"xml:lang\") || b.getAttribute(\"lang\")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + \"-\");\n            } while ((b = b.parentNode) && 1 === b.nodeType);return !1;\n          };\n        }), target: function target(b) {\n          var c = a.location && a.location.hash;return c && c.slice(1) === b.id;\n        }, root: function root(a) {\n          return a === o;\n        }, focus: function focus(a) {\n          return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);\n        }, enabled: function enabled(a) {\n          return a.disabled === !1;\n        }, disabled: function disabled(a) {\n          return a.disabled === !0;\n        }, checked: function checked(a) {\n          var b = a.nodeName.toLowerCase();return \"input\" === b && !!a.checked || \"option\" === b && !!a.selected;\n        }, selected: function selected(a) {\n          return a.parentNode && a.parentNode.selectedIndex, a.selected === !0;\n        }, empty: function empty(a) {\n          for (a = a.firstChild; a; a = a.nextSibling) {\n            if (a.nodeType < 6) return !1;\n          }return !0;\n        }, parent: function parent(a) {\n          return !d.pseudos.empty(a);\n        }, header: function header(a) {\n          return Y.test(a.nodeName);\n        }, input: function input(a) {\n          return X.test(a.nodeName);\n        }, button: function button(a) {\n          var b = a.nodeName.toLowerCase();return \"input\" === b && \"button\" === a.type || \"button\" === b;\n        }, text: function text(a) {\n          var b;return \"input\" === a.nodeName.toLowerCase() && \"text\" === a.type && (null == (b = a.getAttribute(\"type\")) || \"text\" === b.toLowerCase());\n        }, first: na(function () {\n          return [0];\n        }), last: na(function (a, b) {\n          return [b - 1];\n        }), eq: na(function (a, b, c) {\n          return [0 > c ? c + b : c];\n        }), even: na(function (a, b) {\n          for (var c = 0; b > c; c += 2) {\n            a.push(c);\n          }return a;\n        }), odd: na(function (a, b) {\n          for (var c = 1; b > c; c += 2) {\n            a.push(c);\n          }return a;\n        }), lt: na(function (a, b, c) {\n          for (var d = 0 > c ? c + b : c; --d >= 0;) {\n            a.push(d);\n          }return a;\n        }), gt: na(function (a, b, c) {\n          for (var d = 0 > c ? c + b : c; ++d < b;) {\n            a.push(d);\n          }return a;\n        }) } }, d.pseudos.nth = d.pseudos.eq;for (b in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) {\n      d.pseudos[b] = la(b);\n    }for (b in { submit: !0, reset: !0 }) {\n      d.pseudos[b] = ma(b);\n    }function pa() {}pa.prototype = d.filters = d.pseudos, d.setFilters = new pa(), g = fa.tokenize = function (a, b) {\n      var c,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k = z[a + \" \"];if (k) return b ? 0 : k.slice(0);h = a, i = [], j = d.preFilter;while (h) {\n        (!c || (e = R.exec(h))) && (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = S.exec(h)) && (c = e.shift(), f.push({ value: c, type: e[0].replace(Q, \" \") }), h = h.slice(c.length));for (g in d.filter) {\n          !(e = W[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({ value: c, type: g, matches: e }), h = h.slice(c.length));\n        }if (!c) break;\n      }return b ? h.length : h ? fa.error(a) : z(a, i).slice(0);\n    };function qa(a) {\n      for (var b = 0, c = a.length, d = \"\"; c > b; b++) {\n        d += a[b].value;\n      }return d;\n    }function ra(a, b, c) {\n      var d = b.dir,\n          e = c && \"parentNode\" === d,\n          f = x++;return b.first ? function (b, c, f) {\n        while (b = b[d]) {\n          if (1 === b.nodeType || e) return a(b, c, f);\n        }\n      } : function (b, c, g) {\n        var h,\n            i,\n            j,\n            k = [w, f];if (g) {\n          while (b = b[d]) {\n            if ((1 === b.nodeType || e) && a(b, c, g)) return !0;\n          }\n        } else while (b = b[d]) {\n          if (1 === b.nodeType || e) {\n            if (j = b[u] || (b[u] = {}), i = j[b.uniqueID] || (j[b.uniqueID] = {}), (h = i[d]) && h[0] === w && h[1] === f) return k[2] = h[2];if (i[d] = k, k[2] = a(b, c, g)) return !0;\n          }\n        }\n      };\n    }function sa(a) {\n      return a.length > 1 ? function (b, c, d) {\n        var e = a.length;while (e--) {\n          if (!a[e](b, c, d)) return !1;\n        }return !0;\n      } : a[0];\n    }function ta(a, b, c) {\n      for (var d = 0, e = b.length; e > d; d++) {\n        fa(a, b[d], c);\n      }return c;\n    }function ua(a, b, c, d, e) {\n      for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++) {\n        (f = a[h]) && (!c || c(f, d, e)) && (g.push(f), j && b.push(h));\n      }return g;\n    }function va(a, b, c, d, e, f) {\n      return d && !d[u] && (d = va(d)), e && !e[u] && (e = va(e, f)), ha(function (f, g, h, i) {\n        var j,\n            k,\n            l,\n            m = [],\n            n = [],\n            o = g.length,\n            p = f || ta(b || \"*\", h.nodeType ? [h] : h, []),\n            q = !a || !f && b ? p : ua(p, m, a, h, i),\n            r = c ? e || (f ? a : o || d) ? [] : g : q;if (c && c(q, r, h, i), d) {\n          j = ua(r, n), d(j, [], h, i), k = j.length;while (k--) {\n            (l = j[k]) && (r[n[k]] = !(q[n[k]] = l));\n          }\n        }if (f) {\n          if (e || a) {\n            if (e) {\n              j = [], k = r.length;while (k--) {\n                (l = r[k]) && j.push(q[k] = l);\n              }e(null, r = [], j, i);\n            }k = r.length;while (k--) {\n              (l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l));\n            }\n          }\n        } else r = ua(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r);\n      });\n    }function wa(a) {\n      for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[\" \"], i = g ? 1 : 0, k = ra(function (a) {\n        return a === b;\n      }, h, !0), l = ra(function (a) {\n        return J(b, a) > -1;\n      }, h, !0), m = [function (a, c, d) {\n        var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));return b = null, e;\n      }]; f > i; i++) {\n        if (c = d.relative[a[i].type]) m = [ra(sa(m), c)];else {\n          if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {\n            for (e = ++i; f > e; e++) {\n              if (d.relative[a[e].type]) break;\n            }return va(i > 1 && sa(m), i > 1 && qa(a.slice(0, i - 1).concat({ value: \" \" === a[i - 2].type ? \"*\" : \"\" })).replace(Q, \"$1\"), c, e > i && wa(a.slice(i, e)), f > e && wa(a = a.slice(e)), f > e && qa(a));\n          }m.push(c);\n        }\n      }return sa(m);\n    }function xa(a, b) {\n      var c = b.length > 0,\n          e = a.length > 0,\n          f = function f(_f, g, h, i, k) {\n        var l,\n            o,\n            q,\n            r = 0,\n            s = \"0\",\n            t = _f && [],\n            u = [],\n            v = j,\n            x = _f || e && d.find.TAG(\"*\", k),\n            y = w += null == v ? 1 : Math.random() || .1,\n            z = x.length;for (k && (j = g === n || g || k); s !== z && null != (l = x[s]); s++) {\n          if (e && l) {\n            o = 0, g || l.ownerDocument === n || (m(l), h = !p);while (q = a[o++]) {\n              if (q(l, g || n, h)) {\n                i.push(l);break;\n              }\n            }k && (w = y);\n          }c && ((l = !q && l) && r--, _f && t.push(l));\n        }if (r += s, c && s !== r) {\n          o = 0;while (q = b[o++]) {\n            q(t, u, g, h);\n          }if (_f) {\n            if (r > 0) while (s--) {\n              t[s] || u[s] || (u[s] = F.call(i));\n            }u = ua(u);\n          }H.apply(i, u), k && !_f && u.length > 0 && r + b.length > 1 && fa.uniqueSort(i);\n        }return k && (w = y, j = v), t;\n      };return c ? ha(f) : f;\n    }return h = fa.compile = function (a, b) {\n      var c,\n          d = [],\n          e = [],\n          f = A[a + \" \"];if (!f) {\n        b || (b = g(a)), c = b.length;while (c--) {\n          f = wa(b[c]), f[u] ? d.push(f) : e.push(f);\n        }f = A(a, xa(e, d)), f.selector = a;\n      }return f;\n    }, i = fa.select = function (a, b, e, f) {\n      var i,\n          j,\n          k,\n          l,\n          m,\n          n = \"function\" == typeof a && a,\n          o = !f && g(a = n.selector || a);if (e = e || [], 1 === o.length) {\n        if (j = o[0] = o[0].slice(0), j.length > 2 && \"ID\" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {\n          if (b = (d.find.ID(k.matches[0].replace(ba, ca), b) || [])[0], !b) return e;n && (b = b.parentNode), a = a.slice(j.shift().value.length);\n        }i = W.needsContext.test(a) ? 0 : j.length;while (i--) {\n          if (k = j[i], d.relative[l = k.type]) break;if ((m = d.find[l]) && (f = m(k.matches[0].replace(ba, ca), _.test(j[0].type) && oa(b.parentNode) || b))) {\n            if (j.splice(i, 1), a = f.length && qa(j), !a) return H.apply(e, f), e;break;\n          }\n        }\n      }return (n || h(a, o))(f, b, !p, e, !b || _.test(a) && oa(b.parentNode) || b), e;\n    }, c.sortStable = u.split(\"\").sort(B).join(\"\") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ia(function (a) {\n      return 1 & a.compareDocumentPosition(n.createElement(\"div\"));\n    }), ia(function (a) {\n      return a.innerHTML = \"<a href='#'></a>\", \"#\" === a.firstChild.getAttribute(\"href\");\n    }) || ja(\"type|href|height|width\", function (a, b, c) {\n      return c ? void 0 : a.getAttribute(b, \"type\" === b.toLowerCase() ? 1 : 2);\n    }), c.attributes && ia(function (a) {\n      return a.innerHTML = \"<input/>\", a.firstChild.setAttribute(\"value\", \"\"), \"\" === a.firstChild.getAttribute(\"value\");\n    }) || ja(\"value\", function (a, b, c) {\n      return c || \"input\" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue;\n    }), ia(function (a) {\n      return null == a.getAttribute(\"disabled\");\n    }) || ja(K, function (a, b, c) {\n      var d;return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;\n    }), fa;\n  }(a);n.find = t, n.expr = t.selectors, n.expr[\":\"] = n.expr.pseudos, n.uniqueSort = n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains;var u = function u(a, b, c) {\n    var d = [],\n        e = void 0 !== c;while ((a = a[b]) && 9 !== a.nodeType) {\n      if (1 === a.nodeType) {\n        if (e && n(a).is(c)) break;d.push(a);\n      }\n    }return d;\n  },\n      v = function v(a, b) {\n    for (var c = []; a; a = a.nextSibling) {\n      1 === a.nodeType && a !== b && c.push(a);\n    }return c;\n  },\n      w = n.expr.match.needsContext,\n      x = /^<([\\w-]+)\\s*\\/?>(?:<\\/\\1>|)$/,\n      y = /^.[^:#\\[\\.,]*$/;function z(a, b, c) {\n    if (n.isFunction(b)) return n.grep(a, function (a, d) {\n      return !!b.call(a, d, a) !== c;\n    });if (b.nodeType) return n.grep(a, function (a) {\n      return a === b !== c;\n    });if (\"string\" == typeof b) {\n      if (y.test(b)) return n.filter(b, a, c);b = n.filter(b, a);\n    }return n.grep(a, function (a) {\n      return h.call(b, a) > -1 !== c;\n    });\n  }n.filter = function (a, b, c) {\n    var d = b[0];return c && (a = \":not(\" + a + \")\"), 1 === b.length && 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function (a) {\n      return 1 === a.nodeType;\n    }));\n  }, n.fn.extend({ find: function find(a) {\n      var b,\n          c = this.length,\n          d = [],\n          e = this;if (\"string\" != typeof a) return this.pushStack(n(a).filter(function () {\n        for (b = 0; c > b; b++) {\n          if (n.contains(e[b], this)) return !0;\n        }\n      }));for (b = 0; c > b; b++) {\n        n.find(a, e[b], d);\n      }return d = this.pushStack(c > 1 ? n.unique(d) : d), d.selector = this.selector ? this.selector + \" \" + a : a, d;\n    }, filter: function filter(a) {\n      return this.pushStack(z(this, a || [], !1));\n    }, not: function not(a) {\n      return this.pushStack(z(this, a || [], !0));\n    }, is: function is(a) {\n      return !!z(this, \"string\" == typeof a && w.test(a) ? n(a) : a || [], !1).length;\n    } });var A,\n      B = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n      C = n.fn.init = function (a, b, c) {\n    var e, f;if (!a) return this;if (c = c || A, \"string\" == typeof a) {\n      if (e = \"<\" === a[0] && \">\" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : B.exec(a), !e || !e[1] && b) return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a);if (e[1]) {\n        if (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(e[1], b && b.nodeType ? b.ownerDocument || b : d, !0)), x.test(e[1]) && n.isPlainObject(b)) for (e in b) {\n          n.isFunction(this[e]) ? this[e](b[e]) : this.attr(e, b[e]);\n        }return this;\n      }return f = d.getElementById(e[2]), f && f.parentNode && (this.length = 1, this[0] = f), this.context = d, this.selector = a, this;\n    }return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? void 0 !== c.ready ? c.ready(a) : a(n) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray(a, this));\n  };C.prototype = n.fn, A = n(d);var D = /^(?:parents|prev(?:Until|All))/,\n      E = { children: !0, contents: !0, next: !0, prev: !0 };n.fn.extend({ has: function has(a) {\n      var b = n(a, this),\n          c = b.length;return this.filter(function () {\n        for (var a = 0; c > a; a++) {\n          if (n.contains(this, b[a])) return !0;\n        }\n      });\n    }, closest: function closest(a, b) {\n      for (var c, d = 0, e = this.length, f = [], g = w.test(a) || \"string\" != typeof a ? n(a, b || this.context) : 0; e > d; d++) {\n        for (c = this[d]; c && c !== b; c = c.parentNode) {\n          if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && n.find.matchesSelector(c, a))) {\n            f.push(c);break;\n          }\n        }\n      }return this.pushStack(f.length > 1 ? n.uniqueSort(f) : f);\n    }, index: function index(a) {\n      return a ? \"string\" == typeof a ? h.call(n(a), this[0]) : h.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n    }, add: function add(a, b) {\n      return this.pushStack(n.uniqueSort(n.merge(this.get(), n(a, b))));\n    }, addBack: function addBack(a) {\n      return this.add(null == a ? this.prevObject : this.prevObject.filter(a));\n    } });function F(a, b) {\n    while ((a = a[b]) && 1 !== a.nodeType) {}return a;\n  }n.each({ parent: function parent(a) {\n      var b = a.parentNode;return b && 11 !== b.nodeType ? b : null;\n    }, parents: function parents(a) {\n      return u(a, \"parentNode\");\n    }, parentsUntil: function parentsUntil(a, b, c) {\n      return u(a, \"parentNode\", c);\n    }, next: function next(a) {\n      return F(a, \"nextSibling\");\n    }, prev: function prev(a) {\n      return F(a, \"previousSibling\");\n    }, nextAll: function nextAll(a) {\n      return u(a, \"nextSibling\");\n    }, prevAll: function prevAll(a) {\n      return u(a, \"previousSibling\");\n    }, nextUntil: function nextUntil(a, b, c) {\n      return u(a, \"nextSibling\", c);\n    }, prevUntil: function prevUntil(a, b, c) {\n      return u(a, \"previousSibling\", c);\n    }, siblings: function siblings(a) {\n      return v((a.parentNode || {}).firstChild, a);\n    }, children: function children(a) {\n      return v(a.firstChild);\n    }, contents: function contents(a) {\n      return a.contentDocument || n.merge([], a.childNodes);\n    } }, function (a, b) {\n    n.fn[a] = function (c, d) {\n      var e = n.map(this, b, c);return \"Until\" !== a.slice(-5) && (d = c), d && \"string\" == typeof d && (e = n.filter(d, e)), this.length > 1 && (E[a] || n.uniqueSort(e), D.test(a) && e.reverse()), this.pushStack(e);\n    };\n  });var G = /\\S+/g;function H(a) {\n    var b = {};return n.each(a.match(G) || [], function (a, c) {\n      b[c] = !0;\n    }), b;\n  }n.Callbacks = function (a) {\n    a = \"string\" == typeof a ? H(a) : n.extend({}, a);var b,\n        c,\n        d,\n        e,\n        f = [],\n        g = [],\n        h = -1,\n        i = function i() {\n      for (e = a.once, d = b = !0; g.length; h = -1) {\n        c = g.shift();while (++h < f.length) {\n          f[h].apply(c[0], c[1]) === !1 && a.stopOnFalse && (h = f.length, c = !1);\n        }\n      }a.memory || (c = !1), b = !1, e && (f = c ? [] : \"\");\n    },\n        j = { add: function add() {\n        return f && (c && !b && (h = f.length - 1, g.push(c)), function d(b) {\n          n.each(b, function (b, c) {\n            n.isFunction(c) ? a.unique && j.has(c) || f.push(c) : c && c.length && \"string\" !== n.type(c) && d(c);\n          });\n        }(arguments), c && !b && i()), this;\n      }, remove: function remove() {\n        return n.each(arguments, function (a, b) {\n          var c;while ((c = n.inArray(b, f, c)) > -1) {\n            f.splice(c, 1), h >= c && h--;\n          }\n        }), this;\n      }, has: function has(a) {\n        return a ? n.inArray(a, f) > -1 : f.length > 0;\n      }, empty: function empty() {\n        return f && (f = []), this;\n      }, disable: function disable() {\n        return e = g = [], f = c = \"\", this;\n      }, disabled: function disabled() {\n        return !f;\n      }, lock: function lock() {\n        return e = g = [], c || (f = c = \"\"), this;\n      }, locked: function locked() {\n        return !!e;\n      }, fireWith: function fireWith(a, c) {\n        return e || (c = c || [], c = [a, c.slice ? c.slice() : c], g.push(c), b || i()), this;\n      }, fire: function fire() {\n        return j.fireWith(this, arguments), this;\n      }, fired: function fired() {\n        return !!d;\n      } };return j;\n  }, n.extend({ Deferred: function Deferred(a) {\n      var b = [[\"resolve\", \"done\", n.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", n.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", n.Callbacks(\"memory\")]],\n          c = \"pending\",\n          d = { state: function state() {\n          return c;\n        }, always: function always() {\n          return e.done(arguments).fail(arguments), this;\n        }, then: function then() {\n          var a = arguments;return n.Deferred(function (c) {\n            n.each(b, function (b, f) {\n              var g = n.isFunction(a[b]) && a[b];e[f[1]](function () {\n                var a = g && g.apply(this, arguments);a && n.isFunction(a.promise) ? a.promise().progress(c.notify).done(c.resolve).fail(c.reject) : c[f[0] + \"With\"](this === d ? c.promise() : this, g ? [a] : arguments);\n              });\n            }), a = null;\n          }).promise();\n        }, promise: function promise(a) {\n          return null != a ? n.extend(a, d) : d;\n        } },\n          e = {};return d.pipe = d.then, n.each(b, function (a, f) {\n        var g = f[2],\n            h = f[3];d[f[1]] = g.add, h && g.add(function () {\n          c = h;\n        }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function () {\n          return e[f[0] + \"With\"](this === e ? d : this, arguments), this;\n        }, e[f[0] + \"With\"] = g.fireWith;\n      }), d.promise(e), a && a.call(e, e), e;\n    }, when: function when(a) {\n      var b = 0,\n          c = e.call(arguments),\n          d = c.length,\n          f = 1 !== d || a && n.isFunction(a.promise) ? d : 0,\n          g = 1 === f ? a : n.Deferred(),\n          h = function h(a, b, c) {\n        return function (d) {\n          b[a] = this, c[a] = arguments.length > 1 ? e.call(arguments) : d, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c);\n        };\n      },\n          i,\n          j,\n          k;if (d > 1) for (i = new Array(d), j = new Array(d), k = new Array(d); d > b; b++) {\n        c[b] && n.isFunction(c[b].promise) ? c[b].promise().progress(h(b, j, i)).done(h(b, k, c)).fail(g.reject) : --f;\n      }return f || g.resolveWith(k, c), g.promise();\n    } });var I;n.fn.ready = function (a) {\n    return n.ready.promise().done(a), this;\n  }, n.extend({ isReady: !1, readyWait: 1, holdReady: function holdReady(a) {\n      a ? n.readyWait++ : n.ready(!0);\n    }, ready: function ready(a) {\n      (a === !0 ? --n.readyWait : n.isReady) || (n.isReady = !0, a !== !0 && --n.readyWait > 0 || (I.resolveWith(d, [n]), n.fn.triggerHandler && (n(d).triggerHandler(\"ready\"), n(d).off(\"ready\"))));\n    } });function J() {\n    d.removeEventListener(\"DOMContentLoaded\", J), a.removeEventListener(\"load\", J), n.ready();\n  }n.ready.promise = function (b) {\n    return I || (I = n.Deferred(), \"complete\" === d.readyState || \"loading\" !== d.readyState && !d.documentElement.doScroll ? a.setTimeout(n.ready) : (d.addEventListener(\"DOMContentLoaded\", J), a.addEventListener(\"load\", J))), I.promise(b);\n  }, n.ready.promise();var K = function K(a, b, c, d, e, f, g) {\n    var h = 0,\n        i = a.length,\n        j = null == c;if (\"object\" === n.type(c)) {\n      e = !0;for (h in c) {\n        K(a, b, h, c[h], !0, f, g);\n      }\n    } else if (void 0 !== d && (e = !0, n.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function b(a, _b, c) {\n      return j.call(n(a), c);\n    })), b)) for (; i > h; h++) {\n      b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));\n    }return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;\n  },\n      L = function L(a) {\n    return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType;\n  };function M() {\n    this.expando = n.expando + M.uid++;\n  }M.uid = 1, M.prototype = { register: function register(a, b) {\n      var c = b || {};return a.nodeType ? a[this.expando] = c : Object.defineProperty(a, this.expando, { value: c, writable: !0, configurable: !0 }), a[this.expando];\n    }, cache: function cache(a) {\n      if (!L(a)) return {};var b = a[this.expando];return b || (b = {}, L(a) && (a.nodeType ? a[this.expando] = b : Object.defineProperty(a, this.expando, { value: b, configurable: !0 }))), b;\n    }, set: function set(a, b, c) {\n      var d,\n          e = this.cache(a);if (\"string\" == typeof b) e[b] = c;else for (d in b) {\n        e[d] = b[d];\n      }return e;\n    }, get: function get(a, b) {\n      return void 0 === b ? this.cache(a) : a[this.expando] && a[this.expando][b];\n    }, access: function access(a, b, c) {\n      var d;return void 0 === b || b && \"string\" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, n.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b);\n    }, remove: function remove(a, b) {\n      var c,\n          d,\n          e,\n          f = a[this.expando];if (void 0 !== f) {\n        if (void 0 === b) this.register(a);else {\n          n.isArray(b) ? d = b.concat(b.map(n.camelCase)) : (e = n.camelCase(b), b in f ? d = [b, e] : (d = e, d = d in f ? [d] : d.match(G) || [])), c = d.length;while (c--) {\n            delete f[d[c]];\n          }\n        }(void 0 === b || n.isEmptyObject(f)) && (a.nodeType ? a[this.expando] = void 0 : delete a[this.expando]);\n      }\n    }, hasData: function hasData(a) {\n      var b = a[this.expando];return void 0 !== b && !n.isEmptyObject(b);\n    } };var N = new M(),\n      O = new M(),\n      P = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n      Q = /[A-Z]/g;function R(a, b, c) {\n    var d;if (void 0 === c && 1 === a.nodeType) if (d = \"data-\" + b.replace(Q, \"-$&\").toLowerCase(), c = a.getAttribute(d), \"string\" == typeof c) {\n      try {\n        c = \"true\" === c ? !0 : \"false\" === c ? !1 : \"null\" === c ? null : +c + \"\" === c ? +c : P.test(c) ? n.parseJSON(c) : c;\n      } catch (e) {}O.set(a, b, c);\n    } else c = void 0;return c;\n  }n.extend({ hasData: function hasData(a) {\n      return O.hasData(a) || N.hasData(a);\n    }, data: function data(a, b, c) {\n      return O.access(a, b, c);\n    }, removeData: function removeData(a, b) {\n      O.remove(a, b);\n    }, _data: function _data(a, b, c) {\n      return N.access(a, b, c);\n    }, _removeData: function _removeData(a, b) {\n      N.remove(a, b);\n    } }), n.fn.extend({ data: function data(a, b) {\n      var c,\n          d,\n          e,\n          f = this[0],\n          g = f && f.attributes;if (void 0 === a) {\n        if (this.length && (e = O.get(f), 1 === f.nodeType && !N.get(f, \"hasDataAttrs\"))) {\n          c = g.length;while (c--) {\n            g[c] && (d = g[c].name, 0 === d.indexOf(\"data-\") && (d = n.camelCase(d.slice(5)), R(f, d, e[d])));\n          }N.set(f, \"hasDataAttrs\", !0);\n        }return e;\n      }return \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) ? this.each(function () {\n        O.set(this, a);\n      }) : K(this, function (b) {\n        var c, d;if (f && void 0 === b) {\n          if (c = O.get(f, a) || O.get(f, a.replace(Q, \"-$&\").toLowerCase()), void 0 !== c) return c;if (d = n.camelCase(a), c = O.get(f, d), void 0 !== c) return c;if (c = R(f, d, void 0), void 0 !== c) return c;\n        } else d = n.camelCase(a), this.each(function () {\n          var c = O.get(this, d);O.set(this, d, b), a.indexOf(\"-\") > -1 && void 0 !== c && O.set(this, a, b);\n        });\n      }, null, b, arguments.length > 1, null, !0);\n    }, removeData: function removeData(a) {\n      return this.each(function () {\n        O.remove(this, a);\n      });\n    } }), n.extend({ queue: function queue(a, b, c) {\n      var d;return a ? (b = (b || \"fx\") + \"queue\", d = N.get(a, b), c && (!d || n.isArray(c) ? d = N.access(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0;\n    }, dequeue: function dequeue(a, b) {\n      b = b || \"fx\";var c = n.queue(a, b),\n          d = c.length,\n          e = c.shift(),\n          f = n._queueHooks(a, b),\n          g = function g() {\n        n.dequeue(a, b);\n      };\"inprogress\" === e && (e = c.shift(), d--), e && (\"fx\" === b && c.unshift(\"inprogress\"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();\n    }, _queueHooks: function _queueHooks(a, b) {\n      var c = b + \"queueHooks\";return N.get(a, c) || N.access(a, c, { empty: n.Callbacks(\"once memory\").add(function () {\n          N.remove(a, [b + \"queue\", c]);\n        }) });\n    } }), n.fn.extend({ queue: function queue(a, b) {\n      var c = 2;return \"string\" != typeof a && (b = a, a = \"fx\", c--), arguments.length < c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function () {\n        var c = n.queue(this, a, b);n._queueHooks(this, a), \"fx\" === a && \"inprogress\" !== c[0] && n.dequeue(this, a);\n      });\n    }, dequeue: function dequeue(a) {\n      return this.each(function () {\n        n.dequeue(this, a);\n      });\n    }, clearQueue: function clearQueue(a) {\n      return this.queue(a || \"fx\", []);\n    }, promise: function promise(a, b) {\n      var c,\n          d = 1,\n          e = n.Deferred(),\n          f = this,\n          g = this.length,\n          h = function h() {\n        --d || e.resolveWith(f, [f]);\n      };\"string\" != typeof a && (b = a, a = void 0), a = a || \"fx\";while (g--) {\n        c = N.get(f[g], a + \"queueHooks\"), c && c.empty && (d++, c.empty.add(h));\n      }return h(), e.promise(b);\n    } });var S = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n      T = new RegExp(\"^(?:([+-])=|)(\" + S + \")([a-z%]*)$\", \"i\"),\n      U = [\"Top\", \"Right\", \"Bottom\", \"Left\"],\n      V = function V(a, b) {\n    return a = b || a, \"none\" === n.css(a, \"display\") || !n.contains(a.ownerDocument, a);\n  };function W(a, b, c, d) {\n    var e,\n        f = 1,\n        g = 20,\n        h = d ? function () {\n      return d.cur();\n    } : function () {\n      return n.css(a, b, \"\");\n    },\n        i = h(),\n        j = c && c[3] || (n.cssNumber[b] ? \"\" : \"px\"),\n        k = (n.cssNumber[b] || \"px\" !== j && +i) && T.exec(n.css(a, b));if (k && k[3] !== j) {\n      j = j || k[3], c = c || [], k = +i || 1;do {\n        f = f || \".5\", k /= f, n.style(a, b, k + j);\n      } while (f !== (f = h() / i) && 1 !== f && --g);\n    }return c && (k = +k || +i || 0, e = c[1] ? k + (c[1] + 1) * c[2] : +c[2], d && (d.unit = j, d.start = k, d.end = e)), e;\n  }var X = /^(?:checkbox|radio)$/i,\n      Y = /<([\\w:-]+)/,\n      Z = /^$|\\/(?:java|ecma)script/i,\n      $ = { option: [1, \"<select multiple='multiple'>\", \"</select>\"], thead: [1, \"<table>\", \"</table>\"], col: [2, \"<table><colgroup>\", \"</colgroup></table>\"], tr: [2, \"<table><tbody>\", \"</tbody></table>\"], td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"], _default: [0, \"\", \"\"] };$.optgroup = $.option, $.tbody = $.tfoot = $.colgroup = $.caption = $.thead, $.th = $.td;function _(a, b) {\n    var c = \"undefined\" != typeof a.getElementsByTagName ? a.getElementsByTagName(b || \"*\") : \"undefined\" != typeof a.querySelectorAll ? a.querySelectorAll(b || \"*\") : [];return void 0 === b || b && n.nodeName(a, b) ? n.merge([a], c) : c;\n  }function aa(a, b) {\n    for (var c = 0, d = a.length; d > c; c++) {\n      N.set(a[c], \"globalEval\", !b || N.get(b[c], \"globalEval\"));\n    }\n  }var ba = /<|&#?\\w+;/;function ca(a, b, c, d, e) {\n    for (var f, g, h, i, j, k, l = b.createDocumentFragment(), m = [], o = 0, p = a.length; p > o; o++) {\n      if (f = a[o], f || 0 === f) if (\"object\" === n.type(f)) n.merge(m, f.nodeType ? [f] : f);else if (ba.test(f)) {\n        g = g || l.appendChild(b.createElement(\"div\")), h = (Y.exec(f) || [\"\", \"\"])[1].toLowerCase(), i = $[h] || $._default, g.innerHTML = i[1] + n.htmlPrefilter(f) + i[2], k = i[0];while (k--) {\n          g = g.lastChild;\n        }n.merge(m, g.childNodes), g = l.firstChild, g.textContent = \"\";\n      } else m.push(b.createTextNode(f));\n    }l.textContent = \"\", o = 0;while (f = m[o++]) {\n      if (d && n.inArray(f, d) > -1) e && e.push(f);else if (j = n.contains(f.ownerDocument, f), g = _(l.appendChild(f), \"script\"), j && aa(g), c) {\n        k = 0;while (f = g[k++]) {\n          Z.test(f.type || \"\") && c.push(f);\n        }\n      }\n    }return l;\n  }!function () {\n    var a = d.createDocumentFragment(),\n        b = a.appendChild(d.createElement(\"div\")),\n        c = d.createElement(\"input\");c.setAttribute(\"type\", \"radio\"), c.setAttribute(\"checked\", \"checked\"), c.setAttribute(\"name\", \"t\"), b.appendChild(c), l.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = \"<textarea>x</textarea>\", l.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue;\n  }();var da = /^key/,\n      ea = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n      fa = /^([^.]*)(?:\\.(.+)|)/;function ga() {\n    return !0;\n  }function ha() {\n    return !1;\n  }function ia() {\n    try {\n      return d.activeElement;\n    } catch (a) {}\n  }function ja(a, b, c, d, e, f) {\n    var g, h;if (\"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b))) {\n      \"string\" != typeof c && (d = d || c, c = void 0);for (h in b) {\n        ja(a, h, c, d, b[h], f);\n      }return a;\n    }if (null == d && null == e ? (e = c, d = c = void 0) : null == e && (\"string\" == typeof c ? (e = d, d = void 0) : (e = d, d = c, c = void 0)), e === !1) e = ha;else if (!e) return a;return 1 === f && (g = e, e = function e(a) {\n      return n().off(a), g.apply(this, arguments);\n    }, e.guid = g.guid || (g.guid = n.guid++)), a.each(function () {\n      n.event.add(this, b, e, d, c);\n    });\n  }n.event = { global: {}, add: function add(a, b, c, d, e) {\n      var f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          o,\n          p,\n          q,\n          r = N.get(a);if (r) {\n        c.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = n.guid++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = function (b) {\n          return \"undefined\" != typeof n && n.event.triggered !== b.type ? n.event.dispatch.apply(a, arguments) : void 0;\n        }), b = (b || \"\").match(G) || [\"\"], j = b.length;while (j--) {\n          h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || \"\").split(\".\").sort(), o && (l = n.event.special[o] || {}, o = (e ? l.delegateType : l.bindType) || o, l = n.event.special[o] || {}, k = n.extend({ type: o, origType: q, data: d, handler: c, guid: c.guid, selector: e, needsContext: e && n.expr.match.needsContext.test(e), namespace: p.join(\".\") }, f), (m = i[o]) || (m = i[o] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, p, g) !== !1 || a.addEventListener && a.addEventListener(o, g)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), n.event.global[o] = !0);\n        }\n      }\n    }, remove: function remove(a, b, c, d, e) {\n      var f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          o,\n          p,\n          q,\n          r = N.hasData(a) && N.get(a);if (r && (i = r.events)) {\n        b = (b || \"\").match(G) || [\"\"], j = b.length;while (j--) {\n          if (h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || \"\").split(\".\").sort(), o) {\n            l = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = i[o] || [], h = h[2] && new RegExp(\"(^|\\\\.)\" + p.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"), g = f = m.length;while (f--) {\n              k = m[f], !e && q !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && (\"**\" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));\n            }g && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete i[o]);\n          } else for (o in i) {\n            n.event.remove(a, o + b[j], c, d, !0);\n          }\n        }n.isEmptyObject(i) && N.remove(a, \"handle events\");\n      }\n    }, dispatch: function dispatch(a) {\n      a = n.event.fix(a);var b,\n          c,\n          d,\n          f,\n          g,\n          h = [],\n          i = e.call(arguments),\n          j = (N.get(this, \"events\") || {})[a.type] || [],\n          k = n.event.special[a.type] || {};if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {\n        h = n.event.handlers.call(this, a, j), b = 0;while ((f = h[b++]) && !a.isPropagationStopped()) {\n          a.currentTarget = f.elem, c = 0;while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped()) {\n            (!a.rnamespace || a.rnamespace.test(g.namespace)) && (a.handleObj = g, a.data = g.data, d = ((n.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== d && (a.result = d) === !1 && (a.preventDefault(), a.stopPropagation()));\n          }\n        }return k.postDispatch && k.postDispatch.call(this, a), a.result;\n      }\n    }, handlers: function handlers(a, b) {\n      var c,\n          d,\n          e,\n          f,\n          g = [],\n          h = b.delegateCount,\n          i = a.target;if (h && i.nodeType && (\"click\" !== a.type || isNaN(a.button) || a.button < 1)) for (; i !== this; i = i.parentNode || this) {\n        if (1 === i.nodeType && (i.disabled !== !0 || \"click\" !== a.type)) {\n          for (d = [], c = 0; h > c; c++) {\n            f = b[c], e = f.selector + \" \", void 0 === d[e] && (d[e] = f.needsContext ? n(e, this).index(i) > -1 : n.find(e, this, null, [i]).length), d[e] && d.push(f);\n          }d.length && g.push({ elem: i, handlers: d });\n        }\n      }return h < b.length && g.push({ elem: this, handlers: b.slice(h) }), g;\n    }, props: \"altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"), fixHooks: {}, keyHooks: { props: \"char charCode key keyCode\".split(\" \"), filter: function filter(a, b) {\n        return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a;\n      } }, mouseHooks: { props: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"), filter: function filter(a, b) {\n        var c,\n            e,\n            f,\n            g = b.button;return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || d, e = c.documentElement, f = c.body, a.pageX = b.clientX + (e && e.scrollLeft || f && f.scrollLeft || 0) - (e && e.clientLeft || f && f.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || f && f.scrollTop || 0) - (e && e.clientTop || f && f.clientTop || 0)), a.which || void 0 === g || (a.which = 1 & g ? 1 : 2 & g ? 3 : 4 & g ? 2 : 0), a;\n      } }, fix: function fix(a) {\n      if (a[n.expando]) return a;var b,\n          c,\n          e,\n          f = a.type,\n          g = a,\n          h = this.fixHooks[f];h || (this.fixHooks[f] = h = ea.test(f) ? this.mouseHooks : da.test(f) ? this.keyHooks : {}), e = h.props ? this.props.concat(h.props) : this.props, a = new n.Event(g), b = e.length;while (b--) {\n        c = e[b], a[c] = g[c];\n      }return a.target || (a.target = d), 3 === a.target.nodeType && (a.target = a.target.parentNode), h.filter ? h.filter(a, g) : a;\n    }, special: { load: { noBubble: !0 }, focus: { trigger: function trigger() {\n          return this !== ia() && this.focus ? (this.focus(), !1) : void 0;\n        }, delegateType: \"focusin\" }, blur: { trigger: function trigger() {\n          return this === ia() && this.blur ? (this.blur(), !1) : void 0;\n        }, delegateType: \"focusout\" }, click: { trigger: function trigger() {\n          return \"checkbox\" === this.type && this.click && n.nodeName(this, \"input\") ? (this.click(), !1) : void 0;\n        }, _default: function _default(a) {\n          return n.nodeName(a.target, \"a\");\n        } }, beforeunload: { postDispatch: function postDispatch(a) {\n          void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);\n        } } } }, n.removeEvent = function (a, b, c) {\n    a.removeEventListener && a.removeEventListener(b, c);\n  }, n.Event = function (a, b) {\n    return this instanceof n.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? ga : ha) : this.type = a, b && n.extend(this, b), this.timeStamp = a && a.timeStamp || n.now(), void (this[n.expando] = !0)) : new n.Event(a, b);\n  }, n.Event.prototype = { constructor: n.Event, isDefaultPrevented: ha, isPropagationStopped: ha, isImmediatePropagationStopped: ha, preventDefault: function preventDefault() {\n      var a = this.originalEvent;this.isDefaultPrevented = ga, a && a.preventDefault();\n    }, stopPropagation: function stopPropagation() {\n      var a = this.originalEvent;this.isPropagationStopped = ga, a && a.stopPropagation();\n    }, stopImmediatePropagation: function stopImmediatePropagation() {\n      var a = this.originalEvent;this.isImmediatePropagationStopped = ga, a && a.stopImmediatePropagation(), this.stopPropagation();\n    } }, n.each({ mouseenter: \"mouseover\", mouseleave: \"mouseout\", pointerenter: \"pointerover\", pointerleave: \"pointerout\" }, function (a, b) {\n    n.event.special[a] = { delegateType: b, bindType: b, handle: function handle(a) {\n        var c,\n            d = this,\n            e = a.relatedTarget,\n            f = a.handleObj;return (!e || e !== d && !n.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c;\n      } };\n  }), n.fn.extend({ on: function on(a, b, c, d) {\n      return ja(this, a, b, c, d);\n    }, one: function one(a, b, c, d) {\n      return ja(this, a, b, c, d, 1);\n    }, off: function off(a, b, c) {\n      var d, e;if (a && a.preventDefault && a.handleObj) return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + \".\" + d.namespace : d.origType, d.selector, d.handler), this;if (\"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a))) {\n        for (e in a) {\n          this.off(e, b, a[e]);\n        }return this;\n      }return (b === !1 || \"function\" == typeof b) && (c = b, b = void 0), c === !1 && (c = ha), this.each(function () {\n        n.event.remove(this, a, c, b);\n      });\n    } });var ka = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:-]+)[^>]*)\\/>/gi,\n      la = /<script|<style|<link/i,\n      ma = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n      na = /^true\\/(.*)/,\n      oa = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;function pa(a, b) {\n    return n.nodeName(a, \"table\") && n.nodeName(11 !== b.nodeType ? b : b.firstChild, \"tr\") ? a.getElementsByTagName(\"tbody\")[0] || a.appendChild(a.ownerDocument.createElement(\"tbody\")) : a;\n  }function qa(a) {\n    return a.type = (null !== a.getAttribute(\"type\")) + \"/\" + a.type, a;\n  }function ra(a) {\n    var b = na.exec(a.type);return b ? a.type = b[1] : a.removeAttribute(\"type\"), a;\n  }function sa(a, b) {\n    var c, d, e, f, g, h, i, j;if (1 === b.nodeType) {\n      if (N.hasData(a) && (f = N.access(a), g = N.set(b, f), j = f.events)) {\n        delete g.handle, g.events = {};for (e in j) {\n          for (c = 0, d = j[e].length; d > c; c++) {\n            n.event.add(b, e, j[e][c]);\n          }\n        }\n      }O.hasData(a) && (h = O.access(a), i = n.extend({}, h), O.set(b, i));\n    }\n  }function ta(a, b) {\n    var c = b.nodeName.toLowerCase();\"input\" === c && X.test(a.type) ? b.checked = a.checked : (\"input\" === c || \"textarea\" === c) && (b.defaultValue = a.defaultValue);\n  }function ua(a, b, c, d) {\n    b = f.apply([], b);var e,\n        g,\n        h,\n        i,\n        j,\n        k,\n        m = 0,\n        o = a.length,\n        p = o - 1,\n        q = b[0],\n        r = n.isFunction(q);if (r || o > 1 && \"string\" == typeof q && !l.checkClone && ma.test(q)) return a.each(function (e) {\n      var f = a.eq(e);r && (b[0] = q.call(this, e, f.html())), ua(f, b, c, d);\n    });if (o && (e = ca(b, a[0].ownerDocument, !1, a, d), g = e.firstChild, 1 === e.childNodes.length && (e = g), g || d)) {\n      for (h = n.map(_(e, \"script\"), qa), i = h.length; o > m; m++) {\n        j = e, m !== p && (j = n.clone(j, !0, !0), i && n.merge(h, _(j, \"script\"))), c.call(a[m], j, m);\n      }if (i) for (k = h[h.length - 1].ownerDocument, n.map(h, ra), m = 0; i > m; m++) {\n        j = h[m], Z.test(j.type || \"\") && !N.access(j, \"globalEval\") && n.contains(k, j) && (j.src ? n._evalUrl && n._evalUrl(j.src) : n.globalEval(j.textContent.replace(oa, \"\")));\n      }\n    }return a;\n  }function va(a, b, c) {\n    for (var d, e = b ? n.filter(b, a) : a, f = 0; null != (d = e[f]); f++) {\n      c || 1 !== d.nodeType || n.cleanData(_(d)), d.parentNode && (c && n.contains(d.ownerDocument, d) && aa(_(d, \"script\")), d.parentNode.removeChild(d));\n    }return a;\n  }n.extend({ htmlPrefilter: function htmlPrefilter(a) {\n      return a.replace(ka, \"<$1></$2>\");\n    }, clone: function clone(a, b, c) {\n      var d,\n          e,\n          f,\n          g,\n          h = a.cloneNode(!0),\n          i = n.contains(a.ownerDocument, a);if (!(l.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || n.isXMLDoc(a))) for (g = _(h), f = _(a), d = 0, e = f.length; e > d; d++) {\n        ta(f[d], g[d]);\n      }if (b) if (c) for (f = f || _(a), g = g || _(h), d = 0, e = f.length; e > d; d++) {\n        sa(f[d], g[d]);\n      } else sa(a, h);return g = _(h, \"script\"), g.length > 0 && aa(g, !i && _(a, \"script\")), h;\n    }, cleanData: function cleanData(a) {\n      for (var b, c, d, e = n.event.special, f = 0; void 0 !== (c = a[f]); f++) {\n        if (L(c)) {\n          if (b = c[N.expando]) {\n            if (b.events) for (d in b.events) {\n              e[d] ? n.event.remove(c, d) : n.removeEvent(c, d, b.handle);\n            }c[N.expando] = void 0;\n          }c[O.expando] && (c[O.expando] = void 0);\n        }\n      }\n    } }), n.fn.extend({ domManip: ua, detach: function detach(a) {\n      return va(this, a, !0);\n    }, remove: function remove(a) {\n      return va(this, a);\n    }, text: function text(a) {\n      return K(this, function (a) {\n        return void 0 === a ? n.text(this) : this.empty().each(function () {\n          (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = a);\n        });\n      }, null, a, arguments.length);\n    }, append: function append() {\n      return ua(this, arguments, function (a) {\n        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n          var b = pa(this, a);b.appendChild(a);\n        }\n      });\n    }, prepend: function prepend() {\n      return ua(this, arguments, function (a) {\n        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n          var b = pa(this, a);b.insertBefore(a, b.firstChild);\n        }\n      });\n    }, before: function before() {\n      return ua(this, arguments, function (a) {\n        this.parentNode && this.parentNode.insertBefore(a, this);\n      });\n    }, after: function after() {\n      return ua(this, arguments, function (a) {\n        this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);\n      });\n    }, empty: function empty() {\n      for (var a, b = 0; null != (a = this[b]); b++) {\n        1 === a.nodeType && (n.cleanData(_(a, !1)), a.textContent = \"\");\n      }return this;\n    }, clone: function clone(a, b) {\n      return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function () {\n        return n.clone(this, a, b);\n      });\n    }, html: function html(a) {\n      return K(this, function (a) {\n        var b = this[0] || {},\n            c = 0,\n            d = this.length;if (void 0 === a && 1 === b.nodeType) return b.innerHTML;if (\"string\" == typeof a && !la.test(a) && !$[(Y.exec(a) || [\"\", \"\"])[1].toLowerCase()]) {\n          a = n.htmlPrefilter(a);try {\n            for (; d > c; c++) {\n              b = this[c] || {}, 1 === b.nodeType && (n.cleanData(_(b, !1)), b.innerHTML = a);\n            }b = 0;\n          } catch (e) {}\n        }b && this.empty().append(a);\n      }, null, a, arguments.length);\n    }, replaceWith: function replaceWith() {\n      var a = [];return ua(this, arguments, function (b) {\n        var c = this.parentNode;n.inArray(this, a) < 0 && (n.cleanData(_(this)), c && c.replaceChild(b, this));\n      }, a);\n    } }), n.each({ appendTo: \"append\", prependTo: \"prepend\", insertBefore: \"before\", insertAfter: \"after\", replaceAll: \"replaceWith\" }, function (a, b) {\n    n.fn[a] = function (a) {\n      for (var c, d = [], e = n(a), f = e.length - 1, h = 0; f >= h; h++) {\n        c = h === f ? this : this.clone(!0), n(e[h])[b](c), g.apply(d, c.get());\n      }return this.pushStack(d);\n    };\n  });var wa,\n      xa = { HTML: \"block\", BODY: \"block\" };function ya(a, b) {\n    var c = n(b.createElement(a)).appendTo(b.body),\n        d = n.css(c[0], \"display\");return c.detach(), d;\n  }function za(a) {\n    var b = d,\n        c = xa[a];return c || (c = ya(a, b), \"none\" !== c && c || (wa = (wa || n(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(b.documentElement), b = wa[0].contentDocument, b.write(), b.close(), c = ya(a, b), wa.detach()), xa[a] = c), c;\n  }var Aa = /^margin/,\n      Ba = new RegExp(\"^(\" + S + \")(?!px)[a-z%]+$\", \"i\"),\n      Ca = function Ca(b) {\n    var c = b.ownerDocument.defaultView;return c && c.opener || (c = a), c.getComputedStyle(b);\n  },\n      Da = function Da(a, b, c, d) {\n    var e,\n        f,\n        g = {};for (f in b) {\n      g[f] = a.style[f], a.style[f] = b[f];\n    }e = c.apply(a, d || []);for (f in b) {\n      a.style[f] = g[f];\n    }return e;\n  },\n      Ea = d.documentElement;!function () {\n    var b,\n        c,\n        e,\n        f,\n        g = d.createElement(\"div\"),\n        h = d.createElement(\"div\");if (h.style) {\n      (function () {\n        var i = function i() {\n          h.style.cssText = \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%\", h.innerHTML = \"\", Ea.appendChild(g);var d = a.getComputedStyle(h);b = \"1%\" !== d.top, f = \"2px\" === d.marginLeft, c = \"4px\" === d.width, h.style.marginRight = \"50%\", e = \"4px\" === d.marginRight, Ea.removeChild(g);\n        };\n\n        h.style.backgroundClip = \"content-box\", h.cloneNode(!0).style.backgroundClip = \"\", l.clearCloneStyle = \"content-box\" === h.style.backgroundClip, g.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute\", g.appendChild(h);n.extend(l, { pixelPosition: function pixelPosition() {\n            return i(), b;\n          }, boxSizingReliable: function boxSizingReliable() {\n            return null == c && i(), c;\n          }, pixelMarginRight: function pixelMarginRight() {\n            return null == c && i(), e;\n          }, reliableMarginLeft: function reliableMarginLeft() {\n            return null == c && i(), f;\n          }, reliableMarginRight: function reliableMarginRight() {\n            var b,\n                c = h.appendChild(d.createElement(\"div\"));return c.style.cssText = h.style.cssText = \"-webkit-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0\", c.style.marginRight = c.style.width = \"0\", h.style.width = \"1px\", Ea.appendChild(g), b = !parseFloat(a.getComputedStyle(c).marginRight), Ea.removeChild(g), h.removeChild(c), b;\n          } });\n      })();\n    }\n  }();function Fa(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h = a.style;return c = c || Ca(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, \"\" !== g && void 0 !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), c && !l.pixelMarginRight() && Ba.test(g) && Aa.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f), void 0 !== g ? g + \"\" : g;\n  }function Ga(a, b) {\n    return { get: function get() {\n        return a() ? void delete this.get : (this.get = b).apply(this, arguments);\n      } };\n  }var Ha = /^(none|table(?!-c[ea]).+)/,\n      Ia = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n      Ja = { letterSpacing: \"0\", fontWeight: \"400\" },\n      Ka = [\"Webkit\", \"O\", \"Moz\", \"ms\"],\n      La = d.createElement(\"div\").style;function Ma(a) {\n    if (a in La) return a;var b = a[0].toUpperCase() + a.slice(1),\n        c = Ka.length;while (c--) {\n      if (a = Ka[c] + b, a in La) return a;\n    }\n  }function Na(a, b, c) {\n    var d = T.exec(b);return d ? Math.max(0, d[2] - (c || 0)) + (d[3] || \"px\") : b;\n  }function Oa(a, b, c, d, e) {\n    for (var f = c === (d ? \"border\" : \"content\") ? 4 : \"width\" === b ? 1 : 0, g = 0; 4 > f; f += 2) {\n      \"margin\" === c && (g += n.css(a, c + U[f], !0, e)), d ? (\"content\" === c && (g -= n.css(a, \"padding\" + U[f], !0, e)), \"margin\" !== c && (g -= n.css(a, \"border\" + U[f] + \"Width\", !0, e))) : (g += n.css(a, \"padding\" + U[f], !0, e), \"padding\" !== c && (g += n.css(a, \"border\" + U[f] + \"Width\", !0, e)));\n    }return g;\n  }function Pa(b, c, e) {\n    var f = !0,\n        g = \"width\" === c ? b.offsetWidth : b.offsetHeight,\n        h = Ca(b),\n        i = \"border-box\" === n.css(b, \"boxSizing\", !1, h);if (d.msFullscreenElement && a.top !== a && b.getClientRects().length && (g = Math.round(100 * b.getBoundingClientRect()[c])), 0 >= g || null == g) {\n      if (g = Fa(b, c, h), (0 > g || null == g) && (g = b.style[c]), Ba.test(g)) return g;f = i && (l.boxSizingReliable() || g === b.style[c]), g = parseFloat(g) || 0;\n    }return g + Oa(b, c, e || (i ? \"border\" : \"content\"), f, h) + \"px\";\n  }function Qa(a, b) {\n    for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) {\n      d = a[g], d.style && (f[g] = N.get(d, \"olddisplay\"), c = d.style.display, b ? (f[g] || \"none\" !== c || (d.style.display = \"\"), \"\" === d.style.display && V(d) && (f[g] = N.access(d, \"olddisplay\", za(d.nodeName)))) : (e = V(d), \"none\" === c && e || N.set(d, \"olddisplay\", e ? c : n.css(d, \"display\"))));\n    }for (g = 0; h > g; g++) {\n      d = a[g], d.style && (b && \"none\" !== d.style.display && \"\" !== d.style.display || (d.style.display = b ? f[g] || \"\" : \"none\"));\n    }return a;\n  }n.extend({ cssHooks: { opacity: { get: function get(a, b) {\n          if (b) {\n            var c = Fa(a, \"opacity\");return \"\" === c ? \"1\" : c;\n          }\n        } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: { \"float\": \"cssFloat\" }, style: function style(a, b, c, d) {\n      if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {\n        var e,\n            f,\n            g,\n            h = n.camelCase(b),\n            i = a.style;return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c ? g && \"get\" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c === \"undefined\" ? \"undefined\" : _typeof(c), \"string\" === f && (e = T.exec(c)) && e[1] && (c = W(a, b, e), f = \"number\"), null != c && c === c && (\"number\" === f && (c += e && e[3] || (n.cssNumber[h] ? \"\" : \"px\")), l.clearCloneStyle || \"\" !== c || 0 !== b.indexOf(\"background\") || (i[b] = \"inherit\"), g && \"set\" in g && void 0 === (c = g.set(a, c, d)) || (i[b] = c)), void 0);\n      }\n    }, css: function css(a, b, c, d) {\n      var e,\n          f,\n          g,\n          h = n.camelCase(b);return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], g && \"get\" in g && (e = g.get(a, !0, c)), void 0 === e && (e = Fa(a, b, d)), \"normal\" === e && b in Ja && (e = Ja[b]), \"\" === c || c ? (f = parseFloat(e), c === !0 || isFinite(f) ? f || 0 : e) : e;\n    } }), n.each([\"height\", \"width\"], function (a, b) {\n    n.cssHooks[b] = { get: function get(a, c, d) {\n        return c ? Ha.test(n.css(a, \"display\")) && 0 === a.offsetWidth ? Da(a, Ia, function () {\n          return Pa(a, b, d);\n        }) : Pa(a, b, d) : void 0;\n      }, set: function set(a, c, d) {\n        var e,\n            f = d && Ca(a),\n            g = d && Oa(a, b, d, \"border-box\" === n.css(a, \"boxSizing\", !1, f), f);return g && (e = T.exec(c)) && \"px\" !== (e[3] || \"px\") && (a.style[b] = c, c = n.css(a, b)), Na(a, c, g);\n      } };\n  }), n.cssHooks.marginLeft = Ga(l.reliableMarginLeft, function (a, b) {\n    return b ? (parseFloat(Fa(a, \"marginLeft\")) || a.getBoundingClientRect().left - Da(a, { marginLeft: 0 }, function () {\n      return a.getBoundingClientRect().left;\n    })) + \"px\" : void 0;\n  }), n.cssHooks.marginRight = Ga(l.reliableMarginRight, function (a, b) {\n    return b ? Da(a, { display: \"inline-block\" }, Fa, [a, \"marginRight\"]) : void 0;\n  }), n.each({ margin: \"\", padding: \"\", border: \"Width\" }, function (a, b) {\n    n.cssHooks[a + b] = { expand: function expand(c) {\n        for (var d = 0, e = {}, f = \"string\" == typeof c ? c.split(\" \") : [c]; 4 > d; d++) {\n          e[a + U[d] + b] = f[d] || f[d - 2] || f[0];\n        }return e;\n      } }, Aa.test(a) || (n.cssHooks[a + b].set = Na);\n  }), n.fn.extend({ css: function css(a, b) {\n      return K(this, function (a, b, c) {\n        var d,\n            e,\n            f = {},\n            g = 0;if (n.isArray(b)) {\n          for (d = Ca(a), e = b.length; e > g; g++) {\n            f[b[g]] = n.css(a, b[g], !1, d);\n          }return f;\n        }return void 0 !== c ? n.style(a, b, c) : n.css(a, b);\n      }, a, b, arguments.length > 1);\n    }, show: function show() {\n      return Qa(this, !0);\n    }, hide: function hide() {\n      return Qa(this);\n    }, toggle: function toggle(a) {\n      return \"boolean\" == typeof a ? a ? this.show() : this.hide() : this.each(function () {\n        V(this) ? n(this).show() : n(this).hide();\n      });\n    } });function Ra(a, b, c, d, e) {\n    return new Ra.prototype.init(a, b, c, d, e);\n  }n.Tween = Ra, Ra.prototype = { constructor: Ra, init: function init(a, b, c, d, e, f) {\n      this.elem = a, this.prop = c, this.easing = e || n.easing._default, this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (n.cssNumber[c] ? \"\" : \"px\");\n    }, cur: function cur() {\n      var a = Ra.propHooks[this.prop];return a && a.get ? a.get(this) : Ra.propHooks._default.get(this);\n    }, run: function run(a) {\n      var b,\n          c = Ra.propHooks[this.prop];return this.options.duration ? this.pos = b = n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Ra.propHooks._default.set(this), this;\n    } }, Ra.prototype.init.prototype = Ra.prototype, Ra.propHooks = { _default: { get: function get(a) {\n        var b;return 1 !== a.elem.nodeType || null != a.elem[a.prop] && null == a.elem.style[a.prop] ? a.elem[a.prop] : (b = n.css(a.elem, a.prop, \"\"), b && \"auto\" !== b ? b : 0);\n      }, set: function set(a) {\n        n.fx.step[a.prop] ? n.fx.step[a.prop](a) : 1 !== a.elem.nodeType || null == a.elem.style[n.cssProps[a.prop]] && !n.cssHooks[a.prop] ? a.elem[a.prop] = a.now : n.style(a.elem, a.prop, a.now + a.unit);\n      } } }, Ra.propHooks.scrollTop = Ra.propHooks.scrollLeft = { set: function set(a) {\n      a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);\n    } }, n.easing = { linear: function linear(a) {\n      return a;\n    }, swing: function swing(a) {\n      return .5 - Math.cos(a * Math.PI) / 2;\n    }, _default: \"swing\" }, n.fx = Ra.prototype.init, n.fx.step = {};var Sa,\n      Ta,\n      Ua = /^(?:toggle|show|hide)$/,\n      Va = /queueHooks$/;function Wa() {\n    return a.setTimeout(function () {\n      Sa = void 0;\n    }), Sa = n.now();\n  }function Xa(a, b) {\n    var c,\n        d = 0,\n        e = { height: a };for (b = b ? 1 : 0; 4 > d; d += 2 - b) {\n      c = U[d], e[\"margin\" + c] = e[\"padding\" + c] = a;\n    }return b && (e.opacity = e.width = a), e;\n  }function Ya(a, b, c) {\n    for (var d, e = (_a.tweeners[b] || []).concat(_a.tweeners[\"*\"]), f = 0, g = e.length; g > f; f++) {\n      if (d = e[f].call(c, b, a)) return d;\n    }\n  }function Za(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        j,\n        k,\n        l = this,\n        m = {},\n        o = a.style,\n        p = a.nodeType && V(a),\n        q = N.get(a, \"fxshow\");c.queue || (h = n._queueHooks(a, \"fx\"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () {\n      h.unqueued || i();\n    }), h.unqueued++, l.always(function () {\n      l.always(function () {\n        h.unqueued--, n.queue(a, \"fx\").length || h.empty.fire();\n      });\n    })), 1 === a.nodeType && (\"height\" in b || \"width\" in b) && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = n.css(a, \"display\"), k = \"none\" === j ? N.get(a, \"olddisplay\") || za(a.nodeName) : j, \"inline\" === k && \"none\" === n.css(a, \"float\") && (o.display = \"inline-block\")), c.overflow && (o.overflow = \"hidden\", l.always(function () {\n      o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2];\n    }));for (d in b) {\n      if (e = b[d], Ua.exec(e)) {\n        if (delete b[d], f = f || \"toggle\" === e, e === (p ? \"hide\" : \"show\")) {\n          if (\"show\" !== e || !q || void 0 === q[d]) continue;p = !0;\n        }m[d] = q && q[d] || n.style(a, d);\n      } else j = void 0;\n    }if (n.isEmptyObject(m)) \"inline\" === (\"none\" === j ? za(a.nodeName) : j) && (o.display = j);else {\n      q ? \"hidden\" in q && (p = q.hidden) : q = N.access(a, \"fxshow\", {}), f && (q.hidden = !p), p ? n(a).show() : l.done(function () {\n        n(a).hide();\n      }), l.done(function () {\n        var b;N.remove(a, \"fxshow\");for (b in m) {\n          n.style(a, b, m[b]);\n        }\n      });for (d in m) {\n        g = Ya(p ? q[d] : 0, d, l), d in q || (q[d] = g.start, p && (g.end = g.start, g.start = \"width\" === d || \"height\" === d ? 1 : 0));\n      }\n    }\n  }function $a(a, b) {\n    var c, d, e, f, g;for (c in a) {\n      if (d = n.camelCase(c), e = b[d], f = a[c], n.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = n.cssHooks[d], g && \"expand\" in g) {\n        f = g.expand(f), delete a[d];for (c in f) {\n          c in a || (a[c] = f[c], b[c] = e);\n        }\n      } else b[d] = e;\n    }\n  }function _a(a, b, c) {\n    var d,\n        e,\n        f = 0,\n        g = _a.prefilters.length,\n        h = n.Deferred().always(function () {\n      delete i.elem;\n    }),\n        i = function i() {\n      if (e) return !1;for (var b = Sa || Wa(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) {\n        j.tweens[g].run(f);\n      }return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1);\n    },\n        j = h.promise({ elem: a, props: n.extend({}, b), opts: n.extend(!0, { specialEasing: {}, easing: n.easing._default }, c), originalProperties: b, originalOptions: c, startTime: Sa || Wa(), duration: c.duration, tweens: [], createTween: function createTween(b, c) {\n        var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);return j.tweens.push(d), d;\n      }, stop: function stop(b) {\n        var c = 0,\n            d = b ? j.tweens.length : 0;if (e) return this;for (e = !0; d > c; c++) {\n          j.tweens[c].run(1);\n        }return b ? (h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j, b])) : h.rejectWith(a, [j, b]), this;\n      } }),\n        k = j.props;for ($a(k, j.opts.specialEasing); g > f; f++) {\n      if (d = _a.prefilters[f].call(j, a, k, j.opts)) return n.isFunction(d.stop) && (n._queueHooks(j.elem, j.opts.queue).stop = n.proxy(d.stop, d)), d;\n    }return n.map(k, Ya, j), n.isFunction(j.opts.start) && j.opts.start.call(a, j), n.fx.timer(n.extend(i, { elem: a, anim: j, queue: j.opts.queue })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always);\n  }n.Animation = n.extend(_a, { tweeners: { \"*\": [function (a, b) {\n        var c = this.createTween(a, b);return W(c.elem, a, T.exec(b), c), c;\n      }] }, tweener: function tweener(a, b) {\n      n.isFunction(a) ? (b = a, a = [\"*\"]) : a = a.match(G);for (var c, d = 0, e = a.length; e > d; d++) {\n        c = a[d], _a.tweeners[c] = _a.tweeners[c] || [], _a.tweeners[c].unshift(b);\n      }\n    }, prefilters: [Za], prefilter: function prefilter(a, b) {\n      b ? _a.prefilters.unshift(a) : _a.prefilters.push(a);\n    } }), n.speed = function (a, b, c) {\n    var d = a && \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) ? n.extend({}, a) : { complete: c || !c && b || n.isFunction(a) && a, duration: a, easing: c && b || b && !n.isFunction(b) && b };return d.duration = n.fx.off ? 0 : \"number\" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default, (null == d.queue || d.queue === !0) && (d.queue = \"fx\"), d.old = d.complete, d.complete = function () {\n      n.isFunction(d.old) && d.old.call(this), d.queue && n.dequeue(this, d.queue);\n    }, d;\n  }, n.fn.extend({ fadeTo: function fadeTo(a, b, c, d) {\n      return this.filter(V).css(\"opacity\", 0).show().end().animate({ opacity: b }, a, c, d);\n    }, animate: function animate(a, b, c, d) {\n      var e = n.isEmptyObject(a),\n          f = n.speed(b, c, d),\n          g = function g() {\n        var b = _a(this, n.extend({}, a), f);(e || N.get(this, \"finish\")) && b.stop(!0);\n      };return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g);\n    }, stop: function stop(a, b, c) {\n      var d = function d(a) {\n        var b = a.stop;delete a.stop, b(c);\n      };return \"string\" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || \"fx\", []), this.each(function () {\n        var b = !0,\n            e = null != a && a + \"queueHooks\",\n            f = n.timers,\n            g = N.get(this);if (e) g[e] && g[e].stop && d(g[e]);else for (e in g) {\n          g[e] && g[e].stop && Va.test(e) && d(g[e]);\n        }for (e = f.length; e--;) {\n          f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));\n        }(b || !c) && n.dequeue(this, a);\n      });\n    }, finish: function finish(a) {\n      return a !== !1 && (a = a || \"fx\"), this.each(function () {\n        var b,\n            c = N.get(this),\n            d = c[a + \"queue\"],\n            e = c[a + \"queueHooks\"],\n            f = n.timers,\n            g = d ? d.length : 0;for (c.finish = !0, n.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) {\n          f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));\n        }for (b = 0; g > b; b++) {\n          d[b] && d[b].finish && d[b].finish.call(this);\n        }delete c.finish;\n      });\n    } }), n.each([\"toggle\", \"show\", \"hide\"], function (a, b) {\n    var c = n.fn[b];n.fn[b] = function (a, d, e) {\n      return null == a || \"boolean\" == typeof a ? c.apply(this, arguments) : this.animate(Xa(b, !0), a, d, e);\n    };\n  }), n.each({ slideDown: Xa(\"show\"), slideUp: Xa(\"hide\"), slideToggle: Xa(\"toggle\"), fadeIn: { opacity: \"show\" }, fadeOut: { opacity: \"hide\" }, fadeToggle: { opacity: \"toggle\" } }, function (a, b) {\n    n.fn[a] = function (a, c, d) {\n      return this.animate(b, a, c, d);\n    };\n  }), n.timers = [], n.fx.tick = function () {\n    var a,\n        b = 0,\n        c = n.timers;for (Sa = n.now(); b < c.length; b++) {\n      a = c[b], a() || c[b] !== a || c.splice(b--, 1);\n    }c.length || n.fx.stop(), Sa = void 0;\n  }, n.fx.timer = function (a) {\n    n.timers.push(a), a() ? n.fx.start() : n.timers.pop();\n  }, n.fx.interval = 13, n.fx.start = function () {\n    Ta || (Ta = a.setInterval(n.fx.tick, n.fx.interval));\n  }, n.fx.stop = function () {\n    a.clearInterval(Ta), Ta = null;\n  }, n.fx.speeds = { slow: 600, fast: 200, _default: 400 }, n.fn.delay = function (b, c) {\n    return b = n.fx ? n.fx.speeds[b] || b : b, c = c || \"fx\", this.queue(c, function (c, d) {\n      var e = a.setTimeout(c, b);d.stop = function () {\n        a.clearTimeout(e);\n      };\n    });\n  }, function () {\n    var a = d.createElement(\"input\"),\n        b = d.createElement(\"select\"),\n        c = b.appendChild(d.createElement(\"option\"));a.type = \"checkbox\", l.checkOn = \"\" !== a.value, l.optSelected = c.selected, b.disabled = !0, l.optDisabled = !c.disabled, a = d.createElement(\"input\"), a.value = \"t\", a.type = \"radio\", l.radioValue = \"t\" === a.value;\n  }();var ab,\n      bb = n.expr.attrHandle;n.fn.extend({ attr: function attr(a, b) {\n      return K(this, n.attr, a, b, arguments.length > 1);\n    }, removeAttr: function removeAttr(a) {\n      return this.each(function () {\n        n.removeAttr(this, a);\n      });\n    } }), n.extend({ attr: function attr(a, b, c) {\n      var d,\n          e,\n          f = a.nodeType;if (3 !== f && 8 !== f && 2 !== f) return \"undefined\" == typeof a.getAttribute ? n.prop(a, b, c) : (1 === f && n.isXMLDoc(a) || (b = b.toLowerCase(), e = n.attrHooks[b] || (n.expr.match.bool.test(b) ? ab : void 0)), void 0 !== c ? null === c ? void n.removeAttr(a, b) : e && \"set\" in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + \"\"), c) : e && \"get\" in e && null !== (d = e.get(a, b)) ? d : (d = n.find.attr(a, b), null == d ? void 0 : d));\n    }, attrHooks: { type: { set: function set(a, b) {\n          if (!l.radioValue && \"radio\" === b && n.nodeName(a, \"input\")) {\n            var c = a.value;return a.setAttribute(\"type\", b), c && (a.value = c), b;\n          }\n        } } }, removeAttr: function removeAttr(a, b) {\n      var c,\n          d,\n          e = 0,\n          f = b && b.match(G);if (f && 1 === a.nodeType) while (c = f[e++]) {\n        d = n.propFix[c] || c, n.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c);\n      }\n    } }), ab = { set: function set(a, b, c) {\n      return b === !1 ? n.removeAttr(a, c) : a.setAttribute(c, c), c;\n    } }, n.each(n.expr.match.bool.source.match(/\\w+/g), function (a, b) {\n    var c = bb[b] || n.find.attr;bb[b] = function (a, b, d) {\n      var e, f;return d || (f = bb[b], bb[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, bb[b] = f), e;\n    };\n  });var cb = /^(?:input|select|textarea|button)$/i,\n      db = /^(?:a|area)$/i;n.fn.extend({ prop: function prop(a, b) {\n      return K(this, n.prop, a, b, arguments.length > 1);\n    }, removeProp: function removeProp(a) {\n      return this.each(function () {\n        delete this[n.propFix[a] || a];\n      });\n    } }), n.extend({ prop: function prop(a, b, c) {\n      var d,\n          e,\n          f = a.nodeType;if (3 !== f && 8 !== f && 2 !== f) return 1 === f && n.isXMLDoc(a) || (b = n.propFix[b] || b, e = n.propHooks[b]), void 0 !== c ? e && \"set\" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && \"get\" in e && null !== (d = e.get(a, b)) ? d : a[b];\n    }, propHooks: { tabIndex: { get: function get(a) {\n          var b = n.find.attr(a, \"tabindex\");return b ? parseInt(b, 10) : cb.test(a.nodeName) || db.test(a.nodeName) && a.href ? 0 : -1;\n        } } }, propFix: { \"for\": \"htmlFor\", \"class\": \"className\" } }), l.optSelected || (n.propHooks.selected = { get: function get(a) {\n      var b = a.parentNode;return b && b.parentNode && b.parentNode.selectedIndex, null;\n    } }), n.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n    n.propFix[this.toLowerCase()] = this;\n  });var eb = /[\\t\\r\\n\\f]/g;function fb(a) {\n    return a.getAttribute && a.getAttribute(\"class\") || \"\";\n  }n.fn.extend({ addClass: function addClass(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = 0;if (n.isFunction(a)) return this.each(function (b) {\n        n(this).addClass(a.call(this, b, fb(this)));\n      });if (\"string\" == typeof a && a) {\n        b = a.match(G) || [];while (c = this[i++]) {\n          if (e = fb(c), d = 1 === c.nodeType && (\" \" + e + \" \").replace(eb, \" \")) {\n            g = 0;while (f = b[g++]) {\n              d.indexOf(\" \" + f + \" \") < 0 && (d += f + \" \");\n            }h = n.trim(d), e !== h && c.setAttribute(\"class\", h);\n          }\n        }\n      }return this;\n    }, removeClass: function removeClass(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = 0;if (n.isFunction(a)) return this.each(function (b) {\n        n(this).removeClass(a.call(this, b, fb(this)));\n      });if (!arguments.length) return this.attr(\"class\", \"\");if (\"string\" == typeof a && a) {\n        b = a.match(G) || [];while (c = this[i++]) {\n          if (e = fb(c), d = 1 === c.nodeType && (\" \" + e + \" \").replace(eb, \" \")) {\n            g = 0;while (f = b[g++]) {\n              while (d.indexOf(\" \" + f + \" \") > -1) {\n                d = d.replace(\" \" + f + \" \", \" \");\n              }\n            }h = n.trim(d), e !== h && c.setAttribute(\"class\", h);\n          }\n        }\n      }return this;\n    }, toggleClass: function toggleClass(a, b) {\n      var c = typeof a === \"undefined\" ? \"undefined\" : _typeof(a);return \"boolean\" == typeof b && \"string\" === c ? b ? this.addClass(a) : this.removeClass(a) : n.isFunction(a) ? this.each(function (c) {\n        n(this).toggleClass(a.call(this, c, fb(this), b), b);\n      }) : this.each(function () {\n        var b, d, e, f;if (\"string\" === c) {\n          d = 0, e = n(this), f = a.match(G) || [];while (b = f[d++]) {\n            e.hasClass(b) ? e.removeClass(b) : e.addClass(b);\n          }\n        } else (void 0 === a || \"boolean\" === c) && (b = fb(this), b && N.set(this, \"__className__\", b), this.setAttribute && this.setAttribute(\"class\", b || a === !1 ? \"\" : N.get(this, \"__className__\") || \"\"));\n      });\n    }, hasClass: function hasClass(a) {\n      var b,\n          c,\n          d = 0;b = \" \" + a + \" \";while (c = this[d++]) {\n        if (1 === c.nodeType && (\" \" + fb(c) + \" \").replace(eb, \" \").indexOf(b) > -1) return !0;\n      }return !1;\n    } });var gb = /\\r/g;n.fn.extend({ val: function val(a) {\n      var b,\n          c,\n          d,\n          e = this[0];{\n        if (arguments.length) return d = n.isFunction(a), this.each(function (c) {\n          var e;1 === this.nodeType && (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = \"\" : \"number\" == typeof e ? e += \"\" : n.isArray(e) && (e = n.map(e, function (a) {\n            return null == a ? \"\" : a + \"\";\n          })), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b && \"set\" in b && void 0 !== b.set(this, e, \"value\") || (this.value = e));\n        });if (e) return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b && \"get\" in b && void 0 !== (c = b.get(e, \"value\")) ? c : (c = e.value, \"string\" == typeof c ? c.replace(gb, \"\") : null == c ? \"\" : c);\n      }\n    } }), n.extend({ valHooks: { option: { get: function get(a) {\n          return n.trim(a.value);\n        } }, select: { get: function get(a) {\n          for (var b, c, d = a.options, e = a.selectedIndex, f = \"select-one\" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++) {\n            if (c = d[i], (c.selected || i === e) && (l.optDisabled ? !c.disabled : null === c.getAttribute(\"disabled\")) && (!c.parentNode.disabled || !n.nodeName(c.parentNode, \"optgroup\"))) {\n              if (b = n(c).val(), f) return b;g.push(b);\n            }\n          }return g;\n        }, set: function set(a, b) {\n          var c,\n              d,\n              e = a.options,\n              f = n.makeArray(b),\n              g = e.length;while (g--) {\n            d = e[g], (d.selected = n.inArray(n.valHooks.option.get(d), f) > -1) && (c = !0);\n          }return c || (a.selectedIndex = -1), f;\n        } } } }), n.each([\"radio\", \"checkbox\"], function () {\n    n.valHooks[this] = { set: function set(a, b) {\n        return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) > -1 : void 0;\n      } }, l.checkOn || (n.valHooks[this].get = function (a) {\n      return null === a.getAttribute(\"value\") ? \"on\" : a.value;\n    });\n  });var hb = /^(?:focusinfocus|focusoutblur)$/;n.extend(n.event, { trigger: function trigger(b, c, e, f) {\n      var g,\n          h,\n          i,\n          j,\n          l,\n          m,\n          o,\n          p = [e || d],\n          q = k.call(b, \"type\") ? b.type : b,\n          r = k.call(b, \"namespace\") ? b.namespace.split(\".\") : [];if (h = i = e = e || d, 3 !== e.nodeType && 8 !== e.nodeType && !hb.test(q + n.event.triggered) && (q.indexOf(\".\") > -1 && (r = q.split(\".\"), q = r.shift(), r.sort()), l = q.indexOf(\":\") < 0 && \"on\" + q, b = b[n.expando] ? b : new n.Event(q, \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && b), b.isTrigger = f ? 2 : 3, b.namespace = r.join(\".\"), b.rnamespace = b.namespace ? new RegExp(\"(^|\\\\.)\" + r.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null, b.result = void 0, b.target || (b.target = e), c = null == c ? [b] : n.makeArray(c, [b]), o = n.event.special[q] || {}, f || !o.trigger || o.trigger.apply(e, c) !== !1)) {\n        if (!f && !o.noBubble && !n.isWindow(e)) {\n          for (j = o.delegateType || q, hb.test(j + q) || (h = h.parentNode); h; h = h.parentNode) {\n            p.push(h), i = h;\n          }i === (e.ownerDocument || d) && p.push(i.defaultView || i.parentWindow || a);\n        }g = 0;while ((h = p[g++]) && !b.isPropagationStopped()) {\n          b.type = g > 1 ? j : o.bindType || q, m = (N.get(h, \"events\") || {})[b.type] && N.get(h, \"handle\"), m && m.apply(h, c), m = l && h[l], m && m.apply && L(h) && (b.result = m.apply(h, c), b.result === !1 && b.preventDefault());\n        }return b.type = q, f || b.isDefaultPrevented() || o._default && o._default.apply(p.pop(), c) !== !1 || !L(e) || l && n.isFunction(e[q]) && !n.isWindow(e) && (i = e[l], i && (e[l] = null), n.event.triggered = q, e[q](), n.event.triggered = void 0, i && (e[l] = i)), b.result;\n      }\n    }, simulate: function simulate(a, b, c) {\n      var d = n.extend(new n.Event(), c, { type: a, isSimulated: !0 });n.event.trigger(d, null, b), d.isDefaultPrevented() && c.preventDefault();\n    } }), n.fn.extend({ trigger: function trigger(a, b) {\n      return this.each(function () {\n        n.event.trigger(a, b, this);\n      });\n    }, triggerHandler: function triggerHandler(a, b) {\n      var c = this[0];return c ? n.event.trigger(a, b, c, !0) : void 0;\n    } }), n.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"), function (a, b) {\n    n.fn[b] = function (a, c) {\n      return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);\n    };\n  }), n.fn.extend({ hover: function hover(a, b) {\n      return this.mouseenter(a).mouseleave(b || a);\n    } }), l.focusin = \"onfocusin\" in a, l.focusin || n.each({ focus: \"focusin\", blur: \"focusout\" }, function (a, b) {\n    var c = function c(a) {\n      n.event.simulate(b, a.target, n.event.fix(a));\n    };n.event.special[b] = { setup: function setup() {\n        var d = this.ownerDocument || this,\n            e = N.access(d, b);e || d.addEventListener(a, c, !0), N.access(d, b, (e || 0) + 1);\n      }, teardown: function teardown() {\n        var d = this.ownerDocument || this,\n            e = N.access(d, b) - 1;e ? N.access(d, b, e) : (d.removeEventListener(a, c, !0), N.remove(d, b));\n      } };\n  });var ib = a.location,\n      jb = n.now(),\n      kb = /\\?/;n.parseJSON = function (a) {\n    return JSON.parse(a + \"\");\n  }, n.parseXML = function (b) {\n    var c;if (!b || \"string\" != typeof b) return null;try {\n      c = new a.DOMParser().parseFromString(b, \"text/xml\");\n    } catch (d) {\n      c = void 0;\n    }return (!c || c.getElementsByTagName(\"parsererror\").length) && n.error(\"Invalid XML: \" + b), c;\n  };var lb = /#.*$/,\n      mb = /([?&])_=[^&]*/,\n      nb = /^(.*?):[ \\t]*([^\\r\\n]*)$/gm,\n      ob = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n      pb = /^(?:GET|HEAD)$/,\n      qb = /^\\/\\//,\n      rb = {},\n      sb = {},\n      tb = \"*/\".concat(\"*\"),\n      ub = d.createElement(\"a\");ub.href = ib.href;function vb(a) {\n    return function (b, c) {\n      \"string\" != typeof b && (c = b, b = \"*\");var d,\n          e = 0,\n          f = b.toLowerCase().match(G) || [];if (n.isFunction(c)) while (d = f[e++]) {\n        \"+\" === d[0] ? (d = d.slice(1) || \"*\", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);\n      }\n    };\n  }function wb(a, b, c, d) {\n    var e = {},\n        f = a === sb;function g(h) {\n      var i;return e[h] = !0, n.each(a[h] || [], function (a, h) {\n        var j = h(b, c, d);return \"string\" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1);\n      }), i;\n    }return g(b.dataTypes[0]) || !e[\"*\"] && g(\"*\");\n  }function xb(a, b) {\n    var c,\n        d,\n        e = n.ajaxSettings.flatOptions || {};for (c in b) {\n      void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);\n    }return d && n.extend(!0, a, d), a;\n  }function yb(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h = a.contents,\n        i = a.dataTypes;while (\"*\" === i[0]) {\n      i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader(\"Content-Type\"));\n    }if (d) for (e in h) {\n      if (h[e] && h[e].test(d)) {\n        i.unshift(e);break;\n      }\n    }if (i[0] in c) f = i[0];else {\n      for (e in c) {\n        if (!i[0] || a.converters[e + \" \" + i[0]]) {\n          f = e;break;\n        }g || (g = e);\n      }f = f || g;\n    }return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;\n  }function zb(a, b, c, d) {\n    var e,\n        f,\n        g,\n        h,\n        i,\n        j = {},\n        k = a.dataTypes.slice();if (k[1]) for (g in a.converters) {\n      j[g.toLowerCase()] = a.converters[g];\n    }f = k.shift();while (f) {\n      if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if (\"*\" === f) f = i;else if (\"*\" !== i && i !== f) {\n        if (g = j[i + \" \" + f] || j[\"* \" + f], !g) for (e in j) {\n          if (h = e.split(\" \"), h[1] === f && (g = j[i + \" \" + h[0]] || j[\"* \" + h[0]])) {\n            g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));break;\n          }\n        }if (g !== !0) if (g && a[\"throws\"]) b = g(b);else try {\n          b = g(b);\n        } catch (l) {\n          return { state: \"parsererror\", error: g ? l : \"No conversion from \" + i + \" to \" + f };\n        }\n      }\n    }return { state: \"success\", data: b };\n  }n.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: ib.href, type: \"GET\", isLocal: ob.test(ib.protocol), global: !0, processData: !0, async: !0, contentType: \"application/x-www-form-urlencoded; charset=UTF-8\", accepts: { \"*\": tb, text: \"text/plain\", html: \"text/html\", xml: \"application/xml, text/xml\", json: \"application/json, text/javascript\" }, contents: { xml: /\\bxml\\b/, html: /\\bhtml/, json: /\\bjson\\b/ }, responseFields: { xml: \"responseXML\", text: \"responseText\", json: \"responseJSON\" }, converters: { \"* text\": String, \"text html\": !0, \"text json\": n.parseJSON, \"text xml\": n.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function ajaxSetup(a, b) {\n      return b ? xb(xb(a, n.ajaxSettings), b) : xb(n.ajaxSettings, a);\n    }, ajaxPrefilter: vb(rb), ajaxTransport: vb(sb), ajax: function ajax(b, c) {\n      \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && (c = b, b = void 0), c = c || {};var e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m = n.ajaxSetup({}, c),\n          o = m.context || m,\n          p = m.context && (o.nodeType || o.jquery) ? n(o) : n.event,\n          q = n.Deferred(),\n          r = n.Callbacks(\"once memory\"),\n          s = m.statusCode || {},\n          t = {},\n          u = {},\n          v = 0,\n          w = \"canceled\",\n          x = { readyState: 0, getResponseHeader: function getResponseHeader(a) {\n          var b;if (2 === v) {\n            if (!h) {\n              h = {};while (b = nb.exec(g)) {\n                h[b[1].toLowerCase()] = b[2];\n              }\n            }b = h[a.toLowerCase()];\n          }return null == b ? null : b;\n        }, getAllResponseHeaders: function getAllResponseHeaders() {\n          return 2 === v ? g : null;\n        }, setRequestHeader: function setRequestHeader(a, b) {\n          var c = a.toLowerCase();return v || (a = u[c] = u[c] || a, t[a] = b), this;\n        }, overrideMimeType: function overrideMimeType(a) {\n          return v || (m.mimeType = a), this;\n        }, statusCode: function statusCode(a) {\n          var b;if (a) if (2 > v) for (b in a) {\n            s[b] = [s[b], a[b]];\n          } else x.always(a[x.status]);return this;\n        }, abort: function abort(a) {\n          var b = a || w;return e && e.abort(b), z(0, b), this;\n        } };if (q.promise(x).complete = r.add, x.success = x.done, x.error = x.fail, m.url = ((b || m.url || ib.href) + \"\").replace(lb, \"\").replace(qb, ib.protocol + \"//\"), m.type = c.method || c.type || m.method || m.type, m.dataTypes = n.trim(m.dataType || \"*\").toLowerCase().match(G) || [\"\"], null == m.crossDomain) {\n        j = d.createElement(\"a\");try {\n          j.href = m.url, j.href = j.href, m.crossDomain = ub.protocol + \"//\" + ub.host != j.protocol + \"//\" + j.host;\n        } catch (y) {\n          m.crossDomain = !0;\n        }\n      }if (m.data && m.processData && \"string\" != typeof m.data && (m.data = n.param(m.data, m.traditional)), wb(rb, m, c, x), 2 === v) return x;k = n.event && m.global, k && 0 === n.active++ && n.event.trigger(\"ajaxStart\"), m.type = m.type.toUpperCase(), m.hasContent = !pb.test(m.type), f = m.url, m.hasContent || (m.data && (f = m.url += (kb.test(f) ? \"&\" : \"?\") + m.data, delete m.data), m.cache === !1 && (m.url = mb.test(f) ? f.replace(mb, \"$1_=\" + jb++) : f + (kb.test(f) ? \"&\" : \"?\") + \"_=\" + jb++)), m.ifModified && (n.lastModified[f] && x.setRequestHeader(\"If-Modified-Since\", n.lastModified[f]), n.etag[f] && x.setRequestHeader(\"If-None-Match\", n.etag[f])), (m.data && m.hasContent && m.contentType !== !1 || c.contentType) && x.setRequestHeader(\"Content-Type\", m.contentType), x.setRequestHeader(\"Accept\", m.dataTypes[0] && m.accepts[m.dataTypes[0]] ? m.accepts[m.dataTypes[0]] + (\"*\" !== m.dataTypes[0] ? \", \" + tb + \"; q=0.01\" : \"\") : m.accepts[\"*\"]);for (l in m.headers) {\n        x.setRequestHeader(l, m.headers[l]);\n      }if (m.beforeSend && (m.beforeSend.call(o, x, m) === !1 || 2 === v)) return x.abort();w = \"abort\";for (l in { success: 1, error: 1, complete: 1 }) {\n        x[l](m[l]);\n      }if (e = wb(sb, m, c, x)) {\n        if (x.readyState = 1, k && p.trigger(\"ajaxSend\", [x, m]), 2 === v) return x;m.async && m.timeout > 0 && (i = a.setTimeout(function () {\n          x.abort(\"timeout\");\n        }, m.timeout));try {\n          v = 1, e.send(t, z);\n        } catch (y) {\n          if (!(2 > v)) throw y;z(-1, y);\n        }\n      } else z(-1, \"No Transport\");function z(b, c, d, h) {\n        var j,\n            l,\n            t,\n            u,\n            w,\n            y = c;2 !== v && (v = 2, i && a.clearTimeout(i), e = void 0, g = h || \"\", x.readyState = b > 0 ? 4 : 0, j = b >= 200 && 300 > b || 304 === b, d && (u = yb(m, x, d)), u = zb(m, u, x, j), j ? (m.ifModified && (w = x.getResponseHeader(\"Last-Modified\"), w && (n.lastModified[f] = w), w = x.getResponseHeader(\"etag\"), w && (n.etag[f] = w)), 204 === b || \"HEAD\" === m.type ? y = \"nocontent\" : 304 === b ? y = \"notmodified\" : (y = u.state, l = u.data, t = u.error, j = !t)) : (t = y, (b || !y) && (y = \"error\", 0 > b && (b = 0))), x.status = b, x.statusText = (c || y) + \"\", j ? q.resolveWith(o, [l, y, x]) : q.rejectWith(o, [x, y, t]), x.statusCode(s), s = void 0, k && p.trigger(j ? \"ajaxSuccess\" : \"ajaxError\", [x, m, j ? l : t]), r.fireWith(o, [x, y]), k && (p.trigger(\"ajaxComplete\", [x, m]), --n.active || n.event.trigger(\"ajaxStop\")));\n      }return x;\n    }, getJSON: function getJSON(a, b, c) {\n      return n.get(a, b, c, \"json\");\n    }, getScript: function getScript(a, b) {\n      return n.get(a, void 0, b, \"script\");\n    } }), n.each([\"get\", \"post\"], function (a, b) {\n    n[b] = function (a, c, d, e) {\n      return n.isFunction(c) && (e = e || d, d = c, c = void 0), n.ajax(n.extend({ url: a, type: b, dataType: e, data: c, success: d }, n.isPlainObject(a) && a));\n    };\n  }), n._evalUrl = function (a) {\n    return n.ajax({ url: a, type: \"GET\", dataType: \"script\", async: !1, global: !1, \"throws\": !0 });\n  }, n.fn.extend({ wrapAll: function wrapAll(a) {\n      var b;return n.isFunction(a) ? this.each(function (b) {\n        n(this).wrapAll(a.call(this, b));\n      }) : (this[0] && (b = n(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function () {\n        var a = this;while (a.firstElementChild) {\n          a = a.firstElementChild;\n        }return a;\n      }).append(this)), this);\n    }, wrapInner: function wrapInner(a) {\n      return n.isFunction(a) ? this.each(function (b) {\n        n(this).wrapInner(a.call(this, b));\n      }) : this.each(function () {\n        var b = n(this),\n            c = b.contents();c.length ? c.wrapAll(a) : b.append(a);\n      });\n    }, wrap: function wrap(a) {\n      var b = n.isFunction(a);return this.each(function (c) {\n        n(this).wrapAll(b ? a.call(this, c) : a);\n      });\n    }, unwrap: function unwrap() {\n      return this.parent().each(function () {\n        n.nodeName(this, \"body\") || n(this).replaceWith(this.childNodes);\n      }).end();\n    } }), n.expr.filters.hidden = function (a) {\n    return !n.expr.filters.visible(a);\n  }, n.expr.filters.visible = function (a) {\n    return a.offsetWidth > 0 || a.offsetHeight > 0 || a.getClientRects().length > 0;\n  };var Ab = /%20/g,\n      Bb = /\\[\\]$/,\n      Cb = /\\r?\\n/g,\n      Db = /^(?:submit|button|image|reset|file)$/i,\n      Eb = /^(?:input|select|textarea|keygen)/i;function Fb(a, b, c, d) {\n    var e;if (n.isArray(b)) n.each(b, function (b, e) {\n      c || Bb.test(a) ? d(a, e) : Fb(a + \"[\" + (\"object\" == (typeof e === \"undefined\" ? \"undefined\" : _typeof(e)) && null != e ? b : \"\") + \"]\", e, c, d);\n    });else if (c || \"object\" !== n.type(b)) d(a, b);else for (e in b) {\n      Fb(a + \"[\" + e + \"]\", b[e], c, d);\n    }\n  }n.param = function (a, b) {\n    var c,\n        d = [],\n        e = function e(a, b) {\n      b = n.isFunction(b) ? b() : null == b ? \"\" : b, d[d.length] = encodeURIComponent(a) + \"=\" + encodeURIComponent(b);\n    };if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray(a) || a.jquery && !n.isPlainObject(a)) n.each(a, function () {\n      e(this.name, this.value);\n    });else for (c in a) {\n      Fb(c, a[c], b, e);\n    }return d.join(\"&\").replace(Ab, \"+\");\n  }, n.fn.extend({ serialize: function serialize() {\n      return n.param(this.serializeArray());\n    }, serializeArray: function serializeArray() {\n      return this.map(function () {\n        var a = n.prop(this, \"elements\");return a ? n.makeArray(a) : this;\n      }).filter(function () {\n        var a = this.type;return this.name && !n(this).is(\":disabled\") && Eb.test(this.nodeName) && !Db.test(a) && (this.checked || !X.test(a));\n      }).map(function (a, b) {\n        var c = n(this).val();return null == c ? null : n.isArray(c) ? n.map(c, function (a) {\n          return { name: b.name, value: a.replace(Cb, \"\\r\\n\") };\n        }) : { name: b.name, value: c.replace(Cb, \"\\r\\n\") };\n      }).get();\n    } }), n.ajaxSettings.xhr = function () {\n    try {\n      return new a.XMLHttpRequest();\n    } catch (b) {}\n  };var Gb = { 0: 200, 1223: 204 },\n      Hb = n.ajaxSettings.xhr();l.cors = !!Hb && \"withCredentials\" in Hb, l.ajax = Hb = !!Hb, n.ajaxTransport(function (b) {\n    var _c, d;return l.cors || Hb && !b.crossDomain ? { send: function send(e, f) {\n        var g,\n            h = b.xhr();if (h.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields) for (g in b.xhrFields) {\n          h[g] = b.xhrFields[g];\n        }b.mimeType && h.overrideMimeType && h.overrideMimeType(b.mimeType), b.crossDomain || e[\"X-Requested-With\"] || (e[\"X-Requested-With\"] = \"XMLHttpRequest\");for (g in e) {\n          h.setRequestHeader(g, e[g]);\n        }_c = function c(a) {\n          return function () {\n            _c && (_c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null, \"abort\" === a ? h.abort() : \"error\" === a ? \"number\" != typeof h.status ? f(0, \"error\") : f(h.status, h.statusText) : f(Gb[h.status] || h.status, h.statusText, \"text\" !== (h.responseType || \"text\") || \"string\" != typeof h.responseText ? { binary: h.response } : { text: h.responseText }, h.getAllResponseHeaders()));\n          };\n        }, h.onload = _c(), d = h.onerror = _c(\"error\"), void 0 !== h.onabort ? h.onabort = d : h.onreadystatechange = function () {\n          4 === h.readyState && a.setTimeout(function () {\n            _c && d();\n          });\n        }, _c = _c(\"abort\");try {\n          h.send(b.hasContent && b.data || null);\n        } catch (i) {\n          if (_c) throw i;\n        }\n      }, abort: function abort() {\n        _c && _c();\n      } } : void 0;\n  }), n.ajaxSetup({ accepts: { script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\" }, contents: { script: /\\b(?:java|ecma)script\\b/ }, converters: { \"text script\": function textScript(a) {\n        return n.globalEval(a), a;\n      } } }), n.ajaxPrefilter(\"script\", function (a) {\n    void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = \"GET\");\n  }), n.ajaxTransport(\"script\", function (a) {\n    if (a.crossDomain) {\n      var b, _c2;return { send: function send(e, f) {\n          b = n(\"<script>\").prop({ charset: a.scriptCharset, src: a.url }).on(\"load error\", _c2 = function c(a) {\n            b.remove(), _c2 = null, a && f(\"error\" === a.type ? 404 : 200, a.type);\n          }), d.head.appendChild(b[0]);\n        }, abort: function abort() {\n          _c2 && _c2();\n        } };\n    }\n  });var Ib = [],\n      Jb = /(=)\\?(?=&|$)|\\?\\?/;n.ajaxSetup({ jsonp: \"callback\", jsonpCallback: function jsonpCallback() {\n      var a = Ib.pop() || n.expando + \"_\" + jb++;return this[a] = !0, a;\n    } }), n.ajaxPrefilter(\"json jsonp\", function (b, c, d) {\n    var e,\n        f,\n        g,\n        h = b.jsonp !== !1 && (Jb.test(b.url) ? \"url\" : \"string\" == typeof b.data && 0 === (b.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && Jb.test(b.data) && \"data\");return h || \"jsonp\" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Jb, \"$1\" + e) : b.jsonp !== !1 && (b.url += (kb.test(b.url) ? \"&\" : \"?\") + b.jsonp + \"=\" + e), b.converters[\"script json\"] = function () {\n      return g || n.error(e + \" was not called\"), g[0];\n    }, b.dataTypes[0] = \"json\", f = a[e], a[e] = function () {\n      g = arguments;\n    }, d.always(function () {\n      void 0 === f ? n(a).removeProp(e) : a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Ib.push(e)), g && n.isFunction(f) && f(g[0]), g = f = void 0;\n    }), \"script\") : void 0;\n  }), l.createHTMLDocument = function () {\n    var a = d.implementation.createHTMLDocument(\"\").body;return a.innerHTML = \"<form></form><form></form>\", 2 === a.childNodes.length;\n  }(), n.parseHTML = function (a, b, c) {\n    if (!a || \"string\" != typeof a) return null;\"boolean\" == typeof b && (c = b, b = !1), b = b || (l.createHTMLDocument ? d.implementation.createHTMLDocument(\"\") : d);var e = x.exec(a),\n        f = !c && [];return e ? [b.createElement(e[1])] : (e = ca([a], b, f), f && f.length && n(f).remove(), n.merge([], e.childNodes));\n  };var Kb = n.fn.load;n.fn.load = function (a, b, c) {\n    if (\"string\" != typeof a && Kb) return Kb.apply(this, arguments);var d,\n        e,\n        f,\n        g = this,\n        h = a.indexOf(\" \");return h > -1 && (d = n.trim(a.slice(h)), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b && \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && (e = \"POST\"), g.length > 0 && n.ajax({ url: a, type: e || \"GET\", dataType: \"html\", data: b }).done(function (a) {\n      f = arguments, g.html(d ? n(\"<div>\").append(n.parseHTML(a)).find(d) : a);\n    }).always(c && function (a, b) {\n      g.each(function () {\n        c.apply(g, f || [a.responseText, b, a]);\n      });\n    }), this;\n  }, n.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (a, b) {\n    n.fn[b] = function (a) {\n      return this.on(b, a);\n    };\n  }), n.expr.filters.animated = function (a) {\n    return n.grep(n.timers, function (b) {\n      return a === b.elem;\n    }).length;\n  };function Lb(a) {\n    return n.isWindow(a) ? a : 9 === a.nodeType && a.defaultView;\n  }n.offset = { setOffset: function setOffset(a, b, c) {\n      var d,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k = n.css(a, \"position\"),\n          l = n(a),\n          m = {};\"static\" === k && (a.style.position = \"relative\"), h = l.offset(), f = n.css(a, \"top\"), i = n.css(a, \"left\"), j = (\"absolute\" === k || \"fixed\" === k) && (f + i).indexOf(\"auto\") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), n.isFunction(b) && (b = b.call(a, c, n.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), \"using\" in b ? b.using.call(a, m) : l.css(m);\n    } }, n.fn.extend({ offset: function offset(a) {\n      if (arguments.length) return void 0 === a ? this : this.each(function (b) {\n        n.offset.setOffset(this, a, b);\n      });var b,\n          c,\n          d = this[0],\n          e = { top: 0, left: 0 },\n          f = d && d.ownerDocument;if (f) return b = f.documentElement, n.contains(b, d) ? (e = d.getBoundingClientRect(), c = Lb(f), { top: e.top + c.pageYOffset - b.clientTop, left: e.left + c.pageXOffset - b.clientLeft }) : e;\n    }, position: function position() {\n      if (this[0]) {\n        var a,\n            b,\n            c = this[0],\n            d = { top: 0, left: 0 };return \"fixed\" === n.css(c, \"position\") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), n.nodeName(a[0], \"html\") || (d = a.offset()), d.top += n.css(a[0], \"borderTopWidth\", !0), d.left += n.css(a[0], \"borderLeftWidth\", !0)), { top: b.top - d.top - n.css(c, \"marginTop\", !0), left: b.left - d.left - n.css(c, \"marginLeft\", !0) };\n      }\n    }, offsetParent: function offsetParent() {\n      return this.map(function () {\n        var a = this.offsetParent;while (a && \"static\" === n.css(a, \"position\")) {\n          a = a.offsetParent;\n        }return a || Ea;\n      });\n    } }), n.each({ scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function (a, b) {\n    var c = \"pageYOffset\" === b;n.fn[a] = function (d) {\n      return K(this, function (a, d, e) {\n        var f = Lb(a);return void 0 === e ? f ? f[b] : a[d] : void (f ? f.scrollTo(c ? f.pageXOffset : e, c ? e : f.pageYOffset) : a[d] = e);\n      }, a, d, arguments.length);\n    };\n  }), n.each([\"top\", \"left\"], function (a, b) {\n    n.cssHooks[b] = Ga(l.pixelPosition, function (a, c) {\n      return c ? (c = Fa(a, b), Ba.test(c) ? n(a).position()[b] + \"px\" : c) : void 0;\n    });\n  }), n.each({ Height: \"height\", Width: \"width\" }, function (a, b) {\n    n.each({ padding: \"inner\" + a, content: b, \"\": \"outer\" + a }, function (c, d) {\n      n.fn[d] = function (d, e) {\n        var f = arguments.length && (c || \"boolean\" != typeof d),\n            g = c || (d === !0 || e === !0 ? \"margin\" : \"border\");return K(this, function (b, c, d) {\n          var e;return n.isWindow(b) ? b.document.documentElement[\"client\" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body[\"scroll\" + a], e[\"scroll\" + a], b.body[\"offset\" + a], e[\"offset\" + a], e[\"client\" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g);\n        }, b, f ? d : void 0, f, null);\n      };\n    });\n  }), n.fn.extend({ bind: function bind(a, b, c) {\n      return this.on(a, null, b, c);\n    }, unbind: function unbind(a, b) {\n      return this.off(a, null, b);\n    }, delegate: function delegate(a, b, c, d) {\n      return this.on(b, a, c, d);\n    }, undelegate: function undelegate(a, b, c) {\n      return 1 === arguments.length ? this.off(a, \"**\") : this.off(b, a || \"**\", c);\n    }, size: function size() {\n      return this.length;\n    } }), n.fn.andSelf = n.fn.addBack, \"function\" == typeof define && define.amd && define(\"jquery\", [], function () {\n    return n;\n  });var Mb = a.jQuery,\n      Nb = a.$;return n.noConflict = function (b) {\n    return a.$ === n && (a.$ = Nb), b && a.jQuery === n && (a.jQuery = Mb), n;\n  }, b || (a.jQuery = a.$ = n), n;\n});"

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2)(__webpack_require__(5))

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = "\"use strict\";var _typeof=typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}!function(t){\"use strict\";function e(t){if(void 0===Function.prototype.name){var e=/function\\s([^(]{1,})\\(/,i=e.exec(t.toString());return i&&i.length>1?i[1].trim():\"\";}return void 0===t.prototype?t.constructor.name:t.prototype.constructor.name;}function i(t){return /true/.test(t)?!0:/false/.test(t)?!1:isNaN(1*t)?t:parseFloat(t);}function n(t){return t.replace(/([a-z])([A-Z])/g,\"$1-$2\").toLowerCase();}var s=\"6.2.0\",o={version:s,_plugins:{},_uuids:[],rtl:function rtl(){return\"rtl\"===t(\"html\").attr(\"dir\");},plugin:function plugin(t,i){var s=i||e(t),o=n(s);this._plugins[o]=this[s]=t;},registerPlugin:function registerPlugin(t,i){var s=i?n(i):e(t.constructor).toLowerCase();t.uuid=this.GetYoDigits(6,s),t.$element.attr(\"data-\"+s)||t.$element.attr(\"data-\"+s,t.uuid),t.$element.data(\"zfPlugin\")||t.$element.data(\"zfPlugin\",t),t.$element.trigger(\"init.zf.\"+s),this._uuids.push(t.uuid);},unregisterPlugin:function unregisterPlugin(t){var i=n(e(t.$element.data(\"zfPlugin\").constructor));this._uuids.splice(this._uuids.indexOf(t.uuid),1),t.$element.removeAttr(\"data-\"+i).removeData(\"zfPlugin\").trigger(\"destroyed.zf.\"+i);for(var s in t){t[s]=null;}},reInit:function reInit(e){var i=e instanceof t;try{if(i)e.each(function(){t(this).data(\"zfPlugin\")._init();});else{var s=typeof e===\"undefined\"?\"undefined\":_typeof(e),o=this,a={object:function object(e){e.forEach(function(e){e=n(e),t(\"[data-\"+e+\"]\").foundation(\"_init\");});},string:function string(){e=n(e),t(\"[data-\"+e+\"]\").foundation(\"_init\");},undefined:function undefined(){this.object(Object.keys(o._plugins));}};a[s](e);}}catch(r){console.error(r);}finally{return e;}},GetYoDigits:function GetYoDigits(t,e){return t=t||6,Math.round(Math.pow(36,t+1)-Math.random()*Math.pow(36,t)).toString(36).slice(1)+(e?\"-\"+e:\"\");},reflow:function reflow(e,n){\"undefined\"==typeof n?n=Object.keys(this._plugins):\"string\"==typeof n&&(n=[n]);var s=this;t.each(n,function(n,o){var a=s._plugins[o],r=t(e).find(\"[data-\"+o+\"]\").addBack(\"[data-\"+o+\"]\");r.each(function(){var e=t(this),n={};if(e.data(\"zfPlugin\"))return void console.warn(\"Tried to initialize \"+o+\" on an element that already has a Foundation plugin.\");if(e.attr(\"data-options\")){e.attr(\"data-options\").split(\";\").forEach(function(t,e){var s=t.split(\":\").map(function(t){return t.trim();});s[0]&&(n[s[0]]=i(s[1]));});}try{e.data(\"zfPlugin\",new a(t(this),n));}catch(s){console.error(s);}finally{return;}});});},getFnName:e,transitionend:function transitionend(t){var e,i={transition:\"transitionend\",WebkitTransition:\"webkitTransitionEnd\",MozTransition:\"transitionend\",OTransition:\"otransitionend\"},n=document.createElement(\"div\");for(var s in i){\"undefined\"!=typeof n.style[s]&&(e=i[s]);}return e?e:(e=setTimeout(function(){t.triggerHandler(\"transitionend\",[t]);},1),\"transitionend\");}};o.util={throttle:function throttle(t,e){var i=null;return function(){var n=this,s=arguments;null===i&&(i=setTimeout(function(){t.apply(n,s),i=null;},e));};}};var a=function a(i){var n=typeof i===\"undefined\"?\"undefined\":_typeof(i),s=t(\"meta.foundation-mq\"),a=t(\".no-js\");if(s.length||t('<meta class=\"foundation-mq\">').appendTo(document.head),a.length&&a.removeClass(\"no-js\"),\"undefined\"===n)o.MediaQuery._init(),o.reflow(this);else{if(\"string\"!==n)throw new TypeError(\"We're sorry, \"+n+\" is not a valid parameter. You must use a string representing the method you wish to invoke.\");var r=Array.prototype.slice.call(arguments,1),l=this.data(\"zfPlugin\");if(void 0===l||void 0===l[i])throw new ReferenceError(\"We're sorry, '\"+i+\"' is not an available method for \"+(l?e(l):\"this element\")+\".\");1===this.length?l[i].apply(l,r):this.each(function(e,n){l[i].apply(t(n).data(\"zfPlugin\"),r);});}return this;};window.Foundation=o,t.fn.foundation=a,function(){Date.now&&window.Date.now||(window.Date.now=Date.now=function(){return new Date().getTime();});for(var t=[\"webkit\",\"moz\"],e=0;e<t.length&&!window.requestAnimationFrame;++e){var i=t[e];window.requestAnimationFrame=window[i+\"RequestAnimationFrame\"],window.cancelAnimationFrame=window[i+\"CancelAnimationFrame\"]||window[i+\"CancelRequestAnimationFrame\"];}if(/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent)||!window.requestAnimationFrame||!window.cancelAnimationFrame){var n=0;window.requestAnimationFrame=function(t){var e=Date.now(),i=Math.max(n+16,e);return setTimeout(function(){t(n=i);},i-e);},window.cancelAnimationFrame=clearTimeout;}window.performance&&window.performance.now||(window.performance={start:Date.now(),now:function now(){return Date.now()-this.start;}});}(),Function.prototype.bind||(Function.prototype.bind=function(t){if(\"function\"!=typeof this)throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");var e=Array.prototype.slice.call(arguments,1),i=this,n=function n(){},s=function s(){return i.apply(this instanceof n?this:t,e.concat(Array.prototype.slice.call(arguments)));};return this.prototype&&(n.prototype=this.prototype),s.prototype=new n(),s;});}(jQuery),!function(t){function e(t,e,n,s){var o,a,r,l,u=i(t);if(e){var d=i(e);a=u.offset.top+u.height<=d.height+d.offset.top,o=u.offset.top>=d.offset.top,r=u.offset.left>=d.offset.left,l=u.offset.left+u.width<=d.width;}else a=u.offset.top+u.height<=u.windowDims.height+u.windowDims.offset.top,o=u.offset.top>=u.windowDims.offset.top,r=u.offset.left>=u.windowDims.offset.left,l=u.offset.left+u.width<=u.windowDims.width;var h=[a,o,r,l];return n?r===l==!0:s?o===a==!0:-1===h.indexOf(!1);}function i(t,e){if(t=t.length?t[0]:t,t===window||t===document)throw new Error(\"I'm sorry, Dave. I'm afraid I can't do that.\");var i=t.getBoundingClientRect(),n=t.parentNode.getBoundingClientRect(),s=document.body.getBoundingClientRect(),o=window.pageYOffset,a=window.pageXOffset;return{width:i.width,height:i.height,offset:{top:i.top+o,left:i.left+a},parentDims:{width:n.width,height:n.height,offset:{top:n.top+o,left:n.left+a}},windowDims:{width:s.width,height:s.height,offset:{top:o,left:a}}};}function n(t,e,n,s,o,a){var r=i(t),l=e?i(e):null;switch(n){case\"top\":return{left:Foundation.rtl()?l.offset.left-r.width+l.width:l.offset.left,top:l.offset.top-(r.height+s)};case\"left\":return{left:l.offset.left-(r.width+o),top:l.offset.top};case\"right\":return{left:l.offset.left+l.width+o,top:l.offset.top};case\"center top\":return{left:l.offset.left+l.width/2-r.width/2,top:l.offset.top-(r.height+s)};case\"center bottom\":return{left:a?o:l.offset.left+l.width/2-r.width/2,top:l.offset.top+l.height+s};case\"center left\":return{left:l.offset.left-(r.width+o),top:l.offset.top+l.height/2-r.height/2};case\"center right\":return{left:l.offset.left+l.width+o+1,top:l.offset.top+l.height/2-r.height/2};case\"center\":return{left:r.windowDims.offset.left+r.windowDims.width/2-r.width/2,top:r.windowDims.offset.top+r.windowDims.height/2-r.height/2};case\"reveal\":return{left:(r.windowDims.width-r.width)/2,top:r.windowDims.offset.top+s};case\"reveal full\":return{left:r.windowDims.offset.left,top:r.windowDims.offset.top};default:return{left:Foundation.rtl()?l.offset.left-r.width+l.width:l.offset.left,top:l.offset.top+l.height+s};}}Foundation.Box={ImNotTouchingYou:e,GetDimensions:i,GetOffsets:n};}(jQuery),!function(t){function e(t){var e={};for(var i in t){e[t[i]]=t[i];}return e;}var i={9:\"TAB\",13:\"ENTER\",27:\"ESCAPE\",32:\"SPACE\",37:\"ARROW_LEFT\",38:\"ARROW_UP\",39:\"ARROW_RIGHT\",40:\"ARROW_DOWN\"},n={},s={keys:e(i),parseKey:function parseKey(t){var e=i[t.which||t.keyCode]||String.fromCharCode(t.which).toUpperCase();return t.shiftKey&&(e=\"SHIFT_\"+e),t.ctrlKey&&(e=\"CTRL_\"+e),t.altKey&&(e=\"ALT_\"+e),e;},handleKey:function handleKey(e,i,s){var o,a,r,l=n[i],u=this.parseKey(e);return l?(o=\"undefined\"==typeof l.ltr?l:Foundation.rtl()?t.extend({},l.ltr,l.rtl):t.extend({},l.rtl,l.ltr),a=o[u],r=s[a],void(r&&\"function\"==typeof r?(r.apply(),(s.handled||\"function\"==typeof s.handled)&&s.handled.apply()):(s.unhandled||\"function\"==typeof s.unhandled)&&s.unhandled.apply())):console.warn(\"Component not defined!\");},findFocusable:function findFocusable(e){return e.find(\"a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]\").filter(function(){return t(this).is(\":visible\")&&!(t(this).attr(\"tabindex\")<0);});},register:function register(t,e){n[t]=e;}};Foundation.Keyboard=s;}(jQuery),!function(t){function e(t){var e={};return\"string\"!=typeof t?e:(t=t.trim().slice(1,-1))?e=t.split(\"&\").reduce(function(t,e){var i=e.replace(/\\+/g,\" \").split(\"=\"),n=i[0],s=i[1];return n=decodeURIComponent(n),s=void 0===s?null:decodeURIComponent(s),t.hasOwnProperty(n)?Array.isArray(t[n])?t[n].push(s):t[n]=[t[n],s]:t[n]=s,t;},{}):e;}var i={queries:[],current:\"\",_init:function _init(){var i,n=this,s=t(\".foundation-mq\").css(\"font-family\");i=e(s);for(var o in i){n.queries.push({name:o,value:\"only screen and (min-width: \"+i[o]+\")\"});}this.current=this._getCurrentSize(),this._watcher();},atLeast:function atLeast(t){var e=this.get(t);return e?window.matchMedia(e).matches:!1;},get:function get(t){for(var e in this.queries){var i=this.queries[e];if(t===i.name)return i.value;}return null;},_getCurrentSize:function _getCurrentSize(){var t;for(var e in this.queries){var i=this.queries[e];window.matchMedia(i.value).matches&&(t=i);}return\"object\"==(typeof t===\"undefined\"?\"undefined\":_typeof(t))?t.name:t;},_watcher:function _watcher(){var e=this;t(window).on(\"resize.zf.mediaquery\",function(){var i=e._getCurrentSize();i!==e.current&&(t(window).trigger(\"changed.zf.mediaquery\",[i,e.current]),e.current=i);});}};Foundation.MediaQuery=i,window.matchMedia||(window.matchMedia=function(){\"use strict\";var t=window.styleMedia||window.media;if(!t){var e=document.createElement(\"style\"),i=document.getElementsByTagName(\"script\")[0],n=null;e.type=\"text/css\",e.id=\"matchmediajs-test\",i.parentNode.insertBefore(e,i),n=\"getComputedStyle\"in window&&window.getComputedStyle(e,null)||e.currentStyle,t={matchMedium:function matchMedium(t){var i=\"@media \"+t+\"{ #matchmediajs-test { width: 1px; } }\";return e.styleSheet?e.styleSheet.cssText=i:e.textContent=i,\"1px\"===n.width;}};}return function(e){return{matches:t.matchMedium(e||\"all\"),media:e||\"all\"};};}()),Foundation.MediaQuery=i;}(jQuery),!function(t){function e(t,e,i){function n(r){a||(a=window.performance.now()),o=r-a,i.apply(e),t>o?s=window.requestAnimationFrame(n,e):(window.cancelAnimationFrame(s),e.trigger(\"finished.zf.animate\",[e]).triggerHandler(\"finished.zf.animate\",[e]));}var s,o,a=null;s=window.requestAnimationFrame(n);}function i(e,i,o,a){function r(){e||i.hide(),l(),a&&a.apply(i);}function l(){i[0].style.transitionDuration=0,i.removeClass(u+\" \"+d+\" \"+o);}if(i=t(i).eq(0),i.length){var u=e?n[0]:n[1],d=e?s[0]:s[1];l(),i.addClass(o).css(\"transition\",\"none\"),requestAnimationFrame(function(){i.addClass(u),e&&i.show();}),requestAnimationFrame(function(){i[0].offsetWidth,i.css(\"transition\",\"\").addClass(d);}),i.one(Foundation.transitionend(i),r);}}var n=[\"mui-enter\",\"mui-leave\"],s=[\"mui-enter-active\",\"mui-leave-active\"],o={animateIn:function animateIn(t,e,n){i(!0,t,e,n);},animateOut:function animateOut(t,e,n){i(!1,t,e,n);}};Foundation.Move=e,Foundation.Motion=o;}(jQuery),!function(t){var e={Feather:function Feather(e){var i=arguments.length<=1||void 0===arguments[1]?\"zf\":arguments[1];e.attr(\"role\",\"menubar\");var n=e.find(\"li\").attr({role:\"menuitem\"}),s=\"is-\"+i+\"-submenu\",o=s+\"-item\",a=\"is-\"+i+\"-submenu-parent\";e.find(\"a:first\").attr(\"tabindex\",0),n.each(function(){var e=t(this),i=e.children(\"ul\");i.length&&(e.addClass(a).attr({\"aria-haspopup\":!0,\"aria-expanded\":!1,\"aria-label\":e.children(\"a:first\").text()}),i.addClass(\"submenu \"+s).attr({\"data-submenu\":\"\",\"aria-hidden\":!0,role:\"menu\"})),e.parent(\"[data-submenu]\").length&&e.addClass(\"is-submenu-item \"+o);});},Burn:function Burn(t,e){var i=(t.find(\"li\").removeAttr(\"tabindex\"),\"is-\"+e+\"-submenu\"),n=i+\"-item\",s=\"is-\"+e+\"-submenu-parent\";t.find(\"*\").removeClass(i+\" \"+n+\" \"+s+\" is-submenu-item submenu is-active\").removeAttr(\"data-submenu\").css(\"display\",\"\");}};Foundation.Nest=e;}(jQuery),!function(t){function e(t,e,i){var n,s,o=this,a=e.duration,r=Object.keys(t.data())[0]||\"timer\",l=-1;this.isPaused=!1,this.restart=function(){l=-1,clearTimeout(s),this.start();},this.start=function(){this.isPaused=!1,clearTimeout(s),l=0>=l?a:l,t.data(\"paused\",!1),n=Date.now(),s=setTimeout(function(){e.infinite&&o.restart(),i();},l),t.trigger(\"timerstart.zf.\"+r);},this.pause=function(){this.isPaused=!0,clearTimeout(s),t.data(\"paused\",!0);var e=Date.now();l-=e-n,t.trigger(\"timerpaused.zf.\"+r);};}function i(e,i){function n(){s--,0===s&&i();}var s=e.length;0===s&&i(),e.each(function(){this.complete?n():\"undefined\"!=typeof this.naturalWidth&&this.naturalWidth>0?n():t(this).one(\"load\",function(){n();});});}Foundation.Timer=e,Foundation.onImagesLoaded=i;}(jQuery),function(t){function e(){this.removeEventListener(\"touchmove\",i),this.removeEventListener(\"touchend\",e),u=!1;}function i(i){if(t.spotSwipe.preventDefault&&i.preventDefault(),u){var n,s=i.touches[0].pageX,a=(i.touches[0].pageY,o-s);l=new Date().getTime()-r,Math.abs(a)>=t.spotSwipe.moveThreshold&&l<=t.spotSwipe.timeThreshold&&(n=a>0?\"left\":\"right\"),n&&(i.preventDefault(),e.call(this),t(this).trigger(\"swipe\",n).trigger(\"swipe\"+n));}}function n(t){1==t.touches.length&&(o=t.touches[0].pageX,a=t.touches[0].pageY,u=!0,r=new Date().getTime(),this.addEventListener(\"touchmove\",i,!1),this.addEventListener(\"touchend\",e,!1));}function s(){this.addEventListener&&this.addEventListener(\"touchstart\",n,!1);}t.spotSwipe={version:\"1.0.0\",enabled:\"ontouchstart\"in document.documentElement,preventDefault:!1,moveThreshold:75,timeThreshold:200};var o,a,r,l,u=!1;t.event.special.swipe={setup:s},t.each([\"left\",\"up\",\"down\",\"right\"],function(){t.event.special[\"swipe\"+this]={setup:function setup(){t(this).on(\"swipe\",t.noop);}};});}(jQuery),!function(t){t.fn.addTouch=function(){this.each(function(i,n){t(n).bind(\"touchstart touchmove touchend touchcancel\",function(){e(event);});});var e=function e(t){var e,i=t.changedTouches,n=i[0],s={touchstart:\"mousedown\",touchmove:\"mousemove\",touchend:\"mouseup\"},o=s[t.type];\"MouseEvent\"in window&&\"function\"==typeof window.MouseEvent?e=window.MouseEvent(o,{bubbles:!0,cancelable:!0,screenX:n.screenX,screenY:n.screenY,clientX:n.clientX,clientY:n.clientY}):(e=document.createEvent(\"MouseEvent\"),e.initMouseEvent(o,!0,!0,window,1,n.screenX,n.screenY,n.clientX,n.clientY,!1,!1,!1,!1,0,null)),n.target.dispatchEvent(e);};};}(jQuery),!function(t){function e(){o(),n(),s(),i();}function i(e){var i=t(\"[data-yeti-box]\"),n=[\"dropdown\",\"tooltip\",\"reveal\"];if(e&&(\"string\"==typeof e?n.push(e):\"object\"==(typeof e===\"undefined\"?\"undefined\":_typeof(e))&&\"string\"==typeof e[0]?n.concat(e):console.error(\"Plugin names must be strings\")),i.length){var s=n.map(function(t){return\"closeme.zf.\"+t;}).join(\" \");t(window).off(s).on(s,function(e,i){var n=e.namespace.split(\".\")[0],s=t(\"[data-\"+n+\"]\").not('[data-yeti-box=\"'+i+'\"]');s.each(function(){var e=t(this);e.triggerHandler(\"close.zf.trigger\",[e]);});});}}function n(e){var i=void 0,n=t(\"[data-resize]\");n.length&&t(window).off(\"resize.zf.trigger\").on(\"resize.zf.trigger\",function(s){i&&clearTimeout(i),i=setTimeout(function(){a||n.each(function(){t(this).triggerHandler(\"resizeme.zf.trigger\");}),n.attr(\"data-events\",\"resize\");},e||10);});}function s(e){var i=void 0,n=t(\"[data-scroll]\");n.length&&t(window).off(\"scroll.zf.trigger\").on(\"scroll.zf.trigger\",function(s){i&&clearTimeout(i),i=setTimeout(function(){a||n.each(function(){t(this).triggerHandler(\"scrollme.zf.trigger\");}),n.attr(\"data-events\",\"scroll\");},e||10);});}function o(){if(!a)return!1;var e=document.querySelectorAll(\"[data-resize], [data-scroll], [data-mutate]\"),i=function i(e){var i=t(e[0].target);switch(i.attr(\"data-events\")){case\"resize\":i.triggerHandler(\"resizeme.zf.trigger\",[i]);break;case\"scroll\":i.triggerHandler(\"scrollme.zf.trigger\",[i,window.pageYOffset]);break;default:return!1;}};if(e.length)for(var n=0;n<=e.length-1;n++){var s=new a(i);s.observe(e[n],{attributes:!0,childList:!1,characterData:!1,subtree:!1,attributeFilter:[\"data-events\"]});}}var a=function(){for(var t=[\"WebKit\",\"Moz\",\"O\",\"Ms\",\"\"],e=0;e<t.length;e++){if(t[e]+\"MutationObserver\"in window)return window[t[e]+\"MutationObserver\"];}return!1;}(),r=function r(e,i){e.data(i).split(\" \").forEach(function(n){t(\"#\"+n)[\"close\"===i?\"trigger\":\"triggerHandler\"](i+\".zf.trigger\",[e]);});};t(document).on(\"click.zf.trigger\",\"[data-open]\",function(){r(t(this),\"open\");}),t(document).on(\"click.zf.trigger\",\"[data-close]\",function(){var e=t(this).data(\"close\");e?r(t(this),\"close\"):t(this).trigger(\"close.zf.trigger\");}),t(document).on(\"click.zf.trigger\",\"[data-toggle]\",function(){r(t(this),\"toggle\");}),t(document).on(\"close.zf.trigger\",\"[data-closable]\",function(e){e.stopPropagation();var i=t(this).data(\"closable\");\"\"!==i?Foundation.Motion.animateOut(t(this),i,function(){t(this).trigger(\"closed.zf\");}):t(this).fadeOut().trigger(\"closed.zf\");}),t(document).on(\"focus.zf.trigger blur.zf.trigger\",\"[data-toggle-focus]\",function(){var e=t(this).data(\"toggle-focus\");t(\"#\"+e).triggerHandler(\"toggle.zf.trigger\",[t(this)]);}),t(window).load(function(){e();}),Foundation.IHearYou=e;}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i){var n=arguments.length<=1||void 0===arguments[1]?{}:arguments[1];_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Abide\");}return _createClass(e,[{key:\"_init\",value:function value(){this.$inputs=this.$element.find(\"input, textarea, select\").not(\"[data-abide-ignore]\"),this._events();}},{key:\"_events\",value:function value(){var e=this;this.$element.off(\".abide\").on(\"reset.zf.abide\",function(){e.resetForm();}).on(\"submit.zf.abide\",function(){return e.validateForm();}),\"fieldChange\"===this.options.validateOn&&this.$inputs.off(\"change.zf.abide\").on(\"change.zf.abide\",function(i){e.validateInput(t(i.target));}),this.options.liveValidate&&this.$inputs.off(\"input.zf.abide\").on(\"input.zf.abide\",function(i){e.validateInput(t(i.target));});}},{key:\"_reflow\",value:function value(){this._init();}},{key:\"requiredCheck\",value:function value(t){if(!t.attr(\"required\"))return!0;var e=!0;switch(t[0].type){case\"checkbox\":case\"radio\":e=t[0].checked;break;case\"select\":case\"select-one\":case\"select-multiple\":var i=t.find(\"option:selected\");i.length&&i.val()||(e=!1);break;default:t.val()&&t.val().length||(e=!1);}return e;}},{key:\"findFormError\",value:function value(t){var e=t.siblings(this.options.formErrorSelector);return e.length||(e=t.parent().find(this.options.formErrorSelector)),e;}},{key:\"findLabel\",value:function value(t){var e=t[0].id,i=this.$element.find('label[for=\"'+e+'\"]');return i.length?i:t.closest(\"label\");}},{key:\"addErrorClasses\",value:function value(t){var e=this.findLabel(t),i=this.findFormError(t);e.length&&e.addClass(this.options.labelErrorClass),i.length&&i.addClass(this.options.formErrorClass),t.addClass(this.options.inputErrorClass).attr(\"data-invalid\",\"\");}},{key:\"removeErrorClasses\",value:function value(t){var e=this.findLabel(t),i=this.findFormError(t);e.length&&e.removeClass(this.options.labelErrorClass),i.length&&i.removeClass(this.options.formErrorClass),t.removeClass(this.options.inputErrorClass).removeAttr(\"data-invalid\");}},{key:\"validateInput\",value:function value(t){var e=this.requiredCheck(t),i=!1,n=!0,s=t.attr(\"data-validator\"),o=!0;switch(t[0].type){case\"radio\":i=this.validateRadio(t.attr(\"name\"));break;case\"checkbox\":i=e;break;case\"select\":case\"select-one\":case\"select-multiple\":i=e;break;default:i=this.validateText(t);}s&&(n=this.matchValidation(t,s,t.attr(\"required\"))),t.attr(\"data-equalto\")&&(o=this.options.validators.equalTo(t));var a=-1===[e,i,n,o].indexOf(!1),r=(a?\"valid\":\"invalid\")+\".zf.abide\";return this[a?\"removeErrorClasses\":\"addErrorClasses\"](t),t.trigger(r,[t]),a;}},{key:\"validateForm\",value:function value(){var e=[],i=this;this.$inputs.each(function(){e.push(i.validateInput(t(this)));});var n=-1===e.indexOf(!1);return this.$element.find(\"[data-abide-error]\").css(\"display\",n?\"none\":\"block\"),this.$element.trigger((n?\"formvalid\":\"forminvalid\")+\".zf.abide\",[this.$element]),n;}},{key:\"validateText\",value:function value(t,e){e=e||t.attr(\"pattern\")||t.attr(\"type\");var i=t.val();return i.length?this.options.patterns.hasOwnProperty(e)?this.options.patterns[e].test(i):e&&e!==t.attr(\"type\")?new RegExp(e).test(i):!0:!0;}},{key:\"validateRadio\",value:function value(e){var i=this.$element.find(':radio[name=\"'+e+'\"]'),n=[],s=this;return i.each(function(){var e=t(this),i=s.requiredCheck(e);n.push(i),i&&s.removeErrorClasses(e);}),-1===n.indexOf(!1);}},{key:\"matchValidation\",value:function value(t,e,i){var n=this;i=!!i;var s=e.split(\" \").map(function(e){return n.options.validators[e](t,i,t.parent());});return-1===s.indexOf(!1);}},{key:\"resetForm\",value:function value(){var e=this.$element,i=this.options;t(\".\"+i.labelErrorClass,e).not(\"small\").removeClass(i.labelErrorClass),t(\".\"+i.inputErrorClass,e).not(\"small\").removeClass(i.inputErrorClass),t(i.formErrorSelector+\".\"+i.formErrorClass).removeClass(i.formErrorClass),e.find(\"[data-abide-error]\").css(\"display\",\"none\"),t(\":input\",e).not(\":button, :submit, :reset, :hidden, [data-abide-ignore]\").val(\"\").removeAttr(\"data-invalid\"),e.trigger(\"formreset.zf.abide\",[e]);}},{key:\"destroy\",value:function value(){var e=this;this.$element.off(\".abide\").find(\"[data-abide-error]\").css(\"display\",\"none\"),this.$inputs.off(\".abide\").each(function(){e.removeErrorClasses(t(this));}),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={validateOn:\"fieldChange\",labelErrorClass:\"is-invalid-label\",inputErrorClass:\"is-invalid-input\",formErrorSelector:\".form-error\",formErrorClass:\"is-visible\",liveValidate:!1,patterns:{alpha:/^[a-zA-Z]+$/,alpha_numeric:/^[a-zA-Z0-9]+$/,integer:/^[-+]?\\d+$/,number:/^[-+]?\\d*(?:[\\.\\,]\\d+)?$/,card:/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$/,cvv:/^([0-9]){3,4}$/,email:/^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,url:/^(https?|ftp|file|ssh):\\/\\/(((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/,domain:/^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,8}$/,datetime:/^([0-2][0-9]{3})\\-([0-1][0-9])\\-([0-3][0-9])T([0-5][0-9])\\:([0-5][0-9])\\:([0-5][0-9])(Z|([\\-\\+]([0-1][0-9])\\:00))$/,date:/(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,time:/^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,dateISO:/^\\d{4}[\\/\\-]\\d{1,2}[\\/\\-]\\d{1,2}$/,month_day_year:/^(0[1-9]|1[012])[- \\/.](0[1-9]|[12][0-9]|3[01])[- \\/.]\\d{4}$/,day_month_year:/^(0[1-9]|[12][0-9]|3[01])[- \\/.](0[1-9]|1[012])[- \\/.]\\d{4}$/,color:/^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/},validators:{equalTo:function equalTo(e,i,n){return t(\"#\"+e.attr(\"data-equalto\")).val()===e.val();}}},Foundation.plugin(e,\"Abide\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Accordion\"),Foundation.Keyboard.register(\"Accordion\",{ENTER:\"toggle\",SPACE:\"toggle\",ARROW_DOWN:\"next\",ARROW_UP:\"previous\"});}return _createClass(e,[{key:\"_init\",value:function value(){this.$element.attr(\"role\",\"tablist\"),this.$tabs=this.$element.children(\"li\"),0===this.$tabs.length&&(this.$tabs=this.$element.children(\"[data-accordion-item]\")),this.$tabs.each(function(e,i){var n=t(i),s=n.find(\"[data-tab-content]\"),o=s[0].id||Foundation.GetYoDigits(6,\"accordion\"),a=i.id||o+\"-label\";n.find(\"a:first\").attr({\"aria-controls\":o,role:\"tab\",id:a,\"aria-expanded\":!1,\"aria-selected\":!1}),s.attr({role:\"tabpanel\",\"aria-labelledby\":a,\"aria-hidden\":!0,id:o});});var e=this.$element.find(\".is-active\").children(\"[data-tab-content]\");e.length&&this.down(e,!0),this._events();}},{key:\"_events\",value:function value(){var e=this;this.$tabs.each(function(){var i=t(this),n=i.children(\"[data-tab-content]\");n.length&&i.children(\"a\").off(\"click.zf.accordion keydown.zf.accordion\").on(\"click.zf.accordion\",function(t){t.preventDefault(),i.hasClass(\"is-active\")?(e.options.allowAllClosed||i.siblings().hasClass(\"is-active\"))&&e.up(n):e.down(n);}).on(\"keydown.zf.accordion\",function(t){Foundation.Keyboard.handleKey(t,\"Accordion\",{toggle:function toggle(){e.toggle(n);},next:function next(){i.next().find(\"a\").focus().trigger(\"click.zf.accordion\");},previous:function previous(){i.prev().find(\"a\").focus().trigger(\"click.zf.accordion\");},handled:function handled(){t.preventDefault(),t.stopPropagation();}});});});}},{key:\"toggle\",value:function value(t){if(t.parent().hasClass(\"is-active\")){if(!this.options.allowAllClosed&&!t.parent().siblings().hasClass(\"is-active\"))return;this.up(t);}else this.down(t);}},{key:\"down\",value:function value(e,i){var n=this;if(!this.options.multiExpand&&!i){var s=this.$element.find(\".is-active\").children(\"[data-tab-content]\");s.length&&this.up(s);}e.attr(\"aria-hidden\",!1).parent(\"[data-tab-content]\").addBack().parent().addClass(\"is-active\"),e.slideDown(n.options.slideSpeed,function(){n.$element.trigger(\"down.zf.accordion\",[e]);}),t(\"#\"+e.attr(\"aria-labelledby\")).attr({\"aria-expanded\":!0,\"aria-selected\":!0});}},{key:\"up\",value:function value(e){var i=e.parent().siblings(),n=this,s=this.options.multiExpand?i.hasClass(\"is-active\"):e.parent().hasClass(\"is-active\");(this.options.allowAllClosed||s)&&(e.slideUp(n.options.slideSpeed,function(){n.$element.trigger(\"up.zf.accordion\",[e]);}),e.attr(\"aria-hidden\",!0).parent().removeClass(\"is-active\"),t(\"#\"+e.attr(\"aria-labelledby\")).attr({\"aria-expanded\":!1,\"aria-selected\":!1}));}},{key:\"destroy\",value:function value(){this.$element.find(\"[data-tab-content]\").slideUp(0).css(\"display\",\"\"),this.$element.find(\"a\").off(\".zf.accordion\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={slideSpeed:250,multiExpand:!1,allowAllClosed:!1},Foundation.plugin(e,\"Accordion\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),Foundation.Nest.Feather(this.$element,\"accordion\"),this._init(),Foundation.registerPlugin(this,\"AccordionMenu\"),Foundation.Keyboard.register(\"AccordionMenu\",{ENTER:\"toggle\",SPACE:\"toggle\",ARROW_RIGHT:\"open\",ARROW_UP:\"up\",ARROW_DOWN:\"down\",ARROW_LEFT:\"close\",ESCAPE:\"closeAll\",TAB:\"down\",SHIFT_TAB:\"up\"});}return _createClass(e,[{key:\"_init\",value:function value(){this.$element.find(\"[data-submenu]\").not(\".is-active\").slideUp(0),this.$element.attr({role:\"tablist\",\"aria-multiselectable\":this.options.multiOpen}),this.$menuLinks=this.$element.find(\".is-accordion-submenu-parent\"),this.$menuLinks.each(function(){var e=this.id||Foundation.GetYoDigits(6,\"acc-menu-link\"),i=t(this),n=i.children(\"[data-submenu]\"),s=n[0].id||Foundation.GetYoDigits(6,\"acc-menu\"),o=n.hasClass(\"is-active\");i.attr({\"aria-controls\":s,\"aria-expanded\":o,role:\"tab\",id:e}),n.attr({\"aria-labelledby\":e,\"aria-hidden\":!o,role:\"tabpanel\",id:s});});var e=this.$element.find(\".is-active\");if(e.length){var i=this;e.each(function(){i.down(t(this));});}this._events();}},{key:\"_events\",value:function value(){var e=this;this.$element.find(\"li\").each(function(){var i=t(this).children(\"[data-submenu]\");i.length&&t(this).children(\"a\").off(\"click.zf.accordionMenu\").on(\"click.zf.accordionMenu\",function(t){t.preventDefault(),e.toggle(i);});}).on(\"keydown.zf.accordionmenu\",function(i){var n,s,o=t(this),a=o.parent(\"ul\").children(\"li\"),r=o.children(\"[data-submenu]\");a.each(function(e){return t(this).is(o)?(n=a.eq(Math.max(0,e-1)),s=a.eq(Math.min(e+1,a.length-1)),t(this).children(\"[data-submenu]:visible\").length&&(s=o.find(\"li:first-child\")),t(this).is(\":first-child\")?n=o.parents(\"li\").first():n.children(\"[data-submenu]:visible\").length&&(n=n.find(\"li:last-child\")),void(t(this).is(\":last-child\")&&(s=o.parents(\"li\").first().next(\"li\")))):void 0;}),Foundation.Keyboard.handleKey(i,\"AccordionMenu\",{open:function open(){r.is(\":hidden\")&&(e.down(r),r.find(\"li\").first().focus());},close:function close(){r.length&&!r.is(\":hidden\")?e.up(r):o.parent(\"[data-submenu]\").length&&(e.up(o.parent(\"[data-submenu]\")),o.parents(\"li\").first().focus());},up:function up(){n.focus();},down:function down(){s.focus();},toggle:function toggle(){o.children(\"[data-submenu]\").length&&e.toggle(o.children(\"[data-submenu]\"));},closeAll:function closeAll(){e.hideAll();},handled:function handled(){i.preventDefault(),i.stopImmediatePropagation();}});});}},{key:\"hideAll\",value:function value(){this.$element.find(\"[data-submenu]\").slideUp(this.options.slideSpeed);}},{key:\"toggle\",value:function value(t){t.is(\":animated\")||(t.is(\":hidden\")?this.down(t):this.up(t));}},{key:\"down\",value:function value(t){var e=this;this.options.multiOpen||this.up(this.$element.find(\".is-active\").not(t.parentsUntil(this.$element).add(t))),t.addClass(\"is-active\").attr({\"aria-hidden\":!1}).parent(\".is-accordion-submenu-parent\").attr({\"aria-expanded\":!0}),Foundation.Move(this.options.slideSpeed,t,function(){t.slideDown(e.options.slideSpeed,function(){e.$element.trigger(\"down.zf.accordionMenu\",[t]);});});}},{key:\"up\",value:function value(t){var e=this;Foundation.Move(this.options.slideSpeed,t,function(){t.slideUp(e.options.slideSpeed,function(){e.$element.trigger(\"up.zf.accordionMenu\",[t]);});});var i=t.find(\"[data-submenu]\").slideUp(0).addBack().attr(\"aria-hidden\",!0);i.parent(\".is-accordion-submenu-parent\").attr(\"aria-expanded\",!1);}},{key:\"destroy\",value:function value(){this.$element.find(\"[data-submenu]\").slideDown(0).css(\"display\",\"\"),this.$element.find(\"a\").off(\"click.zf.accordionMenu\"),Foundation.Nest.Burn(this.$element,\"accordion\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={slideSpeed:250,multiOpen:!0},Foundation.plugin(e,\"AccordionMenu\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),Foundation.Nest.Feather(this.$element,\"drilldown\"),this._init(),Foundation.registerPlugin(this,\"Drilldown\"),Foundation.Keyboard.register(\"Drilldown\",{ENTER:\"open\",SPACE:\"open\",ARROW_RIGHT:\"next\",ARROW_UP:\"up\",ARROW_DOWN:\"down\",ARROW_LEFT:\"previous\",ESCAPE:\"close\",TAB:\"down\",SHIFT_TAB:\"up\"});}return _createClass(e,[{key:\"_init\",value:function value(){this.$submenuAnchors=this.$element.find(\"li.is-drilldown-submenu-parent\"),this.$submenus=this.$submenuAnchors.children(\"[data-submenu]\"),this.$menuItems=this.$element.find(\"li\").not(\".js-drilldown-back\").attr(\"role\",\"menuitem\"),this._prepareMenu(),this._keyboardEvents();}},{key:\"_prepareMenu\",value:function value(){var e=this;this.$submenuAnchors.each(function(){var i=t(this),n=i.find(\"a:first\");e.options.parentLink&&n.clone().prependTo(i.children(\"[data-submenu]\")).wrap('<li class=\"is-submenu-parent-item is-submenu-item is-drilldown-submenu-item\" role=\"menu-item\"></li>'),n.data(\"savedHref\",n.attr(\"href\")).removeAttr(\"href\"),i.children(\"[data-submenu]\").attr({\"aria-hidden\":!0,tabindex:0,role:\"menu\"}),e._events(i);}),this.$submenus.each(function(){var i=t(this),n=i.find(\".js-drilldown-back\");n.length||i.prepend(e.options.backButton),e._back(i);}),this.$element.parent().hasClass(\"is-drilldown\")||(this.$wrapper=t(this.options.wrapper).addClass(\"is-drilldown\").css(this._getMaxDims()),this.$element.wrap(this.$wrapper));}},{key:\"_events\",value:function value(e){var i=this;e.off(\"click.zf.drilldown\").on(\"click.zf.drilldown\",function(n){if(t(n.target).parentsUntil(\"ul\",\"li\").hasClass(\"is-drilldown-submenu-parent\")&&(n.stopImmediatePropagation(),n.preventDefault()),i._show(e),i.options.closeOnClick){var s=t(\"body\").not(i.$wrapper);s.off(\".zf.drilldown\").on(\"click.zf.drilldown\",function(t){t.preventDefault(),i._hideAll(),s.off(\".zf.drilldown\");});}});}},{key:\"_keyboardEvents\",value:function value(){var e=this;this.$menuItems.add(this.$element.find(\".js-drilldown-back\")).on(\"keydown.zf.drilldown\",function(i){var n,s,o=t(this),a=o.parent(\"ul\").children(\"li\");a.each(function(e){return t(this).is(o)?(n=a.eq(Math.max(0,e-1)),void(s=a.eq(Math.min(e+1,a.length-1)))):void 0;}),Foundation.Keyboard.handleKey(i,\"Drilldown\",{next:function next(){o.is(e.$submenuAnchors)&&(e._show(o),o.on(Foundation.transitionend(o),function(){o.find(\"ul li\").filter(e.$menuItems).first().focus();}));},previous:function previous(){e._hide(o.parent(\"ul\")),o.parent(\"ul\").on(Foundation.transitionend(o),function(){setTimeout(function(){o.parent(\"ul\").parent(\"li\").focus();},1);});},up:function up(){n.focus();},down:function down(){s.focus();},close:function close(){e._back();},open:function open(){o.is(e.$menuItems)?o.is(e.$submenuAnchors)&&(e._show(o),setTimeout(function(){o.find(\"ul li\").filter(e.$menuItems).first().focus();},1)):(e._hide(o.parent(\"ul\")),setTimeout(function(){o.parent(\"ul\").parent(\"li\").focus();},1));},handled:function handled(){i.preventDefault(),i.stopImmediatePropagation();}});});}},{key:\"_hideAll\",value:function value(){var t=this.$element.find(\".is-drilldown-submenu.is-active\").addClass(\"is-closing\");t.one(Foundation.transitionend(t),function(e){t.removeClass(\"is-active is-closing\");}),this.$element.trigger(\"closed.zf.drilldown\");}},{key:\"_back\",value:function value(t){var e=this;t.off(\"click.zf.drilldown\"),t.children(\".js-drilldown-back\").on(\"click.zf.drilldown\",function(i){i.stopImmediatePropagation(),e._hide(t);});}},{key:\"_menuLinkEvents\",value:function value(){var t=this;this.$menuItems.not(\".is-drilldown-submenu-parent\").off(\"click.zf.drilldown\").on(\"click.zf.drilldown\",function(e){setTimeout(function(){t._hideAll();},0);});}},{key:\"_show\",value:function value(t){t.children(\"[data-submenu]\").addClass(\"is-active\"),this.$element.trigger(\"open.zf.drilldown\",[t]);}},{key:\"_hide\",value:function value(t){t.addClass(\"is-closing\").one(Foundation.transitionend(t),function(){t.removeClass(\"is-active is-closing\"),t.blur();}),t.trigger(\"hide.zf.drilldown\",[t]);}},{key:\"_getMaxDims\",value:function value(){var e=0,i={};return this.$submenus.add(this.$element).each(function(){var i=t(this).children(\"li\").length;e=i>e?i:e;}),i[\"min-height\"]=e*this.$menuItems[0].getBoundingClientRect().height+\"px\",i[\"max-width\"]=this.$element[0].getBoundingClientRect().width+\"px\",i;}},{key:\"destroy\",value:function value(){this._hideAll(),Foundation.Nest.Burn(this.$element,\"drilldown\"),this.$element.unwrap().find(\".js-drilldown-back, .is-submenu-parent-item\").remove().end().find(\".is-active, .is-closing, .is-drilldown-submenu\").removeClass(\"is-active is-closing is-drilldown-submenu\").end().find(\"[data-submenu]\").removeAttr(\"aria-hidden tabindex role\").off(\".zf.drilldown\").end().off(\"zf.drilldown\"),this.$element.find(\"a\").each(function(){var e=t(this);e.data(\"savedHref\")&&e.attr(\"href\",e.data(\"savedHref\")).removeData(\"savedHref\");}),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={backButton:'<li class=\"js-drilldown-back\"><a>Back</a></li>',wrapper:\"<div></div>\",parentLink:!1,closeOnClick:!1},Foundation.plugin(e,\"Drilldown\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Dropdown\"),Foundation.Keyboard.register(\"Dropdown\",{ENTER:\"open\",SPACE:\"open\",ESCAPE:\"close\",TAB:\"tab_forward\",SHIFT_TAB:\"tab_backward\"});}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"id\");this.$anchor=t('[data-toggle=\"'+e+'\"]')||t('[data-open=\"'+e+'\"]'),this.$anchor.attr({\"aria-controls\":e,\"data-is-focus\":!1,\"data-yeti-box\":e,\"aria-haspopup\":!0,\"aria-expanded\":!1}),this.options.positionClass=this.getPositionClass(),this.counter=4,this.usedPositions=[],this.$element.attr({\"aria-hidden\":\"true\",\"data-yeti-box\":e,\"data-resize\":e,\"aria-labelledby\":this.$anchor[0].id||Foundation.GetYoDigits(6,\"dd-anchor\")}),this._events();}},{key:\"getPositionClass\",value:function value(){var t=this.$element[0].className.match(/\\b(top|left|right)\\b/g);return t=t?t[0]:\"\";}},{key:\"_reposition\",value:function value(t){this.usedPositions.push(t?t:\"bottom\"),!t&&this.usedPositions.indexOf(\"top\")<0?this.$element.addClass(\"top\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")<0?this.$element.removeClass(t):\"left\"===t&&this.usedPositions.indexOf(\"right\")<0?this.$element.removeClass(t).addClass(\"right\"):\"right\"===t&&this.usedPositions.indexOf(\"left\")<0?this.$element.removeClass(t).addClass(\"left\"):!t&&this.usedPositions.indexOf(\"top\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.$element.addClass(\"left\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.$element.removeClass(t).addClass(\"left\"):\"left\"===t&&this.usedPositions.indexOf(\"right\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.$element.removeClass(t):\"right\"===t&&this.usedPositions.indexOf(\"left\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.$element.removeClass(t):this.$element.removeClass(t),this.classChanged=!0,this.counter--;}},{key:\"_setPosition\",value:function value(){if(\"false\"===this.$anchor.attr(\"aria-expanded\"))return!1;var t=this.getPositionClass(),e=Foundation.Box.GetDimensions(this.$element),i=(Foundation.Box.GetDimensions(this.$anchor),\"left\"===t?\"left\":\"right\"===t?\"left\":\"top\"),n=\"top\"===i?\"height\":\"width\";\"height\"===n?this.options.vOffset:this.options.hOffset;if(e.width>=e.windowDims.width||!this.counter&&!Foundation.Box.ImNotTouchingYou(this.$element))return this.$element.offset(Foundation.Box.GetOffsets(this.$element,this.$anchor,\"center bottom\",this.options.vOffset,this.options.hOffset,!0)).css({width:e.windowDims.width-2*this.options.hOffset,height:\"auto\"}),this.classChanged=!0,!1;for(this.$element.offset(Foundation.Box.GetOffsets(this.$element,this.$anchor,t,this.options.vOffset,this.options.hOffset));!Foundation.Box.ImNotTouchingYou(this.$element)&&this.counter;){this._reposition(t),this._setPosition();}}},{key:\"_events\",value:function value(){var e=this;this.$element.on({\"open.zf.trigger\":this.open.bind(this),\"close.zf.trigger\":this.close.bind(this),\"toggle.zf.trigger\":this.toggle.bind(this),\"resizeme.zf.trigger\":this._setPosition.bind(this)}),this.options.hover&&(this.$anchor.off(\"mouseenter.zf.dropdown mouseleave.zf.dropdown\").on(\"mouseenter.zf.dropdown\",function(){clearTimeout(e.timeout),e.timeout=setTimeout(function(){e.open(),e.$anchor.data(\"hover\",!0);},e.options.hoverDelay);}).on(\"mouseleave.zf.dropdown\",function(){clearTimeout(e.timeout),e.timeout=setTimeout(function(){e.close(),e.$anchor.data(\"hover\",!1);},e.options.hoverDelay);}),this.options.hoverPane&&this.$element.off(\"mouseenter.zf.dropdown mouseleave.zf.dropdown\").on(\"mouseenter.zf.dropdown\",function(){clearTimeout(e.timeout);}).on(\"mouseleave.zf.dropdown\",function(){clearTimeout(e.timeout),e.timeout=setTimeout(function(){e.close(),e.$anchor.data(\"hover\",!1);},e.options.hoverDelay);})),this.$anchor.add(this.$element).on(\"keydown.zf.dropdown\",function(i){var n=t(this),s=Foundation.Keyboard.findFocusable(e.$element);Foundation.Keyboard.handleKey(i,\"Dropdown\",{tab_forward:function tab_forward(){e.$element.find(\":focus\").is(s.eq(-1))&&(e.options.trapFocus?(s.eq(0).focus(),i.preventDefault()):e.close());},tab_backward:function tab_backward(){(e.$element.find(\":focus\").is(s.eq(0))||e.$element.is(\":focus\"))&&(e.options.trapFocus?(s.eq(-1).focus(),i.preventDefault()):e.close());},open:function open(){n.is(e.$anchor)&&(e.open(),e.$element.attr(\"tabindex\",-1).focus(),i.preventDefault());},close:function close(){e.close(),e.$anchor.focus();}});});}},{key:\"_addBodyHandler\",value:function value(){var e=t(document.body).not(this.$element),i=this;e.off(\"click.zf.dropdown\").on(\"click.zf.dropdown\",function(t){i.$anchor.is(t.target)||i.$anchor.find(t.target).length||i.$element.find(t.target).length||(i.close(),e.off(\"click.zf.dropdown\"));});}},{key:\"open\",value:function value(){if(this.$element.trigger(\"closeme.zf.dropdown\",this.$element.attr(\"id\")),this.$anchor.addClass(\"hover\").attr({\"aria-expanded\":!0}),this._setPosition(),this.$element.addClass(\"is-open\").attr({\"aria-hidden\":!1}),this.options.autoFocus){var t=Foundation.Keyboard.findFocusable(this.$element);t.length&&t.eq(0).focus();}this.options.closeOnClick&&this._addBodyHandler(),this.$element.trigger(\"show.zf.dropdown\",[this.$element]);}},{key:\"close\",value:function value(){if(!this.$element.hasClass(\"is-open\"))return!1;if(this.$element.removeClass(\"is-open\").attr({\"aria-hidden\":!0}),this.$anchor.removeClass(\"hover\").attr(\"aria-expanded\",!1),this.classChanged){var t=this.getPositionClass();t&&this.$element.removeClass(t),this.$element.addClass(this.options.positionClass).css({height:\"\",width:\"\"}),this.classChanged=!1,this.counter=4,this.usedPositions.length=0;}this.$element.trigger(\"hide.zf.dropdown\",[this.$element]);}},{key:\"toggle\",value:function value(){if(this.$element.hasClass(\"is-open\")){if(this.$anchor.data(\"hover\"))return;this.close();}else this.open();}},{key:\"destroy\",value:function value(){this.$element.off(\".zf.trigger\").hide(),this.$anchor.off(\".zf.dropdown\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={hoverDelay:250,hover:!1,hoverPane:!1,vOffset:1,hOffset:1,positionClass:\"\",trapFocus:!1,autoFocus:!1,closeOnClick:!1},Foundation.plugin(e,\"Dropdown\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),Foundation.Nest.Feather(this.$element,\"dropdown\"),this._init(),Foundation.registerPlugin(this,\"DropdownMenu\"),Foundation.Keyboard.register(\"DropdownMenu\",{ENTER:\"open\",SPACE:\"open\",ARROW_RIGHT:\"next\",ARROW_UP:\"up\",ARROW_DOWN:\"down\",ARROW_LEFT:\"previous\",ESCAPE:\"close\"});}return _createClass(e,[{key:\"_init\",value:function value(){var t=this.$element.find(\"li.is-dropdown-submenu-parent\");this.$element.children(\".is-dropdown-submenu-parent\").children(\".is-dropdown-submenu\").addClass(\"first-sub\"),this.$menuItems=this.$element.find('[role=\"menuitem\"]'),this.$tabs=this.$element.children('[role=\"menuitem\"]'),this.$tabs.find(\"ul.is-dropdown-submenu\").addClass(this.options.verticalClass),this.$element.hasClass(this.options.rightClass)||\"right\"===this.options.alignment||Foundation.rtl()?(this.options.alignment=\"right\",t.addClass(\"opens-left\")):t.addClass(\"opens-right\"),this.changed=!1,this._events();}},{key:\"_events\",value:function value(){var e=this,i=\"ontouchstart\"in window||\"undefined\"!=typeof window.ontouchstart,n=\"is-dropdown-submenu-parent\";(this.options.clickOpen||i)&&this.$menuItems.on(\"click.zf.dropdownmenu touchstart.zf.dropdownmenu\",function(s){var o=t(s.target).parentsUntil(\"ul\",\".\"+n),a=o.hasClass(n),r=\"true\"===o.attr(\"data-is-click\");o.children(\".is-dropdown-submenu\");if(a)if(r){if(!e.options.closeOnClick||!e.options.clickOpen&&!i||e.options.forceFollow&&i)return;s.stopImmediatePropagation(),s.preventDefault(),e._hide(o);}else s.preventDefault(),s.stopImmediatePropagation(),e._show(o.children(\".is-dropdown-submenu\")),o.add(o.parentsUntil(e.$element,\".\"+n)).attr(\"data-is-click\",!0);}),this.options.disableHover||this.$menuItems.on(\"mouseenter.zf.dropdownmenu\",function(i){i.stopImmediatePropagation();var s=t(this),o=s.hasClass(n);o&&(clearTimeout(e.delay),e.delay=setTimeout(function(){e._show(s.children(\".is-dropdown-submenu\"));},e.options.hoverDelay));}).on(\"mouseleave.zf.dropdownmenu\",function(i){var s=t(this),o=s.hasClass(n);if(o&&e.options.autoclose){if(\"true\"===s.attr(\"data-is-click\")&&e.options.clickOpen)return!1;clearTimeout(e.delay),e.delay=setTimeout(function(){e._hide(s);},e.options.closingTime);}}),this.$menuItems.on(\"keydown.zf.dropdownmenu\",function(i){var n,s,o=t(i.target).parentsUntil(\"ul\",'[role=\"menuitem\"]'),a=e.$tabs.index(o)>-1,r=a?e.$tabs:o.siblings(\"li\").add(o);r.each(function(e){return t(this).is(o)?(n=r.eq(e-1),void(s=r.eq(e+1))):void 0;});var l=function l(){o.is(\":last-child\")||s.children(\"a:first\").focus();},u=function u(){n.children(\"a:first\").focus();},d=function d(){var t=o.children(\"ul.is-dropdown-submenu\");t.length&&(e._show(t),o.find(\"li > a:first\").focus());},h=function h(){var t=o.parent(\"ul\").parent(\"li\");t.children(\"a:first\").focus(),e._hide(t);},c={open:d,close:function close(){e._hide(e.$element),e.$menuItems.find(\"a:first\").focus();},handled:function handled(){i.preventDefault(),i.stopImmediatePropagation();}};a?e.vertical?\"left\"===e.options.alignment?t.extend(c,{down:l,up:u,next:d,previous:h}):t.extend(c,{down:l,up:u,next:h,previous:d}):t.extend(c,{next:l,previous:u,down:d,up:h}):\"left\"===e.options.alignment?t.extend(c,{next:d,previous:h,down:l,up:u}):t.extend(c,{next:h,previous:d,down:l,up:u}),Foundation.Keyboard.handleKey(i,\"DropdownMenu\",c);});}},{key:\"_addBodyHandler\",value:function value(){var e=t(document.body),i=this;e.off(\"mouseup.zf.dropdownmenu touchend.zf.dropdownmenu\").on(\"mouseup.zf.dropdownmenu touchend.zf.dropdownmenu\",function(t){var n=i.$element.find(t.target);n.length||(i._hide(),e.off(\"mouseup.zf.dropdownmenu touchend.zf.dropdownmenu\"));});}},{key:\"_show\",value:function value(e){var i=this.$tabs.index(this.$tabs.filter(function(i,n){return t(n).find(e).length>0;})),n=e.parent(\"li.is-dropdown-submenu-parent\").siblings(\"li.is-dropdown-submenu-parent\");this._hide(n,i),e.css(\"visibility\",\"hidden\").addClass(\"js-dropdown-active\").attr({\"aria-hidden\":!1}).parent(\"li.is-dropdown-submenu-parent\").addClass(\"is-active\").attr({\"aria-expanded\":!0});var s=Foundation.Box.ImNotTouchingYou(e,null,!0);if(!s){var o=\"left\"===this.options.alignment?\"-right\":\"-left\",a=e.parent(\".is-dropdown-submenu-parent\");a.removeClass(\"opens\"+o).addClass(\"opens-\"+this.options.alignment),s=Foundation.Box.ImNotTouchingYou(e,null,!0),s||a.removeClass(\"opens-\"+this.options.alignment).addClass(\"opens-inner\"),this.changed=!0;}e.css(\"visibility\",\"\"),this.options.closeOnClick&&this._addBodyHandler(),this.$element.trigger(\"show.zf.dropdownmenu\",[e]);}},{key:\"_hide\",value:function value(t,e){var i;i=t&&t.length?t:void 0!==e?this.$tabs.not(function(t,i){return t===e;}):this.$element;var n=i.hasClass(\"is-active\")||i.find(\".is-active\").length>0;if(n){if(i.find(\"li.is-active\").add(i).attr({\"aria-expanded\":!1,\"data-is-click\":!1}).removeClass(\"is-active\"),i.find(\"ul.js-dropdown-active\").attr({\"aria-hidden\":!0}).removeClass(\"js-dropdown-active\"),this.changed||i.find(\"opens-inner\").length){var s=\"left\"===this.options.alignment?\"right\":\"left\";i.find(\"li.is-dropdown-submenu-parent\").add(i).removeClass(\"opens-inner opens-\"+this.options.alignment).addClass(\"opens-\"+s),this.changed=!1;}this.$element.trigger(\"hide.zf.dropdownmenu\",[i]);}}},{key:\"destroy\",value:function value(){this.$menuItems.off(\".zf.dropdownmenu\").removeAttr(\"data-is-click\").removeClass(\"is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner\"),t(document.body).off(\".zf.dropdownmenu\"),Foundation.Nest.Burn(this.$element,\"dropdown\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={disableHover:!1,autoclose:!0,hoverDelay:50,clickOpen:!1,closingTime:500,alignment:\"left\",closeOnClick:!0,verticalClass:\"vertical\",rightClass:\"align-right\",forceFollow:!0},Foundation.plugin(e,\"DropdownMenu\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Equalizer\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"data-equalizer\")||\"\",i=this.$element.find('[data-equalizer-watch=\"'+e+'\"]');this.$watched=i.length?i:this.$element.find(\"[data-equalizer-watch]\"),this.$element.attr(\"data-resize\",e||Foundation.GetYoDigits(6,\"eq\")),this.hasNested=this.$element.find(\"[data-equalizer]\").length>0,this.isNested=this.$element.parentsUntil(document.body,\"[data-equalizer]\").length>0,this.isOn=!1;var n,s=this.$element.find(\"img\");this.options.equalizeOn?(n=this._checkMQ(),t(window).on(\"changed.zf.mediaquery\",this._checkMQ.bind(this))):this._events(),(void 0!==n&&n===!1||void 0===n)&&(s.length?Foundation.onImagesLoaded(s,this._reflow.bind(this)):this._reflow());}},{key:\"_pauseEvents\",value:function value(){this.isOn=!1,this.$element.off(\".zf.equalizer resizeme.zf.trigger\");}},{key:\"_events\",value:function value(){var t=this;this._pauseEvents(),this.hasNested?this.$element.on(\"postequalized.zf.equalizer\",function(e){e.target!==t.$element[0]&&t._reflow();}):this.$element.on(\"resizeme.zf.trigger\",this._reflow.bind(this)),this.isOn=!0;}},{key:\"_checkMQ\",value:function value(){var t=!Foundation.MediaQuery.atLeast(this.options.equalizeOn);return t?this.isOn&&(this._pauseEvents(),this.$watched.css(\"height\",\"auto\")):this.isOn||this._events(),t;}},{key:\"_killswitch\",value:function value(){}},{key:\"_reflow\",value:function value(){return!this.options.equalizeOnStack&&this._isStacked()?(this.$watched.css(\"height\",\"auto\"),!1):void(this.options.equalizeByRow?this.getHeightsByRow(this.applyHeightByRow.bind(this)):this.getHeights(this.applyHeight.bind(this)));}},{key:\"_isStacked\",value:function value(){return this.$watched[0].offsetTop!==this.$watched[1].offsetTop;}},{key:\"getHeights\",value:function value(t){for(var e=[],i=0,n=this.$watched.length;n>i;i++){this.$watched[i].style.height=\"auto\",e.push(this.$watched[i].offsetHeight);}t(e);}},{key:\"getHeightsByRow\",value:function value(e){var i=this.$watched.first().offset().top,n=[],s=0;n[s]=[];for(var o=0,a=this.$watched.length;a>o;o++){this.$watched[o].style.height=\"auto\";var r=t(this.$watched[o]).offset().top;r!=i&&(s++,n[s]=[],i=r),n[s].push([this.$watched[o],this.$watched[o].offsetHeight]);}for(var l=0,u=n.length;u>l;l++){var d=t(n[l]).map(function(){return this[1];}).get(),h=Math.max.apply(null,d);n[l].push(h);}e(n);}},{key:\"applyHeight\",value:function value(t){var e=Math.max.apply(null,t);this.$element.trigger(\"preequalized.zf.equalizer\"),this.$watched.css(\"height\",e),this.$element.trigger(\"postequalized.zf.equalizer\");}},{key:\"applyHeightByRow\",value:function value(e){this.$element.trigger(\"preequalized.zf.equalizer\");for(var i=0,n=e.length;n>i;i++){var s=e[i].length,o=e[i][s-1];if(2>=s)t(e[i][0][0]).css({height:\"auto\"});else{this.$element.trigger(\"preequalizedrow.zf.equalizer\");for(var a=0,r=s-1;r>a;a++){t(e[i][a][0]).css({height:o});}this.$element.trigger(\"postequalizedrow.zf.equalizer\");}}this.$element.trigger(\"postequalized.zf.equalizer\");}},{key:\"destroy\",value:function value(){this._pauseEvents(),this.$watched.css(\"height\",\"auto\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={equalizeOnStack:!0,equalizeByRow:!1,equalizeOn:\"\"},Foundation.plugin(e,\"Equalizer\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,n),this.rules=[],this.currentPath=\"\",this._init(),this._events(),Foundation.registerPlugin(this,\"Interchange\");}return _createClass(e,[{key:\"_init\",value:function value(){this._addBreakpoints(),this._generateRules(),this._reflow();}},{key:\"_events\",value:function value(){t(window).on(\"resize.zf.interchange\",Foundation.util.throttle(this._reflow.bind(this),50));}},{key:\"_reflow\",value:function value(){var t;for(var e in this.rules){var i=this.rules[e];window.matchMedia(i.query).matches&&(t=i);}t&&this.replace(t.path);}},{key:\"_addBreakpoints\",value:function value(){for(var t in Foundation.MediaQuery.queries){var i=Foundation.MediaQuery.queries[t];e.SPECIAL_QUERIES[i.name]=i.value;}}},{key:\"_generateRules\",value:function value(t){var i,n=[];i=this.options.rules?this.options.rules:this.$element.data(\"interchange\").match(/\\[.*?\\]/g);for(var s in i){var o=i[s].slice(1,-1).split(\", \"),a=o.slice(0,-1).join(\"\"),r=o[o.length-1];e.SPECIAL_QUERIES[r]&&(r=e.SPECIAL_QUERIES[r]),n.push({path:a,query:r});}this.rules=n;}},{key:\"replace\",value:function value(e){if(this.currentPath!==e){var i=this,n=\"replaced.zf.interchange\";\"IMG\"===this.$element[0].nodeName?this.$element.attr(\"src\",e).load(function(){i.currentPath=e;}).trigger(n):e.match(/\\.(gif|jpg|jpeg|tiff|png)([?#].*)?/i)?this.$element.css({\"background-image\":\"url(\"+e+\")\"}).trigger(n):t.get(e,function(s){i.$element.html(s).trigger(n),t(s).foundation(),i.currentPath=e;});}}},{key:\"destroy\",value:function value(){}}]),e;}();e.defaults={rules:null},e.SPECIAL_QUERIES={landscape:\"screen and (orientation: landscape)\",portrait:\"screen and (orientation: portrait)\",retina:\"only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)\"},Foundation.plugin(e,\"Interchange\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Magellan\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element[0].id||Foundation.GetYoDigits(6,\"magellan\");this.$targets=t(\"[data-magellan-target]\"),this.$links=this.$element.find(\"a\"),this.$element.attr({\"data-resize\":e,\"data-scroll\":e,id:e}),this.$active=t(),this.scrollPos=parseInt(window.pageYOffset,10),this._events();}},{key:\"calcPoints\",value:function value(){var e=this,i=document.body,n=document.documentElement;this.points=[],this.winHeight=Math.round(Math.max(window.innerHeight,n.clientHeight)),this.docHeight=Math.round(Math.max(i.scrollHeight,i.offsetHeight,n.clientHeight,n.scrollHeight,n.offsetHeight)),this.$targets.each(function(){var i=t(this),n=Math.round(i.offset().top-e.options.threshold);i.targetPoint=n,e.points.push(n);});}},{key:\"_events\",value:function value(){var e=this;t(\"html, body\"),{duration:e.options.animationDuration,easing:e.options.animationEasing};t(window).one(\"load\",function(){e.options.deepLinking&&location.hash&&e.scrollToLoc(location.hash),e.calcPoints(),e._updateActive();}),this.$element.on({\"resizeme.zf.trigger\":this.reflow.bind(this),\"scrollme.zf.trigger\":this._updateActive.bind(this)}).on(\"click.zf.magellan\",'a[href^=\"#\"]',function(t){t.preventDefault();var i=this.getAttribute(\"href\");e.scrollToLoc(i);});}},{key:\"scrollToLoc\",value:function value(e){var i=Math.round(t(e).offset().top-this.options.threshold/2-this.options.barOffset);t(\"html, body\").stop(!0).animate({scrollTop:i},this.options.animationDuration,this.options.animationEasing);}},{key:\"reflow\",value:function value(){this.calcPoints(),this._updateActive();}},{key:\"_updateActive\",value:function value(){var t,e=parseInt(window.pageYOffset,10);if(e+this.winHeight===this.docHeight)t=this.points.length-1;else if(e<this.points[0])t=0;else{var i=this.scrollPos<e,n=this,s=this.points.filter(function(t,s){return i?e>=t:t-n.options.threshold<=e;});t=s.length?s.length-1:0;}if(this.$active.removeClass(this.options.activeClass),this.$active=this.$links.eq(t).addClass(this.options.activeClass),this.options.deepLinking){var o=this.$active[0].getAttribute(\"href\");window.history.pushState?window.history.pushState(null,null,o):window.location.hash=o;}this.scrollPos=e,this.$element.trigger(\"update.zf.magellan\",[this.$active]);}},{key:\"destroy\",value:function value(){if(this.$element.off(\".zf.trigger .zf.magellan\").find(\".\"+this.options.activeClass).removeClass(this.options.activeClass),this.options.deepLinking){var t=this.$active[0].getAttribute(\"href\");window.location.hash.replace(t,\"\");}Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={animationDuration:500,animationEasing:\"linear\",threshold:50,activeClass:\"active\",deepLinking:!1,barOffset:0},Foundation.plugin(e,\"Magellan\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this.$lastTrigger=t(),this._init(),this._events(),Foundation.registerPlugin(this,\"OffCanvas\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"id\");if(this.$element.attr(\"aria-hidden\",\"true\"),t(document).find('[data-open=\"'+e+'\"], [data-close=\"'+e+'\"], [data-toggle=\"'+e+'\"]').attr(\"aria-expanded\",\"false\").attr(\"aria-controls\",e),this.options.closeOnClick)if(t(\".js-off-canvas-exit\").length)this.$exiter=t(\".js-off-canvas-exit\");else{var i=document.createElement(\"div\");i.setAttribute(\"class\",\"js-off-canvas-exit\"),t(\"[data-off-canvas-content]\").append(i),this.$exiter=t(i);}this.options.isRevealed=this.options.isRevealed||new RegExp(this.options.revealClass,\"g\").test(this.$element[0].className),this.options.isRevealed&&(this.options.revealOn=this.options.revealOn||this.$element[0].className.match(/(reveal-for-medium|reveal-for-large)/g)[0].split(\"-\")[2],this._setMQChecker()),this.options.transitionTime||(this.options.transitionTime=1e3*parseFloat(window.getComputedStyle(t(\"[data-off-canvas-wrapper]\")[0]).transitionDuration));}},{key:\"_events\",value:function value(){this.$element.off(\".zf.trigger .zf.offcanvas\").on({\"open.zf.trigger\":this.open.bind(this),\"close.zf.trigger\":this.close.bind(this),\"toggle.zf.trigger\":this.toggle.bind(this),\"keydown.zf.offcanvas\":this._handleKeyboard.bind(this)}),this.options.closeOnClick&&this.$exiter.length&&this.$exiter.on({\"click.zf.offcanvas\":this.close.bind(this)});}},{key:\"_setMQChecker\",value:function value(){var e=this;t(window).on(\"changed.zf.mediaquery\",function(){Foundation.MediaQuery.atLeast(e.options.revealOn)?e.reveal(!0):e.reveal(!1);}).one(\"load.zf.offcanvas\",function(){Foundation.MediaQuery.atLeast(e.options.revealOn)&&e.reveal(!0);});}},{key:\"reveal\",value:function value(t){var e=this.$element.find(\"[data-close]\");t?(this.close(),this.isRevealed=!0,this.$element.off(\"open.zf.trigger toggle.zf.trigger\"),e.length&&e.hide()):(this.isRevealed=!1,this.$element.on({\"open.zf.trigger\":this.open.bind(this),\"toggle.zf.trigger\":this.toggle.bind(this)}),e.length&&e.show());}},{key:\"open\",value:function value(e,i){if(!this.$element.hasClass(\"is-open\")&&!this.isRevealed){var n=this;t(document.body);this.options.forceTop&&t(\"body\").scrollTop(0),Foundation.Move(this.options.transitionTime,this.$element,function(){t(\"[data-off-canvas-wrapper]\").addClass(\"is-off-canvas-open is-open-\"+n.options.position),n.$element.addClass(\"is-open\");}),this.$element.attr(\"aria-hidden\",\"false\").trigger(\"opened.zf.offcanvas\"),this.options.closeOnClick&&this.$exiter.addClass(\"is-visible\"),i&&(this.$lastTrigger=i.attr(\"aria-expanded\",\"true\")),this.options.autoFocus&&this.$element.one(Foundation.transitionend(this.$element),function(){n.$element.find(\"a, button\").eq(0).focus();}),this.options.trapFocus&&(t(\"[data-off-canvas-content]\").attr(\"tabindex\",\"-1\"),this._trapFocus());}}},{key:\"_trapFocus\",value:function value(){var t=Foundation.Keyboard.findFocusable(this.$element),e=t.eq(0),i=t.eq(-1);t.off(\".zf.offcanvas\").on(\"keydown.zf.offcanvas\",function(t){9!==t.which&&9!==t.keycode||(t.target!==i[0]||t.shiftKey||(t.preventDefault(),e.focus()),t.target===e[0]&&t.shiftKey&&(t.preventDefault(),i.focus()));});}},{key:\"close\",value:function value(e){if(this.$element.hasClass(\"is-open\")&&!this.isRevealed){var i=this;t(\"[data-off-canvas-wrapper]\").removeClass(\"is-off-canvas-open is-open-\"+i.options.position),i.$element.removeClass(\"is-open\"),this.$element.attr(\"aria-hidden\",\"true\").trigger(\"closed.zf.offcanvas\"),this.options.closeOnClick&&this.$exiter.removeClass(\"is-visible\"),this.$lastTrigger.attr(\"aria-expanded\",\"false\"),this.options.trapFocus&&t(\"[data-off-canvas-content]\").removeAttr(\"tabindex\");}}},{key:\"toggle\",value:function value(t,e){this.$element.hasClass(\"is-open\")?this.close(t,e):this.open(t,e);}},{key:\"_handleKeyboard\",value:function value(t){27===t.which&&(t.stopPropagation(),t.preventDefault(),this.close(),this.$lastTrigger.focus());}},{key:\"destroy\",value:function value(){this.close(),this.$element.off(\".zf.trigger .zf.offcanvas\"),this.$exiter.off(\".zf.offcanvas\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={closeOnClick:!0,transitionTime:0,position:\"left\",forceTop:!0,isRevealed:!1,revealOn:null,autoFocus:!0,revealClass:\"reveal-for-\",trapFocus:!1},Foundation.plugin(e,\"OffCanvas\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Orbit\"),Foundation.Keyboard.register(\"Orbit\",{ltr:{ARROW_RIGHT:\"next\",ARROW_LEFT:\"previous\"},rtl:{ARROW_LEFT:\"next\",ARROW_RIGHT:\"previous\"}});}return _createClass(e,[{key:\"_init\",value:function value(){this.$wrapper=this.$element.find(\".\"+this.options.containerClass),this.$slides=this.$element.find(\".\"+this.options.slideClass);var t=this.$element.find(\"img\"),e=this.$slides.filter(\".is-active\");e.length||this.$slides.eq(0).addClass(\"is-active\"),this.options.useMUI||this.$slides.addClass(\"no-motionui\"),t.length?Foundation.onImagesLoaded(t,this._prepareForOrbit.bind(this)):this._prepareForOrbit(),this.options.bullets&&this._loadBullets(),this._events(),this.options.autoPlay&&this.$slides.length>1&&this.geoSync(),this.options.accessible&&this.$wrapper.attr(\"tabindex\",0);}},{key:\"_loadBullets\",value:function value(){this.$bullets=this.$element.find(\".\"+this.options.boxOfBullets).find(\"button\");}},{key:\"geoSync\",value:function value(){var t=this;this.timer=new Foundation.Timer(this.$element,{duration:this.options.timerDelay,infinite:!1},function(){t.changeSlide(!0);}),this.timer.start();}},{key:\"_prepareForOrbit\",value:function value(){var t=this;this._setWrapperHeight(function(e){t._setSlideHeight(e);});}},{key:\"_setWrapperHeight\",value:function value(e){var i,n=0,s=0;this.$slides.each(function(){i=this.getBoundingClientRect().height,t(this).attr(\"data-slide\",s),s&&t(this).css({position:\"relative\",display:\"none\"}),n=i>n?i:n,s++;}),s===this.$slides.length&&(this.$wrapper.css({height:n}),e(n));}},{key:\"_setSlideHeight\",value:function value(e){this.$slides.each(function(){t(this).css(\"max-height\",e);});}},{key:\"_events\",value:function value(){var e=this;if(this.$slides.length>1){if(this.options.swipe&&this.$slides.off(\"swipeleft.zf.orbit swiperight.zf.orbit\").on(\"swipeleft.zf.orbit\",function(t){t.preventDefault(),e.changeSlide(!0);}).on(\"swiperight.zf.orbit\",function(t){t.preventDefault(),e.changeSlide(!1);}),this.options.autoPlay&&(this.$slides.on(\"click.zf.orbit\",function(){e.$element.data(\"clickedOn\",!e.$element.data(\"clickedOn\")),e.timer[e.$element.data(\"clickedOn\")?\"pause\":\"start\"]();}),this.options.pauseOnHover&&this.$element.on(\"mouseenter.zf.orbit\",function(){e.timer.pause();}).on(\"mouseleave.zf.orbit\",function(){e.$element.data(\"clickedOn\")||e.timer.start();})),this.options.navButtons){var i=this.$element.find(\".\"+this.options.nextClass+\", .\"+this.options.prevClass);i.attr(\"tabindex\",0).on(\"click.zf.orbit touchend.zf.orbit\",function(){e.changeSlide(t(this).hasClass(e.options.nextClass));});}this.options.bullets&&this.$bullets.on(\"click.zf.orbit touchend.zf.orbit\",function(){if(/is-active/g.test(this.className))return!1;var i=t(this).data(\"slide\"),n=i>e.$slides.filter(\".is-active\").data(\"slide\"),s=e.$slides.eq(i);e.changeSlide(n,s,i);}),this.$wrapper.add(this.$bullets).on(\"keydown.zf.orbit\",function(i){Foundation.Keyboard.handleKey(i,\"Orbit\",{next:function next(){e.changeSlide(!0);},previous:function previous(){e.changeSlide(!1);},handled:function handled(){t(i.target).is(e.$bullets)&&e.$bullets.filter(\".is-active\").focus();}});});}}},{key:\"changeSlide\",value:function value(t,e,i){var n=this.$slides.filter(\".is-active\").eq(0);if(/mui/g.test(n[0].className))return!1;var s,o=this.$slides.first(),a=this.$slides.last(),r=t?\"Right\":\"Left\",l=t?\"Left\":\"Right\",u=this;s=e?e:t?this.options.infiniteWrap?n.next(\".\"+this.options.slideClass).length?n.next(\".\"+this.options.slideClass):o:n.next(\".\"+this.options.slideClass):this.options.infiniteWrap?n.prev(\".\"+this.options.slideClass).length?n.prev(\".\"+this.options.slideClass):a:n.prev(\".\"+this.options.slideClass),s.length&&(this.options.bullets&&(i=i||this.$slides.index(s),this._updateBullets(i)),this.options.useMUI?(Foundation.Motion.animateIn(s.addClass(\"is-active\").css({position:\"absolute\",top:0}),this.options[\"animInFrom\"+r],function(){s.css({position:\"relative\",display:\"block\"}).attr(\"aria-live\",\"polite\");}),Foundation.Motion.animateOut(n.removeClass(\"is-active\"),this.options[\"animOutTo\"+l],function(){n.removeAttr(\"aria-live\"),u.options.autoPlay&&!u.timer.isPaused&&u.timer.restart();})):(n.removeClass(\"is-active is-in\").removeAttr(\"aria-live\").hide(),s.addClass(\"is-active is-in\").attr(\"aria-live\",\"polite\").show(),this.options.autoPlay&&!this.timer.isPaused&&this.timer.restart()),this.$element.trigger(\"slidechange.zf.orbit\",[s]));}},{key:\"_updateBullets\",value:function value(t){var e=this.$element.find(\".\"+this.options.boxOfBullets).find(\".is-active\").removeClass(\"is-active\").blur(),i=e.find(\"span:last\").detach();this.$bullets.eq(t).addClass(\"is-active\").append(i);}},{key:\"destroy\",value:function value(){this.$element.off(\".zf.orbit\").find(\"*\").off(\".zf.orbit\").end().hide(),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={bullets:!0,navButtons:!0,animInFromRight:\"slide-in-right\",animOutToRight:\"slide-out-right\",animInFromLeft:\"slide-in-left\",animOutToLeft:\"slide-out-left\",autoPlay:!0,timerDelay:5e3,infiniteWrap:!0,swipe:!0,pauseOnHover:!0,accessible:!0,containerClass:\"orbit-container\",slideClass:\"orbit-slide\",boxOfBullets:\"orbit-bullets\",nextClass:\"orbit-next\",prevClass:\"orbit-previous\",useMUI:!0},Foundation.plugin(e,\"Orbit\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=t(i),this.rules=this.$element.data(\"responsive-menu\"),this.currentMq=null,this.currentPlugin=null,this._init(),this._events(),Foundation.registerPlugin(this,\"ResponsiveMenu\");}return _createClass(e,[{key:\"_init\",value:function value(){for(var e={},n=this.rules.split(\" \"),s=0;s<n.length;s++){var o=n[s].split(\"-\"),a=o.length>1?o[0]:\"small\",r=o.length>1?o[1]:o[0];null!==i[r]&&(e[a]=i[r]);}this.rules=e,t.isEmptyObject(e)||this._checkMediaQueries();}},{key:\"_events\",value:function value(){var e=this;t(window).on(\"changed.zf.mediaquery\",function(){e._checkMediaQueries();});}},{key:\"_checkMediaQueries\",value:function value(){var e,n=this;t.each(this.rules,function(t){Foundation.MediaQuery.atLeast(t)&&(e=t);}),e&&(this.currentPlugin instanceof this.rules[e].plugin||(t.each(i,function(t,e){n.$element.removeClass(e.cssClass);}),this.$element.addClass(this.rules[e].cssClass),this.currentPlugin&&this.currentPlugin.destroy(),this.currentPlugin=new this.rules[e].plugin(this.$element,{})));}},{key:\"destroy\",value:function value(){this.currentPlugin.destroy(),t(window).off(\".zf.ResponsiveMenu\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={};var i={dropdown:{cssClass:\"dropdown\",plugin:Foundation._plugins[\"dropdown-menu\"]||null},drilldown:{cssClass:\"drilldown\",plugin:Foundation._plugins.drilldown||null},accordion:{cssClass:\"accordion-menu\",plugin:Foundation._plugins[\"accordion-menu\"]||null}};Foundation.plugin(e,\"ResponsiveMenu\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=t(i),this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),this._events(),Foundation.registerPlugin(this,\"ResponsiveToggle\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.data(\"responsive-toggle\");e||console.error(\"Your tab bar needs an ID of a Menu as the value of data-tab-bar.\"),this.$targetMenu=t(\"#\"+e),this.$toggler=this.$element.find(\"[data-toggle]\"),this._update();}},{key:\"_events\",value:function value(){t(window).on(\"changed.zf.mediaquery\",this._update.bind(this)),this.$toggler.on(\"click.zf.responsiveToggle\",this.toggleMenu.bind(this));}},{key:\"_update\",value:function value(){Foundation.MediaQuery.atLeast(this.options.hideFor)?(this.$element.hide(),this.$targetMenu.show()):(this.$element.show(),this.$targetMenu.hide());}},{key:\"toggleMenu\",value:function value(){Foundation.MediaQuery.atLeast(this.options.hideFor)||(this.$targetMenu.toggle(0),this.$element.trigger(\"toggled.zf.responsiveToggle\"));}},{key:\"destroy\",value:function value(){}}]),e;}();e.defaults={hideFor:\"medium\"},Foundation.plugin(e,\"ResponsiveToggle\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){function e(){return /iP(ad|hone|od).*OS/.test(window.navigator.userAgent);}var i=function(){function i(e,n){_classCallCheck(this,i),this.$element=e,this.options=t.extend({},i.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Reveal\"),Foundation.Keyboard.register(\"Reveal\",{ENTER:\"open\",SPACE:\"open\",ESCAPE:\"close\",TAB:\"tab_forward\",SHIFT_TAB:\"tab_backward\"});}return _createClass(i,[{key:\"_init\",value:function value(){if(this.id=this.$element.attr(\"id\"),this.isActive=!1,this.cached={mq:Foundation.MediaQuery.current},this.isiOS=e(),this.isiOS&&this.$element.addClass(\"is-ios\"),this.$anchor=t(t('[data-open=\"'+this.id+'\"]').length?'[data-open=\"'+this.id+'\"]':'[data-toggle=\"'+this.id+'\"]'),this.$anchor.length){var i=this.$anchor[0].id||Foundation.GetYoDigits(6,\"reveal\");this.$anchor.attr({\"aria-controls\":this.id,id:i,\"aria-haspopup\":!0,tabindex:0}),this.$element.attr({\"aria-labelledby\":i});}(this.options.fullScreen||this.$element.hasClass(\"full\"))&&(this.options.fullScreen=!0,this.options.overlay=!1),this.options.overlay&&!this.$overlay&&(this.$overlay=this._makeOverlay(this.id)),this.$element.attr({role:\"dialog\",\"aria-hidden\":!0,\"data-yeti-box\":this.id,\"data-resize\":this.id}),this.$overlay?this.$element.detach().appendTo(this.$overlay):(this.$element.detach().appendTo(t(\"body\")),this.$element.addClass(\"without-overlay\")),this._events(),this.options.deepLink&&window.location.hash===\"#\"+this.id&&t(window).one(\"load.zf.reveal\",this.open.bind(this));}},{key:\"_makeOverlay\",value:function value(e){var i=t(\"<div></div>\").addClass(\"reveal-overlay\").attr({tabindex:-1,\"aria-hidden\":!0}).appendTo(\"body\");return i;}},{key:\"_updatePosition\",value:function value(){var e,i=this.$element.outerWidth(),n=t(window).width(),s=this.$element.outerHeight(),o=t(window).height(),a=parseInt((n-i)/2,10);e=s>o?parseInt(Math.min(100,o/10),10):parseInt((o-s)/4,10),this.$element.css({top:e+\"px\"}),this.$overlay||this.$element.css({left:a+\"px\"});}},{key:\"_events\",value:function value(){var e=this;this.$element.on({\"open.zf.trigger\":this.open.bind(this),\"close.zf.trigger\":this.close.bind(this),\"toggle.zf.trigger\":this.toggle.bind(this),\"resizeme.zf.trigger\":function resizemeZfTrigger(){e._updatePosition();}}),this.$anchor.length&&this.$anchor.on(\"keydown.zf.reveal\",function(t){13!==t.which&&32!==t.which||(t.stopPropagation(),t.preventDefault(),e.open());}),this.options.closeOnClick&&this.options.overlay&&this.$overlay.off(\".zf.reveal\").on(\"click.zf.reveal\",function(i){i.target===e.$element[0]||t.contains(e.$element[0],i.target)||e.close();}),this.options.deepLink&&t(window).on(\"popstate.zf.reveal:\"+this.id,this._handleState.bind(this));}},{key:\"_handleState\",value:function value(t){window.location.hash!==\"#\"+this.id||this.isActive?this.close():this.open();}},{key:\"open\",value:function value(){var e=this;if(this.options.deepLink){var i=\"#\"+this.id;window.history.pushState?window.history.pushState(null,null,i):window.location.hash=i;}if(this.isActive=!0,this.$element.css({visibility:\"hidden\"}).show().scrollTop(0),this.options.overlay&&this.$overlay.css({visibility:\"hidden\"}).show(),this._updatePosition(),this.$element.hide().css({visibility:\"\"}),this.$overlay&&this.$overlay.css({visibility:\"\"}).hide(),this.options.multipleOpened||this.$element.trigger(\"closeme.zf.reveal\",this.id),this.options.animationIn?(this.options.overlay&&Foundation.Motion.animateIn(this.$overlay,\"fade-in\"),Foundation.Motion.animateIn(this.$element,this.options.animationIn,function(){this.focusableElements=Foundation.Keyboard.findFocusable(this.$element);})):(this.options.overlay&&this.$overlay.show(0),this.$element.show(this.options.showDelay)),this.$element.attr({\"aria-hidden\":!1,tabindex:-1}).focus(),this.$element.trigger(\"open.zf.reveal\"),this.isiOS){var n=window.pageYOffset;t(\"html, body\").addClass(\"is-reveal-open\").scrollTop(n);}else t(\"body\").addClass(\"is-reveal-open\");t(\"body\").addClass(\"is-reveal-open\").attr(\"aria-hidden\",!(!this.options.overlay&&!this.options.fullScreen)),setTimeout(function(){e._extraHandlers();},0);}},{key:\"_extraHandlers\",value:function value(){var e=this;this.focusableElements=Foundation.Keyboard.findFocusable(this.$element),this.options.overlay||!this.options.closeOnClick||this.options.fullScreen||t(\"body\").on(\"click.zf.reveal\",function(i){i.target===e.$element[0]||t.contains(e.$element[0],i.target)||e.close();}),this.options.closeOnEsc&&t(window).on(\"keydown.zf.reveal\",function(t){Foundation.Keyboard.handleKey(t,\"Reveal\",{close:function close(){e.options.closeOnEsc&&(e.close(),e.$anchor.focus());}}),0===e.focusableElements.length&&t.preventDefault();}),this.$element.on(\"keydown.zf.reveal\",function(i){var n=t(this);Foundation.Keyboard.handleKey(i,\"Reveal\",{tab_forward:function tab_forward(){e.$element.find(\":focus\").is(e.focusableElements.eq(-1))&&(e.focusableElements.eq(0).focus(),i.preventDefault());},tab_backward:function tab_backward(){(e.$element.find(\":focus\").is(e.focusableElements.eq(0))||e.$element.is(\":focus\"))&&(e.focusableElements.eq(-1).focus(),i.preventDefault());},open:function open(){e.$element.find(\":focus\").is(e.$element.find(\"[data-close]\"))?setTimeout(function(){e.$anchor.focus();},1):n.is(e.focusableElements)&&e.open();},close:function close(){e.options.closeOnEsc&&(e.close(),e.$anchor.focus());}});});}},{key:\"close\",value:function value(){function e(){i.isiOS?t(\"html, body\").removeClass(\"is-reveal-open\"):t(\"body\").removeClass(\"is-reveal-open\"),t(\"body\").attr({\"aria-hidden\":!1,tabindex:\"\"}),i.$element.attr(\"aria-hidden\",!0),i.$element.trigger(\"closed.zf.reveal\");}if(!this.isActive||!this.$element.is(\":visible\"))return!1;var i=this;this.options.animationOut?(this.options.overlay?Foundation.Motion.animateOut(this.$overlay,\"fade-out\",e):e(),Foundation.Motion.animateOut(this.$element,this.options.animationOut)):(this.options.overlay?this.$overlay.hide(0,e):e(),this.$element.hide(this.options.hideDelay)),this.options.closeOnEsc&&t(window).off(\"keydown.zf.reveal\"),!this.options.overlay&&this.options.closeOnClick&&t(\"body\").off(\"click.zf.reveal\"),this.$element.off(\"keydown.zf.reveal\"),this.options.resetOnClose&&this.$element.html(this.$element.html()),this.isActive=!1,i.options.deepLink&&(window.history.replaceState?window.history.replaceState(\"\",document.title,window.location.pathname):window.location.hash=\"\");}},{key:\"toggle\",value:function value(){this.isActive?this.close():this.open();}},{key:\"destroy\",value:function value(){this.options.overlay&&this.$overlay.hide().off().remove(),this.$element.hide().off(),this.$anchor.off(\".zf\"),t(window).off(\".zf.reveal:\"+this.id),Foundation.unregisterPlugin(this);}}]),i;}();i.defaults={animationIn:\"\",animationOut:\"\",showDelay:0,hideDelay:0,closeOnClick:!0,closeOnEsc:!0,multipleOpened:!1,vOffset:100,hOffset:0,fullScreen:!1,btmOffsetPct:10,overlay:!0,resetOnClose:!1,deepLink:!1},Foundation.plugin(i,\"Reveal\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){function e(t,e){return t/e;}function i(t,e,i,n){return Math.abs(t.position()[e]+t[n]()/2-i);}var n=function(){function n(e,i){_classCallCheck(this,n),this.$element=e,this.options=t.extend({},n.defaults,this.$element.data(),i),this._init(),Foundation.registerPlugin(this,\"Slider\"),Foundation.Keyboard.register(\"Slider\",{ltr:{ARROW_RIGHT:\"increase\",ARROW_UP:\"increase\",ARROW_DOWN:\"decrease\",ARROW_LEFT:\"decrease\",SHIFT_ARROW_RIGHT:\"increase_fast\",SHIFT_ARROW_UP:\"increase_fast\",SHIFT_ARROW_DOWN:\"decrease_fast\",SHIFT_ARROW_LEFT:\"decrease_fast\"},rtl:{ARROW_LEFT:\"increase\",ARROW_RIGHT:\"decrease\",SHIFT_ARROW_LEFT:\"increase_fast\",SHIFT_ARROW_RIGHT:\"decrease_fast\"}});}return _createClass(n,[{key:\"_init\",value:function value(){this.inputs=this.$element.find(\"input\"),this.handles=this.$element.find(\"[data-slider-handle]\"),this.$handle=this.handles.eq(0),this.$input=this.inputs.length?this.inputs.eq(0):t(\"#\"+this.$handle.attr(\"aria-controls\")),this.$fill=this.$element.find(\"[data-slider-fill]\").css(this.options.vertical?\"height\":\"width\",0);var e=!1,i=this;(this.options.disabled||this.$element.hasClass(this.options.disabledClass))&&(this.options.disabled=!0,this.$element.addClass(this.options.disabledClass)),this.inputs.length||(this.inputs=t().add(this.$input),this.options.binding=!0),this._setInitAttr(0),this._events(this.$handle),this.handles[1]&&(this.options.doubleSided=!0,this.$handle2=this.handles.eq(1),this.$input2=this.inputs.length>1?this.inputs.eq(1):t(\"#\"+this.$handle2.attr(\"aria-controls\")),this.inputs[1]||(this.inputs=this.inputs.add(this.$input2)),e=!0,this._setHandlePos(this.$handle,this.options.initialStart,!0,function(){i._setHandlePos(i.$handle2,i.options.initialEnd,!0);}),this._setInitAttr(1),this._events(this.$handle2)),e||this._setHandlePos(this.$handle,this.options.initialStart,!0);}},{key:\"_setHandlePos\",value:function value(t,i,n,s){i=parseFloat(i),i<this.options.start?i=this.options.start:i>this.options.end&&(i=this.options.end);var o=this.options.doubleSided;if(o)if(0===this.handles.index(t)){var a=parseFloat(this.$handle2.attr(\"aria-valuenow\"));i=i>=a?a-this.options.step:i;}else{var r=parseFloat(this.$handle.attr(\"aria-valuenow\"));i=r>=i?r+this.options.step:i;}this.options.vertical&&!n&&(i=this.options.end-i);var l=this,u=this.options.vertical,d=u?\"height\":\"width\",h=u?\"top\":\"left\",c=t[0].getBoundingClientRect()[d],f=this.$element[0].getBoundingClientRect()[d],p=e(i,this.options.end).toFixed(2),m=(f-c)*p,v=(100*e(m,f)).toFixed(this.options.decimal);i=parseFloat(i.toFixed(this.options.decimal));var g={};if(this._setValues(t,i),o){var w,y=0===this.handles.index(t),b=~~(100*e(c,f));if(y)g[h]=v+\"%\",w=parseFloat(this.$handle2[0].style[h])-v+b,s&&\"function\"==typeof s&&s();else{var $=parseFloat(this.$handle[0].style[h]);w=v-(isNaN($)?this.options.initialStart/((this.options.end-this.options.start)/100):$)+b;}g[\"min-\"+d]=w+\"%\";}this.$element.one(\"finished.zf.animate\",function(){l.$element.trigger(\"moved.zf.slider\",[t]);});var C=this.$element.data(\"dragging\")?1e3/60:this.options.moveTime;Foundation.Move(C,t,function(){t.css(h,v+\"%\"),l.options.doubleSided?l.$fill.css(g):l.$fill.css(d,100*p+\"%\");});}},{key:\"_setInitAttr\",value:function value(t){var e=this.inputs.eq(t).attr(\"id\")||Foundation.GetYoDigits(6,\"slider\");this.inputs.eq(t).attr({id:e,max:this.options.end,min:this.options.start,step:this.options.step}),this.handles.eq(t).attr({role:\"slider\",\"aria-controls\":e,\"aria-valuemax\":this.options.end,\"aria-valuemin\":this.options.start,\"aria-valuenow\":0===t?this.options.initialStart:this.options.initialEnd,\"aria-orientation\":this.options.vertical?\"vertical\":\"horizontal\",tabindex:0});}},{key:\"_setValues\",value:function value(t,e){var i=this.options.doubleSided?this.handles.index(t):0;this.inputs.eq(i).val(e),t.attr(\"aria-valuenow\",e);}},{key:\"_handleEvent\",value:function value(t,n,s){var o,a;if(s)o=this._adjustValue(null,s),a=!0;else{t.preventDefault();var r=this,l=this.options.vertical,u=l?\"height\":\"width\",d=l?\"top\":\"left\",h=l?t.pageY:t.pageX,c=this.$handle[0].getBoundingClientRect()[u]/2,f=this.$element[0].getBoundingClientRect()[u],p=this.$element.offset()[d]-h,m=p>0?-c:-f>p-c?f:Math.abs(p),v=e(m,f);if(o=(this.options.end-this.options.start)*v,Foundation.rtl()&&!this.options.vertical&&(o=this.options.end-o),o=r._adjustValue(null,o),a=!1,!n){var g=i(this.$handle,d,m,u),w=i(this.$handle2,d,m,u);n=w>=g?this.$handle:this.$handle2;}}this._setHandlePos(n,o,a);}},{key:\"_adjustValue\",value:function value(t,e){var i,n,s,o,a=this.options.step,r=parseFloat(a/2);return i=t?parseFloat(t.attr(\"aria-valuenow\")):e,n=i%a,s=i-n,o=s+a,0===n?i:i=i>=s+r?o:s;}},{key:\"_events\",value:function value(e){if(this.options.disabled)return!1;var i,n=this;if(this.inputs.off(\"change.zf.slider\").on(\"change.zf.slider\",function(e){var i=n.inputs.index(t(this));n._handleEvent(e,n.handles.eq(i),t(this).val());}),this.options.clickSelect&&this.$element.off(\"click.zf.slider\").on(\"click.zf.slider\",function(e){return n.$element.data(\"dragging\")?!1:void(t(e.target).is(\"[data-slider-handle]\")||(n.options.doubleSided?n._handleEvent(e):n._handleEvent(e,n.$handle)));}),this.options.draggable){this.handles.addTouch();var s=t(\"body\");e.off(\"mousedown.zf.slider\").on(\"mousedown.zf.slider\",function(o){e.addClass(\"is-dragging\"),n.$fill.addClass(\"is-dragging\"),n.$element.data(\"dragging\",!0),i=t(o.currentTarget),s.on(\"mousemove.zf.slider\",function(t){t.preventDefault(),n._handleEvent(t,i);}).on(\"mouseup.zf.slider\",function(t){n._handleEvent(t,i),e.removeClass(\"is-dragging\"),n.$fill.removeClass(\"is-dragging\"),n.$element.data(\"dragging\",!1),s.off(\"mousemove.zf.slider mouseup.zf.slider\");});});}e.off(\"keydown.zf.slider\").on(\"keydown.zf.slider\",function(e){var i,s=t(this),o=n.options.doubleSided?n.handles.index(s):0,a=parseFloat(n.inputs.eq(o).val());Foundation.Keyboard.handleKey(e,\"Slider\",{decrease:function decrease(){i=a-n.options.step;},increase:function increase(){i=a+n.options.step;},decrease_fast:function decrease_fast(){i=a-10*n.options.step;},increase_fast:function increase_fast(){i=a+10*n.options.step;},handled:function handled(){e.preventDefault(),n._setHandlePos(s,i,!0);}});});}},{key:\"destroy\",value:function value(){this.handles.off(\".zf.slider\"),this.inputs.off(\".zf.slider\"),this.$element.off(\".zf.slider\"),Foundation.unregisterPlugin(this);}}]),n;}();n.defaults={start:0,end:100,step:1,initialStart:0,initialEnd:100,binding:!1,clickSelect:!0,vertical:!1,draggable:!0,disabled:!1,doubleSided:!1,decimal:2,moveTime:200,disabledClass:\"disabled\",invertVertical:!1},Foundation.plugin(n,\"Slider\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){function e(t){return parseInt(window.getComputedStyle(document.body,null).fontSize,10)*t;}var i=function(){function i(e,n){_classCallCheck(this,i),this.$element=e,this.options=t.extend({},i.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Sticky\");}return _createClass(i,[{key:\"_init\",value:function value(){var e=this.$element.parent(\"[data-sticky-container]\"),i=this.$element[0].id||Foundation.GetYoDigits(6,\"sticky\"),n=this;e.length||(this.wasWrapped=!0),this.$container=e.length?e:t(this.options.container).wrapInner(this.$element),this.$container.addClass(this.options.containerClass),this.$element.addClass(this.options.stickyClass).attr({\"data-resize\":i}),this.scrollCount=this.options.checkEvery,this.isStuck=!1,t(window).one(\"load.zf.sticky\",function(){\"\"!==n.options.anchor?n.$anchor=t(\"#\"+n.options.anchor):n._parsePoints(),n._setSizes(function(){n._calc(!1);}),n._events(i.split(\"-\").reverse().join(\"-\"));});}},{key:\"_parsePoints\",value:function value(){var e=this.options.topAnchor,i=this.options.btmAnchor,n=[e,i],s={};if(e&&i)for(var o=0,a=n.length;a>o&&n[o];o++){var r;if(\"number\"==typeof n[o])r=n[o];else{var l=n[o].split(\":\"),u=t(\"#\"+l[0]);r=u.offset().top,l[1]&&\"bottom\"===l[1].toLowerCase()&&(r+=u[0].getBoundingClientRect().height);}s[o]=r;}else s={0:1,1:document.documentElement.scrollHeight};this.points=s;}},{key:\"_events\",value:function value(e){var i=this,n=this.scrollListener=\"scroll.zf.\"+e;this.isOn||(this.canStick&&(this.isOn=!0,t(window).off(n).on(n,function(t){0===i.scrollCount?(i.scrollCount=i.options.checkEvery,i._setSizes(function(){i._calc(!1,window.pageYOffset);})):(i.scrollCount--,i._calc(!1,window.pageYOffset));})),this.$element.off(\"resizeme.zf.trigger\").on(\"resizeme.zf.trigger\",function(t,s){i._setSizes(function(){i._calc(!1),i.canStick?i.isOn||i._events(e):i.isOn&&i._pauseListeners(n);});}));}},{key:\"_pauseListeners\",value:function value(e){this.isOn=!1,t(window).off(e),this.$element.trigger(\"pause.zf.sticky\");}},{key:\"_calc\",value:function value(t,e){return t&&this._setSizes(),this.canStick?(e||(e=window.pageYOffset),void(e>=this.topPoint?e<=this.bottomPoint?this.isStuck||this._setSticky():this.isStuck&&this._removeSticky(!1):this.isStuck&&this._removeSticky(!0))):(this.isStuck&&this._removeSticky(!0),!1);}},{key:\"_setSticky\",value:function value(){var t=this.options.stickTo,e=\"top\"===t?\"marginTop\":\"marginBottom\",i=\"top\"===t?\"bottom\":\"top\",n={};n[e]=this.options[e]+\"em\",n[t]=0,n[i]=\"auto\",n.left=this.$container.offset().left+parseInt(window.getComputedStyle(this.$container[0])[\"padding-left\"],10),this.isStuck=!0,this.$element.removeClass(\"is-anchored is-at-\"+i).addClass(\"is-stuck is-at-\"+t).css(n).trigger(\"sticky.zf.stuckto:\"+t);}},{key:\"_removeSticky\",value:function value(t){var e=this.options.stickTo,i=\"top\"===e,n={},s=(this.points?this.points[1]-this.points[0]:this.anchorHeight)-this.elemHeight,o=i?\"marginTop\":\"marginBottom\",a=i?\"bottom\":\"top\",r=t?\"top\":\"bottom\";n[o]=0,t&&!i||i&&!t?(n[e]=s,n[a]=0):(n[e]=0,n[a]=s),n.left=\"\",this.isStuck=!1,this.$element.removeClass(\"is-stuck is-at-\"+e).addClass(\"is-anchored is-at-\"+r).css(n).trigger(\"sticky.zf.unstuckfrom:\"+r);}},{key:\"_setSizes\",value:function value(t){this.canStick=Foundation.MediaQuery.atLeast(this.options.stickyOn),this.canStick||t();var e=this.$container[0].getBoundingClientRect().width,i=window.getComputedStyle(this.$container[0]),n=parseInt(i[\"padding-right\"],10);this.$anchor&&this.$anchor.length?this.anchorHeight=this.$anchor[0].getBoundingClientRect().height:this._parsePoints(),this.$element.css({\"max-width\":e-n+\"px\"});var s=this.$element[0].getBoundingClientRect().height||this.containerHeight;this.containerHeight=s,this.$container.css({height:s}),this.elemHeight=s,this.isStuck&&this.$element.css({left:this.$container.offset().left+parseInt(i[\"padding-left\"],10)}),this._setBreakPoints(s,function(){t&&t();});}},{key:\"_setBreakPoints\",value:function value(t,i){if(!this.canStick){if(!i)return!1;i();}var n=e(this.options.marginTop),s=e(this.options.marginBottom),o=this.points?this.points[0]:this.$anchor.offset().top,a=this.points?this.points[1]:o+this.anchorHeight,r=window.innerHeight;\"top\"===this.options.stickTo?(o-=n,a-=t+n):\"bottom\"===this.options.stickTo&&(o-=r-(t+s),a-=r-s),this.topPoint=o,this.bottomPoint=a,i&&i();}},{key:\"destroy\",value:function value(){this._removeSticky(!0),this.$element.removeClass(this.options.stickyClass+\" is-anchored is-at-top\").css({height:\"\",top:\"\",bottom:\"\",\"max-width\":\"\"}).off(\"resizeme.zf.trigger\"),this.$anchor.off(\"change.zf.sticky\"),t(window).off(this.scrollListener),this.wasWrapped?this.$element.unwrap():this.$container.removeClass(this.options.containerClass).css({height:\"\"}),Foundation.unregisterPlugin(this);}}]),i;}();i.defaults={container:\"<div data-sticky-container></div>\",stickTo:\"top\",anchor:\"\",topAnchor:\"\",btmAnchor:\"\",marginTop:1,marginBottom:1,stickyOn:\"medium\",stickyClass:\"sticky\",containerClass:\"sticky-container\",checkEvery:-1},Foundation.plugin(i,\"Sticky\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Tabs\"),Foundation.Keyboard.register(\"Tabs\",{ENTER:\"open\",SPACE:\"open\",ARROW_RIGHT:\"next\",ARROW_UP:\"previous\",ARROW_DOWN:\"next\",ARROW_LEFT:\"previous\"});}return _createClass(e,[{key:\"_init\",value:function value(){var e=this;if(this.$tabTitles=this.$element.find(\".\"+this.options.linkClass),this.$tabContent=t('[data-tabs-content=\"'+this.$element[0].id+'\"]'),this.$tabTitles.each(function(){var i=t(this),n=i.find(\"a\"),s=i.hasClass(\"is-active\"),o=n[0].hash.slice(1),a=n[0].id?n[0].id:o+\"-label\",r=t(\"#\"+o);i.attr({role:\"presentation\"}),n.attr({role:\"tab\",\"aria-controls\":o,\"aria-selected\":s,id:a}),r.attr({role:\"tabpanel\",\"aria-hidden\":!s,\"aria-labelledby\":a}),s&&e.options.autoFocus&&n.focus();}),this.options.matchHeight){var i=this.$tabContent.find(\"img\");i.length?Foundation.onImagesLoaded(i,this._setHeight.bind(this)):this._setHeight();}this._events();}},{key:\"_events\",value:function value(){this._addKeyHandler(),this._addClickHandler(),this.options.matchHeight&&t(window).on(\"changed.zf.mediaquery\",this._setHeight.bind(this));}},{key:\"_addClickHandler\",value:function value(){var e=this;this.$element.off(\"click.zf.tabs\").on(\"click.zf.tabs\",\".\"+this.options.linkClass,function(i){i.preventDefault(),i.stopPropagation(),t(this).hasClass(\"is-active\")||e._handleTabChange(t(this));});}},{key:\"_addKeyHandler\",value:function value(){var e=this;e.$element.find(\"li:first-of-type\"),e.$element.find(\"li:last-of-type\");this.$tabTitles.off(\"keydown.zf.tabs\").on(\"keydown.zf.tabs\",function(i){if(9!==i.which){i.stopPropagation(),i.preventDefault();var n,s,o=t(this),a=o.parent(\"ul\").children(\"li\");a.each(function(i){return t(this).is(o)?void(e.options.wrapOnKeys?(n=0===i?a.last():a.eq(i-1),s=i===a.length-1?a.first():a.eq(i+1)):(n=a.eq(Math.max(0,i-1)),s=a.eq(Math.min(i+1,a.length-1)))):void 0;}),Foundation.Keyboard.handleKey(i,\"Tabs\",{open:function open(){o.find('[role=\"tab\"]').focus(),e._handleTabChange(o);},previous:function previous(){n.find('[role=\"tab\"]').focus(),e._handleTabChange(n);},next:function next(){s.find('[role=\"tab\"]').focus(),e._handleTabChange(s);}});}});}},{key:\"_handleTabChange\",value:function value(e){var i=e.find('[role=\"tab\"]'),n=i[0].hash,s=this.$tabContent.find(n),o=this.$element.find(\".\"+this.options.linkClass+\".is-active\").removeClass(\"is-active\").find('[role=\"tab\"]').attr({\"aria-selected\":\"false\"});t(\"#\"+o.attr(\"aria-controls\")).removeClass(\"is-active\").attr({\"aria-hidden\":\"true\"}),e.addClass(\"is-active\"),i.attr({\"aria-selected\":\"true\"}),s.addClass(\"is-active\").attr({\"aria-hidden\":\"false\"}),this.$element.trigger(\"change.zf.tabs\",[e]);}},{key:\"selectTab\",value:function value(t){var e;e=\"object\"==(typeof t===\"undefined\"?\"undefined\":_typeof(t))?t[0].id:t,e.indexOf(\"#\")<0&&(e=\"#\"+e);var i=this.$tabTitles.find('[href=\"'+e+'\"]').parent(\".\"+this.options.linkClass);this._handleTabChange(i);}},{key:\"_setHeight\",value:function value(){var e=0;this.$tabContent.find(\".\"+this.options.panelClass).css(\"height\",\"\").each(function(){var i=t(this),n=i.hasClass(\"is-active\");n||i.css({visibility:\"hidden\",display:\"block\"});var s=this.getBoundingClientRect().height;n||i.css({visibility:\"\",display:\"\"}),e=s>e?s:e;}).css(\"height\",e+\"px\");}},{key:\"destroy\",value:function value(){this.$element.find(\".\"+this.options.linkClass).off(\".zf.tabs\").hide().end().find(\".\"+this.options.panelClass).hide(),this.options.matchHeight&&t(window).off(\"changed.zf.mediaquery\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={autoFocus:!1,wrapOnKeys:!0,matchHeight:!1,linkClass:\"tabs-title\",panelClass:\"tabs-panel\"},Foundation.plugin(e,\"Tabs\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,i.data(),n),this.className=\"\",this._init(),this._events(),Foundation.registerPlugin(this,\"Toggler\");}return _createClass(e,[{key:\"_init\",value:function value(){var e;this.options.animate?(e=this.options.animate.split(\" \"),this.animationIn=e[0],this.animationOut=e[1]||null):(e=this.$element.data(\"toggler\"),this.className=\".\"===e[0]?e.slice(1):e);var i=this.$element[0].id;t('[data-open=\"'+i+'\"], [data-close=\"'+i+'\"], [data-toggle=\"'+i+'\"]').attr(\"aria-controls\",i),this.$element.attr(\"aria-expanded\",!this.$element.is(\":hidden\"));}},{key:\"_events\",value:function value(){this.$element.off(\"toggle.zf.trigger\").on(\"toggle.zf.trigger\",this.toggle.bind(this));}},{key:\"toggle\",value:function value(){this[this.options.animate?\"_toggleAnimate\":\"_toggleClass\"]();}},{key:\"_toggleClass\",value:function value(){this.$element.toggleClass(this.className);var t=this.$element.hasClass(this.className);t?this.$element.trigger(\"on.zf.toggler\"):this.$element.trigger(\"off.zf.toggler\"),this._updateARIA(t);}},{key:\"_toggleAnimate\",value:function value(){var t=this;this.$element.is(\":hidden\")?Foundation.Motion.animateIn(this.$element,this.animationIn,function(){this.trigger(\"on.zf.toggler\"),t._updateARIA(!0);}):Foundation.Motion.animateOut(this.$element,this.animationOut,function(){this.trigger(\"off.zf.toggler\"),t._updateARIA(!1);});}},{key:\"_updateARIA\",value:function value(t){this.$element.attr(\"aria-expanded\",!!t);}},{key:\"destroy\",value:function value(){this.$element.off(\".zf.toggler\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={animate:!1},Foundation.plugin(e,\"Toggler\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this.isActive=!1,this.isClick=!1,this._init(),Foundation.registerPlugin(this,\"Tooltip\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"aria-describedby\")||Foundation.GetYoDigits(6,\"tooltip\");this.options.positionClass=this._getPositionClass(this.$element),this.options.tipText=this.options.tipText||this.$element.attr(\"title\"),this.template=this.options.template?t(this.options.template):this._buildTemplate(e),this.template.appendTo(document.body).text(this.options.tipText).hide(),this.$element.attr({title:\"\",\"aria-describedby\":e,\"data-yeti-box\":e,\"data-toggle\":e,\"data-resize\":e}).addClass(this.triggerClass),this.usedPositions=[],this.counter=4,this.classChanged=!1,this._events();}},{key:\"_getPositionClass\",value:function value(t){if(!t)return\"\";var e=t[0].className.match(/\\b(top|left|right)\\b/g);return e=e?e[0]:\"\";}},{key:\"_buildTemplate\",value:function value(e){var i=(this.options.tooltipClass+\" \"+this.options.positionClass+\" \"+this.options.templateClasses).trim(),n=t(\"<div></div>\").addClass(i).attr({role:\"tooltip\",\"aria-hidden\":!0,\"data-is-active\":!1,\"data-is-focus\":!1,id:e});return n;}},{key:\"_reposition\",value:function value(t){this.usedPositions.push(t?t:\"bottom\"),!t&&this.usedPositions.indexOf(\"top\")<0?this.template.addClass(\"top\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")<0?this.template.removeClass(t):\"left\"===t&&this.usedPositions.indexOf(\"right\")<0?this.template.removeClass(t).addClass(\"right\"):\"right\"===t&&this.usedPositions.indexOf(\"left\")<0?this.template.removeClass(t).addClass(\"left\"):!t&&this.usedPositions.indexOf(\"top\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.template.addClass(\"left\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.template.removeClass(t).addClass(\"left\"):\"left\"===t&&this.usedPositions.indexOf(\"right\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.template.removeClass(t):\"right\"===t&&this.usedPositions.indexOf(\"left\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.template.removeClass(t):this.template.removeClass(t),this.classChanged=!0,this.counter--;}},{key:\"_setPosition\",value:function value(){var t=this._getPositionClass(this.template),e=Foundation.Box.GetDimensions(this.template),i=Foundation.Box.GetDimensions(this.$element),n=\"left\"===t?\"left\":\"right\"===t?\"left\":\"top\",s=\"top\"===n?\"height\":\"width\";\"height\"===s?this.options.vOffset:this.options.hOffset;if(e.width>=e.windowDims.width||!this.counter&&!Foundation.Box.ImNotTouchingYou(this.template))return this.template.offset(Foundation.Box.GetOffsets(this.template,this.$element,\"center bottom\",this.options.vOffset,this.options.hOffset,!0)).css({width:i.windowDims.width-2*this.options.hOffset,height:\"auto\"}),!1;for(this.template.offset(Foundation.Box.GetOffsets(this.template,this.$element,\"center \"+(t||\"bottom\"),this.options.vOffset,this.options.hOffset));!Foundation.Box.ImNotTouchingYou(this.template)&&this.counter;){this._reposition(t),this._setPosition();}}},{key:\"show\",value:function value(){if(\"all\"!==this.options.showOn&&!Foundation.MediaQuery.atLeast(this.options.showOn))return!1;var t=this;this.template.css(\"visibility\",\"hidden\").show(),this._setPosition(),this.$element.trigger(\"closeme.zf.tooltip\",this.template.attr(\"id\")),this.template.attr({\"data-is-active\":!0,\"aria-hidden\":!1}),t.isActive=!0,this.template.stop().hide().css(\"visibility\",\"\").fadeIn(this.options.fadeInDuration,function(){}),this.$element.trigger(\"show.zf.tooltip\");}},{key:\"hide\",value:function value(){var t=this;this.template.stop().attr({\"aria-hidden\":!0,\"data-is-active\":!1}).fadeOut(this.options.fadeOutDuration,function(){t.isActive=!1,t.isClick=!1,t.classChanged&&(t.template.removeClass(t._getPositionClass(t.template)).addClass(t.options.positionClass),t.usedPositions=[],t.counter=4,t.classChanged=!1);}),this.$element.trigger(\"hide.zf.tooltip\");}},{key:\"_events\",value:function value(){var t=this,e=(this.template,!1);this.options.disableHover||this.$element.on(\"mouseenter.zf.tooltip\",function(e){t.isActive||(t.timeout=setTimeout(function(){t.show();},t.options.hoverDelay));}).on(\"mouseleave.zf.tooltip\",function(i){clearTimeout(t.timeout),(!e||!t.isClick&&t.options.clickOpen)&&t.hide();}),this.options.clickOpen&&this.$element.on(\"mousedown.zf.tooltip\",function(e){e.stopImmediatePropagation(),t.isClick?t.hide():(t.isClick=!0,!t.options.disableHover&&t.$element.attr(\"tabindex\")||t.isActive||t.show());}),this.options.disableForTouch||this.$element.on(\"tap.zf.tooltip touchend.zf.tooltip\",function(e){t.isActive?t.hide():t.show();}),this.$element.on({\"close.zf.trigger\":this.hide.bind(this)}),this.$element.on(\"focus.zf.tooltip\",function(i){return e=!0,t.isClick?!1:void t.show();}).on(\"focusout.zf.tooltip\",function(i){e=!1,t.isClick=!1,t.hide();}).on(\"resizeme.zf.trigger\",function(){t.isActive&&t._setPosition();});}},{key:\"toggle\",value:function value(){this.isActive?this.hide():this.show();}},{key:\"destroy\",value:function value(){this.$element.attr(\"title\",this.template.text()).off(\".zf.trigger .zf.tootip\").removeAttr(\"aria-describedby\").removeAttr(\"data-yeti-box\").removeAttr(\"data-toggle\").removeAttr(\"data-resize\"),this.template.remove(),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={disableForTouch:!1,hoverDelay:200,fadeInDuration:150,fadeOutDuration:150,disableHover:!1,templateClasses:\"\",tooltipClass:\"tooltip\",triggerClass:\"has-tip\",showOn:\"small\",template:\"\",tipText:\"\",touchCloseText:\"Tap to close.\",clickOpen:!0,positionClass:\"\",vOffset:10,hOffset:12},Foundation.plugin(e,\"Tooltip\");}(jQuery);"

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(39);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _reactRouter = __webpack_require__(185);
	
	var _Main = __webpack_require__(240);
	
	var _Main2 = _interopRequireDefault(_Main);
	
	var _Weather = __webpack_require__(242);
	
	var _Weather2 = _interopRequireDefault(_Weather);
	
	var _About = __webpack_require__(272);
	
	var _About2 = _interopRequireDefault(_About);
	
	var _Examples = __webpack_require__(273);
	
	var _Examples2 = _interopRequireDefault(_Examples);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Load Foundation
	__webpack_require__(274);
	$(document).foundation();
	
	// App styles
	__webpack_require__(278);
	
	_reactDom2.default.render(_react2.default.createElement(
	    _reactRouter.Router,
	    { history: _reactRouter.hashHistory },
	    _react2.default.createElement(
	        _reactRouter.Route,
	        { path: '/', component: _Main2.default },
	        _react2.default.createElement(_reactRouter.Route, { path: 'about', component: _About2.default }),
	        _react2.default.createElement(_reactRouter.Route, { path: 'examples', component: _Examples2.default }),
	        _react2.default.createElement(_reactRouter.IndexRoute, { component: _Weather2.default })
	    )
	), document.getElementById('app'));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = jQuery;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(9);

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var ReactChildren = __webpack_require__(12);
	var ReactComponent = __webpack_require__(25);
	var ReactPureComponent = __webpack_require__(28);
	var ReactClass = __webpack_require__(29);
	var ReactDOMFactories = __webpack_require__(31);
	var ReactElement = __webpack_require__(16);
	var ReactPropTypes = __webpack_require__(36);
	var ReactVersion = __webpack_require__(37);
	
	var onlyChild = __webpack_require__(38);
	var warning = __webpack_require__(18);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(32);
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var __spread = _assign;
	
	if (process.env.NODE_ENV !== 'production') {
	  var warned = false;
	  __spread = function __spread() {
	    process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
	    warned = true;
	    return _assign.apply(null, arguments);
	  };
	}
	
	var React = {
	
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactComponent,
	  PureComponent: ReactPureComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function createMixin(mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Deprecated hook for JSX spread, don't use this for anything.
	  __spread: __spread
	};
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 10 */
/***/ function(module, exports) {

	'use strict';
	
	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout() {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	})();
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () {
	    return '/';
	};
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function () {
	    return 0;
	};

/***/ },
/* 11 */
/***/ function(module, exports) {

	'use strict';
	/* eslint-disable no-unused-vars */
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc'); // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(13);
	var ReactElement = __webpack_require__(16);
	
	var emptyFunction = __webpack_require__(19);
	var traverseAllChildren = __webpack_require__(22);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/+/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func,
	      context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result,
	      keyPrefix = bookKeeping.keyPrefix,
	      func = bookKeeping.func,
	      context = bookKeeping.context;
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(14);
	
	var invariant = __webpack_require__(15);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function fiveArgumentPooler(a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function standardReleaser(instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
	  // Casting as any so that flow ignores the actual implementation and trusts
	  // it to match the type we declared
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 14 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	'use strict';
	
	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */
	
	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;
	
	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
	
	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }
	
	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
	
	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame
	
	  throw error;
	}
	
	module.exports = reactProdInvariant;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _assign = __webpack_require__(11);
	
	var ReactCurrentOwner = __webpack_require__(17);
	
	var warning = __webpack_require__(18);
	var canDefineProperty = __webpack_require__(20);
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	var REACT_ELEMENT_TYPE = __webpack_require__(21);
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	var specialPropKeyWarningShown, specialPropRefWarningShown;
	
	function hasValidRef(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'ref')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.ref !== undefined;
	}
	
	function hasValidKey(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'key')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.key !== undefined;
	}
	
	function defineKeyPropWarningGetter(props, displayName) {
	  var warnAboutAccessingKey = function warnAboutAccessingKey() {
	    if (!specialPropKeyWarningShown) {
	      specialPropKeyWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingKey.isReactWarning = true;
	  Object.defineProperty(props, 'key', {
	    get: warnAboutAccessingKey,
	    configurable: true
	  });
	}
	
	function defineRefPropWarningGetter(props, displayName) {
	  var warnAboutAccessingRef = function warnAboutAccessingRef() {
	    if (!specialPropRefWarningShown) {
	      specialPropRefWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingRef.isReactWarning = true;
	  Object.defineProperty(props, 'ref', {
	    get: warnAboutAccessingRef,
	    configurable: true
	  });
	}
	
	/**
	 * Factory method to create a new React element. This no longer adheres to
	 * the class pattern, so do not use new to call it. Also, no instanceof check
	 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
	 * if something is a React Element.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._source = source;
	    }
	    if (Object.freeze) {
	      Object.freeze(element.props);
	      Object.freeze(element);
	    }
	  }
	
	  return element;
	};
	
	/**
	 * Create and return a new ReactElement of the given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
	 */
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    if (hasValidRef(config)) {
	      ref = config.ref;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (Object.freeze) {
	        Object.freeze(childArray);
	      }
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (props[propName] === undefined) {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (key || ref) {
	      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
	        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
	        if (key) {
	          defineKeyPropWarningGetter(props, displayName);
	        }
	        if (ref) {
	          defineRefPropWarningGetter(props, displayName);
	        }
	      }
	    }
	  }
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	/**
	 * Return a function that produces ReactElements of a given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
	 */
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	/**
	 * Clone and return a new ReactElement using element as the starting point.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
	 */
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = _assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (hasValidRef(config)) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    // Remaining properties override existing props
	    var defaultProps;
	    if (element.type && element.type.defaultProps) {
	      defaultProps = element.type.defaultProps;
	    }
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        if (config[propName] === undefined && defaultProps !== undefined) {
	          // Resolve default props
	          props[propName] = defaultProps[propName];
	        } else {
	          props[propName] = config[propName];
	        }
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * Verifies the object is a ReactElement.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 17 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(19);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var printWarning = function printWarning(format) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    };
	
	    warning = function warning(condition, format) {
	      if (format === undefined) {
	        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	      }
	
	      if (format.indexOf('Failed Composite propType: ') === 0) {
	        return; // Ignore CompositeComponent proptype check.
	      }
	
	      if (!condition) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	          args[_key2 - 2] = arguments[_key2];
	        }
	
	        printWarning.apply(undefined, [format].concat(args));
	      }
	    };
	  })();
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 19 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    // $FlowFixMe https://github.com/facebook/flow/issues/285
	    Object.defineProperty({}, 'x', { get: function get() {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 21 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	module.exports = REACT_ELEMENT_TYPE;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(14);
	
	var ReactCurrentOwner = __webpack_require__(17);
	var REACT_ELEMENT_TYPE = __webpack_require__(21);
	
	var getIteratorFn = __webpack_require__(23);
	var invariant = __webpack_require__(15);
	var KeyEscapeUtils = __webpack_require__(24);
	var warning = __webpack_require__(18);
	
	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';
	
	/**
	 * This is inlined from ReactElement since this file is shared between
	 * isomorphic and renderers. We could extract this to a
	 *
	 */
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var didWarnAboutMaps = false;
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && (typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' ||
	  // The following is inlined from ReactElement. This means we can optimize
	  // some checks. React Fiber also inlines this logic for similar purposes.
	  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 23 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 24 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */
	
	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });
	
	  return '$' + escapedString;
	}
	
	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
	
	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}
	
	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};
	
	module.exports = KeyEscapeUtils;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(14);
	
	var ReactNoopUpdateQueue = __webpack_require__(26);
	
	var canDefineProperty = __webpack_require__(20);
	var emptyObject = __webpack_require__(27);
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'setState');
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'forceUpdate');
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
	  };
	  var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function get() {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var warning = __webpack_require__(18);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted(publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function enqueueCallback(publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
	    warnNoop(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
	    warnNoop(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
	    warnNoop(publicInstance, 'setState');
	  }
	};
	
	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var ReactComponent = __webpack_require__(25);
	var ReactNoopUpdateQueue = __webpack_require__(26);
	
	var emptyObject = __webpack_require__(27);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactPureComponent(props, context, updater) {
	  // Duplicated from ReactComponent.
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	function ComponentDummy() {}
	ComponentDummy.prototype = ReactComponent.prototype;
	ReactPureComponent.prototype = new ComponentDummy();
	ReactPureComponent.prototype.constructor = ReactPureComponent;
	// Avoid an extra prototype jump for these methods.
	_assign(ReactPureComponent.prototype, ReactComponent.prototype);
	ReactPureComponent.prototype.isPureReactComponent = true;
	
	module.exports = ReactPureComponent;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(14),
	    _assign = __webpack_require__(11);
	
	var ReactComponent = __webpack_require__(25);
	var ReactElement = __webpack_require__(16);
	var ReactPropTypeLocationNames = __webpack_require__(30);
	var ReactNoopUpdateQueue = __webpack_require__(26);
	
	var emptyObject = __webpack_require__(27);
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	var MIXINS_KEY = 'mixins';
	
	// Helper function to allow the creation of anonymous functions which do not
	// have .name set to the name of the variable being assigned to.
	function identity(fn) {
	  return fn;
	}
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	
	var injectedMixins = [];
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or host components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: 'DEFINE_MANY',
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: 'DEFINE_MANY',
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: 'DEFINE_MANY',
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: 'DEFINE_MANY',
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: 'DEFINE_MANY',
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: 'DEFINE_MANY_MERGED',
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: 'DEFINE_MANY_MERGED',
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: 'DEFINE_MANY_MERGED',
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: 'DEFINE_ONCE',
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: 'DEFINE_MANY',
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: 'DEFINE_MANY',
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: 'DEFINE_MANY',
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: 'DEFINE_ONCE',
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: 'DEFINE_MANY',
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: 'DEFINE_MANY',
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: 'DEFINE_MANY',
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: 'OVERRIDE_BASE'
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function displayName(Constructor, _displayName) {
	    Constructor.displayName = _displayName;
	  },
	  mixins: function mixins(Constructor, _mixins) {
	    if (_mixins) {
	      for (var i = 0; i < _mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, _mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function childContextTypes(Constructor, _childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _childContextTypes, 'childContext');
	    }
	    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, _childContextTypes);
	  },
	  contextTypes: function contextTypes(Constructor, _contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _contextTypes, 'context');
	    }
	    Constructor.contextTypes = _assign({}, Constructor.contextTypes, _contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function getDefaultProps(Constructor, _getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, _getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = _getDefaultProps;
	    }
	  },
	  propTypes: function propTypes(Constructor, _propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _propTypes, 'prop');
	    }
	    Constructor.propTypes = _assign({}, Constructor.propTypes, _propTypes);
	  },
	  statics: function statics(Constructor, _statics) {
	    mixStaticSpecIntoComponent(Constructor, _statics);
	  },
	  autobind: function autobind() {} };
	
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but only in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
	    }
	  }
	}
	
	function validateMethodOverride(isAlreadyDefined, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === 'OVERRIDE_BASE') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (isAlreadyDefined) {
	    !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classes.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    if (process.env.NODE_ENV !== 'production') {
	      var typeofSpec = typeof spec === 'undefined' ? 'undefined' : _typeof(spec);
	      var isMixinValid = typeofSpec === 'object' && spec !== null;
	
	      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
	    }
	
	    return;
	  }
	
	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;
	
	  var proto = Constructor.prototype;
	  var autoBindPairs = proto.__reactAutoBindPairs;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }
	
	    var property = spec[name];
	    var isAlreadyDefined = proto.hasOwnProperty(name);
	    validateMethodOverride(isAlreadyDefined, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	      if (shouldAutoBind) {
	        autoBindPairs.push(name, property);
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === 'DEFINE_MANY_MERGED') {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === 'DEFINE_MANY') {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = name in RESERVED_SPEC_KEYS;
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;
	
	    var isInherited = name in Constructor;
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && (typeof one === 'undefined' ? 'undefined' : _typeof(one)) === 'object' && (typeof two === 'undefined' ? 'undefined' : _typeof(two)) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  var pairs = component.__reactAutoBindPairs;
	  for (var i = 0; i < pairs.length; i += 2) {
	    var autoBindKey = pairs[i];
	    var method = pairs[i + 1];
	    component[autoBindKey] = bindAutoBindMethod(component, method);
	  }
	}
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function replaceState(newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback, 'replaceState');
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted() {
	    return this.updater.isMounted(this);
	  }
	};
	
	var ReactClassComponent = function ReactClassComponent() {};
	_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function createClass(spec) {
	    // To keep our warnings more understandable, we'll use a little hack here to
	    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
	    // unnecessarily identify a class without displayName as 'Constructor'.
	    var Constructor = identity(function (props, context, updater) {
	      // This constructor gets overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindPairs.length) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (initialState === undefined && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;
	
	      this.state = initialState;
	    });
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	    Constructor.prototype.__reactAutoBindPairs = [];
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function injectMixin(mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(16);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @private
	 */
	var createDOMFactory = ReactElement.createFactory;
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(32);
	  createDOMFactory = ReactElementValidator.createFactory;
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = {
	  a: createDOMFactory('a'),
	  abbr: createDOMFactory('abbr'),
	  address: createDOMFactory('address'),
	  area: createDOMFactory('area'),
	  article: createDOMFactory('article'),
	  aside: createDOMFactory('aside'),
	  audio: createDOMFactory('audio'),
	  b: createDOMFactory('b'),
	  base: createDOMFactory('base'),
	  bdi: createDOMFactory('bdi'),
	  bdo: createDOMFactory('bdo'),
	  big: createDOMFactory('big'),
	  blockquote: createDOMFactory('blockquote'),
	  body: createDOMFactory('body'),
	  br: createDOMFactory('br'),
	  button: createDOMFactory('button'),
	  canvas: createDOMFactory('canvas'),
	  caption: createDOMFactory('caption'),
	  cite: createDOMFactory('cite'),
	  code: createDOMFactory('code'),
	  col: createDOMFactory('col'),
	  colgroup: createDOMFactory('colgroup'),
	  data: createDOMFactory('data'),
	  datalist: createDOMFactory('datalist'),
	  dd: createDOMFactory('dd'),
	  del: createDOMFactory('del'),
	  details: createDOMFactory('details'),
	  dfn: createDOMFactory('dfn'),
	  dialog: createDOMFactory('dialog'),
	  div: createDOMFactory('div'),
	  dl: createDOMFactory('dl'),
	  dt: createDOMFactory('dt'),
	  em: createDOMFactory('em'),
	  embed: createDOMFactory('embed'),
	  fieldset: createDOMFactory('fieldset'),
	  figcaption: createDOMFactory('figcaption'),
	  figure: createDOMFactory('figure'),
	  footer: createDOMFactory('footer'),
	  form: createDOMFactory('form'),
	  h1: createDOMFactory('h1'),
	  h2: createDOMFactory('h2'),
	  h3: createDOMFactory('h3'),
	  h4: createDOMFactory('h4'),
	  h5: createDOMFactory('h5'),
	  h6: createDOMFactory('h6'),
	  head: createDOMFactory('head'),
	  header: createDOMFactory('header'),
	  hgroup: createDOMFactory('hgroup'),
	  hr: createDOMFactory('hr'),
	  html: createDOMFactory('html'),
	  i: createDOMFactory('i'),
	  iframe: createDOMFactory('iframe'),
	  img: createDOMFactory('img'),
	  input: createDOMFactory('input'),
	  ins: createDOMFactory('ins'),
	  kbd: createDOMFactory('kbd'),
	  keygen: createDOMFactory('keygen'),
	  label: createDOMFactory('label'),
	  legend: createDOMFactory('legend'),
	  li: createDOMFactory('li'),
	  link: createDOMFactory('link'),
	  main: createDOMFactory('main'),
	  map: createDOMFactory('map'),
	  mark: createDOMFactory('mark'),
	  menu: createDOMFactory('menu'),
	  menuitem: createDOMFactory('menuitem'),
	  meta: createDOMFactory('meta'),
	  meter: createDOMFactory('meter'),
	  nav: createDOMFactory('nav'),
	  noscript: createDOMFactory('noscript'),
	  object: createDOMFactory('object'),
	  ol: createDOMFactory('ol'),
	  optgroup: createDOMFactory('optgroup'),
	  option: createDOMFactory('option'),
	  output: createDOMFactory('output'),
	  p: createDOMFactory('p'),
	  param: createDOMFactory('param'),
	  picture: createDOMFactory('picture'),
	  pre: createDOMFactory('pre'),
	  progress: createDOMFactory('progress'),
	  q: createDOMFactory('q'),
	  rp: createDOMFactory('rp'),
	  rt: createDOMFactory('rt'),
	  ruby: createDOMFactory('ruby'),
	  s: createDOMFactory('s'),
	  samp: createDOMFactory('samp'),
	  script: createDOMFactory('script'),
	  section: createDOMFactory('section'),
	  select: createDOMFactory('select'),
	  small: createDOMFactory('small'),
	  source: createDOMFactory('source'),
	  span: createDOMFactory('span'),
	  strong: createDOMFactory('strong'),
	  style: createDOMFactory('style'),
	  sub: createDOMFactory('sub'),
	  summary: createDOMFactory('summary'),
	  sup: createDOMFactory('sup'),
	  table: createDOMFactory('table'),
	  tbody: createDOMFactory('tbody'),
	  td: createDOMFactory('td'),
	  textarea: createDOMFactory('textarea'),
	  tfoot: createDOMFactory('tfoot'),
	  th: createDOMFactory('th'),
	  thead: createDOMFactory('thead'),
	  time: createDOMFactory('time'),
	  title: createDOMFactory('title'),
	  tr: createDOMFactory('tr'),
	  track: createDOMFactory('track'),
	  u: createDOMFactory('u'),
	  ul: createDOMFactory('ul'),
	  'var': createDOMFactory('var'),
	  video: createDOMFactory('video'),
	  wbr: createDOMFactory('wbr'),
	
	  // SVG
	  circle: createDOMFactory('circle'),
	  clipPath: createDOMFactory('clipPath'),
	  defs: createDOMFactory('defs'),
	  ellipse: createDOMFactory('ellipse'),
	  g: createDOMFactory('g'),
	  image: createDOMFactory('image'),
	  line: createDOMFactory('line'),
	  linearGradient: createDOMFactory('linearGradient'),
	  mask: createDOMFactory('mask'),
	  path: createDOMFactory('path'),
	  pattern: createDOMFactory('pattern'),
	  polygon: createDOMFactory('polygon'),
	  polyline: createDOMFactory('polyline'),
	  radialGradient: createDOMFactory('radialGradient'),
	  rect: createDOMFactory('rect'),
	  stop: createDOMFactory('stop'),
	  svg: createDOMFactory('svg'),
	  text: createDOMFactory('text'),
	  tspan: createDOMFactory('tspan')
	};
	
	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactComponentTreeHook = __webpack_require__(33);
	var ReactElement = __webpack_require__(16);
	
	var checkReactTypeSpec = __webpack_require__(34);
	
	var canDefineProperty = __webpack_require__(20);
	var getIteratorFn = __webpack_require__(23);
	var warning = __webpack_require__(18);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	function getCurrentComponentErrorInfo(parentType) {
	  var info = getDeclarationErrorAddendum();
	
	  if (!info) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      info = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	  return info;
	}
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it. Error statuses are cached so a warning
	 * will only be shown once.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});
	
	  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
	  if (memoizer[currentComponentErrorInfo]) {
	    return;
	  }
	  memoizer[currentComponentErrorInfo] = true;
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  var childOwner = '';
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }
	
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
	  }
	}
	
	var ReactElementValidator = {
	
	  createElement: function createElement(type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    if (!validType) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : void 0;
	    }
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function createFactory(type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function get() {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }
	
	    return validatedFactory;
	  },
	
	  cloneElement: function cloneElement(element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(14);
	
	var ReactCurrentOwner = __webpack_require__(17);
	
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	function isNative(fn) {
	  // Based on isNative() from Lodash
	  var funcToString = Function.prototype.toString;
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	  var reIsNative = RegExp('^' + funcToString
	  // Take an example native function source for comparison
	  .call(hasOwnProperty)
	  // Strip regex characters so we can use it for regex
	  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  // Remove hasOwnProperty from the template to make it generic
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	  try {
	    var source = funcToString.call(fn);
	    return reIsNative.test(source);
	  } catch (err) {
	    return false;
	  }
	}
	
	var canUseCollections =
	// Array.from
	typeof Array.from === 'function' &&
	// Map
	typeof Map === 'function' && isNative(Map) &&
	// Map.prototype.keys
	Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
	// Set
	typeof Set === 'function' && isNative(Set) &&
	// Set.prototype.keys
	Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);
	
	if (canUseCollections) {
	  var itemMap = new Map();
	  var rootIDSet = new Set();
	
	  var setItem = function setItem(id, item) {
	    itemMap.set(id, item);
	  };
	  var getItem = function getItem(id) {
	    return itemMap.get(id);
	  };
	  var removeItem = function removeItem(id) {
	    itemMap['delete'](id);
	  };
	  var getItemIDs = function getItemIDs() {
	    return Array.from(itemMap.keys());
	  };
	
	  var addRoot = function addRoot(id) {
	    rootIDSet.add(id);
	  };
	  var removeRoot = function removeRoot(id) {
	    rootIDSet['delete'](id);
	  };
	  var getRootIDs = function getRootIDs() {
	    return Array.from(rootIDSet.keys());
	  };
	} else {
	  var itemByKey = {};
	  var rootByKey = {};
	
	  // Use non-numeric keys to prevent V8 performance issues:
	  // https://github.com/facebook/react/pull/7232
	  var getKeyFromID = function getKeyFromID(id) {
	    return '.' + id;
	  };
	  var getIDFromKey = function getIDFromKey(key) {
	    return parseInt(key.substr(1), 10);
	  };
	
	  var setItem = function setItem(id, item) {
	    var key = getKeyFromID(id);
	    itemByKey[key] = item;
	  };
	  var getItem = function getItem(id) {
	    var key = getKeyFromID(id);
	    return itemByKey[key];
	  };
	  var removeItem = function removeItem(id) {
	    var key = getKeyFromID(id);
	    delete itemByKey[key];
	  };
	  var getItemIDs = function getItemIDs() {
	    return Object.keys(itemByKey).map(getIDFromKey);
	  };
	
	  var addRoot = function addRoot(id) {
	    var key = getKeyFromID(id);
	    rootByKey[key] = true;
	  };
	  var removeRoot = function removeRoot(id) {
	    var key = getKeyFromID(id);
	    delete rootByKey[key];
	  };
	  var getRootIDs = function getRootIDs() {
	    return Object.keys(rootByKey).map(getIDFromKey);
	  };
	}
	
	var unmountedIDs = [];
	
	function purgeDeep(id) {
	  var item = getItem(id);
	  if (item) {
	    var childIDs = item.childIDs;
	
	    removeItem(id);
	    childIDs.forEach(purgeDeep);
	  }
	}
	
	function describeComponentFrame(name, source, ownerName) {
	  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
	}
	
	function _getDisplayName(element) {
	  if (element == null) {
	    return '#empty';
	  } else if (typeof element === 'string' || typeof element === 'number') {
	    return '#text';
	  } else if (typeof element.type === 'string') {
	    return element.type;
	  } else {
	    return element.type.displayName || element.type.name || 'Unknown';
	  }
	}
	
	function describeID(id) {
	  var name = ReactComponentTreeHook.getDisplayName(id);
	  var element = ReactComponentTreeHook.getElement(id);
	  var ownerID = ReactComponentTreeHook.getOwnerID(id);
	  var ownerName;
	  if (ownerID) {
	    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
	  }
	  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
	  return describeComponentFrame(name, element && element._source, ownerName);
	}
	
	var ReactComponentTreeHook = {
	  onSetChildren: function onSetChildren(id, nextChildIDs) {
	    var item = getItem(id);
	    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
	    item.childIDs = nextChildIDs;
	
	    for (var i = 0; i < nextChildIDs.length; i++) {
	      var nextChildID = nextChildIDs[i];
	      var nextChild = getItem(nextChildID);
	      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
	      !(nextChild.childIDs != null || _typeof(nextChild.element) !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
	      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
	      if (nextChild.parentID == null) {
	        nextChild.parentID = id;
	        // TODO: This shouldn't be necessary but mounting a new root during in
	        // componentWillMount currently causes not-yet-mounted components to
	        // be purged from our tree data so their parent id is missing.
	      }
	      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
	    }
	  },
	  onBeforeMountComponent: function onBeforeMountComponent(id, element, parentID) {
	    var item = {
	      element: element,
	      parentID: parentID,
	      text: null,
	      childIDs: [],
	      isMounted: false,
	      updateCount: 0
	    };
	    setItem(id, item);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(id, element) {
	    var item = getItem(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.element = element;
	  },
	  onMountComponent: function onMountComponent(id) {
	    var item = getItem(id);
	    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
	    item.isMounted = true;
	    var isRoot = item.parentID === 0;
	    if (isRoot) {
	      addRoot(id);
	    }
	  },
	  onUpdateComponent: function onUpdateComponent(id) {
	    var item = getItem(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.updateCount++;
	  },
	  onUnmountComponent: function onUnmountComponent(id) {
	    var item = getItem(id);
	    if (item) {
	      // We need to check if it exists.
	      // `item` might not exist if it is inside an error boundary, and a sibling
	      // error boundary child threw while mounting. Then this instance never
	      // got a chance to mount, but it still gets an unmounting event during
	      // the error boundary cleanup.
	      item.isMounted = false;
	      var isRoot = item.parentID === 0;
	      if (isRoot) {
	        removeRoot(id);
	      }
	    }
	    unmountedIDs.push(id);
	  },
	  purgeUnmountedComponents: function purgeUnmountedComponents() {
	    if (ReactComponentTreeHook._preventPurging) {
	      // Should only be used for testing.
	      return;
	    }
	
	    for (var i = 0; i < unmountedIDs.length; i++) {
	      var id = unmountedIDs[i];
	      purgeDeep(id);
	    }
	    unmountedIDs.length = 0;
	  },
	  isMounted: function isMounted(id) {
	    var item = getItem(id);
	    return item ? item.isMounted : false;
	  },
	  getCurrentStackAddendum: function getCurrentStackAddendum(topElement) {
	    var info = '';
	    if (topElement) {
	      var name = _getDisplayName(topElement);
	      var owner = topElement._owner;
	      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
	    }
	
	    var currentOwner = ReactCurrentOwner.current;
	    var id = currentOwner && currentOwner._debugID;
	
	    info += ReactComponentTreeHook.getStackAddendumByID(id);
	    return info;
	  },
	  getStackAddendumByID: function getStackAddendumByID(id) {
	    var info = '';
	    while (id) {
	      info += describeID(id);
	      id = ReactComponentTreeHook.getParentID(id);
	    }
	    return info;
	  },
	  getChildIDs: function getChildIDs(id) {
	    var item = getItem(id);
	    return item ? item.childIDs : [];
	  },
	  getDisplayName: function getDisplayName(id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element) {
	      return null;
	    }
	    return _getDisplayName(element);
	  },
	  getElement: function getElement(id) {
	    var item = getItem(id);
	    return item ? item.element : null;
	  },
	  getOwnerID: function getOwnerID(id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element || !element._owner) {
	      return null;
	    }
	    return element._owner._debugID;
	  },
	  getParentID: function getParentID(id) {
	    var item = getItem(id);
	    return item ? item.parentID : null;
	  },
	  getSource: function getSource(id) {
	    var item = getItem(id);
	    var element = item ? item.element : null;
	    var source = element != null ? element._source : null;
	    return source;
	  },
	  getText: function getText(id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (typeof element === 'string') {
	      return element;
	    } else if (typeof element === 'number') {
	      return '' + element;
	    } else {
	      return null;
	    }
	  },
	  getUpdateCount: function getUpdateCount(id) {
	    var item = getItem(id);
	    return item ? item.updateCount : 0;
	  },
	
	  getRootIDs: getRootIDs,
	  getRegisteredIDs: getItemIDs
	};
	
	module.exports = ReactComponentTreeHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(14);
	
	var ReactPropTypeLocationNames = __webpack_require__(30);
	var ReactPropTypesSecret = __webpack_require__(35);
	
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(33);
	}
	
	var loggedTypeFailures = {};
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error)) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var componentStackInfo = '';
	
	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(33);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }
	
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}
	
	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 35 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactElement = __webpack_require__(16);
	var ReactPropTypeLocationNames = __webpack_require__(30);
	var ReactPropTypesSecret = __webpack_require__(35);
	
	var emptyFunction = __webpack_require__(19);
	var getIteratorFn = __webpack_require__(23);
	var warning = __webpack_require__(18);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	  symbol: createPrimitiveTypeChecker('symbol'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	/*eslint-disable no-self-compare*/
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	/*eslint-enable no-self-compare*/
	
	/**
	 * We use an Error-like object for backward compatibility as people may call
	 * PropTypes directly and inspect their output. However we don't use real
	 * Errors anymore. We don't inspect their stack anyway, and creating them
	 * is prohibitively expensive if they are created too often, such as what
	 * happens in oneOfType() for any type before the one that matched.
	 */
	function PropTypeError(message) {
	  this.message = message;
	  this.stack = '';
	}
	// Make `instanceof Error` still work for returned errors.
	PropTypeError.prototype = Error.prototype;
	
	function createChainableTypeChecker(validate) {
	  if (process.env.NODE_ENV !== 'production') {
	    var manualPropTypeCallCache = {};
	  }
	  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (process.env.NODE_ENV !== 'production') {
	      if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
	        var cacheKey = componentName + ':' + propName;
	        if (!manualPropTypeCallCache[cacheKey]) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in production with the next major version. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName) : void 0;
	          manualPropTypeCallCache[cacheKey] = true;
	        }
	      }
	    }
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        if (props[propName] === null) {
	          return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	        }
	        return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName, secret) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	    }
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!ReactElement.isValidElement(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (is(propValue, expectedValues[i])) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	    }
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	
	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }
	
	      return true;
	    default:
	      return false;
	  }
	}
	
	function isSymbol(propType, propValue) {
	  // Native Symbol.
	  if (propType === 'symbol') {
	    return true;
	  }
	
	  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	  if (propValue['@@toStringTag'] === 'Symbol') {
	    return true;
	  }
	
	  // Fallback for non-spec compliant Symbols which are polyfilled.
	  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	    return true;
	  }
	
	  return false;
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  if (isSymbol(propType, propValue)) {
	    return 'symbol';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return ANONYMOUS;
	  }
	  return propValue.constructor.name;
	}
	
	module.exports = ReactPropTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 37 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	module.exports = '15.4.0';

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	'use strict';
	
	var _prodInvariant = __webpack_require__(14);
	
	var ReactElement = __webpack_require__(16);
	
	var invariant = __webpack_require__(15);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
	 *
	 * The current implementation of this function assumes that a single child gets
	 * passed without a wrapper, but the purpose of this helper function is to
	 * abstract away the particular structure of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactElement} The first and only `ReactElement` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
	  return children;
	}
	
	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(40);

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactDefaultInjection = __webpack_require__(45);
	var ReactMount = __webpack_require__(173);
	var ReactReconciler = __webpack_require__(66);
	var ReactUpdates = __webpack_require__(63);
	var ReactVersion = __webpack_require__(178);
	
	var findDOMNode = __webpack_require__(179);
	var getHostComponentFromComposite = __webpack_require__(180);
	var renderSubtreeIntoContainer = __webpack_require__(181);
	var warning = __webpack_require__(18);
	
	ReactDefaultInjection.inject();
	
	var ReactDOM = {
	  findDOMNode: findDOMNode,
	  render: ReactMount.render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    ComponentTree: {
	      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
	      getNodeFromInstance: function getNodeFromInstance(inst) {
	        // inst is an internal instance (but could be a composite)
	        if (inst._renderedComponent) {
	          inst = getHostComponentFromComposite(inst);
	        }
	        if (inst) {
	          return ReactDOMComponentTree.getNodeFromInstance(inst);
	        } else {
	          return null;
	        }
	      }
	    },
	    Mount: ReactMount,
	    Reconciler: ReactReconciler
	  });
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(55);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        // Firefox does not have the issue with devtools loaded over file://
	        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
	        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    var testFunc = function testFn() {};
	    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
	        break;
	      }
	    }
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactInstrumentation = __webpack_require__(69);
	  var ReactDOMUnknownPropertyHook = __webpack_require__(182);
	  var ReactDOMNullInputValuePropHook = __webpack_require__(183);
	  var ReactDOMInvalidARIAHook = __webpack_require__(184);
	
	  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
	}
	
	module.exports = ReactDOM;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var DOMProperty = __webpack_require__(43);
	var ReactDOMComponentFlags = __webpack_require__(44);
	
	var invariant = __webpack_require__(15);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var Flags = ReactDOMComponentFlags;
	
	var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);
	
	/**
	 * Drill down (through composites and empty components) until we get a host or
	 * host text component.
	 *
	 * This is pretty polymorphic but unavoidable with the current structure we have
	 * for `_renderedChildren`.
	 */
	function getRenderedHostOrTextFromComponent(component) {
	  var rendered;
	  while (rendered = component._renderedComponent) {
	    component = rendered;
	  }
	  return component;
	}
	
	/**
	 * Populate `_hostNode` on the rendered host/text component with the given
	 * DOM node. The passed `inst` can be a composite.
	 */
	function precacheNode(inst, node) {
	  var hostInst = getRenderedHostOrTextFromComponent(inst);
	  hostInst._hostNode = node;
	  node[internalInstanceKey] = hostInst;
	}
	
	function uncacheNode(inst) {
	  var node = inst._hostNode;
	  if (node) {
	    delete node[internalInstanceKey];
	    inst._hostNode = null;
	  }
	}
	
	/**
	 * Populate `_hostNode` on each child of `inst`, assuming that the children
	 * match up with the DOM (element) children of `node`.
	 *
	 * We cache entire levels at once to avoid an n^2 problem where we access the
	 * children of a node sequentially and have to walk from the start to our target
	 * node every time.
	 *
	 * Since we update `_renderedChildren` and the actual DOM at (slightly)
	 * different times, we could race here and see a newer `_renderedChildren` than
	 * the DOM nodes we see. To avoid this, ReactMultiChild calls
	 * `prepareToManageChildren` before we change `_renderedChildren`, at which
	 * time the container's child nodes are always cached (until it unmounts).
	 */
	function precacheChildNodes(inst, node) {
	  if (inst._flags & Flags.hasCachedChildNodes) {
	    return;
	  }
	  var children = inst._renderedChildren;
	  var childNode = node.firstChild;
	  outer: for (var name in children) {
	    if (!children.hasOwnProperty(name)) {
	      continue;
	    }
	    var childInst = children[name];
	    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
	    if (childID === 0) {
	      // We're currently unmounting this child in ReactMultiChild; skip it.
	      continue;
	    }
	    // We assume the child nodes are in the same order as the child instances.
	    for (; childNode !== null; childNode = childNode.nextSibling) {
	      if (childNode.nodeType === 1 && childNode.getAttribute(ATTR_NAME) === String(childID) || childNode.nodeType === 8 && childNode.nodeValue === ' react-text: ' + childID + ' ' || childNode.nodeType === 8 && childNode.nodeValue === ' react-empty: ' + childID + ' ') {
	        precacheNode(childInst, childNode);
	        continue outer;
	      }
	    }
	    // We reached the end of the DOM children without finding an ID match.
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
	  }
	  inst._flags |= Flags.hasCachedChildNodes;
	}
	
	/**
	 * Given a DOM node, return the closest ReactDOMComponent or
	 * ReactDOMTextComponent instance ancestor.
	 */
	function getClosestInstanceFromNode(node) {
	  if (node[internalInstanceKey]) {
	    return node[internalInstanceKey];
	  }
	
	  // Walk up the tree until we find an ancestor whose instance we have cached.
	  var parents = [];
	  while (!node[internalInstanceKey]) {
	    parents.push(node);
	    if (node.parentNode) {
	      node = node.parentNode;
	    } else {
	      // Top of the tree. This node must not be part of a React tree (or is
	      // unmounted, potentially).
	      return null;
	    }
	  }
	
	  var closest;
	  var inst;
	  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
	    closest = inst;
	    if (parents.length) {
	      precacheChildNodes(inst, node);
	    }
	  }
	
	  return closest;
	}
	
	/**
	 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
	 * instance, or null if the node was not rendered by this React.
	 */
	function getInstanceFromNode(node) {
	  var inst = getClosestInstanceFromNode(node);
	  if (inst != null && inst._hostNode === node) {
	    return inst;
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
	 * DOM node.
	 */
	function getNodeFromInstance(inst) {
	  // Without this first invariant, passing a non-DOM-component triggers the next
	  // invariant for a missing parent, which is super confusing.
	  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  if (inst._hostNode) {
	    return inst._hostNode;
	  }
	
	  // Walk up the tree until we find an ancestor whose DOM node we have cached.
	  var parents = [];
	  while (!inst._hostNode) {
	    parents.push(inst);
	    !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
	    inst = inst._hostParent;
	  }
	
	  // Now parents contains each ancestor that does *not* have a cached native
	  // node, and `inst` is the deepest ancestor that does.
	  for (; parents.length; inst = parents.pop()) {
	    precacheChildNodes(inst, inst._hostNode);
	  }
	
	  return inst._hostNode;
	}
	
	var ReactDOMComponentTree = {
	  getClosestInstanceFromNode: getClosestInstanceFromNode,
	  getInstanceFromNode: getInstanceFromNode,
	  getNodeFromInstance: getNodeFromInstance,
	  precacheChildNodes: precacheChildNodes,
	  precacheNode: precacheNode,
	  uncacheNode: uncacheNode
	};
	
	module.exports = ReactDOMComponentTree;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 42 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	'use strict';
	
	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */
	
	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;
	
	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
	
	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }
	
	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
	
	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame
	
	  throw error;
	}
	
	module.exports = reactProdInvariant;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var invariant = __webpack_require__(15);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_PROPERTY: 0x1,
	  HAS_BOOLEAN_VALUE: 0x4,
	  HAS_NUMERIC_VALUE: 0x8,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function injectDOMPropertyConfig(domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;
	
	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	
	/* eslint-disable max-len */
	var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
	/* eslint-enable max-len */
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	  ROOT_ATTRIBUTE_NAME: 'data-reactroot',
	
	  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
	  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   *
	   * autofocus is predefined, because adding it to the property whitelist
	   * causes unintended side effects.
	   *
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? { autofocus: 'autoFocus' } : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function isCustomAttribute(attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 44 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMComponentFlags = {
	  hasCachedChildNodes: 1 << 0
	};
	
	module.exports = ReactDOMComponentFlags;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ARIADOMPropertyConfig = __webpack_require__(46);
	var BeforeInputEventPlugin = __webpack_require__(47);
	var ChangeEventPlugin = __webpack_require__(62);
	var DefaultEventPluginOrder = __webpack_require__(79);
	var EnterLeaveEventPlugin = __webpack_require__(80);
	var HTMLDOMPropertyConfig = __webpack_require__(85);
	var ReactComponentBrowserEnvironment = __webpack_require__(86);
	var ReactDOMComponent = __webpack_require__(99);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactDOMEmptyComponent = __webpack_require__(144);
	var ReactDOMTreeTraversal = __webpack_require__(145);
	var ReactDOMTextComponent = __webpack_require__(146);
	var ReactDefaultBatchingStrategy = __webpack_require__(147);
	var ReactEventListener = __webpack_require__(148);
	var ReactInjection = __webpack_require__(151);
	var ReactReconcileTransaction = __webpack_require__(152);
	var SVGDOMPropertyConfig = __webpack_require__(160);
	var SelectEventPlugin = __webpack_require__(161);
	var SimpleEventPlugin = __webpack_require__(162);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
	  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
	    return new ReactDOMEmptyComponent(instantiate);
	  });
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	}
	
	module.exports = {
	  inject: inject
	};

/***/ },
/* 46 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ARIADOMPropertyConfig = {
	  Properties: {
	    // Global States and Properties
	    'aria-current': 0, // state
	    'aria-details': 0,
	    'aria-disabled': 0, // state
	    'aria-hidden': 0, // state
	    'aria-invalid': 0, // state
	    'aria-keyshortcuts': 0,
	    'aria-label': 0,
	    'aria-roledescription': 0,
	    // Widget Attributes
	    'aria-autocomplete': 0,
	    'aria-checked': 0,
	    'aria-expanded': 0,
	    'aria-haspopup': 0,
	    'aria-level': 0,
	    'aria-modal': 0,
	    'aria-multiline': 0,
	    'aria-multiselectable': 0,
	    'aria-orientation': 0,
	    'aria-placeholder': 0,
	    'aria-pressed': 0,
	    'aria-readonly': 0,
	    'aria-required': 0,
	    'aria-selected': 0,
	    'aria-sort': 0,
	    'aria-valuemax': 0,
	    'aria-valuemin': 0,
	    'aria-valuenow': 0,
	    'aria-valuetext': 0,
	    // Live Region Attributes
	    'aria-atomic': 0,
	    'aria-busy': 0,
	    'aria-live': 0,
	    'aria-relevant': 0,
	    // Drag-and-Drop Attributes
	    'aria-dropeffect': 0,
	    'aria-grabbed': 0,
	    // Relationship Attributes
	    'aria-activedescendant': 0,
	    'aria-colcount': 0,
	    'aria-colindex': 0,
	    'aria-colspan': 0,
	    'aria-controls': 0,
	    'aria-describedby': 0,
	    'aria-errormessage': 0,
	    'aria-flowto': 0,
	    'aria-labelledby': 0,
	    'aria-owns': 0,
	    'aria-posinset': 0,
	    'aria-rowcount': 0,
	    'aria-rowindex': 0,
	    'aria-rowspan': 0,
	    'aria-setsize': 0
	  },
	  DOMAttributeNames: {},
	  DOMPropertyNames: {}
	};
	
	module.exports = ARIADOMPropertyConfig;

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var EventPropagators = __webpack_require__(48);
	var ExecutionEnvironment = __webpack_require__(55);
	var FallbackCompositionState = __webpack_require__(56);
	var SyntheticCompositionEvent = __webpack_require__(59);
	var SyntheticInputEvent = __webpack_require__(61);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return (typeof opera === 'undefined' ? 'undefined' : _typeof(opera)) === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: 'onBeforeInput',
	      captured: 'onBeforeInputCapture'
	    },
	    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionEnd',
	      captured: 'onCompositionEndCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionStart',
	      captured: 'onCompositionStartCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionUpdate',
	      captured: 'onCompositionUpdateCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case 'topCompositionStart':
	      return eventTypes.compositionStart;
	    case 'topCompositionEnd':
	      return eventTypes.compositionEnd;
	    case 'topCompositionUpdate':
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case 'topKeyUp':
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case 'topKeyDown':
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case 'topKeyPress':
	    case 'topMouseDown':
	    case 'topBlur':
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if ((typeof detail === 'undefined' ? 'undefined' : _typeof(detail)) === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case 'topCompositionEnd':
	      return getDataFromCustomEvent(nativeEvent);
	    case 'topKeyPress':
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case 'topTextInput':
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  // If composition event is available, we extract a string only at
	  // compositionevent, otherwise extract it at fallback events.
	  if (currentComposition) {
	    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case 'topPaste':
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case 'topKeyPress':
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case 'topCompositionEnd':
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(49);
	var EventPluginUtils = __webpack_require__(51);
	
	var accumulateInto = __webpack_require__(53);
	var forEachAccumulated = __webpack_require__(54);
	var warning = __webpack_require__(18);
	
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(inst, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(inst, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(inst, phase, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
	  }
	  var listener = listenerAtPhase(inst, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    var targetInst = event._targetInst;
	    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
	    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(inst, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(inst, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event._targetInst, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, from, to) {
	  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(42);
	
	var EventPluginRegistry = __webpack_require__(50);
	var EventPluginUtils = __webpack_require__(51);
	var ReactErrorUtils = __webpack_require__(52);
	
	var accumulateInto = __webpack_require__(53);
	var forEachAccumulated = __webpack_require__(54);
	var invariant = __webpack_require__(15);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function executeDispatchesAndRelease(event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	var getDictionaryKey = function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	};
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {function} listener The callback to store.
	   */
	  putListener: function putListener(inst, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) : _prodInvariant('94', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) : void 0;
	
	    var key = getDictionaryKey(inst);
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[key] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(inst, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function getListener(inst, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    var key = getDictionaryKey(inst);
	    return bankForRegistrationName && bankForRegistrationName[key];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function deleteListener(inst, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(inst, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      var key = getDictionaryKey(inst);
	      delete bankForRegistrationName[key];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   */
	  deleteAllListeners: function deleteAllListeners(inst) {
	    var key = getDictionaryKey(inst);
	    for (var registrationName in listenerBank) {
	      if (!listenerBank.hasOwnProperty(registrationName)) {
	        continue;
	      }
	
	      if (!listenerBank[registrationName][key]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(inst, registrationName);
	      }
	
	      delete listenerBank[registrationName][key];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function enqueueEvents(events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function processEventQueue(simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function __purge() {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function __getListenerBank() {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var invariant = __webpack_require__(15);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var eventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!eventPluginOrder) {
	    // Wait until an `eventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var pluginModule = namesToPlugins[pluginName];
	    var pluginIndex = eventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !pluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
	    EventPluginRegistry.plugins[pluginIndex] = pluginModule;
	    var publishedEvents = pluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, pluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
	  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;
	
	  if (process.env.NODE_ENV !== 'production') {
	    var lowerCasedName = registrationName.toLowerCase();
	    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;
	
	    if (registrationName === 'onDoubleClick') {
	      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
	    }
	  }
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Mapping from lowercase registration names to the properly cased version,
	   * used to warn in the case of missing event handlers. Available
	   * only in __DEV__.
	   * @type {Object}
	   */
	  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
	  // Trust the developer to only use possibleRegistrationNames in __DEV__
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function injectEventPluginOrder(injectedEventPluginOrder) {
	    !!eventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
	    // Clone the ordering so it cannot be dynamically mutated.
	    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function injectEventPluginsByName(injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var pluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
	        namesToPlugins[pluginName] = pluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function getPluginModuleForEvent(event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    if (dispatchConfig.phasedRegistrationNames !== undefined) {
	      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
	      // that it is not undefined.
	      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	
	      for (var phase in phasedRegistrationNames) {
	        if (!phasedRegistrationNames.hasOwnProperty(phase)) {
	          continue;
	        }
	        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
	        if (pluginModule) {
	          return pluginModule;
	        }
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function _resetEventPlugins() {
	    eventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
	      for (var lowerCasedName in possibleRegistrationNames) {
	        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
	          delete possibleRegistrationNames[lowerCasedName];
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var ReactErrorUtils = __webpack_require__(52);
	
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `ComponentTree`: [required] Module that can convert between React instances
	 *   and actual node references.
	 */
	var ComponentTree;
	var TreeTraversal;
	var injection = {
	  injectComponentTree: function injectComponentTree(Injected) {
	    ComponentTree = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
	    }
	  },
	  injectTreeTraversal: function injectTreeTraversal(Injected) {
	    TreeTraversal = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
	    }
	  }
	};
	
	function isEndish(topLevelType) {
	  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
	}
	function isStartish(topLevelType) {
	  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
	}
	
	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function validateEventDispatches(event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchInstances = event._dispatchInstances;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    var instancesIsArr = Array.isArray(dispatchInstances);
	    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {*} inst Internal component instance
	 */
	function executeDispatch(event, simulated, listener, inst) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
	  }
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchInstances[i])) {
	        return dispatchInstances[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchInstances)) {
	      return dispatchInstances;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchInstances = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchInstance = event._dispatchInstances;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
	  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
	  var res = dispatchListener ? dispatchListener(event) : null;
	  event.currentTarget = null;
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getInstanceFromNode: function getInstanceFromNode(node) {
	    return ComponentTree.getInstanceFromNode(node);
	  },
	  getNodeFromInstance: function getNodeFromInstance(node) {
	    return ComponentTree.getNodeFromInstance(node);
	  },
	  isAncestor: function isAncestor(a, b) {
	    return TreeTraversal.isAncestor(a, b);
	  },
	  getLowestCommonAncestor: function getLowestCommonAncestor(a, b) {
	    return TreeTraversal.getLowestCommonAncestor(a, b);
	  },
	  getParentInstance: function getParentInstance(inst) {
	    return TreeTraversal.getParentInstance(inst);
	  },
	  traverseTwoPhase: function traverseTwoPhase(target, fn, arg) {
	    return TreeTraversal.traverseTwoPhase(target, fn, arg);
	  },
	  traverseEnterLeave: function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a) {
	  try {
	    func(a);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function rethrowCaughtError() {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
	      var boundFunc = func.bind(null, a);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      // $FlowFixMe https://github.com/facebook/flow/issues/2336
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var invariant = __webpack_require__(15);
	
	/**
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;
	
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  if (Array.isArray(current)) {
	    if (Array.isArray(next)) {
	      current.push.apply(current, next);
	      return current;
	    }
	    current.push(next);
	    return current;
	  }
	
	  if (Array.isArray(next)) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 54 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	
	function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	}
	
	module.exports = forEachAccumulated;

/***/ },
/* 55 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var PooledClass = __webpack_require__(57);
	
	var getTextContentAccessor = __webpack_require__(58);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	_assign(FallbackCompositionState.prototype, {
	  destructor: function destructor() {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function getText() {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function getData() {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var invariant = __webpack_require__(15);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function fiveArgumentPooler(a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function standardReleaser(instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
	  // Casting as any so that flow ignores the actual implementation and trusts
	  // it to match the type we declared
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(55);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(60);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var PooledClass = __webpack_require__(57);
	
	var emptyFunction = __webpack_require__(19);
	var warning = __webpack_require__(18);
	
	var didWarnForAddedNewProperty = false;
	var isProxySupported = typeof Proxy === 'function';
	
	var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function timeStamp(event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {*} targetInst Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @param {DOMEventTarget} nativeEventTarget Target node.
	 */
	function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
	  if (process.env.NODE_ENV !== 'production') {
	    // these have a getter/setter for warnings
	    delete this.nativeEvent;
	    delete this.preventDefault;
	    delete this.stopPropagation;
	  }
	
	  this.dispatchConfig = dispatchConfig;
	  this._targetInst = targetInst;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      delete this[propName]; // this has a getter/setter for warnings
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	  return this;
	}
	
	_assign(SyntheticEvent.prototype, {
	
	  preventDefault: function preventDefault() {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else if (typeof event.returnValue !== 'unknown') {
	      // eslint-disable-line valid-typeof
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function stopPropagation() {
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else if (typeof event.cancelBubble !== 'unknown') {
	      // eslint-disable-line valid-typeof
	      // The ChangeEventPlugin registers a "propertychange" event for
	      // IE. This event does not support bubbling or cancelling, and
	      // any references to cancelBubble throw "Member not found".  A
	      // typeof check of "unknown" circumvents this issue (and is also
	      // IE specific).
	      event.cancelBubble = true;
	    }
	
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function persist() {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function destructor() {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      if (process.env.NODE_ENV !== 'production') {
	        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
	      } else {
	        this[propName] = null;
	      }
	    }
	    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
	      this[shouldBeReleasedProperties[i]] = null;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
	      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
	      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
	    }
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	if (process.env.NODE_ENV !== 'production') {
	  if (isProxySupported) {
	    /*eslint-disable no-func-assign */
	    SyntheticEvent = new Proxy(SyntheticEvent, {
	      construct: function construct(target, args) {
	        return this.apply(target, Object.create(target.prototype), args);
	      },
	      apply: function apply(constructor, that, args) {
	        return new Proxy(constructor.apply(that, args), {
	          set: function set(target, prop, value) {
	            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
	              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
	              didWarnForAddedNewProperty = true;
	            }
	            target[prop] = value;
	            return true;
	          }
	        });
	      }
	    });
	    /*eslint-enable no-func-assign */
	  }
	}
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var E = function E() {};
	  E.prototype = Super.prototype;
	  var prototype = new E();
	
	  _assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = _assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;
	
	/**
	  * Helper to nullify syntheticEvent instance properties when destructing
	  *
	  * @param {object} SyntheticEvent
	  * @param {String} propName
	  * @return {object} defineProperty object
	  */
	function getPooledWarningPropertyDefinition(propName, getVal) {
	  var isFunction = typeof getVal === 'function';
	  return {
	    configurable: true,
	    set: set,
	    get: get
	  };
	
	  function set(val) {
	    var action = isFunction ? 'setting the method' : 'setting the property';
	    warn(action, 'This is effectively a no-op');
	    return val;
	  }
	
	  function get() {
	    var action = isFunction ? 'accessing the method' : 'accessing the property';
	    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
	    warn(action, result);
	    return getVal;
	  }
	
	  function warn(action, result) {
	    var warningCondition = false;
	    process.env.NODE_ENV !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(60);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(49);
	var EventPropagators = __webpack_require__(48);
	var ExecutionEnvironment = __webpack_require__(55);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactUpdates = __webpack_require__(63);
	var SyntheticEvent = __webpack_require__(60);
	
	var getEventTarget = __webpack_require__(76);
	var isEventSupported = __webpack_require__(77);
	var isTextInputElement = __webpack_require__(78);
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: 'onChange',
	      captured: 'onChangeCapture'
	    },
	    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementInst = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementInst = null;
	}
	
	function getTargetInstForChangeEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topChange') {
	    return targetInst;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
	  if (topLevelType === 'topFocus') {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(target, targetInst);
	  } else if (topLevelType === 'topBlur') {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events.
	  // IE10+ fire input events to often, such when a placeholder
	  // changes or when an input with a placeholder is focused.
	  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 11);
	}
	
	/**
	 * (For IE <=11) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function get() {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function set(val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For IE <=11) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
	
	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  if (activeElement.attachEvent) {
	    activeElement.attachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.addEventListener('propertychange', handlePropertyChange, false);
	  }
	}
	
	/**
	 * (For IE <=11) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	
	  if (activeElement.detachEvent) {
	    activeElement.detachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
	  }
	
	  activeElement = null;
	  activeElementInst = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For IE <=11) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetInstForInputEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topInput') {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return targetInst;
	  }
	}
	
	function handleEventsForInputEventIE(topLevelType, target, targetInst) {
	  if (topLevelType === 'topFocus') {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9-11, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(target, targetInst);
	  } else if (topLevelType === 'topBlur') {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetInstForInputEventIE(topLevelType, targetInst) {
	  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementInst;
	    }
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetInstForClickEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topClick') {
	    return targetInst;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    var getTargetInstFunc, handleEventFunc;
	    if (shouldUseChangeEvent(targetNode)) {
	      if (doesChangeEventBubble) {
	        getTargetInstFunc = getTargetInstForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(targetNode)) {
	      if (isInputEventSupported) {
	        getTargetInstFunc = getTargetInstForInputEvent;
	      } else {
	        getTargetInstFunc = getTargetInstForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(targetNode)) {
	      getTargetInstFunc = getTargetInstForClickEvent;
	    }
	
	    if (getTargetInstFunc) {
	      var inst = getTargetInstFunc(topLevelType, targetInst);
	      if (inst) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, targetNode, targetInst);
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);
	
	var CallbackQueue = __webpack_require__(64);
	var PooledClass = __webpack_require__(57);
	var ReactFeatureFlags = __webpack_require__(65);
	var ReactReconciler = __webpack_require__(66);
	var Transaction = __webpack_require__(75);
	
	var invariant = __webpack_require__(15);
	
	var dirtyComponents = [];
	var updateBatchNumber = 0;
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
	}
	
	var NESTED_UPDATES = {
	  initialize: function initialize() {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function close() {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function initialize() {
	    this.callbackQueue.reset();
	  },
	  close: function close() {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */true);
	}
	
	_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function destructor() {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function perform(method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  // Any updates enqueued while reconciling must be performed after this entire
	  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
	  // C, B could update twice in a single batch if C's render enqueues an update
	  // to B (since B would have already updated, we should skip it, and the only
	  // way we can know to do so is by checking the batch counter).
	  updateBatchNumber++;
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    var markerName;
	    if (ReactFeatureFlags.logTopLevelRenders) {
	      var namedComponent = component;
	      // Duck type TopLevelWrapper. This is probably always true.
	      if (component._currentElement.type.isReactTopLevelWrapper) {
	        namedComponent = component._renderedComponent;
	      }
	      markerName = 'React update: ' + namedComponent.getName();
	      console.time(markerName);
	    }
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);
	
	    if (markerName) {
	      console.timeEnd(markerName);
	    }
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function flushBatchedUpdates() {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	  if (component._updateBatchNumber == null) {
	    component._updateBatchNumber = updateBatchNumber + 1;
	  }
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function injectReconcileTransaction(ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function injectBatchingStrategy(_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	var PooledClass = __webpack_require__(57);
	
	var invariant = __webpack_require__(15);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	
	var CallbackQueue = function () {
	  function CallbackQueue(arg) {
	    _classCallCheck(this, CallbackQueue);
	
	    this._callbacks = null;
	    this._contexts = null;
	    this._arg = arg;
	  }
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	
	  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._callbacks.push(callback);
	    this._contexts = this._contexts || [];
	    this._contexts.push(context);
	  };
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	
	  CallbackQueue.prototype.notifyAll = function notifyAll() {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    var arg = this._arg;
	    if (callbacks && contexts) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i], arg);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  };
	
	  CallbackQueue.prototype.checkpoint = function checkpoint() {
	    return this._callbacks ? this._callbacks.length : 0;
	  };
	
	  CallbackQueue.prototype.rollback = function rollback(len) {
	    if (this._callbacks && this._contexts) {
	      this._callbacks.length = len;
	      this._contexts.length = len;
	    }
	  };
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	
	  CallbackQueue.prototype.reset = function reset() {
	    this._callbacks = null;
	    this._contexts = null;
	  };
	
	  /**
	   * `PooledClass` looks for this.
	   */
	
	  CallbackQueue.prototype.destructor = function destructor() {
	    this.reset();
	  };
	
	  return CallbackQueue;
	}();
	
	module.exports = PooledClass.addPoolingTo(CallbackQueue);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 65 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactFeatureFlags = {
	  // When true, call console.time() before and .timeEnd() after each top-level
	  // render (both initial renders and updates). Useful when looking at prod-mode
	  // timeline profiles in Chrome, for example.
	  logTopLevelRenders: false
	};
	
	module.exports = ReactFeatureFlags;

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(67);
	var ReactInstrumentation = __webpack_require__(69);
	
	var warning = __webpack_require__(18);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} the containing host component instance
	   * @param {?object} info about the host container
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function mountComponent(internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
	  ) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
	      }
	    }
	    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
	      }
	    }
	    return markup;
	  },
	
	  /**
	   * Returns a value that can be passed to
	   * ReactComponentEnvironment.replaceNodeWithMarkup.
	   */
	  getHostNode: function getHostNode(internalInstance) {
	    return internalInstance.getHostNode();
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function unmountComponent(internalInstance, safely) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
	      }
	    }
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent(safely);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function receiveComponent(internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
	      }
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function performUpdateIfNecessary(internalInstance, transaction, updateBatchNumber) {
	    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
	      // The component's enqueued batch number should always be the current
	      // batch or the following one.
	      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
	      return;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
	      }
	    }
	    internalInstance.performUpdateIfNecessary(transaction);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactOwner = __webpack_require__(68);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || (typeof element === 'undefined' ? 'undefined' : _typeof(element)) !== 'object') {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevRef = null;
	  var prevOwner = null;
	  if (prevElement !== null && (typeof prevElement === 'undefined' ? 'undefined' : _typeof(prevElement)) === 'object') {
	    prevRef = prevElement.ref;
	    prevOwner = prevElement._owner;
	  }
	
	  var nextRef = null;
	  var nextOwner = null;
	  if (nextElement !== null && (typeof nextElement === 'undefined' ? 'undefined' : _typeof(nextElement)) === 'object') {
	    nextRef = nextElement.ref;
	    nextOwner = nextElement._owner;
	  }
	
	  return prevRef !== nextRef ||
	  // If owner changes but we have an unchanged function ref, don't update refs
	  typeof nextRef === 'string' && nextOwner !== prevOwner;
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || (typeof element === 'undefined' ? 'undefined' : _typeof(element)) !== 'object') {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var invariant = __webpack_require__(15);
	
	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid owner.
	 * @final
	 */
	function isValidOwner(object) {
	  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	}
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function addComponentAsRefTo(component, ref, owner) {
	    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function removeComponentAsRefFrom(component, ref, owner) {
	    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
	    var ownerPublicInstance = owner.getPublicInstance();
	    // Check that `component`'s owner is still alive and that `component` is still the current ref
	    // because we do not want to detach the ref if another component stole it.
	    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	// Trust the developer to only use ReactInstrumentation with a __DEV__ check
	
	var debugTool = null;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactDebugTool = __webpack_require__(70);
	  debugTool = ReactDebugTool;
	}
	
	module.exports = { debugTool: debugTool };
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactInvalidSetStateWarningHook = __webpack_require__(71);
	var ReactHostOperationHistoryHook = __webpack_require__(72);
	var ReactComponentTreeHook = __webpack_require__(33);
	var ExecutionEnvironment = __webpack_require__(55);
	
	var performanceNow = __webpack_require__(73);
	var warning = __webpack_require__(18);
	
	var hooks = [];
	var didHookThrowForEvent = {};
	
	function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
	  try {
	    fn.call(context, arg1, arg2, arg3, arg4, arg5);
	  } catch (e) {
	    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
	    didHookThrowForEvent[event] = true;
	  }
	}
	
	function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
	  for (var i = 0; i < hooks.length; i++) {
	    var hook = hooks[i];
	    var fn = hook[event];
	    if (fn) {
	      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
	    }
	  }
	}
	
	var _isProfiling = false;
	var flushHistory = [];
	var lifeCycleTimerStack = [];
	var currentFlushNesting = 0;
	var currentFlushMeasurements = [];
	var currentFlushStartTime = 0;
	var currentTimerDebugID = null;
	var currentTimerStartTime = 0;
	var currentTimerNestedFlushDuration = 0;
	var currentTimerType = null;
	
	var lifeCycleTimerHasWarned = false;
	
	function clearHistory() {
	  ReactComponentTreeHook.purgeUnmountedComponents();
	  ReactHostOperationHistoryHook.clearHistory();
	}
	
	function getTreeSnapshot(registeredIDs) {
	  return registeredIDs.reduce(function (tree, id) {
	    var ownerID = ReactComponentTreeHook.getOwnerID(id);
	    var parentID = ReactComponentTreeHook.getParentID(id);
	    tree[id] = {
	      displayName: ReactComponentTreeHook.getDisplayName(id),
	      text: ReactComponentTreeHook.getText(id),
	      updateCount: ReactComponentTreeHook.getUpdateCount(id),
	      childIDs: ReactComponentTreeHook.getChildIDs(id),
	      // Text nodes don't have owners but this is close enough.
	      ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
	      parentID: parentID
	    };
	    return tree;
	  }, {});
	}
	
	function resetMeasurements() {
	  var previousStartTime = currentFlushStartTime;
	  var previousMeasurements = currentFlushMeasurements;
	  var previousOperations = ReactHostOperationHistoryHook.getHistory();
	
	  if (currentFlushNesting === 0) {
	    currentFlushStartTime = 0;
	    currentFlushMeasurements = [];
	    clearHistory();
	    return;
	  }
	
	  if (previousMeasurements.length || previousOperations.length) {
	    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
	    flushHistory.push({
	      duration: performanceNow() - previousStartTime,
	      measurements: previousMeasurements || [],
	      operations: previousOperations || [],
	      treeSnapshot: getTreeSnapshot(registeredIDs)
	    });
	  }
	
	  clearHistory();
	  currentFlushStartTime = performanceNow();
	  currentFlushMeasurements = [];
	}
	
	function checkDebugID(debugID) {
	  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	  if (allowRoot && debugID === 0) {
	    return;
	  }
	  if (!debugID) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
	  }
	}
	
	function beginLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  currentTimerStartTime = performanceNow();
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	function endLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  if (_isProfiling) {
	    currentFlushMeasurements.push({
	      timerType: timerType,
	      instanceID: debugID,
	      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
	    });
	  }
	  currentTimerStartTime = 0;
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function pauseCurrentLifeCycleTimer() {
	  var currentTimer = {
	    startTime: currentTimerStartTime,
	    nestedFlushStartTime: performanceNow(),
	    debugID: currentTimerDebugID,
	    timerType: currentTimerType
	  };
	  lifeCycleTimerStack.push(currentTimer);
	  currentTimerStartTime = 0;
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function resumeCurrentLifeCycleTimer() {
	  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
	      startTime = _lifeCycleTimerStack$.startTime,
	      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
	      debugID = _lifeCycleTimerStack$.debugID,
	      timerType = _lifeCycleTimerStack$.timerType;
	
	  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
	  currentTimerStartTime = startTime;
	  currentTimerNestedFlushDuration += nestedFlushDuration;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	var lastMarkTimeStamp = 0;
	var canUsePerformanceMeasure =
	// $FlowFixMe https://github.com/facebook/flow/issues/2345
	typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';
	
	function shouldMark(debugID) {
	  if (!_isProfiling || !canUsePerformanceMeasure) {
	    return false;
	  }
	  var element = ReactComponentTreeHook.getElement(debugID);
	  if (element == null || (typeof element === 'undefined' ? 'undefined' : _typeof(element)) !== 'object') {
	    return false;
	  }
	  var isHostElement = typeof element.type === 'string';
	  if (isHostElement) {
	    return false;
	  }
	  return true;
	}
	
	function markBegin(debugID, markType) {
	  if (!shouldMark(debugID)) {
	    return;
	  }
	
	  var markName = debugID + '::' + markType;
	  lastMarkTimeStamp = performanceNow();
	  performance.mark(markName);
	}
	
	function markEnd(debugID, markType) {
	  if (!shouldMark(debugID)) {
	    return;
	  }
	
	  var markName = debugID + '::' + markType;
	  var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';
	
	  // Chrome has an issue of dropping markers recorded too fast:
	  // https://bugs.chromium.org/p/chromium/issues/detail?id=640652
	  // To work around this, we will not report very small measurements.
	  // I determined the magic number by tweaking it back and forth.
	  // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.
	  // When the bug is fixed, we can `measure()` unconditionally if we want to.
	  var timeStamp = performanceNow();
	  if (timeStamp - lastMarkTimeStamp > 0.1) {
	    var measurementName = displayName + ' [' + markType + ']';
	    performance.measure(measurementName, markName);
	  }
	
	  performance.clearMarks(markName);
	  performance.clearMeasures(measurementName);
	}
	
	var ReactDebugTool = {
	  addHook: function addHook(hook) {
	    hooks.push(hook);
	  },
	  removeHook: function removeHook(hook) {
	    for (var i = 0; i < hooks.length; i++) {
	      if (hooks[i] === hook) {
	        hooks.splice(i, 1);
	        i--;
	      }
	    }
	  },
	  isProfiling: function isProfiling() {
	    return _isProfiling;
	  },
	  beginProfiling: function beginProfiling() {
	    if (_isProfiling) {
	      return;
	    }
	
	    _isProfiling = true;
	    flushHistory.length = 0;
	    resetMeasurements();
	    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
	  },
	  endProfiling: function endProfiling() {
	    if (!_isProfiling) {
	      return;
	    }
	
	    _isProfiling = false;
	    resetMeasurements();
	    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
	  },
	  getFlushHistory: function getFlushHistory() {
	    return flushHistory;
	  },
	  onBeginFlush: function onBeginFlush() {
	    currentFlushNesting++;
	    resetMeasurements();
	    pauseCurrentLifeCycleTimer();
	    emitEvent('onBeginFlush');
	  },
	  onEndFlush: function onEndFlush() {
	    resetMeasurements();
	    currentFlushNesting--;
	    resumeCurrentLifeCycleTimer();
	    emitEvent('onEndFlush');
	  },
	  onBeginLifeCycleTimer: function onBeginLifeCycleTimer(debugID, timerType) {
	    checkDebugID(debugID);
	    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
	    markBegin(debugID, timerType);
	    beginLifeCycleTimer(debugID, timerType);
	  },
	  onEndLifeCycleTimer: function onEndLifeCycleTimer(debugID, timerType) {
	    checkDebugID(debugID);
	    endLifeCycleTimer(debugID, timerType);
	    markEnd(debugID, timerType);
	    emitEvent('onEndLifeCycleTimer', debugID, timerType);
	  },
	  onBeginProcessingChildContext: function onBeginProcessingChildContext() {
	    emitEvent('onBeginProcessingChildContext');
	  },
	  onEndProcessingChildContext: function onEndProcessingChildContext() {
	    emitEvent('onEndProcessingChildContext');
	  },
	  onHostOperation: function onHostOperation(operation) {
	    checkDebugID(operation.instanceID);
	    emitEvent('onHostOperation', operation);
	  },
	  onSetState: function onSetState() {
	    emitEvent('onSetState');
	  },
	  onSetChildren: function onSetChildren(debugID, childDebugIDs) {
	    checkDebugID(debugID);
	    childDebugIDs.forEach(checkDebugID);
	    emitEvent('onSetChildren', debugID, childDebugIDs);
	  },
	  onBeforeMountComponent: function onBeforeMountComponent(debugID, element, parentDebugID) {
	    checkDebugID(debugID);
	    checkDebugID(parentDebugID, true);
	    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
	    markBegin(debugID, 'mount');
	  },
	  onMountComponent: function onMountComponent(debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'mount');
	    emitEvent('onMountComponent', debugID);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUpdateComponent', debugID, element);
	    markBegin(debugID, 'update');
	  },
	  onUpdateComponent: function onUpdateComponent(debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'update');
	    emitEvent('onUpdateComponent', debugID);
	  },
	  onBeforeUnmountComponent: function onBeforeUnmountComponent(debugID) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUnmountComponent', debugID);
	    markBegin(debugID, 'unmount');
	  },
	  onUnmountComponent: function onUnmountComponent(debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'unmount');
	    emitEvent('onUnmountComponent', debugID);
	  },
	  onTestEvent: function onTestEvent() {
	    emitEvent('onTestEvent');
	  }
	};
	
	// TODO remove these when RN/www gets updated
	ReactDebugTool.addDevtool = ReactDebugTool.addHook;
	ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;
	
	ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
	ReactDebugTool.addHook(ReactComponentTreeHook);
	var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	if (/[?&]react_perf\b/.test(url)) {
	  ReactDebugTool.beginProfiling();
	}
	
	module.exports = ReactDebugTool;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var warning = __webpack_require__(18);
	
	if (process.env.NODE_ENV !== 'production') {
	  var processingChildContext = false;
	
	  var warnInvalidSetState = function warnInvalidSetState() {
	    process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
	  };
	}
	
	var ReactInvalidSetStateWarningHook = {
	  onBeginProcessingChildContext: function onBeginProcessingChildContext() {
	    processingChildContext = true;
	  },
	  onEndProcessingChildContext: function onEndProcessingChildContext() {
	    processingChildContext = false;
	  },
	  onSetState: function onSetState() {
	    warnInvalidSetState();
	  }
	};
	
	module.exports = ReactInvalidSetStateWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 72 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var history = [];
	
	var ReactHostOperationHistoryHook = {
	  onHostOperation: function onHostOperation(operation) {
	    history.push(operation);
	  },
	  clearHistory: function clearHistory() {
	    if (ReactHostOperationHistoryHook._preventClearing) {
	      // Should only be used for tests.
	      return;
	    }
	
	    history = [];
	  },
	  getHistory: function getHistory() {
	    return history;
	  }
	};
	
	module.exports = ReactHostOperationHistoryHook;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var performance = __webpack_require__(74);
	
	var performanceNow;
	
	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function performanceNow() {
	    return performance.now();
	  };
	} else {
	  performanceNow = function performanceNow() {
	    return Date.now();
	  };
	}
	
	module.exports = performanceNow;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(55);
	
	var performance;
	
	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}
	
	module.exports = performance || {};

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var invariant = __webpack_require__(15);
	
	var OBSERVED_ERROR = {};
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var TransactionImpl = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function reinitializeTransaction() {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function isInTransaction() {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function perform(method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function initializeAll(startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function closeAll(startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	module.exports = TransactionImpl;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 76 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	
	  // Normalize SVG <use> element events #4963
	  if (target.correspondingUseElement) {
	    target = target.correspondingUseElement;
	  }
	
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(55);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ },
/* 78 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	
	  if (nodeName === 'input') {
	    return !!supportedInputTypes[elem.type];
	  }
	
	  if (nodeName === 'textarea') {
	    return true;
	  }
	
	  return false;
	}
	
	module.exports = isTextInputElement;

/***/ },
/* 79 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	
	var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];
	
	module.exports = DefaultEventPluginOrder;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPropagators = __webpack_require__(48);
	var ReactDOMComponentTree = __webpack_require__(41);
	var SyntheticMouseEvent = __webpack_require__(81);
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: 'onMouseEnter',
	    dependencies: ['topMouseOut', 'topMouseOver']
	  },
	  mouseLeave: {
	    registrationName: 'onMouseLeave',
	    dependencies: ['topMouseOut', 'topMouseOver']
	  }
	};
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   */
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (nativeEventTarget.window === nativeEventTarget) {
	      // `nativeEventTarget` is probably a window object.
	      win = nativeEventTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = nativeEventTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    if (topLevelType === 'topMouseOut') {
	      from = targetInst;
	      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
	      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
	    } else {
	      // Moving to a node from outside the window.
	      from = null;
	      to = targetInst;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
	    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = fromNode;
	    leave.relatedTarget = toNode;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = toNode;
	    enter.relatedTarget = fromNode;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);
	
	    return [leave, enter];
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(82);
	var ViewportMetrics = __webpack_require__(83);
	
	var getEventModifierState = __webpack_require__(84);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function button(event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function relatedTarget(event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function pageX(event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function pageY(event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(60);
	
	var getEventTarget = __webpack_require__(76);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function view(event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function detail(event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ },
/* 83 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function refreshScrollValues(scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;

/***/ },
/* 84 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(43);
	
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: 0,
	    acceptCharset: 0,
	    accessKey: 0,
	    action: 0,
	    allowFullScreen: HAS_BOOLEAN_VALUE,
	    allowTransparency: 0,
	    alt: 0,
	    // specifies target context for links with `preload` type
	    as: 0,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: 0,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: HAS_BOOLEAN_VALUE,
	    cellPadding: 0,
	    cellSpacing: 0,
	    charSet: 0,
	    challenge: 0,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    cite: 0,
	    classID: 0,
	    className: 0,
	    cols: HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: 0,
	    content: 0,
	    contentEditable: 0,
	    contextMenu: 0,
	    controls: HAS_BOOLEAN_VALUE,
	    coords: 0,
	    crossOrigin: 0,
	    data: 0, // For `<object />` acts as `src`.
	    dateTime: 0,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: 0,
	    disabled: HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: 0,
	    encType: 0,
	    form: 0,
	    formAction: 0,
	    formEncType: 0,
	    formMethod: 0,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: 0,
	    frameBorder: 0,
	    headers: 0,
	    height: 0,
	    hidden: HAS_BOOLEAN_VALUE,
	    high: 0,
	    href: 0,
	    hrefLang: 0,
	    htmlFor: 0,
	    httpEquiv: 0,
	    icon: 0,
	    id: 0,
	    inputMode: 0,
	    integrity: 0,
	    is: 0,
	    keyParams: 0,
	    keyType: 0,
	    kind: 0,
	    label: 0,
	    lang: 0,
	    list: 0,
	    loop: HAS_BOOLEAN_VALUE,
	    low: 0,
	    manifest: 0,
	    marginHeight: 0,
	    marginWidth: 0,
	    max: 0,
	    maxLength: 0,
	    media: 0,
	    mediaGroup: 0,
	    method: 0,
	    min: 0,
	    minLength: 0,
	    // Caution; `option.selected` is not updated if `select.multiple` is
	    // disabled with `removeAttribute`.
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: 0,
	    nonce: 0,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: 0,
	    pattern: 0,
	    placeholder: 0,
	    playsInline: HAS_BOOLEAN_VALUE,
	    poster: 0,
	    preload: 0,
	    profile: 0,
	    radioGroup: 0,
	    readOnly: HAS_BOOLEAN_VALUE,
	    referrerPolicy: 0,
	    rel: 0,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: 0,
	    rows: HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: HAS_NUMERIC_VALUE,
	    sandbox: 0,
	    scope: 0,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: 0,
	    seamless: HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: 0,
	    size: HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: 0,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: 0,
	    src: 0,
	    srcDoc: 0,
	    srcLang: 0,
	    srcSet: 0,
	    start: HAS_NUMERIC_VALUE,
	    step: 0,
	    style: 0,
	    summary: 0,
	    tabIndex: 0,
	    target: 0,
	    title: 0,
	    // Setting .type throws on non-<input> tags
	    type: 0,
	    useMap: 0,
	    value: 0,
	    width: 0,
	    wmode: 0,
	    wrap: 0,
	
	    /**
	     * RDFa Properties
	     */
	    about: 0,
	    datatype: 0,
	    inlist: 0,
	    prefix: 0,
	    // property is also supported for OpenGraph in meta tags.
	    property: 0,
	    resource: 0,
	    'typeof': 0,
	    vocab: 0,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: 0,
	    autoCorrect: 0,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: 0,
	    // color is for Safari mask-icon link
	    color: 0,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: 0,
	    itemScope: HAS_BOOLEAN_VALUE,
	    itemType: 0,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: 0,
	    itemRef: 0,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: 0,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: 0,
	    // IE-only attribute that controls focus behavior
	    unselectable: 0
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {}
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(87);
	var ReactDOMIDOperations = __webpack_require__(98);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMLazyTree = __webpack_require__(88);
	var Danger = __webpack_require__(94);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactInstrumentation = __webpack_require__(69);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(91);
	var setInnerHTML = __webpack_require__(90);
	var setTextContent = __webpack_require__(92);
	
	function getNodeAfter(parentNode, node) {
	  // Special case for text components, which return [open, close] comments
	  // from getHostNode.
	  if (Array.isArray(node)) {
	    node = node[1];
	  }
	  return node ? node.nextSibling : parentNode.firstChild;
	}
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
	  // We rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
	  // we are careful to use `null`.)
	  parentNode.insertBefore(childNode, referenceNode);
	});
	
	function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
	  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
	}
	
	function moveChild(parentNode, childNode, referenceNode) {
	  if (Array.isArray(childNode)) {
	    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
	  } else {
	    insertChildAt(parentNode, childNode, referenceNode);
	  }
	}
	
	function removeChild(parentNode, childNode) {
	  if (Array.isArray(childNode)) {
	    var closingComment = childNode[1];
	    childNode = childNode[0];
	    removeDelimitedText(parentNode, childNode, closingComment);
	    parentNode.removeChild(closingComment);
	  }
	  parentNode.removeChild(childNode);
	}
	
	function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
	  var node = openingComment;
	  while (true) {
	    var nextNode = node.nextSibling;
	    insertChildAt(parentNode, node, referenceNode);
	    if (node === closingComment) {
	      break;
	    }
	    node = nextNode;
	  }
	}
	
	function removeDelimitedText(parentNode, startNode, closingComment) {
	  while (true) {
	    var node = startNode.nextSibling;
	    if (node === closingComment) {
	      // The closing comment is removed by ReactMultiChild.
	      break;
	    } else {
	      parentNode.removeChild(node);
	    }
	  }
	}
	
	function replaceDelimitedText(openingComment, closingComment, stringText) {
	  var parentNode = openingComment.parentNode;
	  var nodeAfterComment = openingComment.nextSibling;
	  if (nodeAfterComment === closingComment) {
	    // There are no text nodes between the opening and closing comments; insert
	    // a new one if stringText isn't empty.
	    if (stringText) {
	      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
	    }
	  } else {
	    if (stringText) {
	      // Set the text content of the first node after the opening comment, and
	      // remove all following nodes up until the closing comment.
	      setTextContent(nodeAfterComment, stringText);
	      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
	    } else {
	      removeDelimitedText(parentNode, openingComment, closingComment);
	    }
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onHostOperation({
	      instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
	      type: 'replace text',
	      payload: stringText
	    });
	  }
	}
	
	var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
	if (process.env.NODE_ENV !== 'production') {
	  dangerouslyReplaceNodeWithMarkup = function dangerouslyReplaceNodeWithMarkup(oldChild, markup, prevInstance) {
	    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
	    if (prevInstance._debugID !== 0) {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: prevInstance._debugID,
	        type: 'replace with',
	        payload: markup.toString()
	      });
	    } else {
	      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
	      if (nextInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation({
	          instanceID: nextInstance._debugID,
	          type: 'mount',
	          payload: markup.toString()
	        });
	      }
	    }
	  };
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,
	
	  replaceDelimitedText: replaceDelimitedText,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  processUpdates: function processUpdates(parentNode, updates) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      var update = updates[k];
	      switch (update.type) {
	        case 'INSERT_MARKUP':
	          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'insert child',
	              payload: { toIndex: update.toIndex, content: update.content.toString() }
	            });
	          }
	          break;
	        case 'MOVE_EXISTING':
	          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'move child',
	              payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
	            });
	          }
	          break;
	        case 'SET_MARKUP':
	          setInnerHTML(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'replace children',
	              payload: update.content.toString()
	            });
	          }
	          break;
	        case 'TEXT_CONTENT':
	          setTextContent(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'replace text',
	              payload: update.content.toString()
	            });
	          }
	          break;
	        case 'REMOVE_NODE':
	          removeChild(parentNode, update.fromNode);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'remove child',
	              payload: { fromIndex: update.fromIndex }
	            });
	          }
	          break;
	      }
	    }
	  }
	
	};
	
	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMNamespaces = __webpack_require__(89);
	var setInnerHTML = __webpack_require__(90);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(91);
	var setTextContent = __webpack_require__(92);
	
	var ELEMENT_NODE_TYPE = 1;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * In IE (8-11) and Edge, appending nodes with no children is dramatically
	 * faster than appending a full subtree, so we essentially queue up the
	 * .appendChild calls here and apply them so each node is added to its parent
	 * before any children are added.
	 *
	 * In other browsers, doing so is slower or neutral compared to the other order
	 * (in Firefox, twice as slow) so we only do this inversion in IE.
	 *
	 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
	 */
	var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);
	
	function insertTreeChildren(tree) {
	  if (!enableLazy) {
	    return;
	  }
	  var node = tree.node;
	  var children = tree.children;
	  if (children.length) {
	    for (var i = 0; i < children.length; i++) {
	      insertTreeBefore(node, children[i], null);
	    }
	  } else if (tree.html != null) {
	    setInnerHTML(node, tree.html);
	  } else if (tree.text != null) {
	    setTextContent(node, tree.text);
	  }
	}
	
	var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
	  // DocumentFragments aren't actually part of the DOM after insertion so
	  // appending children won't update the DOM. We need to ensure the fragment
	  // is properly populated first, breaking out of our lazy approach for just
	  // this level. Also, some <object> plugins (like Flash Player) will read
	  // <param> nodes immediately upon insertion into the DOM, so <object>
	  // must also be populated prior to insertion into the DOM.
	  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
	    insertTreeChildren(tree);
	    parentNode.insertBefore(tree.node, referenceNode);
	  } else {
	    parentNode.insertBefore(tree.node, referenceNode);
	    insertTreeChildren(tree);
	  }
	});
	
	function replaceChildWithTree(oldNode, newTree) {
	  oldNode.parentNode.replaceChild(newTree.node, oldNode);
	  insertTreeChildren(newTree);
	}
	
	function queueChild(parentTree, childTree) {
	  if (enableLazy) {
	    parentTree.children.push(childTree);
	  } else {
	    parentTree.node.appendChild(childTree.node);
	  }
	}
	
	function queueHTML(tree, html) {
	  if (enableLazy) {
	    tree.html = html;
	  } else {
	    setInnerHTML(tree.node, html);
	  }
	}
	
	function queueText(tree, text) {
	  if (enableLazy) {
	    tree.text = text;
	  } else {
	    setTextContent(tree.node, text);
	  }
	}
	
	function toString() {
	  return this.node.nodeName;
	}
	
	function DOMLazyTree(node) {
	  return {
	    node: node,
	    children: [],
	    html: null,
	    text: null,
	    toString: toString
	  };
	}
	
	DOMLazyTree.insertTreeBefore = insertTreeBefore;
	DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
	DOMLazyTree.queueChild = queueChild;
	DOMLazyTree.queueHTML = queueHTML;
	DOMLazyTree.queueText = queueText;
	
	module.exports = DOMLazyTree;

/***/ },
/* 89 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMNamespaces = {
	  html: 'http://www.w3.org/1999/xhtml',
	  mathml: 'http://www.w3.org/1998/Math/MathML',
	  svg: 'http://www.w3.org/2000/svg'
	};
	
	module.exports = DOMNamespaces;

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(55);
	var DOMNamespaces = __webpack_require__(89);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(91);
	
	// SVG temp container for IE lacking innerHTML
	var reusableSVGContainer;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
	  // IE does not have innerHTML for SVG nodes, so instead we inject the
	  // new markup in a temp node and then move the child nodes across into
	  // the target node
	  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
	    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
	    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
	    var svgNode = reusableSVGContainer.firstChild;
	    while (svgNode.firstChild) {
	      node.appendChild(svgNode.firstChild);
	    }
	  } else {
	    node.innerHTML = html;
	  }
	});
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function setInnerHTML(node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	  testElement = null;
	}
	
	module.exports = setInnerHTML;

/***/ },
/* 91 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	/**
	 * Create a function which has 'unsafe' privileges (required by windows8 apps)
	 */
	
	var createMicrosoftUnsafeLocalFunction = function createMicrosoftUnsafeLocalFunction(func) {
	  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	    return function (arg0, arg1, arg2, arg3) {
	      MSApp.execUnsafeLocalFunction(function () {
	        return func(arg0, arg1, arg2, arg3);
	      });
	    };
	  } else {
	    return func;
	  }
	};
	
	module.exports = createMicrosoftUnsafeLocalFunction;

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(55);
	var escapeTextContentForBrowser = __webpack_require__(93);
	var setInnerHTML = __webpack_require__(90);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function setTextContent(node, text) {
	  if (text) {
	    var firstChild = node.firstChild;
	
	    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
	      firstChild.nodeValue = text;
	      return;
	    }
	  }
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function setTextContent(node, text) {
	      if (node.nodeType === 3) {
	        node.nodeValue = text;
	        return;
	      }
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ },
/* 93 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * Based on the escape-html library, which is used under the MIT License below:
	 *
	 * Copyright (c) 2012-2013 TJ Holowaychuk
	 * Copyright (c) 2015 Andreas Lubbe
	 * Copyright (c) 2015 Tiancheng "Timothy" Gu
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * 'Software'), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 */
	
	'use strict';
	
	// code copied and modified from escape-html
	/**
	 * Module variables.
	 * @private
	 */
	
	var matchHtmlRegExp = /["'&<>]/;
	
	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */
	
	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);
	
	  if (!match) {
	    return str;
	  }
	
	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;
	
	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34:
	        // "
	        escape = '&quot;';
	        break;
	      case 38:
	        // &
	        escape = '&amp;';
	        break;
	      case 39:
	        // '
	        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
	        break;
	      case 60:
	        // <
	        escape = '&lt;';
	        break;
	      case 62:
	        // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }
	
	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }
	
	    lastIndex = index + 1;
	    html += escape;
	  }
	
	  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
	// end code copied and modified from escape-html
	
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  if (typeof text === 'boolean' || typeof text === 'number') {
	    // this shortcircuit helps perf for types that we know will never have
	    // special characters, especially given that this function is used often
	    // for numeric dom ids.
	    return '' + text;
	  }
	  return escapeHtml(text);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var DOMLazyTree = __webpack_require__(88);
	var ExecutionEnvironment = __webpack_require__(55);
	
	var createNodesFromMarkup = __webpack_require__(95);
	var emptyFunction = __webpack_require__(19);
	var invariant = __webpack_require__(15);
	
	var Danger = {
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function dangerouslyReplaceNodeWithMarkup(oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
	    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;
	
	    if (typeof markup === 'string') {
	      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	      oldChild.parentNode.replaceChild(newChild, oldChild);
	    } else {
	      DOMLazyTree.replaceChildWithTree(oldChild, markup);
	    }
	  }
	
	};
	
	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	var ExecutionEnvironment = __webpack_require__(55);
	
	var createArrayFromMixed = __webpack_require__(96);
	var getMarkupWrap = __webpack_require__(97);
	var invariant = __webpack_require__(15);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = Array.from(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var invariant = __webpack_require__(15);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
	  // in old versions of Safari).
	  !(!Array.isArray(obj) && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;
	
	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;
	
	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;
	
	  !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	var ExecutionEnvironment = __webpack_require__(55);
	
	var invariant = __webpack_require__(15);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(87);
	var ReactDOMComponentTree = __webpack_require__(41);
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function dangerouslyProcessChildrenUpdates(parentInst, updates) {
	    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
	    DOMChildrenOperations.processUpdates(node, updates);
	  }
	};
	
	module.exports = ReactDOMIDOperations;

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);
	
	var AutoFocusUtils = __webpack_require__(100);
	var CSSPropertyOperations = __webpack_require__(102);
	var DOMLazyTree = __webpack_require__(88);
	var DOMNamespaces = __webpack_require__(89);
	var DOMProperty = __webpack_require__(43);
	var DOMPropertyOperations = __webpack_require__(110);
	var EventPluginHub = __webpack_require__(49);
	var EventPluginRegistry = __webpack_require__(50);
	var ReactBrowserEventEmitter = __webpack_require__(112);
	var ReactDOMComponentFlags = __webpack_require__(44);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactDOMInput = __webpack_require__(115);
	var ReactDOMOption = __webpack_require__(118);
	var ReactDOMSelect = __webpack_require__(119);
	var ReactDOMTextarea = __webpack_require__(120);
	var ReactInstrumentation = __webpack_require__(69);
	var ReactMultiChild = __webpack_require__(121);
	var ReactServerRenderingTransaction = __webpack_require__(140);
	
	var emptyFunction = __webpack_require__(19);
	var escapeTextContentForBrowser = __webpack_require__(93);
	var invariant = __webpack_require__(15);
	var isEventSupported = __webpack_require__(77);
	var shallowEqual = __webpack_require__(130);
	var validateDOMNesting = __webpack_require__(143);
	var warning = __webpack_require__(18);
	
	var Flags = ReactDOMComponentFlags;
	var deleteListener = EventPluginHub.deleteListener;
	var getNode = ReactDOMComponentTree.getNodeFromInstance;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = EventPluginRegistry.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };
	
	var STYLE = 'style';
	var HTML = '__html';
	var RESERVED_PROPS = {
	  children: null,
	  dangerouslySetInnerHTML: null,
	  suppressContentEditableWarning: null
	};
	
	// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
	var DOC_FRAGMENT_TYPE = 11;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	function friendlyStringify(obj) {
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined because undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (voidElementTags[component._tag]) {
	    !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
	    !(_typeof(props.dangerouslySetInnerHTML) === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
	  }
	  !(props.style == null || _typeof(props.style) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
	}
	
	function enqueuePutListener(inst, registrationName, listener, transaction) {
	  if (transaction instanceof ReactServerRenderingTransaction) {
	    return;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
	  }
	  var containerInfo = inst._hostContainerInfo;
	  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
	  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
	  listenTo(registrationName, doc);
	  transaction.getReactMountReady().enqueue(putListener, {
	    inst: inst,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	function inputPostMount() {
	  var inst = this;
	  ReactDOMInput.postMountWrapper(inst);
	}
	
	function textareaPostMount() {
	  var inst = this;
	  ReactDOMTextarea.postMountWrapper(inst);
	}
	
	function optionPostMount() {
	  var inst = this;
	  ReactDOMOption.postMountWrapper(inst);
	}
	
	var setAndValidateContentChildDev = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  setAndValidateContentChildDev = function setAndValidateContentChildDev(content) {
	    var hasExistingContent = this._contentDebugID != null;
	    var debugID = this._debugID;
	    // This ID represents the inlined child that has no backing instance:
	    var contentDebugID = -debugID;
	
	    if (content == null) {
	      if (hasExistingContent) {
	        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
	      }
	      this._contentDebugID = null;
	      return;
	    }
	
	    validateDOMNesting(null, String(content), this, this._ancestorInfo);
	    this._contentDebugID = contentDebugID;
	    if (hasExistingContent) {
	      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
	      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
	    } else {
	      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
	      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
	      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
	    }
	  };
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
	  var node = getNode(inst);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;
	
	  switch (inst._tag) {
	    case 'iframe':
	    case 'object':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	
	      inst._wrapperState.listeners = [];
	      // Create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
	        }
	      }
	      break;
	    case 'source':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
	      break;
	    case 'input':
	    case 'select':
	    case 'textarea':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
	      break;
	  }
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special-case tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};
	
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = _assign({
	  'menuitem': true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	var globalIdCounter = 1;
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(element) {
	  var tag = element.type;
	  validateDangerousTag(tag);
	  this._currentElement = element;
	  this._tag = tag.toLowerCase();
	  this._namespaceURI = null;
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._hostNode = null;
	  this._hostParent = null;
	  this._rootNodeID = 0;
	  this._domID = 0;
	  this._hostContainerInfo = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._flags = 0;
	  if (process.env.NODE_ENV !== 'production') {
	    this._ancestorInfo = null;
	    setAndValidateContentChildDev.call(this, null);
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?ReactDOMComponent} the parent component instance
	   * @param {?object} info about the host container
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    this._rootNodeID = globalIdCounter++;
	    this._domID = hostContainerInfo._idCounter++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, hostParent);
	        props = ReactDOMInput.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, hostParent);
	        props = ReactDOMOption.getHostProps(this, props);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, hostParent);
	        props = ReactDOMSelect.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, hostParent);
	        props = ReactDOMTextarea.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	    }
	
	    assertValidProps(this, props);
	
	    // We create tags in the namespace of their parent container, except HTML
	    // tags get no namespace.
	    var namespaceURI;
	    var parentTag;
	    if (hostParent != null) {
	      namespaceURI = hostParent._namespaceURI;
	      parentTag = hostParent._tag;
	    } else if (hostContainerInfo._tag) {
	      namespaceURI = hostContainerInfo._namespaceURI;
	      parentTag = hostContainerInfo._tag;
	    }
	    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
	      namespaceURI = DOMNamespaces.html;
	    }
	    if (namespaceURI === DOMNamespaces.html) {
	      if (this._tag === 'svg') {
	        namespaceURI = DOMNamespaces.svg;
	      } else if (this._tag === 'math') {
	        namespaceURI = DOMNamespaces.mathml;
	      }
	    }
	    this._namespaceURI = namespaceURI;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo._tag) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(this._tag, null, this, parentInfo);
	      }
	      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var el;
	      if (namespaceURI === DOMNamespaces.html) {
	        if (this._tag === 'script') {
	          // Create the script via .innerHTML so its "parser-inserted" flag is
	          // set to true and it does not execute
	          var div = ownerDocument.createElement('div');
	          var type = this._currentElement.type;
	          div.innerHTML = '<' + type + '></' + type + '>';
	          el = div.removeChild(div.firstChild);
	        } else if (props.is) {
	          el = ownerDocument.createElement(this._currentElement.type, props.is);
	        } else {
	          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
	          // See discussion in https://github.com/facebook/react/pull/6896
	          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
	          el = ownerDocument.createElement(this._currentElement.type);
	        }
	      } else {
	        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
	      }
	      ReactDOMComponentTree.precacheNode(this, el);
	      this._flags |= Flags.hasCachedChildNodes;
	      if (!this._hostParent) {
	        DOMPropertyOperations.setAttributeForRoot(el);
	      }
	      this._updateDOMProperties(null, props, transaction);
	      var lazyTree = DOMLazyTree(el);
	      this._createInitialChildren(transaction, props, context, lazyTree);
	      mountImage = lazyTree;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(inputPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'textarea':
	        transaction.getReactMountReady().enqueue(textareaPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'select':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'button':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'option':
	        transaction.getReactMountReady().enqueue(optionPostMount, this);
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function _createOpenTagMarkupAndPutListeners(transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = _assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    if (!this._hostParent) {
	      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
	    }
	    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
	    return ret;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function _createContentMarkup(transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	        if (process.env.NODE_ENV !== 'production') {
	          setAndValidateContentChildDev.call(this, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function _createInitialChildren(transaction, props, context, lazyTree) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        if (process.env.NODE_ENV !== 'production') {
	          setAndValidateContentChildDev.call(this, contentToUse);
	        }
	        DOMLazyTree.queueText(lazyTree, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function receiveComponent(nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function updateComponent(transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'input':
	        lastProps = ReactDOMInput.getHostProps(this, lastProps);
	        nextProps = ReactDOMInput.getHostProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getHostProps(this, lastProps);
	        nextProps = ReactDOMOption.getHostProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
	        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
	        break;
	      case 'textarea':
	        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
	        break;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    switch (this._tag) {
	      case 'input':
	        // Update the wrapper around inputs *after* updating props. This has to
	        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
	        // raise warnings and prevent the new value from being assigned.
	        ReactDOMInput.updateWrapper(this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        break;
	      case 'select':
	        // <select> value update needs to occur after <option> children
	        // reconciliation
	        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	        break;
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function _updateDOMProperties(lastProps, nextProps, transaction) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, lastProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = _assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        var node = getNode(this);
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertently setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function _updateDOMChildren(lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[_typeof(lastProps.children)] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[_typeof(nextProps.children)] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	        if (process.env.NODE_ENV !== 'production') {
	          setAndValidateContentChildDev.call(this, nextContent);
	        }
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    } else if (nextChildren != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        setAndValidateContentChildDev.call(this, null);
	      }
	
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  getHostNode: function getHostNode() {
	    return getNode(this);
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function unmountComponent(safely) {
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
	        break;
	    }
	
	    this.unmountChildren(safely);
	    ReactDOMComponentTree.uncacheNode(this);
	    EventPluginHub.deleteAllListeners(this);
	    this._rootNodeID = 0;
	    this._domID = 0;
	    this._wrapperState = null;
	
	    if (process.env.NODE_ENV !== 'production') {
	      setAndValidateContentChildDev.call(this, null);
	    }
	  },
	
	  getPublicInstance: function getPublicInstance() {
	    return getNode(this);
	  }
	
	};
	
	_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(41);
	
	var focusNode = __webpack_require__(101);
	
	var AutoFocusUtils = {
	  focusDOMComponent: function focusDOMComponent() {
	    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ },
/* 101 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(103);
	var ExecutionEnvironment = __webpack_require__(55);
	var ReactInstrumentation = __webpack_require__(69);
	
	var camelizeStyleName = __webpack_require__(104);
	var dangerousStyleValue = __webpack_require__(106);
	var hyphenateStyleName = __webpack_require__(107);
	var memoizeStringOnly = __webpack_require__(109);
	var warning = __webpack_require__(18);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	  var warnedForNaNValue = false;
	
	  var warnHyphenatedStyleName = function warnHyphenatedStyleName(name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnBadVendoredStyleName = function warnBadVendoredStyleName(name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon(name, value, owner) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
	  };
	
	  var warnStyleValueIsNaN = function warnStyleValueIsNaN(name, value, owner) {
	    if (warnedForNaNValue) {
	      return;
	    }
	
	    warnedForNaNValue = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
	  };
	
	  var checkRenderMessage = function checkRenderMessage(owner) {
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' Check the render method of `' + name + '`.';
	      }
	    }
	    return '';
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   * @param {ReactDOMComponent} component
	   */
	  var warnValidStyle = function warnValidStyle(name, value, component) {
	    var owner;
	    if (component) {
	      owner = component._currentElement._owner;
	    }
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name, owner);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name, owner);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value, owner);
	    }
	
	    if (typeof value === 'number' && isNaN(value)) {
	      warnStyleValueIsNaN(name, value, owner);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   * @return {?string}
	   */
	  createMarkupForStyles: function createMarkupForStyles(styles, component) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue, component);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   */
	  setValueForStyles: function setValueForStyles(node, styles, component) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: component._debugID,
	        type: 'update styles',
	        payload: styles
	      });
	    }
	
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName], component);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
	      if (styleName === 'float' || styleName === 'cssFloat') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 103 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  borderImageOutset: true,
	  borderImageSlice: true,
	  borderImageWidth: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  gridRow: true,
	  gridColumn: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  floodOpacity: true,
	  stopOpacity: true,
	  strokeDasharray: true,
	  strokeDashoffset: true,
	  strokeMiterlimit: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(105);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 105 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(103);
	var warning = __webpack_require__(18);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	var styleWarnings = {};
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @param {ReactDOMComponent} component
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value, component) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    if (process.env.NODE_ENV !== 'production') {
	      // Allow '0' to pass through without warning. 0 is already special and
	      // doesn't require units, so we don't need to warn about it.
	      if (component && value !== '0') {
	        var owner = component._currentElement._owner;
	        var ownerName = owner ? owner.getName() : null;
	        if (ownerName && !styleWarnings[ownerName]) {
	          styleWarnings[ownerName] = {};
	        }
	        var warned = false;
	        if (ownerName) {
	          var warnings = styleWarnings[ownerName];
	          warned = warnings[name];
	          if (!warned) {
	            warnings[name] = true;
	          }
	        }
	        if (!warned) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
	        }
	      }
	    }
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(108);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 108 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 109 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 */
	
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(43);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactInstrumentation = __webpack_require__(69);
	
	var quoteAttributeValueForBrowser = __webpack_require__(111);
	var warning = __webpack_require__(18);
	
	var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function createMarkupForID(id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function setAttributeForID(node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  createMarkupForRoot: function createMarkupForRoot() {
	    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
	  },
	
	  setAttributeForRoot: function setAttributeForRoot(node) {
	    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function createMarkupForProperty(name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function createMarkupForCustomAttribute(name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function setValueForProperty(node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	        return;
	      } else if (propertyInfo.mustUseProperty) {
	        // Contrary to `setAttribute`, object properties are properly
	        // `toString`ed by IE8/9.
	        node[propertyInfo.propertyName] = value;
	      } else {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'update attribute',
	        payload: payload
	      });
	    }
	  },
	
	  setValueForAttribute: function setValueForAttribute(node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'update attribute',
	        payload: payload
	      });
	    }
	  },
	
	  /**
	   * Deletes an attributes from a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForAttribute: function deleteValueForAttribute(node, name) {
	    node.removeAttribute(name);
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'remove attribute',
	        payload: name
	      });
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function deleteValueForProperty(node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseProperty) {
	        var propName = propertyInfo.propertyName;
	        if (propertyInfo.hasBooleanValue) {
	          node[propName] = false;
	        } else {
	          node[propName] = '';
	        }
	      } else {
	        node.removeAttribute(propertyInfo.attributeName);
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'remove attribute',
	        payload: name
	      });
	    }
	  }
	
	};
	
	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(93);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var EventPluginRegistry = __webpack_require__(50);
	var ReactEventEmitterMixin = __webpack_require__(113);
	var ViewportMetrics = __webpack_require__(83);
	
	var getVendorPrefixedEventName = __webpack_require__(114);
	var isEventSupported = __webpack_require__(77);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var hasEventPageXY;
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
	  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
	  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function injectReactEventListener(ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function setEnabled(enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function isEnabled() {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function listenTo(registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === 'topWheel') {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === 'topScroll') {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === 'topFocus' || dependency === 'topBlur') {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening.topBlur = true;
	          isListening.topFocus = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Protect against document.createEvent() returning null
	   * Some popup blocker extensions appear to do this:
	   * https://github.com/facebook/react/issues/6887
	   */
	  supportsEventPageXY: function supportsEventPageXY() {
	    if (!document.createEvent) {
	      return false;
	    }
	    var ev = document.createEvent('MouseEvent');
	    return ev != null && 'pageX' in ev;
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
	   * pageX/pageY isn't supported (legacy browsers).
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function ensureScrollValueMonitoring() {
	    if (hasEventPageXY === undefined) {
	      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
	    }
	    if (!hasEventPageXY && !isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  }
	
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(49);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   */
	  handleTopLevel: function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(55);
	
	/**
	 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
	 *
	 * @param {string} styleProp
	 * @param {string} eventName
	 * @returns {object}
	 */
	function makePrefixMap(styleProp, eventName) {
	  var prefixes = {};
	
	  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
	  prefixes['Moz' + styleProp] = 'moz' + eventName;
	  prefixes['ms' + styleProp] = 'MS' + eventName;
	  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();
	
	  return prefixes;
	}
	
	/**
	 * A list of event names to a configurable list of vendor prefixes.
	 */
	var vendorPrefixes = {
	  animationend: makePrefixMap('Animation', 'AnimationEnd'),
	  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
	  animationstart: makePrefixMap('Animation', 'AnimationStart'),
	  transitionend: makePrefixMap('Transition', 'TransitionEnd')
	};
	
	/**
	 * Event names that have already been detected and prefixed (if applicable).
	 */
	var prefixedEventNames = {};
	
	/**
	 * Element to check for prefixes on.
	 */
	var style = {};
	
	/**
	 * Bootstrap if a DOM exists.
	 */
	if (ExecutionEnvironment.canUseDOM) {
	  style = document.createElement('div').style;
	
	  // On some platforms, in particular some releases of Android 4.x,
	  // the un-prefixed "animation" and "transition" properties are defined on the
	  // style object but the events that fire will still be prefixed, so we need
	  // to check if the un-prefixed events are usable, and if not remove them from the map.
	  if (!('AnimationEvent' in window)) {
	    delete vendorPrefixes.animationend.animation;
	    delete vendorPrefixes.animationiteration.animation;
	    delete vendorPrefixes.animationstart.animation;
	  }
	
	  // Same as above
	  if (!('TransitionEvent' in window)) {
	    delete vendorPrefixes.transitionend.transition;
	  }
	}
	
	/**
	 * Attempts to determine the correct vendor prefixed event name.
	 *
	 * @param {string} eventName
	 * @returns {string}
	 */
	function getVendorPrefixedEventName(eventName) {
	  if (prefixedEventNames[eventName]) {
	    return prefixedEventNames[eventName];
	  } else if (!vendorPrefixes[eventName]) {
	    return eventName;
	  }
	
	  var prefixMap = vendorPrefixes[eventName];
	
	  for (var styleProp in prefixMap) {
	    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
	      return prefixedEventNames[eventName] = prefixMap[styleProp];
	    }
	  }
	
	  return '';
	}
	
	module.exports = getVendorPrefixedEventName;

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);
	
	var DOMPropertyOperations = __webpack_require__(110);
	var LinkedValueUtils = __webpack_require__(116);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactUpdates = __webpack_require__(63);
	
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	var didWarnValueLink = false;
	var didWarnCheckedLink = false;
	var didWarnValueDefaultValue = false;
	var didWarnCheckedDefaultChecked = false;
	var didWarnControlledToUncontrolled = false;
	var didWarnUncontrolledToControlled = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	function isControlled(props) {
	  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
	  return usesChecked ? props.checked != null : props.value != null;
	}
	
	/**
	 * Implements an <input> host component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getHostProps: function getHostProps(inst, props) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var hostProps = _assign({
	      // Make sure we set .type before any other properties (setting .value
	      // before .type means .value is lost in IE11 and below)
	      type: undefined,
	      // Make sure we set .step before .value (setting .value before .step
	      // means .value is rounded on mount, based upon step precision)
	      step: undefined,
	      // Make sure we set .min & .max before .value (to ensure proper order
	      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
	      min: undefined,
	      max: undefined
	    }, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	
	      var owner = inst._currentElement._owner;
	
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnCheckedLink = true;
	      }
	      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnCheckedDefaultChecked = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnValueDefaultValue = true;
	      }
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
	      initialValue: props.value != null ? props.value : defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	
	    if (process.env.NODE_ENV !== 'production') {
	      inst._wrapperState.controlled = isControlled(props);
	    }
	  },
	
	  updateWrapper: function updateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var controlled = isControlled(props);
	      var owner = inst._currentElement._owner;
	
	      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnUncontrolledToControlled = true;
	      }
	      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnControlledToUncontrolled = true;
	      }
	    }
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
	    }
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	    } else {
	      if (props.value == null && props.defaultValue != null) {
	        node.defaultValue = '' + props.defaultValue;
	      }
	      if (props.checked == null && props.defaultChecked != null) {
	        node.defaultChecked = !!props.defaultChecked;
	      }
	    }
	  },
	
	  postMountWrapper: function postMountWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Detach value from defaultValue. We won't do anything if we're working on
	    // submit or reset inputs as those values & defaultValues are linked. They
	    // are not resetable nodes so this operation doesn't matter and actually
	    // removes browser-default values (eg "Submit Query") when no value is
	    // provided.
	
	    switch (props.type) {
	      case 'submit':
	      case 'reset':
	        break;
	      case 'color':
	      case 'date':
	      case 'datetime':
	      case 'datetime-local':
	      case 'month':
	      case 'time':
	      case 'week':
	        // This fixes the no-show issue on iOS Safari and Android Chrome:
	        // https://github.com/facebook/react/issues/7233
	        node.value = '';
	        node.value = node.defaultValue;
	        break;
	      default:
	        node.value = node.value;
	        break;
	    }
	
	    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
	    // this is needed to work around a chrome bug where setting defaultChecked
	    // will sometimes influence the value of checked (even after detachment).
	    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
	    // We need to temporarily unset name to avoid disrupting radio button groups.
	    var name = node.name;
	    if (name !== '') {
	      node.name = '';
	    }
	    node.defaultChecked = !node.defaultChecked;
	    node.defaultChecked = !node.defaultChecked;
	    if (name !== '') {
	      node.name = name;
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React radio buttons with non-React ones.
	      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var React = __webpack_require__(9);
	var ReactPropTypesSecret = __webpack_require__(117);
	
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
	}
	
	var propTypes = {
	  value: function value(props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function checked(props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: React.PropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function checkPropTypes(tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function getValue(inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function getChecked(inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function executeOnChange(inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 117 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var React = __webpack_require__(9);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactDOMSelect = __webpack_require__(119);
	
	var warning = __webpack_require__(18);
	var didWarnInvalidOptionChildren = false;
	
	function flattenChildren(children) {
	  var content = '';
	
	  // Flatten children and warn if they aren't strings or numbers;
	  // invalid types are ignored.
	  React.Children.forEach(children, function (child) {
	    if (child == null) {
	      return;
	    }
	    if (typeof child === 'string' || typeof child === 'number') {
	      content += child;
	    } else if (!didWarnInvalidOptionChildren) {
	      didWarnInvalidOptionChildren = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
	    }
	  });
	
	  return content;
	}
	
	/**
	 * Implements an <option> host component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function mountWrapper(inst, props, hostParent) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
	    }
	
	    // Look up whether this option is 'selected'
	    var selectValue = null;
	    if (hostParent != null) {
	      var selectParent = hostParent;
	
	      if (selectParent._tag === 'optgroup') {
	        selectParent = selectParent._hostParent;
	      }
	
	      if (selectParent != null && selectParent._tag === 'select') {
	        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
	      }
	    }
	
	    // If the value is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      var value;
	      if (props.value != null) {
	        value = props.value + '';
	      } else {
	        value = flattenChildren(props.children);
	      }
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  postMountWrapper: function postMountWrapper(inst) {
	    // value="" should make a value attribute (#6219)
	    var props = inst._currentElement.props;
	    if (props.value != null) {
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      node.setAttribute('value', props.value);
	    }
	  },
	
	  getHostProps: function getHostProps(inst, props) {
	    var hostProps = _assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      hostProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = flattenChildren(props.children);
	
	    if (content) {
	      hostProps.children = content;
	    }
	
	    return hostProps;
	  }
	
	};
	
	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var LinkedValueUtils = __webpack_require__(116);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactUpdates = __webpack_require__(63);
	
	var warning = __webpack_require__(18);
	
	var didWarnValueLink = false;
	var didWarnValueDefaultValue = false;
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  if (props.valueLink !== undefined && !didWarnValueLink) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
	    didWarnValueLink = true;
	  }
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    var isArray = Array.isArray(props[propName]);
	    if (props.multiple && !isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    } else if (!props.multiple && isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> host component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  getHostProps: function getHostProps(inst, props) {
	    return _assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	
	    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	      didWarnValueDefaultValue = true;
	    }
	  },
	
	  getSelectValueContext: function getSelectValueContext(inst) {
	    // ReactDOMOption looks at this initial value so the initial generated
	    // markup has correct `selected` attributes
	    return inst._wrapperState.initialValue;
	  },
	
	  postUpdateWrapper: function postUpdateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // this value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  if (this._rootNodeID) {
	    this._wrapperState.pendingUpdate = true;
	  }
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);
	
	var LinkedValueUtils = __webpack_require__(116);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactUpdates = __webpack_require__(63);
	
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	var didWarnValueLink = false;
	var didWarnValDefaultVal = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> host component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getHostProps: function getHostProps(inst, props) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.  We could add a check in setTextContent
	    // to only set the value if/when the value differs from the node value (which would
	    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
	    // The value can be a boolean or object so that's why it's forced to be a string.
	    var hostProps = _assign({}, props, {
	      value: undefined,
	      defaultValue: undefined,
	      children: '' + inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	        didWarnValDefaultVal = true;
	      }
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    var initialValue = value;
	
	    // Only bother fetching default value if we're going to use it
	    if (value == null) {
	      var defaultValue = props.defaultValue;
	      // TODO (yungsters): Remove support for children content in <textarea>.
	      var children = props.children;
	      if (children != null) {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
	        }
	        !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
	        if (Array.isArray(children)) {
	          !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
	          children = children[0];
	        }
	
	        defaultValue = '' + children;
	      }
	      if (defaultValue == null) {
	        defaultValue = '';
	      }
	      initialValue = defaultValue;
	    }
	
	    inst._wrapperState = {
	      initialValue: '' + initialValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function updateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	      if (props.defaultValue == null) {
	        node.defaultValue = newValue;
	      }
	    }
	    if (props.defaultValue != null) {
	      node.defaultValue = props.defaultValue;
	    }
	  },
	
	  postMountWrapper: function postMountWrapper(inst) {
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Warning: node.value may be the empty string at this point (IE11) if placeholder is set.
	    node.value = node.textContent; // Detach value from defaultValue
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var ReactComponentEnvironment = __webpack_require__(122);
	var ReactInstanceMap = __webpack_require__(123);
	var ReactInstrumentation = __webpack_require__(69);
	
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactReconciler = __webpack_require__(66);
	var ReactChildReconciler = __webpack_require__(124);
	
	var emptyFunction = __webpack_require__(19);
	var flattenChildren = __webpack_require__(139);
	var invariant = __webpack_require__(15);
	
	/**
	 * Make an update for markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function makeInsertMarkup(markup, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'INSERT_MARKUP',
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for moving an existing element to another index.
	 *
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function makeMove(child, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'MOVE_EXISTING',
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: ReactReconciler.getHostNode(child),
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for removing an element at an index.
	 *
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function makeRemove(child, node) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'REMOVE_NODE',
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: node,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the markup of a node.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function makeSetMarkup(markup) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'SET_MARKUP',
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the text content.
	 *
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function makeTextContent(textContent) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'TEXT_CONTENT',
	    content: textContent,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Push an update, if any, onto the queue. Creates a new queue if none is
	 * passed and always returns the queue. Mutative.
	 */
	function enqueue(queue, update) {
	  if (update) {
	    queue = queue || [];
	    queue.push(update);
	  }
	  return queue;
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue(inst, updateQueue) {
	  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
	}
	
	var setChildrenForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  var getDebugID = function getDebugID(inst) {
	    if (!inst._debugID) {
	      // Check for ART-like instances. TODO: This is silly/gross.
	      var internal;
	      if (internal = ReactInstanceMap.get(inst)) {
	        inst = internal;
	      }
	    }
	    return inst._debugID;
	  };
	  setChildrenForInstrumentation = function setChildrenForInstrumentation(children) {
	    var debugID = getDebugID(this);
	    // TODO: React Native empty components are also multichild.
	    // This means they still get into this method but don't have _debugID.
	    if (debugID !== 0) {
	      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
	        return children[key]._debugID;
	      }) : []);
	    }
	  };
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    _reconcilerInstantiateChildren: function _reconcilerInstantiateChildren(nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        var selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function _reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
	      var nextChildren;
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          return nextChildren;
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	      return nextChildren;
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function mountChildren(nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          var selfDebugID = 0;
	          if (process.env.NODE_ENV !== 'production') {
	            selfDebugID = getDebugID(this);
	          }
	          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, children);
	      }
	
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function updateTextContent(nextContent) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      // Set new text content.
	      var updates = [makeTextContent(nextContent)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function updateMarkup(nextMarkup) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      var updates = [makeSetMarkup(nextMarkup)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function updateChildren(nextNestedChildrenElements, transaction, context) {
	      // Hook used by React ART
	      this._updateChildren(nextNestedChildrenElements, transaction, context);
	    },
	
	    /**
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function _updateChildren(nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var removedNodes = {};
	      var mountImages = [];
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var updates = null;
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var nextIndex = 0;
	      var lastIndex = 0;
	      // `nextMountIndex` will increment for each newly mounted child.
	      var nextMountIndex = 0;
	      var lastPlacedNode = null;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            // The `removedNodes` loop below will actually remove the child.
	          }
	          // The child must be instantiated before it's mounted.
	          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
	          nextMountIndex++;
	        }
	        nextIndex++;
	        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
	      }
	      // Remove children that are no longer present.
	      for (name in removedNodes) {
	        if (removedNodes.hasOwnProperty(name)) {
	          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
	        }
	      }
	      if (updates) {
	        processQueue(this, updates);
	      }
	      this._renderedChildren = nextChildren;
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, nextChildren);
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted. It does not actually perform any
	     * backend operations.
	     *
	     * @internal
	     */
	    unmountChildren: function unmountChildren(safely) {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren, safely);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function moveChild(child, afterNode, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        return makeMove(child, afterNode, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function createChild(child, afterNode, mountImage) {
	      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function removeChild(child, node) {
	      return makeRemove(child, node);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildAtIndex: function _mountChildAtIndex(child, mountImage, afterNode, index, transaction, context) {
	      child._mountIndex = index;
	      return this.createChild(child, afterNode, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function _unmountChild(child, node) {
	      var update = this.removeChild(child, node);
	      child._mountIndex = null;
	      return update;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var invariant = __webpack_require__(15);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkup: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function injectEnvironment(environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
	      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 123 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function remove(key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function get(key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function has(key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function set(key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(66);
	
	var instantiateReactComponent = __webpack_require__(125);
	var KeyEscapeUtils = __webpack_require__(135);
	var shouldUpdateReactComponent = __webpack_require__(131);
	var traverseAllChildren = __webpack_require__(136);
	var warning = __webpack_require__(18);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(33);
	}
	
	function instantiateChild(childInstances, child, name, selfDebugID) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    if (!ReactComponentTreeHook) {
	      ReactComponentTreeHook = __webpack_require__(33);
	    }
	    if (!keyUnique) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	    }
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, true);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function instantiateChildren(nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
	  ) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	
	    if (process.env.NODE_ENV !== 'production') {
	      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
	        return instantiateChild(childInsts, child, name, selfDebugID);
	      }, childInstances);
	    } else {
	      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    }
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
	  ) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return;
	    }
	    var name;
	    var prevChild;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	          ReactReconciler.unmountComponent(prevChild, false);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, true);
	        nextChildren[name] = nextChildInstance;
	        // Creating mount image now ensures refs are resolved in right order
	        // (see https://github.com/facebook/react/pull/7101 for explanation).
	        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
	        mountImages.push(nextChildMountImage);
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        prevChild = prevChildren[name];
	        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	        ReactReconciler.unmountComponent(prevChild, false);
	      }
	    }
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function unmountChildren(renderedChildren, safely) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild, safely);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);
	
	var ReactCompositeComponent = __webpack_require__(126);
	var ReactEmptyComponent = __webpack_require__(132);
	var ReactHostComponent = __webpack_require__(133);
	
	var getNextDebugID = __webpack_require__(134);
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function ReactCompositeComponentWrapper(element) {
	  this.construct(element);
	};
	_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @param {boolean} shouldHaveDebugID
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node, shouldHaveDebugID) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = ReactEmptyComponent.create(instantiateReactComponent);
	  } else if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : _typeof(element.type), getDeclarationErrorAddendum(element._owner)) : _prodInvariant('130', element.type == null ? element.type : _typeof(element.type), getDeclarationErrorAddendum(element._owner)) : void 0;
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactHostComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	
	      // We renamed this. Allow the old name for compat. :(
	      if (!instance.getHostNode) {
	        instance.getHostNode = instance.getNativeNode;
	      }
	    } else {
	      instance = new ReactCompositeComponentWrapper(element);
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactHostComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node === 'undefined' ? 'undefined' : _typeof(node)) : _prodInvariant('131', typeof node === 'undefined' ? 'undefined' : _typeof(node)) : void 0;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
	  }
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (process.env.NODE_ENV !== 'production') {
	    instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);
	
	var React = __webpack_require__(9);
	var ReactComponentEnvironment = __webpack_require__(122);
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactErrorUtils = __webpack_require__(52);
	var ReactInstanceMap = __webpack_require__(123);
	var ReactInstrumentation = __webpack_require__(69);
	var ReactNodeTypes = __webpack_require__(127);
	var ReactReconciler = __webpack_require__(66);
	
	if (process.env.NODE_ENV !== 'production') {
	  var checkReactTypeSpec = __webpack_require__(128);
	}
	
	var emptyObject = __webpack_require__(27);
	var invariant = __webpack_require__(15);
	var shallowEqual = __webpack_require__(130);
	var shouldUpdateReactComponent = __webpack_require__(131);
	var warning = __webpack_require__(18);
	
	var CompositeTypes = {
	  ImpureClass: 0,
	  PureClass: 1,
	  StatelessFunctional: 2
	};
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  var element = Component(this.props, this.context, this.updater);
	  warnIfInvalidElement(Component, element);
	  return element;
	};
	
	function warnIfInvalidElement(Component, element) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
	  }
	}
	
	function shouldConstruct(Component) {
	  return !!(Component.prototype && Component.prototype.isReactComponent);
	}
	
	function isPureComponent(Component) {
	  return !!(Component.prototype && Component.prototype.isPureReactComponent);
	}
	
	// Separated into a function to contain deoptimizations caused by try/finally.
	function measureLifeCyclePerf(fn, debugID, timerType) {
	  if (debugID === 0) {
	    // Top-level wrappers (see ReactMount) and empty components (see
	    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
	    // Both are implementation details that should go away in the future.
	    return fn();
	  }
	
	  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
	  try {
	    return fn();
	  } finally {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
	  }
	}
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponent = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function construct(element) {
	    this._currentElement = element;
	    this._rootNodeID = 0;
	    this._compositeType = null;
	    this._instance = null;
	    this._hostParent = null;
	    this._hostContainerInfo = null;
	
	    // See ReactUpdateQueue
	    this._updateBatchNumber = null;
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedNodeType = null;
	    this._renderedComponent = null;
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	
	    // ComponentWillUnmount shall only be called once
	    this._calledComponentWillUnmount = false;
	
	    if (process.env.NODE_ENV !== 'production') {
	      this._warnedAboutRefsInRender = false;
	    }
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} hostParent
	   * @param {?object} hostContainerInfo
	   * @param {?object} context
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    var _this = this;
	
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var publicProps = this._currentElement.props;
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    var updateQueue = transaction.getUpdateQueue();
	
	    // Initialize the public class
	    var doConstruct = shouldConstruct(Component);
	    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
	    var renderedElement;
	
	    // Support functional components
	    if (!doConstruct && (inst == null || inst.render == null)) {
	      renderedElement = inst;
	      warnIfInvalidElement(Component, renderedElement);
	      !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
	      inst = new StatelessComponent(Component);
	      this._compositeType = CompositeTypes.StatelessFunctional;
	    } else {
	      if (isPureComponent(Component)) {
	        this._compositeType = CompositeTypes.PureClass;
	      } else {
	        this._compositeType = CompositeTypes.ImpureClass;
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
	      }
	
	      var propsMutated = inst.props !== publicProps;
	      var componentName = Component.displayName || Component.name || 'Component';
	
	      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = updateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    var markup;
	    if (inst.unstable_handleError) {
	      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } else {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	
	    if (inst.componentDidMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(function () {
	          measureLifeCyclePerf(function () {
	            return inst.componentDidMount();
	          }, _this._debugID, 'componentDidMount');
	        });
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	      }
	    }
	
	    return markup;
	  },
	
	  _constructComponent: function _constructComponent(doConstruct, publicProps, publicContext, updateQueue) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactCurrentOwner.current = this;
	      try {
	        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	    }
	  },
	
	  _constructComponentWithoutOwner: function _constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue) {
	    var Component = this._currentElement.type;
	
	    if (doConstruct) {
	      if (process.env.NODE_ENV !== 'production') {
	        return measureLifeCyclePerf(function () {
	          return new Component(publicProps, publicContext, updateQueue);
	        }, this._debugID, 'ctor');
	      } else {
	        return new Component(publicProps, publicContext, updateQueue);
	      }
	    }
	
	    // This can still be an instance in case of factory components
	    // but we'll count this as time spent rendering as the more common case.
	    if (process.env.NODE_ENV !== 'production') {
	      return measureLifeCyclePerf(function () {
	        return Component(publicProps, publicContext, updateQueue);
	      }, this._debugID, 'render');
	    } else {
	      return Component(publicProps, publicContext, updateQueue);
	    }
	  },
	
	  performInitialMountWithErrorHandling: function performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var markup;
	    var checkpoint = transaction.checkpoint();
	    try {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } catch (e) {
	      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
	      transaction.rollback(checkpoint);
	      this._instance.unstable_handleError(e);
	      if (this._pendingStateQueue) {
	        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
	      }
	      checkpoint = transaction.checkpoint();
	
	      this._renderedComponent.unmountComponent(true);
	      transaction.rollback(checkpoint);
	
	      // Try again - we've informed the component about the error, so they can render an error message this time.
	      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	    return markup;
	  },
	
	  performInitialMount: function performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var inst = this._instance;
	
	    var debugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      debugID = this._debugID;
	    }
	
	    if (inst.componentWillMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillMount();
	        }, debugID, 'componentWillMount');
	      } else {
	        inst.componentWillMount();
	      }
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    var nodeType = ReactNodeTypes.getType(renderedElement);
	    this._renderedNodeType = nodeType;
	    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	    );
	    this._renderedComponent = child;
	
	    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (debugID !== 0) {
	        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
	        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
	      }
	    }
	
	    return markup;
	  },
	
	  getHostNode: function getHostNode() {
	    return ReactReconciler.getHostNode(this._renderedComponent);
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function unmountComponent(safely) {
	    if (!this._renderedComponent) {
	      return;
	    }
	
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
	      inst._calledComponentWillUnmount = true;
	
	      if (safely) {
	        var name = this.getName() + '.componentWillUnmount()';
	        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          measureLifeCyclePerf(function () {
	            return inst.componentWillUnmount();
	          }, this._debugID, 'componentWillUnmount');
	        } else {
	          inst.componentWillUnmount();
	        }
	      }
	    }
	
	    if (this._renderedComponent) {
	      ReactReconciler.unmountComponent(this._renderedComponent, safely);
	      this._renderedNodeType = null;
	      this._renderedComponent = null;
	      this._instance = null;
	    }
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = 0;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function _maskContext(context) {
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    var maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function _processContext(context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function _processChildContext(currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext;
	
	    if (inst.getChildContext) {
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onBeginProcessingChildContext();
	        try {
	          childContext = inst.getChildContext();
	        } finally {
	          ReactInstrumentation.debugTool.onEndProcessingChildContext();
	        }
	      } else {
	        childContext = inst.getChildContext();
	      }
	    }
	
	    if (childContext) {
	      !(_typeof(Component.childContextTypes) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkContextTypes(Component.childContextTypes, childContext, 'childContext');
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
	      }
	      return _assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Assert that the context types are valid
	   *
	   * @param {object} typeSpecs Map of context field to a ReactPropType
	   * @param {object} values Runtime values that need to be type-checked
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkContextTypes: function _checkContextTypes(typeSpecs, values, location) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
	    }
	  },
	
	  receiveComponent: function receiveComponent(nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function performUpdateIfNecessary(transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
	    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    } else {
	      this._updateBatchNumber = null;
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function updateComponent(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    var willReceive = false;
	    var nextContext;
	
	    // Determine if the context has changed or not
	    if (this._context === nextUnmaskedContext) {
	      nextContext = inst.context;
	    } else {
	      nextContext = this._processContext(nextUnmaskedContext);
	      willReceive = true;
	    }
	
	    var prevProps = prevParentElement.props;
	    var nextProps = nextParentElement.props;
	
	    // Not a simple state update but a props update
	    if (prevParentElement !== nextParentElement) {
	      willReceive = true;
	    }
	
	    // An update here will schedule an update but immediately set
	    // _pendingStateQueue which will ensure that any state updates gets
	    // immediately reconciled instead of waiting for the next batch.
	    if (willReceive && inst.componentWillReceiveProps) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillReceiveProps(nextProps, nextContext);
	        }, this._debugID, 'componentWillReceiveProps');
	      } else {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	    var shouldUpdate = true;
	
	    if (!this._pendingForceUpdate) {
	      if (inst.shouldComponentUpdate) {
	        if (process.env.NODE_ENV !== 'production') {
	          shouldUpdate = measureLifeCyclePerf(function () {
	            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	          }, this._debugID, 'shouldComponentUpdate');
	        } else {
	          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	        }
	      } else {
	        if (this._compositeType === CompositeTypes.PureClass) {
	          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
	        }
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
	    }
	
	    this._updateBatchNumber = null;
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function _processPendingState(props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = _assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function _performComponentUpdate(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var _this2 = this;
	
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillUpdate(nextProps, nextState, nextContext);
	        }, this._debugID, 'componentWillUpdate');
	      } else {
	        inst.componentWillUpdate(nextProps, nextState, nextContext);
	      }
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(function () {
	          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
	        });
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	      }
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function _updateRenderedComponent(transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	
	    var debugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      debugID = this._debugID;
	    }
	
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
	      ReactReconciler.unmountComponent(prevComponentInstance, false);
	
	      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
	      this._renderedNodeType = nodeType;
	      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	      );
	      this._renderedComponent = child;
	
	      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);
	
	      if (process.env.NODE_ENV !== 'production') {
	        if (debugID !== 0) {
	          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
	          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
	        }
	      }
	
	      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
	    }
	  },
	
	  /**
	   * Overridden in shallow rendering.
	   *
	   * @protected
	   */
	  _replaceNodeWithMarkup: function _replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance) {
	    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function _renderValidatedComponentWithoutOwnerOrContext() {
	    var inst = this._instance;
	    var renderedElement;
	
	    if (process.env.NODE_ENV !== 'production') {
	      renderedElement = measureLifeCyclePerf(function () {
	        return inst.render();
	      }, this._debugID, 'render');
	    } else {
	      renderedElement = inst.render();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (renderedElement === undefined && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedElement = null;
	      }
	    }
	
	    return renderedElement;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function _renderValidatedComponent() {
	    var renderedElement;
	    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
	      ReactCurrentOwner.current = this;
	      try {
	        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    return renderedElement;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function attachRef(ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function detachRef(ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function getName() {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function getPublicInstance() {
	    var inst = this._instance;
	    if (this._compositeType === CompositeTypes.StatelessFunctional) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var React = __webpack_require__(9);
	
	var invariant = __webpack_require__(15);
	
	var ReactNodeTypes = {
	  HOST: 0,
	  COMPOSITE: 1,
	  EMPTY: 2,
	
	  getType: function getType(node) {
	    if (node === null || node === false) {
	      return ReactNodeTypes.EMPTY;
	    } else if (React.isValidElement(node)) {
	      if (typeof node.type === 'function') {
	        return ReactNodeTypes.COMPOSITE;
	      } else {
	        return ReactNodeTypes.HOST;
	      }
	    }
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
	  }
	};
	
	module.exports = ReactNodeTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(42);
	
	var ReactPropTypeLocationNames = __webpack_require__(129);
	var ReactPropTypesSecret = __webpack_require__(117);
	
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(33);
	}
	
	var loggedTypeFailures = {};
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error)) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var componentStackInfo = '';
	
	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(33);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }
	
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}
	
	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 130 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * 
	 */
	
	/*eslint-disable no-self-compare */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Added the nonzero y check to make Flow happy, but it is redundant
	    return x !== 0 || y !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }
	
	  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 131 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement === 'undefined' ? 'undefined' : _typeof(prevElement);
	  var nextType = typeof nextElement === 'undefined' ? 'undefined' : _typeof(nextElement);
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ },
/* 132 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyComponentFactory;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponentFactory: function injectEmptyComponentFactory(factory) {
	    emptyComponentFactory = factory;
	  }
	};
	
	var ReactEmptyComponent = {
	  create: function create(instantiate) {
	    return emptyComponentFactory(instantiate);
	  }
	};
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);
	
	var invariant = __webpack_require__(15);
	
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around host tags.
	var tagToComponentClass = {};
	var textComponentClass = null;
	
	var ReactHostComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function injectGenericComponentClass(componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function injectTextComponentClass(componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function injectComponentClasses(componentClasses) {
	    _assign(tagToComponentClass, componentClasses);
	  }
	};
	
	/**
	 * Get a host internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
	  return new genericComponentClass(element);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactHostComponent = {
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactHostComponentInjection
	};
	
	module.exports = ReactHostComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 134 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var nextDebugID = 1;
	
	function getNextDebugID() {
	  return nextDebugID++;
	}
	
	module.exports = getNextDebugID;

/***/ },
/* 135 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */
	
	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });
	
	  return '$' + escapedString;
	}
	
	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
	
	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}
	
	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};
	
	module.exports = KeyEscapeUtils;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(42);
	
	var ReactCurrentOwner = __webpack_require__(17);
	var REACT_ELEMENT_TYPE = __webpack_require__(137);
	
	var getIteratorFn = __webpack_require__(138);
	var invariant = __webpack_require__(15);
	var KeyEscapeUtils = __webpack_require__(135);
	var warning = __webpack_require__(18);
	
	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';
	
	/**
	 * This is inlined from ReactElement since this file is shared between
	 * isomorphic and renderers. We could extract this to a
	 *
	 */
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var didWarnAboutMaps = false;
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && (typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' ||
	  // The following is inlined from ReactElement. This means we can optimize
	  // some checks. React Fiber also inlines this logic for similar purposes.
	  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 137 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	module.exports = REACT_ELEMENT_TYPE;

/***/ },
/* 138 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var KeyEscapeUtils = __webpack_require__(135);
	var traverseAllChildren = __webpack_require__(136);
	var warning = __webpack_require__(18);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(33);
	}
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 * @param {number=} selfDebugID Optional debugID of the current internal instance.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
	  // We found a component instance.
	  if (traverseContext && (typeof traverseContext === 'undefined' ? 'undefined' : _typeof(traverseContext)) === 'object') {
	    var result = traverseContext;
	    var keyUnique = result[name] === undefined;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!ReactComponentTreeHook) {
	        ReactComponentTreeHook = __webpack_require__(33);
	      }
	      if (!keyUnique) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	      }
	    }
	    if (keyUnique && child != null) {
	      result[name] = child;
	    }
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children, selfDebugID) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	
	  if (process.env.NODE_ENV !== 'production') {
	    traverseAllChildren(children, function (traverseContext, child, name) {
	      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
	    }, result);
	  } else {
	    traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  }
	  return result;
	}
	
	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var PooledClass = __webpack_require__(57);
	var Transaction = __webpack_require__(75);
	var ReactInstrumentation = __webpack_require__(69);
	var ReactServerUpdateQueue = __webpack_require__(141);
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	var noopCallbackQueue = {
	  enqueue: function enqueue() {}
	};
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.useCreateElement = false;
	  this.updateQueue = new ReactServerUpdateQueue(this);
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function getReactMountReady() {
	    return noopCallbackQueue;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function getUpdateQueue() {
	    return this.updateQueue;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function destructor() {},
	
	  checkpoint: function checkpoint() {},
	
	  rollback: function rollback() {}
	};
	
	_assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	var ReactUpdateQueue = __webpack_require__(142);
	
	var warning = __webpack_require__(18);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the update queue used for server rendering.
	 * It delegates to ReactUpdateQueue while server rendering is in progress and
	 * switches to ReactNoopUpdateQueue after the transaction has completed.
	 * @class ReactServerUpdateQueue
	 * @param {Transaction} transaction
	 */
	
	var ReactServerUpdateQueue = function () {
	  function ReactServerUpdateQueue(transaction) {
	    _classCallCheck(this, ReactServerUpdateQueue);
	
	    this.transaction = transaction;
	  }
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	
	  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
	    return false;
	  };
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
	    }
	  };
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
	    } else {
	      warnNoop(publicInstance, 'forceUpdate');
	    }
	  };
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} completeState Next state.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
	    } else {
	      warnNoop(publicInstance, 'replaceState');
	    }
	  };
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} partialState Next partial state to be merged with state.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
	    } else {
	      warnNoop(publicInstance, 'setState');
	    }
	  };
	
	  return ReactServerUpdateQueue;
	}();
	
	module.exports = ReactServerUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(42);
	
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactInstanceMap = __webpack_require__(123);
	var ReactInstrumentation = __webpack_require__(69);
	var ReactUpdates = __webpack_require__(63);
	
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function formatUnexpectedArgument(arg) {
	  var type = typeof arg === 'undefined' ? 'undefined' : _typeof(arg);
	  if (type !== 'object') {
	    return type;
	  }
	  var displayName = arg.constructor && arg.constructor.name || type;
	  var keys = Object.keys(arg);
	  if (keys.length > 0 && keys.length < 20) {
	    return displayName + ' (keys: ' + keys.join(', ') + ')';
	  }
	  return displayName;
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var ctor = publicInstance.constructor;
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
	    }
	    return null;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted(publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @param {string} callerName Name of the calling function in the public API.
	   * @internal
	   */
	  enqueueCallback: function enqueueCallback(publicInstance, callback, callerName) {
	    ReactUpdateQueue.validateCallback(callback, callerName);
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function enqueueCallbackInternal(internalInstance, callback) {
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onSetState();
	      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
	    }
	
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueElementInternal: function enqueueElementInternal(internalInstance, nextElement, nextContext) {
	    internalInstance._pendingElement = nextElement;
	    // TODO: introduce _pendingContext instead of setting it directly.
	    internalInstance._context = nextContext;
	    enqueueUpdate(internalInstance);
	  },
	
	  validateCallback: function validateCallback(callback, callerName) {
	    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
	  }
	
	};
	
	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var emptyFunction = __webpack_require__(19);
	var warning = __webpack_require__(18);
	
	var validateDOMNesting = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    current: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function updatedAncestorInfo(oldInfo, tag, instance) {
	    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.current = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function isTagValidWithParent(tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	      case '#document':
	        return tag === 'html';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'body':
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'html':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function findInvalidAncestorForTag(tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	
	      case 'pre':
	      case 'listing':
	
	      case 'table':
	
	      case 'hr':
	
	      case 'xmp':
	
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function findOwnerStack(instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    do {
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function validateDOMNesting(childTag, childText, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    if (childText != null) {
	      process.env.NODE_ENV !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
	      childTag = '#text';
	    }
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      var tagDisplayName = childTag;
	      var whitespaceInfo = '';
	      if (childTag === '#text') {
	        if (/\S/.test(childText)) {
	          tagDisplayName = 'Text nodes';
	        } else {
	          tagDisplayName = 'Whitespace text nodes';
	          whitespaceInfo = ' Make sure you don\'t have any extra whitespace between tags on ' + 'each line of your source code.';
	        }
	      } else {
	        tagDisplayName = '<' + childTag + '>';
	      }
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
	      }
	    }
	  };
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var DOMLazyTree = __webpack_require__(88);
	var ReactDOMComponentTree = __webpack_require__(41);
	
	var ReactDOMEmptyComponent = function ReactDOMEmptyComponent(instantiate) {
	  // ReactCompositeComponent uses this:
	  this._currentElement = null;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	  this._hostContainerInfo = null;
	  this._domID = 0;
	};
	_assign(ReactDOMEmptyComponent.prototype, {
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    var domID = hostContainerInfo._idCounter++;
	    this._domID = domID;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var nodeValue = ' react-empty: ' + this._domID + ' ';
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var node = ownerDocument.createComment(nodeValue);
	      ReactDOMComponentTree.precacheNode(this, node);
	      return DOMLazyTree(node);
	    } else {
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd insert a comment node, but since this is a situation
	        // where React won't take over (static pages), we can simply return
	        // nothing.
	        return '';
	      }
	      return '<!--' + nodeValue + '-->';
	    }
	  },
	  receiveComponent: function receiveComponent() {},
	  getHostNode: function getHostNode() {
	    return ReactDOMComponentTree.getNodeFromInstance(this);
	  },
	  unmountComponent: function unmountComponent() {
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});
	
	module.exports = ReactDOMEmptyComponent;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var invariant = __webpack_require__(15);
	
	/**
	 * Return the lowest common ancestor of A and B, or null if they are in
	 * different trees.
	 */
	function getLowestCommonAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  var depthA = 0;
	  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
	    depthA++;
	  }
	  var depthB = 0;
	  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
	    depthB++;
	  }
	
	  // If A is deeper, crawl up.
	  while (depthA - depthB > 0) {
	    instA = instA._hostParent;
	    depthA--;
	  }
	
	  // If B is deeper, crawl up.
	  while (depthB - depthA > 0) {
	    instB = instB._hostParent;
	    depthB--;
	  }
	
	  // Walk in lockstep until we find a match.
	  var depth = depthA;
	  while (depth--) {
	    if (instA === instB) {
	      return instA;
	    }
	    instA = instA._hostParent;
	    instB = instB._hostParent;
	  }
	  return null;
	}
	
	/**
	 * Return if A is an ancestor of B.
	 */
	function isAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	
	  while (instB) {
	    if (instB === instA) {
	      return true;
	    }
	    instB = instB._hostParent;
	  }
	  return false;
	}
	
	/**
	 * Return the parent instance of the passed-in instance.
	 */
	function getParentInstance(inst) {
	  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;
	
	  return inst._hostParent;
	}
	
	/**
	 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	 */
	function traverseTwoPhase(inst, fn, arg) {
	  var path = [];
	  while (inst) {
	    path.push(inst);
	    inst = inst._hostParent;
	  }
	  var i;
	  for (i = path.length; i-- > 0;) {
	    fn(path[i], 'captured', arg);
	  }
	  for (i = 0; i < path.length; i++) {
	    fn(path[i], 'bubbled', arg);
	  }
	}
	
	/**
	 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	 * should would receive a `mouseEnter` or `mouseLeave` event.
	 *
	 * Does not invoke the callback on the nearest common ancestor because nothing
	 * "entered" or "left" that element.
	 */
	function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	  var common = from && to ? getLowestCommonAncestor(from, to) : null;
	  var pathFrom = [];
	  while (from && from !== common) {
	    pathFrom.push(from);
	    from = from._hostParent;
	  }
	  var pathTo = [];
	  while (to && to !== common) {
	    pathTo.push(to);
	    to = to._hostParent;
	  }
	  var i;
	  for (i = 0; i < pathFrom.length; i++) {
	    fn(pathFrom[i], 'bubbled', argFrom);
	  }
	  for (i = pathTo.length; i-- > 0;) {
	    fn(pathTo[i], 'captured', argTo);
	  }
	}
	
	module.exports = {
	  isAncestor: isAncestor,
	  getLowestCommonAncestor: getLowestCommonAncestor,
	  getParentInstance: getParentInstance,
	  traverseTwoPhase: traverseTwoPhase,
	  traverseEnterLeave: traverseEnterLeave
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);
	
	var DOMChildrenOperations = __webpack_require__(87);
	var DOMLazyTree = __webpack_require__(88);
	var ReactDOMComponentTree = __webpack_require__(41);
	
	var escapeTextContentForBrowser = __webpack_require__(93);
	var invariant = __webpack_require__(15);
	var validateDOMNesting = __webpack_require__(143);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings between comment nodes so that they
	 * can undergo the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function ReactDOMTextComponent(text) {
	  // TODO: This is really a ReactText (ReactNode), not a ReactElement
	  this._currentElement = text;
	  this._stringText = '' + text;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	
	  // Properties
	  this._domID = 0;
	  this._mountIndex = 0;
	  this._closingComment = null;
	  this._commentNodes = null;
	};
	
	_assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo != null) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(null, this._stringText, this, parentInfo);
	      }
	    }
	
	    var domID = hostContainerInfo._idCounter++;
	    var openingValue = ' react-text: ' + domID + ' ';
	    var closingValue = ' /react-text ';
	    this._domID = domID;
	    this._hostParent = hostParent;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var openingComment = ownerDocument.createComment(openingValue);
	      var closingComment = ownerDocument.createComment(closingValue);
	      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
	      if (this._stringText) {
	        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
	      }
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
	      ReactDOMComponentTree.precacheNode(this, openingComment);
	      this._closingComment = closingComment;
	      return lazyTree;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this between comment nodes for the reasons stated
	        // above, but since this is a situation where React won't take over
	        // (static pages), we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function receiveComponent(nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var commentNodes = this.getHostNode();
	        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
	      }
	    }
	  },
	
	  getHostNode: function getHostNode() {
	    var hostNode = this._commentNodes;
	    if (hostNode) {
	      return hostNode;
	    }
	    if (!this._closingComment) {
	      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
	      var node = openingComment.nextSibling;
	      while (true) {
	        !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
	        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
	          this._closingComment = node;
	          break;
	        }
	        node = node.nextSibling;
	      }
	    }
	    hostNode = [this._hostNode, this._closingComment];
	    this._commentNodes = hostNode;
	    return hostNode;
	  },
	
	  unmountComponent: function unmountComponent() {
	    this._closingComment = null;
	    this._commentNodes = null;
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var ReactUpdates = __webpack_require__(63);
	var Transaction = __webpack_require__(75);
	
	var emptyFunction = __webpack_require__(19);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function close() {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function batchedUpdates(callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      return callback(a, b, c, d, e);
	    } else {
	      return transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var EventListener = __webpack_require__(149);
	var ExecutionEnvironment = __webpack_require__(55);
	var PooledClass = __webpack_require__(57);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactUpdates = __webpack_require__(63);
	
	var getEventTarget = __webpack_require__(76);
	var getUnboundedScrollPosition = __webpack_require__(150);
	
	/**
	 * Find the deepest React component completely containing the root of the
	 * passed-in instance (for use when entire React trees are nested within each
	 * other). If React trees are not nested, returns null.
	 */
	function findParent(inst) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  while (inst._hostParent) {
	    inst = inst._hostParent;
	  }
	  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
	  var container = rootNode.parentNode;
	  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	_assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function destructor() {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
	  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = targetInst;
	  do {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = ancestor && findParent(ancestor);
	  } while (ancestor);
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    targetInst = bookKeeping.ancestors[i];
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function setHandleTopLevel(handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function setEnabled(enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function isEnabled() {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} element Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, element) {
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} element Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, element) {
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function monitorScrollValue(refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function dispatchEvent(topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @typechecks
	 */
	
	var emptyFunction = __webpack_require__(19);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function registerDefault() {}
	};
	
	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 150 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(43);
	var EventPluginHub = __webpack_require__(49);
	var EventPluginUtils = __webpack_require__(51);
	var ReactComponentEnvironment = __webpack_require__(122);
	var ReactEmptyComponent = __webpack_require__(132);
	var ReactBrowserEventEmitter = __webpack_require__(112);
	var ReactHostComponent = __webpack_require__(133);
	var ReactUpdates = __webpack_require__(63);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventPluginUtils: EventPluginUtils.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  HostComponent: ReactHostComponent.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var CallbackQueue = __webpack_require__(64);
	var PooledClass = __webpack_require__(57);
	var ReactBrowserEventEmitter = __webpack_require__(112);
	var ReactInputSelection = __webpack_require__(153);
	var ReactInstrumentation = __webpack_require__(69);
	var Transaction = __webpack_require__(75);
	var ReactUpdateQueue = __webpack_require__(142);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function initialize() {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function close(previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function initialize() {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function close() {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(useCreateElement) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactDOMTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function getReactMountReady() {
	    return this.reactMountReady;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function getUpdateQueue() {
	    return ReactUpdateQueue;
	  },
	
	  /**
	   * Save current transaction state -- if the return value from this method is
	   * passed to `rollback`, the transaction will be reset to that state.
	   */
	  checkpoint: function checkpoint() {
	    // reactMountReady is the our only stateful wrapper
	    return this.reactMountReady.checkpoint();
	  },
	
	  rollback: function rollback(checkpoint) {
	    this.reactMountReady.rollback(checkpoint);
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function destructor() {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	_assign(ReactReconcileTransaction.prototype, Transaction, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(154);
	
	var containsNode = __webpack_require__(156);
	var focusNode = __webpack_require__(101);
	var getActiveElement = __webpack_require__(159);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function hasSelectionCapabilities(elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function getSelectionInformation() {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function restoreSelection(priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function getSelection(input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function setSelection(input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (end === undefined) {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(55);
	
	var getNodeForCharacterOffset = __webpack_require__(155);
	var getTextContentAccessor = __webpack_require__(58);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (offsets.end === undefined) {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programmatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ },
/* 155 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	var isTextNode = __webpack_require__(157);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 */
	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode(outerNode)) {
	    return false;
	  } else if (isTextNode(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if ('contains' in outerNode) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var isNode = __webpack_require__(158);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 158 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 159 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 160 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	// We use attributes for everything SVG so let's avoid some duplication and run
	// code instead.
	// The following are all specified in the HTML config already so we exclude here.
	// - class (as className)
	// - color
	// - height
	// - id
	// - lang
	// - max
	// - media
	// - method
	// - min
	// - name
	// - style
	// - target
	// - type
	// - width
	var ATTRS = {
	  accentHeight: 'accent-height',
	  accumulate: 0,
	  additive: 0,
	  alignmentBaseline: 'alignment-baseline',
	  allowReorder: 'allowReorder',
	  alphabetic: 0,
	  amplitude: 0,
	  arabicForm: 'arabic-form',
	  ascent: 0,
	  attributeName: 'attributeName',
	  attributeType: 'attributeType',
	  autoReverse: 'autoReverse',
	  azimuth: 0,
	  baseFrequency: 'baseFrequency',
	  baseProfile: 'baseProfile',
	  baselineShift: 'baseline-shift',
	  bbox: 0,
	  begin: 0,
	  bias: 0,
	  by: 0,
	  calcMode: 'calcMode',
	  capHeight: 'cap-height',
	  clip: 0,
	  clipPath: 'clip-path',
	  clipRule: 'clip-rule',
	  clipPathUnits: 'clipPathUnits',
	  colorInterpolation: 'color-interpolation',
	  colorInterpolationFilters: 'color-interpolation-filters',
	  colorProfile: 'color-profile',
	  colorRendering: 'color-rendering',
	  contentScriptType: 'contentScriptType',
	  contentStyleType: 'contentStyleType',
	  cursor: 0,
	  cx: 0,
	  cy: 0,
	  d: 0,
	  decelerate: 0,
	  descent: 0,
	  diffuseConstant: 'diffuseConstant',
	  direction: 0,
	  display: 0,
	  divisor: 0,
	  dominantBaseline: 'dominant-baseline',
	  dur: 0,
	  dx: 0,
	  dy: 0,
	  edgeMode: 'edgeMode',
	  elevation: 0,
	  enableBackground: 'enable-background',
	  end: 0,
	  exponent: 0,
	  externalResourcesRequired: 'externalResourcesRequired',
	  fill: 0,
	  fillOpacity: 'fill-opacity',
	  fillRule: 'fill-rule',
	  filter: 0,
	  filterRes: 'filterRes',
	  filterUnits: 'filterUnits',
	  floodColor: 'flood-color',
	  floodOpacity: 'flood-opacity',
	  focusable: 0,
	  fontFamily: 'font-family',
	  fontSize: 'font-size',
	  fontSizeAdjust: 'font-size-adjust',
	  fontStretch: 'font-stretch',
	  fontStyle: 'font-style',
	  fontVariant: 'font-variant',
	  fontWeight: 'font-weight',
	  format: 0,
	  from: 0,
	  fx: 0,
	  fy: 0,
	  g1: 0,
	  g2: 0,
	  glyphName: 'glyph-name',
	  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
	  glyphOrientationVertical: 'glyph-orientation-vertical',
	  glyphRef: 'glyphRef',
	  gradientTransform: 'gradientTransform',
	  gradientUnits: 'gradientUnits',
	  hanging: 0,
	  horizAdvX: 'horiz-adv-x',
	  horizOriginX: 'horiz-origin-x',
	  ideographic: 0,
	  imageRendering: 'image-rendering',
	  'in': 0,
	  in2: 0,
	  intercept: 0,
	  k: 0,
	  k1: 0,
	  k2: 0,
	  k3: 0,
	  k4: 0,
	  kernelMatrix: 'kernelMatrix',
	  kernelUnitLength: 'kernelUnitLength',
	  kerning: 0,
	  keyPoints: 'keyPoints',
	  keySplines: 'keySplines',
	  keyTimes: 'keyTimes',
	  lengthAdjust: 'lengthAdjust',
	  letterSpacing: 'letter-spacing',
	  lightingColor: 'lighting-color',
	  limitingConeAngle: 'limitingConeAngle',
	  local: 0,
	  markerEnd: 'marker-end',
	  markerMid: 'marker-mid',
	  markerStart: 'marker-start',
	  markerHeight: 'markerHeight',
	  markerUnits: 'markerUnits',
	  markerWidth: 'markerWidth',
	  mask: 0,
	  maskContentUnits: 'maskContentUnits',
	  maskUnits: 'maskUnits',
	  mathematical: 0,
	  mode: 0,
	  numOctaves: 'numOctaves',
	  offset: 0,
	  opacity: 0,
	  operator: 0,
	  order: 0,
	  orient: 0,
	  orientation: 0,
	  origin: 0,
	  overflow: 0,
	  overlinePosition: 'overline-position',
	  overlineThickness: 'overline-thickness',
	  paintOrder: 'paint-order',
	  panose1: 'panose-1',
	  pathLength: 'pathLength',
	  patternContentUnits: 'patternContentUnits',
	  patternTransform: 'patternTransform',
	  patternUnits: 'patternUnits',
	  pointerEvents: 'pointer-events',
	  points: 0,
	  pointsAtX: 'pointsAtX',
	  pointsAtY: 'pointsAtY',
	  pointsAtZ: 'pointsAtZ',
	  preserveAlpha: 'preserveAlpha',
	  preserveAspectRatio: 'preserveAspectRatio',
	  primitiveUnits: 'primitiveUnits',
	  r: 0,
	  radius: 0,
	  refX: 'refX',
	  refY: 'refY',
	  renderingIntent: 'rendering-intent',
	  repeatCount: 'repeatCount',
	  repeatDur: 'repeatDur',
	  requiredExtensions: 'requiredExtensions',
	  requiredFeatures: 'requiredFeatures',
	  restart: 0,
	  result: 0,
	  rotate: 0,
	  rx: 0,
	  ry: 0,
	  scale: 0,
	  seed: 0,
	  shapeRendering: 'shape-rendering',
	  slope: 0,
	  spacing: 0,
	  specularConstant: 'specularConstant',
	  specularExponent: 'specularExponent',
	  speed: 0,
	  spreadMethod: 'spreadMethod',
	  startOffset: 'startOffset',
	  stdDeviation: 'stdDeviation',
	  stemh: 0,
	  stemv: 0,
	  stitchTiles: 'stitchTiles',
	  stopColor: 'stop-color',
	  stopOpacity: 'stop-opacity',
	  strikethroughPosition: 'strikethrough-position',
	  strikethroughThickness: 'strikethrough-thickness',
	  string: 0,
	  stroke: 0,
	  strokeDasharray: 'stroke-dasharray',
	  strokeDashoffset: 'stroke-dashoffset',
	  strokeLinecap: 'stroke-linecap',
	  strokeLinejoin: 'stroke-linejoin',
	  strokeMiterlimit: 'stroke-miterlimit',
	  strokeOpacity: 'stroke-opacity',
	  strokeWidth: 'stroke-width',
	  surfaceScale: 'surfaceScale',
	  systemLanguage: 'systemLanguage',
	  tableValues: 'tableValues',
	  targetX: 'targetX',
	  targetY: 'targetY',
	  textAnchor: 'text-anchor',
	  textDecoration: 'text-decoration',
	  textRendering: 'text-rendering',
	  textLength: 'textLength',
	  to: 0,
	  transform: 0,
	  u1: 0,
	  u2: 0,
	  underlinePosition: 'underline-position',
	  underlineThickness: 'underline-thickness',
	  unicode: 0,
	  unicodeBidi: 'unicode-bidi',
	  unicodeRange: 'unicode-range',
	  unitsPerEm: 'units-per-em',
	  vAlphabetic: 'v-alphabetic',
	  vHanging: 'v-hanging',
	  vIdeographic: 'v-ideographic',
	  vMathematical: 'v-mathematical',
	  values: 0,
	  vectorEffect: 'vector-effect',
	  version: 0,
	  vertAdvY: 'vert-adv-y',
	  vertOriginX: 'vert-origin-x',
	  vertOriginY: 'vert-origin-y',
	  viewBox: 'viewBox',
	  viewTarget: 'viewTarget',
	  visibility: 0,
	  widths: 0,
	  wordSpacing: 'word-spacing',
	  writingMode: 'writing-mode',
	  x: 0,
	  xHeight: 'x-height',
	  x1: 0,
	  x2: 0,
	  xChannelSelector: 'xChannelSelector',
	  xlinkActuate: 'xlink:actuate',
	  xlinkArcrole: 'xlink:arcrole',
	  xlinkHref: 'xlink:href',
	  xlinkRole: 'xlink:role',
	  xlinkShow: 'xlink:show',
	  xlinkTitle: 'xlink:title',
	  xlinkType: 'xlink:type',
	  xmlBase: 'xml:base',
	  xmlns: 0,
	  xmlnsXlink: 'xmlns:xlink',
	  xmlLang: 'xml:lang',
	  xmlSpace: 'xml:space',
	  y: 0,
	  y1: 0,
	  y2: 0,
	  yChannelSelector: 'yChannelSelector',
	  z: 0,
	  zoomAndPan: 'zoomAndPan'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {},
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {}
	};
	
	Object.keys(ATTRS).forEach(function (key) {
	  SVGDOMPropertyConfig.Properties[key] = 0;
	  if (ATTRS[key]) {
	    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
	  }
	});
	
	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPropagators = __webpack_require__(48);
	var ExecutionEnvironment = __webpack_require__(55);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactInputSelection = __webpack_require__(153);
	var SyntheticEvent = __webpack_require__(60);
	
	var getActiveElement = __webpack_require__(159);
	var isTextInputElement = __webpack_require__(78);
	var shallowEqual = __webpack_require__(130);
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: 'onSelect',
	      captured: 'onSelectCapture'
	    },
	    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
	  }
	};
	
	var activeElement = null;
	var activeElementInst = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events. See #3639.
	var hasListener = false;
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case 'topFocus':
	        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
	          activeElement = targetNode;
	          activeElementInst = targetInst;
	          lastSelection = null;
	        }
	        break;
	      case 'topBlur':
	        activeElement = null;
	        activeElementInst = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case 'topMouseDown':
	        mouseDown = true;
	        break;
	      case 'topContextMenu':
	      case 'topMouseUp':
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case 'topSelectionChange':
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case 'topKeyDown':
	      case 'topKeyUp':
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function didPutListener(inst, registrationName, listener) {
	    if (registrationName === 'onSelect') {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var EventListener = __webpack_require__(149);
	var EventPropagators = __webpack_require__(48);
	var ReactDOMComponentTree = __webpack_require__(41);
	var SyntheticAnimationEvent = __webpack_require__(163);
	var SyntheticClipboardEvent = __webpack_require__(164);
	var SyntheticEvent = __webpack_require__(60);
	var SyntheticFocusEvent = __webpack_require__(165);
	var SyntheticKeyboardEvent = __webpack_require__(166);
	var SyntheticMouseEvent = __webpack_require__(81);
	var SyntheticDragEvent = __webpack_require__(169);
	var SyntheticTouchEvent = __webpack_require__(170);
	var SyntheticTransitionEvent = __webpack_require__(171);
	var SyntheticUIEvent = __webpack_require__(82);
	var SyntheticWheelEvent = __webpack_require__(172);
	
	var emptyFunction = __webpack_require__(19);
	var getEventCharCode = __webpack_require__(167);
	var invariant = __webpack_require__(15);
	
	/**
	 * Turns
	 * ['abort', ...]
	 * into
	 * eventTypes = {
	 *   'abort': {
	 *     phasedRegistrationNames: {
	 *       bubbled: 'onAbort',
	 *       captured: 'onAbortCapture',
	 *     },
	 *     dependencies: ['topAbort'],
	 *   },
	 *   ...
	 * };
	 * topLevelEventsToDispatchConfig = {
	 *   'topAbort': { sameConfig }
	 * };
	 */
	var eventTypes = {};
	var topLevelEventsToDispatchConfig = {};
	['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
	  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
	  var onEvent = 'on' + capitalizedEvent;
	  var topEvent = 'top' + capitalizedEvent;
	
	  var type = {
	    phasedRegistrationNames: {
	      bubbled: onEvent,
	      captured: onEvent + 'Capture'
	    },
	    dependencies: [topEvent]
	  };
	  eventTypes[event] = type;
	  topLevelEventsToDispatchConfig[topEvent] = type;
	});
	
	var onClickListeners = {};
	
	function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	}
	
	function isInteractive(tag) {
	  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
	}
	
	function shouldPreventMouseEvent(inst) {
	  if (inst) {
	    var disabled = inst._currentElement && inst._currentElement.props.disabled;
	
	    if (disabled) {
	      return isInteractive(inst._tag);
	    }
	  }
	
	  return false;
	}
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case 'topAbort':
	      case 'topCanPlay':
	      case 'topCanPlayThrough':
	      case 'topDurationChange':
	      case 'topEmptied':
	      case 'topEncrypted':
	      case 'topEnded':
	      case 'topError':
	      case 'topInput':
	      case 'topInvalid':
	      case 'topLoad':
	      case 'topLoadedData':
	      case 'topLoadedMetadata':
	      case 'topLoadStart':
	      case 'topPause':
	      case 'topPlay':
	      case 'topPlaying':
	      case 'topProgress':
	      case 'topRateChange':
	      case 'topReset':
	      case 'topSeeked':
	      case 'topSeeking':
	      case 'topStalled':
	      case 'topSubmit':
	      case 'topSuspend':
	      case 'topTimeUpdate':
	      case 'topVolumeChange':
	      case 'topWaiting':
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case 'topKeyPress':
	        // Firefox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case 'topKeyDown':
	      case 'topKeyUp':
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case 'topBlur':
	      case 'topFocus':
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case 'topClick':
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case 'topDoubleClick':
	      case 'topMouseDown':
	      case 'topMouseMove':
	      case 'topMouseUp':
	        // Disabled elements should not respond to mouse events
	        if (shouldPreventMouseEvent(targetInst)) {
	          return null;
	        }
	      /* falls through */
	      case 'topMouseOut':
	      case 'topMouseOver':
	      case 'topContextMenu':
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case 'topDrag':
	      case 'topDragEnd':
	      case 'topDragEnter':
	      case 'topDragExit':
	      case 'topDragLeave':
	      case 'topDragOver':
	      case 'topDragStart':
	      case 'topDrop':
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case 'topTouchCancel':
	      case 'topTouchEnd':
	      case 'topTouchMove':
	      case 'topTouchStart':
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case 'topAnimationEnd':
	      case 'topAnimationIteration':
	      case 'topAnimationStart':
	        EventConstructor = SyntheticAnimationEvent;
	        break;
	      case 'topTransitionEnd':
	        EventConstructor = SyntheticTransitionEvent;
	        break;
	      case 'topScroll':
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case 'topWheel':
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case 'topCopy':
	      case 'topCut':
	      case 'topPaste':
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
	    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function didPutListener(inst, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
	      var key = getDictionaryKey(inst);
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      if (!onClickListeners[key]) {
	        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function willDeleteListener(inst, registrationName) {
	    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
	      var key = getDictionaryKey(inst);
	      onClickListeners[key].remove();
	      delete onClickListeners[key];
	    }
	  }
	
	};
	
	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(60);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
	 */
	var AnimationEventInterface = {
	  animationName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);
	
	module.exports = SyntheticAnimationEvent;

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(60);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function clipboardData(event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(82);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(82);
	
	var getEventCharCode = __webpack_require__(167);
	var getEventKey = __webpack_require__(168);
	var getEventModifierState = __webpack_require__(84);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function charCode(event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function keyCode(event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function which(event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 167 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(167);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(81);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(82);
	
	var getEventModifierState = __webpack_require__(84);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(60);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
	 */
	var TransitionEventInterface = {
	  propertyName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);
	
	module.exports = SyntheticTransitionEvent;

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(81);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function deltaX(event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function deltaY(event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var DOMLazyTree = __webpack_require__(88);
	var DOMProperty = __webpack_require__(43);
	var React = __webpack_require__(9);
	var ReactBrowserEventEmitter = __webpack_require__(112);
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactDOMContainerInfo = __webpack_require__(174);
	var ReactDOMFeatureFlags = __webpack_require__(175);
	var ReactFeatureFlags = __webpack_require__(65);
	var ReactInstanceMap = __webpack_require__(123);
	var ReactInstrumentation = __webpack_require__(69);
	var ReactMarkupChecksum = __webpack_require__(176);
	var ReactReconciler = __webpack_require__(66);
	var ReactUpdateQueue = __webpack_require__(142);
	var ReactUpdates = __webpack_require__(63);
	
	var emptyObject = __webpack_require__(27);
	var instantiateReactComponent = __webpack_require__(125);
	var invariant = __webpack_require__(15);
	var setInnerHTML = __webpack_require__(90);
	var shouldUpdateReactComponent = __webpack_require__(131);
	var warning = __webpack_require__(18);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var instancesByReactRootID = {};
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
	  var markerName;
	  if (ReactFeatureFlags.logTopLevelRenders) {
	    var wrappedElement = wrapperInstance._currentElement.props.child;
	    var type = wrappedElement.type;
	    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
	    console.time(markerName);
	  }
	
	  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
	  );
	
	  if (markerName) {
	    console.timeEnd(markerName);
	  }
	
	  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
	  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */
	  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container, safely) {
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onBeginFlush();
	  }
	  ReactReconciler.unmountComponent(instance, safely);
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onEndFlush();
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  if (rootEl) {
	    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
	    return !!(inst && inst._hostParent);
	  }
	}
	
	/**
	 * True if the supplied DOM node is a React DOM element and
	 * it has been rendered by another copy of React.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM has been rendered by another copy of React
	 * @internal
	 */
	function nodeIsRenderedByOtherInstance(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
	}
	
	/**
	 * True if the supplied DOM node is a valid node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid DOM node.
	 * @internal
	 */
	function isValidContainer(node) {
	  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
	}
	
	/**
	 * True if the supplied DOM node is a valid React node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid React DOM node.
	 * @internal
	 */
	function isReactNode(node) {
	  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
	}
	
	function getHostRootInstanceInContainer(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
	  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
	}
	
	function getTopLevelWrapperInContainer(container) {
	  var root = getHostRootInstanceInContainer(container);
	  return root ? root._hostContainerInfo._topLevelWrapper : null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var topLevelRootCounter = 1;
	var TopLevelWrapper = function TopLevelWrapper() {
	  this.rootID = topLevelRootCounter++;
	};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  return this.props.child;
	};
	TopLevelWrapper.isReactTopLevelWrapper = true;
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	
	  TopLevelWrapper: TopLevelWrapper,
	
	  /**
	   * Used by devtools. The keys are not important.
	   */
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function scrollMonitor(container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function _updateRootComponent(prevComponent, nextElement, nextContext, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    return prevComponent;
	  },
	
	  /**
	   * Render a new component into the DOM. Hooked by hooks!
	   *
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function _renderNewRootComponent(nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	    var componentInstance = instantiateReactComponent(nextElement, false);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);
	
	    var wrapperID = componentInstance._instance.rootID;
	    instancesByReactRootID[wrapperID] = componentInstance;
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function _renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
	    !React.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;
	
	    var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });
	
	    var nextContext;
	    if (parentComponent) {
	      var parentInst = ReactInstanceMap.get(parentComponent);
	      nextContext = parentInst._processChildContext(parentInst._context);
	    } else {
	      nextContext = emptyObject;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props.child;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function render(nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function unmountComponentAtNode(container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	    if (!prevComponent) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
	      }
	
	      return false;
	    }
	    delete instancesByReactRootID[prevComponent._instance.rootID];
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
	    return true;
	  },
	
	  _mountImageIntoNode: function _mountImageIntoNode(markup, container, instance, shouldReuseMarkup, transaction) {
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        ReactDOMComponentTree.precacheNode(instance, rootElement);
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;
	
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      DOMLazyTree.insertTreeBefore(container, markup, null);
	    } else {
	      setInnerHTML(container, markup);
	      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
	      if (hostNode._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation({
	          instanceID: hostNode._debugID,
	          type: 'mount',
	          payload: markup.toString()
	        });
	      }
	    }
	  }
	};
	
	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var validateDOMNesting = __webpack_require__(143);
	
	var DOC_NODE_TYPE = 9;
	
	function ReactDOMContainerInfo(topLevelWrapper, node) {
	  var info = {
	    _topLevelWrapper: topLevelWrapper,
	    _idCounter: 1,
	    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
	    _node: node,
	    _tag: node ? node.nodeName.toLowerCase() : null,
	    _namespaceURI: node ? node.namespaceURI : null
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
	  }
	  return info;
	}
	
	module.exports = ReactDOMContainerInfo;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 175 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: true,
	  useFiber: false
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(177);
	
	var TAG_END = /\/?>/;
	var COMMENT_START = /^<\!\-\-/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function addChecksumToMarkup(markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags, comments and self-closing tags)
	    if (COMMENT_START.test(markup)) {
	      return markup;
	    } else {
	      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	    }
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function canReuseMarkup(markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ },
/* 177 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    var n = Math.min(i + 4096, m);
	    for (; i < n; i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ },
/* 178 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	module.exports = '15.4.0';

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactInstanceMap = __webpack_require__(123);
	
	var getHostComponentFromComposite = __webpack_require__(180);
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	
	  var inst = ReactInstanceMap.get(componentOrElement);
	  if (inst) {
	    inst = getHostComponentFromComposite(inst);
	    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
	  }
	
	  if (typeof componentOrElement.render === 'function') {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
	  }
	}
	
	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactNodeTypes = __webpack_require__(127);
	
	function getHostComponentFromComposite(inst) {
	  var type;
	
	  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
	    inst = inst._renderedComponent;
	  }
	
	  if (type === ReactNodeTypes.HOST) {
	    return inst._renderedComponent;
	  } else if (type === ReactNodeTypes.EMPTY) {
	    return null;
	  }
	}
	
	module.exports = getHostComponentFromComposite;

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactMount = __webpack_require__(173);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(43);
	var EventPluginRegistry = __webpack_require__(50);
	var ReactComponentTreeHook = __webpack_require__(33);
	
	var warning = __webpack_require__(18);
	
	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true,
	
	    autoFocus: true,
	    defaultValue: true,
	    valueLink: true,
	    defaultChecked: true,
	    checkedLink: true,
	    innerHTML: true,
	    suppressContentEditableWarning: true,
	    onFocusIn: true,
	    onFocusOut: true
	  };
	  var warnedProperties = {};
	
	  var validateProperty = function validateProperty(tagName, name, debugID) {
	    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
	      return true;
	    }
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return true;
	    }
	    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
	      return true;
	    }
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;
	
	    if (standardName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else if (registrationName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else {
	      // We were unable to guess which prop the user intended.
	      // It is likely that the user was just blindly spreading/forwarding props
	      // Components should be careful to only render valid props/attributes.
	      // Warning will be invoked in warnUnknownProperties to allow grouping.
	      return false;
	    }
	  };
	}
	
	var warnUnknownProperties = function warnUnknownProperties(debugID, element) {
	  var unknownProps = [];
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      unknownProps.push(key);
	    }
	  }
	
	  var unknownPropString = unknownProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');
	
	  if (unknownProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (unknownProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	};
	
	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	  warnUnknownProperties(debugID, element);
	}
	
	var ReactDOMUnknownPropertyHook = {
	  onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMUnknownPropertyHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactComponentTreeHook = __webpack_require__(33);
	
	var warning = __webpack_require__(18);
	
	var didWarnValueNull = false;
	
	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
	    return;
	  }
	  if (element.props != null && element.props.value === null && !didWarnValueNull) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	
	    didWarnValueNull = true;
	  }
	}
	
	var ReactDOMNullInputValuePropHook = {
	  onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMNullInputValuePropHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(43);
	var ReactComponentTreeHook = __webpack_require__(33);
	
	var warning = __webpack_require__(18);
	
	var warnedProperties = {};
	var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	
	function validateProperty(tagName, name, debugID) {
	  if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	    return true;
	  }
	
	  if (rARIA.test(name)) {
	    var lowerCasedName = name.toLowerCase();
	    var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    // If this is an aria-* attribute, but is not listed in the known DOM
	    // DOM properties, then it is an invalid aria-* attribute.
	    if (standardName == null) {
	      warnedProperties[name] = true;
	      return false;
	    }
	    // aria-* attributes should be lowercase; suggest the lowercase version.
	    if (name !== standardName) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      warnedProperties[name] = true;
	      return true;
	    }
	  }
	
	  return true;
	}
	
	function warnInvalidARIAProps(debugID, element) {
	  var invalidProps = [];
	
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      invalidProps.push(key);
	    }
	  }
	
	  var unknownPropString = invalidProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');
	
	  if (invalidProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (invalidProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	}
	
	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	
	  warnInvalidARIAProps(debugID, element);
	}
	
	var ReactDOMInvalidARIAHook = {
	  onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {
	    if (process.env.NODE_ENV !== 'production') {
	      handleElement(debugID, element);
	    }
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	    if (process.env.NODE_ENV !== 'production') {
	      handleElement(debugID, element);
	    }
	  }
	};
	
	module.exports = ReactDOMInvalidARIAHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.createMemoryHistory = exports.hashHistory = exports.browserHistory = exports.applyRouterMiddleware = exports.formatPattern = exports.useRouterHistory = exports.match = exports.routerShape = exports.locationShape = exports.RouterContext = exports.createRoutes = exports.Route = exports.Redirect = exports.IndexRoute = exports.IndexRedirect = exports.withRouter = exports.IndexLink = exports.Link = exports.Router = undefined;
	
	var _RouteUtils = __webpack_require__(186);
	
	Object.defineProperty(exports, 'createRoutes', {
	  enumerable: true,
	  get: function get() {
	    return _RouteUtils.createRoutes;
	  }
	});
	
	var _PropTypes = __webpack_require__(187);
	
	Object.defineProperty(exports, 'locationShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes.locationShape;
	  }
	});
	Object.defineProperty(exports, 'routerShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes.routerShape;
	  }
	});
	
	var _PatternUtils = __webpack_require__(188);
	
	Object.defineProperty(exports, 'formatPattern', {
	  enumerable: true,
	  get: function get() {
	    return _PatternUtils.formatPattern;
	  }
	});
	
	var _Router2 = __webpack_require__(190);
	
	var _Router3 = _interopRequireDefault(_Router2);
	
	var _Link2 = __webpack_require__(206);
	
	var _Link3 = _interopRequireDefault(_Link2);
	
	var _IndexLink2 = __webpack_require__(207);
	
	var _IndexLink3 = _interopRequireDefault(_IndexLink2);
	
	var _withRouter2 = __webpack_require__(208);
	
	var _withRouter3 = _interopRequireDefault(_withRouter2);
	
	var _IndexRedirect2 = __webpack_require__(210);
	
	var _IndexRedirect3 = _interopRequireDefault(_IndexRedirect2);
	
	var _IndexRoute2 = __webpack_require__(212);
	
	var _IndexRoute3 = _interopRequireDefault(_IndexRoute2);
	
	var _Redirect2 = __webpack_require__(211);
	
	var _Redirect3 = _interopRequireDefault(_Redirect2);
	
	var _Route2 = __webpack_require__(213);
	
	var _Route3 = _interopRequireDefault(_Route2);
	
	var _RouterContext2 = __webpack_require__(202);
	
	var _RouterContext3 = _interopRequireDefault(_RouterContext2);
	
	var _match2 = __webpack_require__(214);
	
	var _match3 = _interopRequireDefault(_match2);
	
	var _useRouterHistory2 = __webpack_require__(227);
	
	var _useRouterHistory3 = _interopRequireDefault(_useRouterHistory2);
	
	var _applyRouterMiddleware2 = __webpack_require__(228);
	
	var _applyRouterMiddleware3 = _interopRequireDefault(_applyRouterMiddleware2);
	
	var _browserHistory2 = __webpack_require__(229);
	
	var _browserHistory3 = _interopRequireDefault(_browserHistory2);
	
	var _hashHistory2 = __webpack_require__(237);
	
	var _hashHistory3 = _interopRequireDefault(_hashHistory2);
	
	var _createMemoryHistory2 = __webpack_require__(216);
	
	var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.Router = _Router3.default; /* components */
	
	exports.Link = _Link3.default;
	exports.IndexLink = _IndexLink3.default;
	exports.withRouter = _withRouter3.default;
	
	/* components (configuration) */
	
	exports.IndexRedirect = _IndexRedirect3.default;
	exports.IndexRoute = _IndexRoute3.default;
	exports.Redirect = _Redirect3.default;
	exports.Route = _Route3.default;
	
	/* utils */
	
	exports.RouterContext = _RouterContext3.default;
	exports.match = _match3.default;
	exports.useRouterHistory = _useRouterHistory3.default;
	exports.applyRouterMiddleware = _applyRouterMiddleware3.default;
	
	/* histories */
	
	exports.browserHistory = _browserHistory3.default;
	exports.hashHistory = _hashHistory3.default;
	exports.createMemoryHistory = _createMemoryHistory3.default;

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.isReactChildren = isReactChildren;
	exports.createRouteFromReactElement = createRouteFromReactElement;
	exports.createRoutesFromReactChildren = createRoutesFromReactChildren;
	exports.createRoutes = createRoutes;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function isValidChild(object) {
	  return object == null || _react2.default.isValidElement(object);
	}
	
	function isReactChildren(object) {
	  return isValidChild(object) || Array.isArray(object) && object.every(isValidChild);
	}
	
	function createRoute(defaultProps, props) {
	  return _extends({}, defaultProps, props);
	}
	
	function createRouteFromReactElement(element) {
	  var type = element.type;
	  var route = createRoute(type.defaultProps, element.props);
	
	  if (route.children) {
	    var childRoutes = createRoutesFromReactChildren(route.children, route);
	
	    if (childRoutes.length) route.childRoutes = childRoutes;
	
	    delete route.children;
	  }
	
	  return route;
	}
	
	/**
	 * Creates and returns a routes object from the given ReactChildren. JSX
	 * provides a convenient way to visualize how routes in the hierarchy are
	 * nested.
	 *
	 *   import { Route, createRoutesFromReactChildren } from 'react-router'
	 *
	 *   const routes = createRoutesFromReactChildren(
	 *     <Route component={App}>
	 *       <Route path="home" component={Dashboard}/>
	 *       <Route path="news" component={NewsFeed}/>
	 *     </Route>
	 *   )
	 *
	 * Note: This method is automatically used when you provide <Route> children
	 * to a <Router> component.
	 */
	function createRoutesFromReactChildren(children, parentRoute) {
	  var routes = [];
	
	  _react2.default.Children.forEach(children, function (element) {
	    if (_react2.default.isValidElement(element)) {
	      // Component classes may have a static create* method.
	      if (element.type.createRouteFromReactElement) {
	        var route = element.type.createRouteFromReactElement(element, parentRoute);
	
	        if (route) routes.push(route);
	      } else {
	        routes.push(createRouteFromReactElement(element));
	      }
	    }
	  });
	
	  return routes;
	}
	
	/**
	 * Creates and returns an array of routes from the given object which
	 * may be a JSX route, a plain object route, or an array of either.
	 */
	function createRoutes(routes) {
	  if (isReactChildren(routes)) {
	    routes = createRoutesFromReactChildren(routes);
	  } else if (routes && !Array.isArray(routes)) {
	    routes = [routes];
	  }
	
	  return routes;
	}

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.locationShape = exports.routerShape = undefined;
	
	var _react = __webpack_require__(8);
	
	var func = _react.PropTypes.func,
	    object = _react.PropTypes.object,
	    shape = _react.PropTypes.shape,
	    string = _react.PropTypes.string;
	var routerShape = exports.routerShape = shape({
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired,
	  setRouteLeaveHook: func.isRequired,
	  isActive: func.isRequired
	});
	
	var locationShape = exports.locationShape = shape({
	  pathname: string.isRequired,
	  search: string.isRequired,
	  state: object,
	  action: string.isRequired,
	  key: string
	});

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compilePattern = compilePattern;
	exports.matchPattern = matchPattern;
	exports.getParamNames = getParamNames;
	exports.getParams = getParams;
	exports.formatPattern = formatPattern;
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function escapeRegExp(string) {
	  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
	}
	
	function _compilePattern(pattern) {
	  var regexpSource = '';
	  var paramNames = [];
	  var tokens = [];
	
	  var match = void 0,
	      lastIndex = 0,
	      matcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\*\*|\*|\(|\)/g;
	  while (match = matcher.exec(pattern)) {
	    if (match.index !== lastIndex) {
	      tokens.push(pattern.slice(lastIndex, match.index));
	      regexpSource += escapeRegExp(pattern.slice(lastIndex, match.index));
	    }
	
	    if (match[1]) {
	      regexpSource += '([^/]+)';
	      paramNames.push(match[1]);
	    } else if (match[0] === '**') {
	      regexpSource += '(.*)';
	      paramNames.push('splat');
	    } else if (match[0] === '*') {
	      regexpSource += '(.*?)';
	      paramNames.push('splat');
	    } else if (match[0] === '(') {
	      regexpSource += '(?:';
	    } else if (match[0] === ')') {
	      regexpSource += ')?';
	    }
	
	    tokens.push(match[0]);
	
	    lastIndex = matcher.lastIndex;
	  }
	
	  if (lastIndex !== pattern.length) {
	    tokens.push(pattern.slice(lastIndex, pattern.length));
	    regexpSource += escapeRegExp(pattern.slice(lastIndex, pattern.length));
	  }
	
	  return {
	    pattern: pattern,
	    regexpSource: regexpSource,
	    paramNames: paramNames,
	    tokens: tokens
	  };
	}
	
	var CompiledPatternsCache = Object.create(null);
	
	function compilePattern(pattern) {
	  if (!CompiledPatternsCache[pattern]) CompiledPatternsCache[pattern] = _compilePattern(pattern);
	
	  return CompiledPatternsCache[pattern];
	}
	
	/**
	 * Attempts to match a pattern on the given pathname. Patterns may use
	 * the following special characters:
	 *
	 * - :paramName     Matches a URL segment up to the next /, ?, or #. The
	 *                  captured string is considered a "param"
	 * - ()             Wraps a segment of the URL that is optional
	 * - *              Consumes (non-greedy) all characters up to the next
	 *                  character in the pattern, or to the end of the URL if
	 *                  there is none
	 * - **             Consumes (greedy) all characters up to the next character
	 *                  in the pattern, or to the end of the URL if there is none
	 *
	 *  The function calls callback(error, matched) when finished.
	 * The return value is an object with the following properties:
	 *
	 * - remainingPathname
	 * - paramNames
	 * - paramValues
	 */
	function matchPattern(pattern, pathname) {
	  // Ensure pattern starts with leading slash for consistency with pathname.
	  if (pattern.charAt(0) !== '/') {
	    pattern = '/' + pattern;
	  }
	
	  var _compilePattern2 = compilePattern(pattern),
	      regexpSource = _compilePattern2.regexpSource,
	      paramNames = _compilePattern2.paramNames,
	      tokens = _compilePattern2.tokens;
	
	  if (pattern.charAt(pattern.length - 1) !== '/') {
	    regexpSource += '/?'; // Allow optional path separator at end.
	  }
	
	  // Special-case patterns like '*' for catch-all routes.
	  if (tokens[tokens.length - 1] === '*') {
	    regexpSource += '$';
	  }
	
	  var match = pathname.match(new RegExp('^' + regexpSource, 'i'));
	  if (match == null) {
	    return null;
	  }
	
	  var matchedPath = match[0];
	  var remainingPathname = pathname.substr(matchedPath.length);
	
	  if (remainingPathname) {
	    // Require that the match ends at a path separator, if we didn't match
	    // the full path, so any remaining pathname is a new path segment.
	    if (matchedPath.charAt(matchedPath.length - 1) !== '/') {
	      return null;
	    }
	
	    // If there is a remaining pathname, treat the path separator as part of
	    // the remaining pathname for properly continuing the match.
	    remainingPathname = '/' + remainingPathname;
	  }
	
	  return {
	    remainingPathname: remainingPathname,
	    paramNames: paramNames,
	    paramValues: match.slice(1).map(function (v) {
	      return v && decodeURIComponent(v);
	    })
	  };
	}
	
	function getParamNames(pattern) {
	  return compilePattern(pattern).paramNames;
	}
	
	function getParams(pattern, pathname) {
	  var match = matchPattern(pattern, pathname);
	  if (!match) {
	    return null;
	  }
	
	  var paramNames = match.paramNames,
	      paramValues = match.paramValues;
	
	  var params = {};
	
	  paramNames.forEach(function (paramName, index) {
	    params[paramName] = paramValues[index];
	  });
	
	  return params;
	}
	
	/**
	 * Returns a version of the given pattern with params interpolated. Throws
	 * if there is a dynamic segment of the pattern for which there is no param.
	 */
	function formatPattern(pattern, params) {
	  params = params || {};
	
	  var _compilePattern3 = compilePattern(pattern),
	      tokens = _compilePattern3.tokens;
	
	  var parenCount = 0,
	      pathname = '',
	      splatIndex = 0,
	      parenHistory = [];
	
	  var token = void 0,
	      paramName = void 0,
	      paramValue = void 0;
	  for (var i = 0, len = tokens.length; i < len; ++i) {
	    token = tokens[i];
	
	    if (token === '*' || token === '**') {
	      paramValue = Array.isArray(params.splat) ? params.splat[splatIndex++] : params.splat;
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing splat #%s for path "%s"', splatIndex, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue != null) pathname += encodeURI(paramValue);
	    } else if (token === '(') {
	      parenHistory[parenCount] = '';
	      parenCount += 1;
	    } else if (token === ')') {
	      var parenText = parenHistory.pop();
	      parenCount -= 1;
	
	      if (parenCount) parenHistory[parenCount - 1] += parenText;else pathname += parenText;
	    } else if (token.charAt(0) === ':') {
	      paramName = token.substring(1);
	      paramValue = params[paramName];
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing "%s" parameter for path "%s"', paramName, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue == null) {
	        if (parenCount) {
	          parenHistory[parenCount - 1] = '';
	
	          var curTokenIdx = tokens.indexOf(token);
	          var tokensSubset = tokens.slice(curTokenIdx, tokens.length);
	          var nextParenIdx = -1;
	
	          for (var _i = 0; _i < tokensSubset.length; _i++) {
	            if (tokensSubset[_i] == ')') {
	              nextParenIdx = _i;
	              break;
	            }
	          }
	
	          !(nextParenIdx > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Path "%s" is missing end paren at segment "%s"', pattern, tokensSubset.join('')) : (0, _invariant2.default)(false) : void 0;
	
	          // jump to ending paren
	          i = curTokenIdx + nextParenIdx - 1;
	        }
	      } else if (parenCount) parenHistory[parenCount - 1] += encodeURIComponent(paramValue);else pathname += encodeURIComponent(paramValue);
	    } else {
	      if (parenCount) parenHistory[parenCount - 1] += token;else pathname += token;
	    }
	  }
	
	  !(parenCount <= 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Path "%s" is missing end paren', pattern) : (0, _invariant2.default)(false) : void 0;
	
	  return pathname.replace(/\/+/g, '/');
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _createTransitionManager2 = __webpack_require__(191);
	
	var _createTransitionManager3 = _interopRequireDefault(_createTransitionManager2);
	
	var _InternalPropTypes = __webpack_require__(201);
	
	var _RouterContext = __webpack_require__(202);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _RouteUtils = __webpack_require__(186);
	
	var _RouterUtils = __webpack_require__(205);
	
	var _routerWarning = __webpack_require__(192);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	var _React$PropTypes = _react2.default.PropTypes,
	    func = _React$PropTypes.func,
	    object = _React$PropTypes.object;
	
	/**
	 * A <Router> is a high-level API for automatically setting up
	 * a router that renders a <RouterContext> with all the props
	 * it needs each time the URL changes.
	 */
	
	var Router = _react2.default.createClass({
	  displayName: 'Router',
	
	  propTypes: {
	    history: object,
	    children: _InternalPropTypes.routes,
	    routes: _InternalPropTypes.routes, // alias for children
	    render: func,
	    createElement: func,
	    onError: func,
	    onUpdate: func,
	
	    // PRIVATE: For client-side rehydration of server match.
	    matchContext: object
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      render: function render(props) {
	        return _react2.default.createElement(_RouterContext2.default, props);
	      }
	    };
	  },
	  getInitialState: function getInitialState() {
	    return {
	      location: null,
	      routes: null,
	      params: null,
	      components: null
	    };
	  },
	  handleError: function handleError(error) {
	    if (this.props.onError) {
	      this.props.onError.call(this, error);
	    } else {
	      // Throw errors by default so we don't silently swallow them!
	      throw error; // This error probably occurred in getChildRoutes or getComponents.
	    }
	  },
	  createRouterObject: function createRouterObject(state) {
	    var matchContext = this.props.matchContext;
	
	    if (matchContext) {
	      return matchContext.router;
	    }
	
	    var history = this.props.history;
	
	    return (0, _RouterUtils.createRouterObject)(history, this.transitionManager, state);
	  },
	  createTransitionManager: function createTransitionManager() {
	    var matchContext = this.props.matchContext;
	
	    if (matchContext) {
	      return matchContext.transitionManager;
	    }
	
	    var history = this.props.history;
	    var _props = this.props,
	        routes = _props.routes,
	        children = _props.children;
	
	    !history.getCurrentLocation ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You have provided a history object created with history v2.x or ' + 'earlier. This version of React Router is only compatible with v3 ' + 'history objects. Please upgrade to history v3.x.') : (0, _invariant2.default)(false) : void 0;
	
	    return (0, _createTransitionManager3.default)(history, (0, _RouteUtils.createRoutes)(routes || children));
	  },
	  componentWillMount: function componentWillMount() {
	    var _this = this;
	
	    this.transitionManager = this.createTransitionManager();
	    this.router = this.createRouterObject(this.state);
	
	    this._unlisten = this.transitionManager.listen(function (error, state) {
	      if (error) {
	        _this.handleError(error);
	      } else {
	        // Keep the identity of this.router because of a caveat in ContextUtils:
	        // they only work if the object identity is preserved.
	        (0, _RouterUtils.assignRouterState)(_this.router, state);
	        _this.setState(state, _this.props.onUpdate);
	      }
	    });
	  },
	
	  /* istanbul ignore next: sanity check */
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(nextProps.history === this.props.history, 'You cannot change <Router history>; it will be ignored') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)((nextProps.routes || nextProps.children) === (this.props.routes || this.props.children), 'You cannot change <Router routes>; it will be ignored') : void 0;
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlisten) this._unlisten();
	  },
	  render: function render() {
	    var _state = this.state,
	        location = _state.location,
	        routes = _state.routes,
	        params = _state.params,
	        components = _state.components;
	
	    var _props2 = this.props,
	        createElement = _props2.createElement,
	        render = _props2.render,
	        props = _objectWithoutProperties(_props2, ['createElement', 'render']);
	
	    if (location == null) return null; // Async match
	
	    // Only forward non-Router-specific props to routing context, as those are
	    // the only ones that might be custom routing context props.
	    Object.keys(Router.propTypes).forEach(function (propType) {
	      return delete props[propType];
	    });
	
	    return render(_extends({}, props, {
	      router: this.router,
	      location: location,
	      routes: routes,
	      params: params,
	      components: components,
	      createElement: createElement
	    }));
	  }
	});
	
	exports.default = Router;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.default = createTransitionManager;
	
	var _routerWarning = __webpack_require__(192);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _computeChangedRoutes2 = __webpack_require__(194);
	
	var _computeChangedRoutes3 = _interopRequireDefault(_computeChangedRoutes2);
	
	var _TransitionUtils = __webpack_require__(195);
	
	var _isActive2 = __webpack_require__(197);
	
	var _isActive3 = _interopRequireDefault(_isActive2);
	
	var _getComponents = __webpack_require__(198);
	
	var _getComponents2 = _interopRequireDefault(_getComponents);
	
	var _matchRoutes = __webpack_require__(200);
	
	var _matchRoutes2 = _interopRequireDefault(_matchRoutes);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function hasAnyProperties(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return true;
	  }return false;
	}
	
	function createTransitionManager(history, routes) {
	  var state = {};
	
	  // Signature should be (location, indexOnly), but needs to support (path,
	  // query, indexOnly)
	  function isActive(location, indexOnly) {
	    location = history.createLocation(location);
	
	    return (0, _isActive3.default)(location, indexOnly, state.location, state.routes, state.params);
	  }
	
	  var partialNextState = void 0;
	
	  function match(location, callback) {
	    if (partialNextState && partialNextState.location === location) {
	      // Continue from where we left off.
	      finishMatch(partialNextState, callback);
	    } else {
	      (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	        if (error) {
	          callback(error);
	        } else if (nextState) {
	          finishMatch(_extends({}, nextState, { location: location }), callback);
	        } else {
	          callback();
	        }
	      });
	    }
	  }
	
	  function finishMatch(nextState, callback) {
	    var _computeChangedRoutes = (0, _computeChangedRoutes3.default)(state, nextState),
	        leaveRoutes = _computeChangedRoutes.leaveRoutes,
	        changeRoutes = _computeChangedRoutes.changeRoutes,
	        enterRoutes = _computeChangedRoutes.enterRoutes;
	
	    (0, _TransitionUtils.runLeaveHooks)(leaveRoutes, state);
	
	    // Tear down confirmation hooks for left routes
	    leaveRoutes.filter(function (route) {
	      return enterRoutes.indexOf(route) === -1;
	    }).forEach(removeListenBeforeHooksForRoute);
	
	    // change and enter hooks are run in series
	    (0, _TransitionUtils.runChangeHooks)(changeRoutes, state, nextState, function (error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      (0, _TransitionUtils.runEnterHooks)(enterRoutes, nextState, finishEnterHooks);
	    });
	
	    function finishEnterHooks(error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      // TODO: Fetch components after state is updated.
	      (0, _getComponents2.default)(nextState, function (error, components) {
	        if (error) {
	          callback(error);
	        } else {
	          // TODO: Make match a pure function and have some other API
	          // for "match and update state".
	          callback(null, null, state = _extends({}, nextState, { components: components }));
	        }
	      });
	    }
	
	    function handleErrorOrRedirect(error, redirectInfo) {
	      if (error) callback(error);else callback(null, redirectInfo);
	    }
	  }
	
	  var RouteGuid = 1;
	
	  function getRouteID(route) {
	    var create = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	    return route.__id__ || create && (route.__id__ = RouteGuid++);
	  }
	
	  var RouteHooks = Object.create(null);
	
	  function getRouteHooksForRoutes(routes) {
	    return routes.map(function (route) {
	      return RouteHooks[getRouteID(route)];
	    }).filter(function (hook) {
	      return hook;
	    });
	  }
	
	  function transitionHook(location, callback) {
	    (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	      if (nextState == null) {
	        // TODO: We didn't actually match anything, but hang
	        // onto error/nextState so we don't have to matchRoutes
	        // again in the listen callback.
	        callback();
	        return;
	      }
	
	      // Cache some state here so we don't have to
	      // matchRoutes() again in the listen callback.
	      partialNextState = _extends({}, nextState, { location: location });
	
	      var hooks = getRouteHooksForRoutes((0, _computeChangedRoutes3.default)(state, partialNextState).leaveRoutes);
	
	      var result = void 0;
	      for (var i = 0, len = hooks.length; result == null && i < len; ++i) {
	        // Passing the location arg here indicates to
	        // the user that this is a transition hook.
	        result = hooks[i](location);
	      }
	
	      callback(result);
	    });
	  }
	
	  /* istanbul ignore next: untestable with Karma */
	  function beforeUnloadHook() {
	    // Synchronously check to see if any route hooks want
	    // to prevent the current window/tab from closing.
	    if (state.routes) {
	      var hooks = getRouteHooksForRoutes(state.routes);
	
	      var message = void 0;
	      for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {
	        // Passing no args indicates to the user that this is a
	        // beforeunload hook. We don't know the next location.
	        message = hooks[i]();
	      }
	
	      return message;
	    }
	  }
	
	  var unlistenBefore = void 0,
	      unlistenBeforeUnload = void 0;
	
	  function removeListenBeforeHooksForRoute(route) {
	    var routeID = getRouteID(route);
	    if (!routeID) {
	      return;
	    }
	
	    delete RouteHooks[routeID];
	
	    if (!hasAnyProperties(RouteHooks)) {
	      // teardown transition & beforeunload hooks
	      if (unlistenBefore) {
	        unlistenBefore();
	        unlistenBefore = null;
	      }
	
	      if (unlistenBeforeUnload) {
	        unlistenBeforeUnload();
	        unlistenBeforeUnload = null;
	      }
	    }
	  }
	
	  /**
	   * Registers the given hook function to run before leaving the given route.
	   *
	   * During a normal transition, the hook function receives the next location
	   * as its only argument and can return either a prompt message (string) to show the user,
	   * to make sure they want to leave the page; or `false`, to prevent the transition.
	   * Any other return value will have no effect.
	   *
	   * During the beforeunload event (in browsers) the hook receives no arguments.
	   * In this case it must return a prompt message to prevent the transition.
	   *
	   * Returns a function that may be used to unbind the listener.
	   */
	  function listenBeforeLeavingRoute(route, hook) {
	    var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);
	    var routeID = getRouteID(route, true);
	
	    RouteHooks[routeID] = hook;
	
	    if (thereWereNoRouteHooks) {
	      // setup transition & beforeunload hooks
	      unlistenBefore = history.listenBefore(transitionHook);
	
	      if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);
	    }
	
	    return function () {
	      removeListenBeforeHooksForRoute(route);
	    };
	  }
	
	  /**
	   * This is the API for stateful environments. As the location
	   * changes, we update state and call the listener. We can also
	   * gracefully handle errors and redirects.
	   */
	  function listen(listener) {
	    function historyListener(location) {
	      if (state.location === location) {
	        listener(null, state);
	      } else {
	        match(location, function (error, redirectLocation, nextState) {
	          if (error) {
	            listener(error);
	          } else if (redirectLocation) {
	            history.replace(redirectLocation);
	          } else if (nextState) {
	            listener(null, nextState);
	          } else {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'Location "%s" did not match any routes', location.pathname + location.search + location.hash) : void 0;
	          }
	        });
	      }
	    }
	
	    // TODO: Only use a single history listener. Otherwise we'll end up with
	    // multiple concurrent calls to match.
	
	    // Set up the history listener first in case the initial match redirects.
	    var unsubscribe = history.listen(historyListener);
	
	    if (state.location) {
	      // Picking up on a matchContext.
	      listener(null, state);
	    } else {
	      historyListener(history.getCurrentLocation());
	    }
	
	    return unsubscribe;
	  }
	
	  return {
	    isActive: isActive,
	    match: match,
	    listenBeforeLeavingRoute: listenBeforeLeavingRoute,
	    listen: listen
	  };
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = routerWarning;
	exports._resetWarned = _resetWarned;
	
	var _warning = __webpack_require__(193);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var warned = {};
	
	function routerWarning(falseToWarn, message) {
	  // Only issue deprecation warnings once.
	  if (message.indexOf('deprecated') !== -1) {
	    if (warned[message]) {
	      return;
	    }
	
	    warned[message] = true;
	  }
	
	  message = '[react-router] ' + message;
	
	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }
	
	  _warning2.default.apply(undefined, [falseToWarn, message].concat(args));
	}
	
	function _resetWarned() {
	  warned = {};
	}

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = function warning() {};
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function warning(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.length < 10 || /^[s\W]*$/.test(format)) {
	      throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(188);
	
	function routeParamsChanged(route, prevState, nextState) {
	  if (!route.path) return false;
	
	  var paramNames = (0, _PatternUtils.getParamNames)(route.path);
	
	  return paramNames.some(function (paramName) {
	    return prevState.params[paramName] !== nextState.params[paramName];
	  });
	}
	
	/**
	 * Returns an object of { leaveRoutes, changeRoutes, enterRoutes } determined by
	 * the change from prevState to nextState. We leave routes if either
	 * 1) they are not in the next state or 2) they are in the next state
	 * but their params have changed (i.e. /users/123 => /users/456).
	 *
	 * leaveRoutes are ordered starting at the leaf route of the tree
	 * we're leaving up to the common parent route. enterRoutes are ordered
	 * from the top of the tree we're entering down to the leaf route.
	 *
	 * changeRoutes are any routes that didn't leave or enter during
	 * the transition.
	 */
	function computeChangedRoutes(prevState, nextState) {
	  var prevRoutes = prevState && prevState.routes;
	  var nextRoutes = nextState.routes;
	
	  var leaveRoutes = void 0,
	      changeRoutes = void 0,
	      enterRoutes = void 0;
	  if (prevRoutes) {
	    (function () {
	      var parentIsLeaving = false;
	      leaveRoutes = prevRoutes.filter(function (route) {
	        if (parentIsLeaving) {
	          return true;
	        } else {
	          var isLeaving = nextRoutes.indexOf(route) === -1 || routeParamsChanged(route, prevState, nextState);
	          if (isLeaving) parentIsLeaving = true;
	          return isLeaving;
	        }
	      });
	
	      // onLeave hooks start at the leaf route.
	      leaveRoutes.reverse();
	
	      enterRoutes = [];
	      changeRoutes = [];
	
	      nextRoutes.forEach(function (route) {
	        var isNew = prevRoutes.indexOf(route) === -1;
	        var paramsChanged = leaveRoutes.indexOf(route) !== -1;
	
	        if (isNew || paramsChanged) enterRoutes.push(route);else changeRoutes.push(route);
	      });
	    })();
	  } else {
	    leaveRoutes = [];
	    changeRoutes = [];
	    enterRoutes = nextRoutes;
	  }
	
	  return {
	    leaveRoutes: leaveRoutes,
	    changeRoutes: changeRoutes,
	    enterRoutes: enterRoutes
	  };
	}
	
	exports.default = computeChangedRoutes;
	module.exports = exports['default'];

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.runEnterHooks = runEnterHooks;
	exports.runChangeHooks = runChangeHooks;
	exports.runLeaveHooks = runLeaveHooks;
	
	var _AsyncUtils = __webpack_require__(196);
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	var PendingHooks = function PendingHooks() {
	  var _this = this;
	
	  _classCallCheck(this, PendingHooks);
	
	  this.hooks = [];
	
	  this.add = function (hook) {
	    return _this.hooks.push(hook);
	  };
	
	  this.remove = function (hook) {
	    return _this.hooks = _this.hooks.filter(function (h) {
	      return h !== hook;
	    });
	  };
	
	  this.has = function (hook) {
	    return _this.hooks.indexOf(hook) !== -1;
	  };
	
	  this.clear = function () {
	    return _this.hooks = [];
	  };
	};
	
	var enterHooks = new PendingHooks();
	var changeHooks = new PendingHooks();
	
	function createTransitionHook(hook, route, asyncArity, pendingHooks) {
	  var isSync = hook.length < asyncArity;
	
	  var transitionHook = function transitionHook() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    hook.apply(route, args);
	
	    if (isSync) {
	      var callback = args[args.length - 1];
	      // Assume hook executes synchronously and
	      // automatically call the callback.
	      callback();
	    }
	  };
	
	  pendingHooks.add(transitionHook);
	
	  return transitionHook;
	}
	
	function getEnterHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onEnter) hooks.push(createTransitionHook(route.onEnter, route, 3, enterHooks));
	    return hooks;
	  }, []);
	}
	
	function getChangeHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onChange) hooks.push(createTransitionHook(route.onChange, route, 4, changeHooks));
	    return hooks;
	  }, []);
	}
	
	function runTransitionHooks(length, iter, callback) {
	  if (!length) {
	    callback();
	    return;
	  }
	
	  var redirectInfo = void 0;
	  function replace(location) {
	    redirectInfo = location;
	  }
	
	  (0, _AsyncUtils.loopAsync)(length, function (index, next, done) {
	    iter(index, replace, function (error) {
	      if (error || redirectInfo) {
	        done(error, redirectInfo); // No need to continue.
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	
	/**
	 * Runs all onEnter hooks in the given array of routes in order
	 * with onEnter(nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runEnterHooks(routes, nextState, callback) {
	  enterHooks.clear();
	  var hooks = getEnterHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    var wrappedNext = function wrappedNext() {
	      if (enterHooks.has(hooks[index])) {
	        next();
	        enterHooks.remove(hooks[index]);
	      }
	    };
	    hooks[index](nextState, replace, wrappedNext);
	  }, callback);
	}
	
	/**
	 * Runs all onChange hooks in the given array of routes in order
	 * with onChange(prevState, nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runChangeHooks(routes, state, nextState, callback) {
	  changeHooks.clear();
	  var hooks = getChangeHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    var wrappedNext = function wrappedNext() {
	      if (changeHooks.has(hooks[index])) {
	        next();
	        changeHooks.remove(hooks[index]);
	      }
	    };
	    hooks[index](state, nextState, replace, wrappedNext);
	  }, callback);
	}
	
	/**
	 * Runs all onLeave hooks in the given array of routes in order.
	 */
	function runLeaveHooks(routes, prevState) {
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    if (routes[i].onLeave) routes[i].onLeave.call(routes[i], prevState);
	  }
	}

/***/ },
/* 196 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports.loopAsync = loopAsync;
	exports.mapAsync = mapAsync;
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = void 0;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(Array.prototype.slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}
	
	function mapAsync(array, work, callback) {
	  var length = array.length;
	  var values = [];
	
	  if (length === 0) return callback(null, values);
	
	  var isDone = false,
	      doneCount = 0;
	
	  function done(index, error, value) {
	    if (isDone) return;
	
	    if (error) {
	      isDone = true;
	      callback(error);
	    } else {
	      values[index] = value;
	
	      isDone = ++doneCount === length;
	
	      if (isDone) callback(null, values);
	    }
	  }
	
	  array.forEach(function (item, index) {
	    work(item, index, function (error, value) {
	      done(index, error, value);
	    });
	  });
	}

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	exports.default = isActive;
	
	var _PatternUtils = __webpack_require__(188);
	
	function deepEqual(a, b) {
	  if (a == b) return true;
	
	  if (a == null || b == null) return false;
	
	  if (Array.isArray(a)) {
	    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
	      return deepEqual(item, b[index]);
	    });
	  }
	
	  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {
	    for (var p in a) {
	      if (!Object.prototype.hasOwnProperty.call(a, p)) {
	        continue;
	      }
	
	      if (a[p] === undefined) {
	        if (b[p] !== undefined) {
	          return false;
	        }
	      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {
	        return false;
	      } else if (!deepEqual(a[p], b[p])) {
	        return false;
	      }
	    }
	
	    return true;
	  }
	
	  return String(a) === String(b);
	}
	
	/**
	 * Returns true if the current pathname matches the supplied one, net of
	 * leading and trailing slash normalization. This is sufficient for an
	 * indexOnly route match.
	 */
	function pathIsActive(pathname, currentPathname) {
	  // Normalize leading slash for consistency. Leading slash on pathname has
	  // already been normalized in isActive. See caveat there.
	  if (currentPathname.charAt(0) !== '/') {
	    currentPathname = '/' + currentPathname;
	  }
	
	  // Normalize the end of both path names too. Maybe `/foo/` shouldn't show
	  // `/foo` as active, but in this case, we would already have failed the
	  // match.
	  if (pathname.charAt(pathname.length - 1) !== '/') {
	    pathname += '/';
	  }
	  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {
	    currentPathname += '/';
	  }
	
	  return currentPathname === pathname;
	}
	
	/**
	 * Returns true if the given pathname matches the active routes and params.
	 */
	function routeIsActive(pathname, routes, params) {
	  var remainingPathname = pathname,
	      paramNames = [],
	      paramValues = [];
	
	  // for...of would work here but it's probably slower post-transpilation.
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    var route = routes[i];
	    var pattern = route.path || '';
	
	    if (pattern.charAt(0) === '/') {
	      remainingPathname = pathname;
	      paramNames = [];
	      paramValues = [];
	    }
	
	    if (remainingPathname !== null && pattern) {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	
	      if (remainingPathname === '') {
	        // We have an exact match on the route. Just check that all the params
	        // match.
	        // FIXME: This doesn't work on repeated params.
	        return paramNames.every(function (paramName, index) {
	          return String(paramValues[index]) === String(params[paramName]);
	        });
	      }
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Returns true if all key/value pairs in the given query are
	 * currently active.
	 */
	function queryIsActive(query, activeQuery) {
	  if (activeQuery == null) return query == null;
	
	  if (query == null) return true;
	
	  return deepEqual(query, activeQuery);
	}
	
	/**
	 * Returns true if a <Link> to the given pathname/query combination is
	 * currently active.
	 */
	function isActive(_ref, indexOnly, currentLocation, routes, params) {
	  var pathname = _ref.pathname,
	      query = _ref.query;
	
	  if (currentLocation == null) return false;
	
	  // TODO: This is a bit ugly. It keeps around support for treating pathnames
	  // without preceding slashes as absolute paths, but possibly also works
	  // around the same quirks with basenames as in matchRoutes.
	  if (pathname.charAt(0) !== '/') {
	    pathname = '/' + pathname;
	  }
	
	  if (!pathIsActive(pathname, currentLocation.pathname)) {
	    // The path check is necessary and sufficient for indexOnly, but otherwise
	    // we still need to check the routes.
	    if (indexOnly || !routeIsActive(pathname, routes, params)) {
	      return false;
	    }
	  }
	
	  return queryIsActive(query, currentLocation.query);
	}
	module.exports = exports['default'];

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _AsyncUtils = __webpack_require__(196);
	
	var _PromiseUtils = __webpack_require__(199);
	
	function getComponentsForRoute(nextState, route, callback) {
	  if (route.component || route.components) {
	    callback(null, route.component || route.components);
	    return;
	  }
	
	  var getComponent = route.getComponent || route.getComponents;
	  if (getComponent) {
	    var componentReturn = getComponent.call(route, nextState, callback);
	    if ((0, _PromiseUtils.isPromise)(componentReturn)) componentReturn.then(function (component) {
	      return callback(null, component);
	    }, callback);
	  } else {
	    callback();
	  }
	}
	
	/**
	 * Asynchronously fetches all components needed for the given router
	 * state and calls callback(error, components) when finished.
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getComponents method.
	 */
	function getComponents(nextState, callback) {
	  (0, _AsyncUtils.mapAsync)(nextState.routes, function (route, index, callback) {
	    getComponentsForRoute(nextState, route, callback);
	  }, callback);
	}
	
	exports.default = getComponents;
	module.exports = exports['default'];

/***/ },
/* 199 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.isPromise = isPromise;
	function isPromise(obj) {
	  return obj && typeof obj.then === 'function';
	}

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	exports.default = matchRoutes;
	
	var _AsyncUtils = __webpack_require__(196);
	
	var _PromiseUtils = __webpack_require__(199);
	
	var _PatternUtils = __webpack_require__(188);
	
	var _routerWarning = __webpack_require__(192);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _RouteUtils = __webpack_require__(186);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function getChildRoutes(route, location, paramNames, paramValues, callback) {
	  if (route.childRoutes) {
	    return [null, route.childRoutes];
	  }
	  if (!route.getChildRoutes) {
	    return [];
	  }
	
	  var sync = true,
	      result = void 0;
	
	  var partialNextState = {
	    location: location,
	    params: createParams(paramNames, paramValues)
	  };
	
	  var childRoutesReturn = route.getChildRoutes(partialNextState, function (error, childRoutes) {
	    childRoutes = !error && (0, _RouteUtils.createRoutes)(childRoutes);
	    if (sync) {
	      result = [error, childRoutes];
	      return;
	    }
	
	    callback(error, childRoutes);
	  });
	
	  if ((0, _PromiseUtils.isPromise)(childRoutesReturn)) childRoutesReturn.then(function (childRoutes) {
	    return callback(null, (0, _RouteUtils.createRoutes)(childRoutes));
	  }, callback);
	
	  sync = false;
	  return result; // Might be undefined.
	}
	
	function getIndexRoute(route, location, paramNames, paramValues, callback) {
	  if (route.indexRoute) {
	    callback(null, route.indexRoute);
	  } else if (route.getIndexRoute) {
	    var partialNextState = {
	      location: location,
	      params: createParams(paramNames, paramValues)
	    };
	
	    var indexRoutesReturn = route.getIndexRoute(partialNextState, function (error, indexRoute) {
	      callback(error, !error && (0, _RouteUtils.createRoutes)(indexRoute)[0]);
	    });
	
	    if ((0, _PromiseUtils.isPromise)(indexRoutesReturn)) indexRoutesReturn.then(function (indexRoute) {
	      return callback(null, (0, _RouteUtils.createRoutes)(indexRoute)[0]);
	    }, callback);
	  } else if (route.childRoutes) {
	    (function () {
	      var pathless = route.childRoutes.filter(function (childRoute) {
	        return !childRoute.path;
	      });
	
	      (0, _AsyncUtils.loopAsync)(pathless.length, function (index, next, done) {
	        getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {
	          if (error || indexRoute) {
	            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);
	            done(error, routes);
	          } else {
	            next();
	          }
	        });
	      }, function (err, routes) {
	        callback(null, routes);
	      });
	    })();
	  } else {
	    callback();
	  }
	}
	
	function assignParams(params, paramNames, paramValues) {
	  return paramNames.reduce(function (params, paramName, index) {
	    var paramValue = paramValues && paramValues[index];
	
	    if (Array.isArray(params[paramName])) {
	      params[paramName].push(paramValue);
	    } else if (paramName in params) {
	      params[paramName] = [params[paramName], paramValue];
	    } else {
	      params[paramName] = paramValue;
	    }
	
	    return params;
	  }, params);
	}
	
	function createParams(paramNames, paramValues) {
	  return assignParams({}, paramNames, paramValues);
	}
	
	function matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {
	  var pattern = route.path || '';
	
	  if (pattern.charAt(0) === '/') {
	    remainingPathname = location.pathname;
	    paramNames = [];
	    paramValues = [];
	  }
	
	  // Only try to match the path if the route actually has a pattern, and if
	  // we're not just searching for potential nested absolute paths.
	  if (remainingPathname !== null && pattern) {
	    try {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	    } catch (error) {
	      callback(error);
	    }
	
	    // By assumption, pattern is non-empty here, which is the prerequisite for
	    // actually terminating a match.
	    if (remainingPathname === '') {
	      var _ret2 = function () {
	        var match = {
	          routes: [route],
	          params: createParams(paramNames, paramValues)
	        };
	
	        getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {
	          if (error) {
	            callback(error);
	          } else {
	            if (Array.isArray(indexRoute)) {
	              var _match$routes;
	
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(indexRoute.every(function (route) {
	                return !route.path;
	              }), 'Index routes should not have paths') : void 0;
	              (_match$routes = match.routes).push.apply(_match$routes, indexRoute);
	            } else if (indexRoute) {
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!indexRoute.path, 'Index routes should not have paths') : void 0;
	              match.routes.push(indexRoute);
	            }
	
	            callback(null, match);
	          }
	        });
	
	        return {
	          v: void 0
	        };
	      }();
	
	      if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
	    }
	  }
	
	  if (remainingPathname != null || route.childRoutes) {
	    // Either a) this route matched at least some of the path or b)
	    // we don't have to load this route's children asynchronously. In
	    // either case continue checking for matches in the subtree.
	    var onChildRoutes = function onChildRoutes(error, childRoutes) {
	      if (error) {
	        callback(error);
	      } else if (childRoutes) {
	        // Check the child routes to see if any of them match.
	        matchRoutes(childRoutes, location, function (error, match) {
	          if (error) {
	            callback(error);
	          } else if (match) {
	            // A child route matched! Augment the match and pass it up the stack.
	            match.routes.unshift(route);
	            callback(null, match);
	          } else {
	            callback();
	          }
	        }, remainingPathname, paramNames, paramValues);
	      } else {
	        callback();
	      }
	    };
	
	    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);
	    if (result) {
	      onChildRoutes.apply(undefined, result);
	    }
	  } else {
	    callback();
	  }
	}
	
	/**
	 * Asynchronously matches the given location to a set of routes and calls
	 * callback(error, state) when finished. The state object will have the
	 * following properties:
	 *
	 * - routes       An array of routes that matched, in hierarchical order
	 * - params       An object of URL parameters
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getChildRoutes method.
	 */
	function matchRoutes(routes, location, callback, remainingPathname) {
	  var paramNames = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
	  var paramValues = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
	
	  if (remainingPathname === undefined) {
	    // TODO: This is a little bit ugly, but it works around a quirk in history
	    // that strips the leading slash from pathnames when using basenames with
	    // trailing slashes.
	    if (location.pathname.charAt(0) !== '/') {
	      location = _extends({}, location, {
	        pathname: '/' + location.pathname
	      });
	    }
	    remainingPathname = location.pathname;
	  }
	
	  (0, _AsyncUtils.loopAsync)(routes.length, function (index, next, done) {
	    matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {
	      if (error || match) {
	        done(error, match);
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.routes = exports.route = exports.components = exports.component = exports.history = undefined;
	exports.falsy = falsy;
	
	var _react = __webpack_require__(8);
	
	var func = _react.PropTypes.func,
	    object = _react.PropTypes.object,
	    arrayOf = _react.PropTypes.arrayOf,
	    oneOfType = _react.PropTypes.oneOfType,
	    element = _react.PropTypes.element,
	    shape = _react.PropTypes.shape,
	    string = _react.PropTypes.string;
	function falsy(props, propName, componentName) {
	  if (props[propName]) return new Error('<' + componentName + '> should not have a "' + propName + '" prop');
	}
	
	var history = exports.history = shape({
	  listen: func.isRequired,
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired
	});
	
	var component = exports.component = oneOfType([func, string]);
	var components = exports.components = oneOfType([component, object]);
	var route = exports.route = oneOfType([object, element]);
	var routes = exports.routes = oneOfType([route, arrayOf(route)]);

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _getRouteParams = __webpack_require__(203);
	
	var _getRouteParams2 = _interopRequireDefault(_getRouteParams);
	
	var _ContextUtils = __webpack_require__(204);
	
	var _RouteUtils = __webpack_require__(186);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes,
	    array = _React$PropTypes.array,
	    func = _React$PropTypes.func,
	    object = _React$PropTypes.object;
	
	/**
	 * A <RouterContext> renders the component tree for a given router state
	 * and sets the history object and the current location in context.
	 */
	
	var RouterContext = _react2.default.createClass({
	  displayName: 'RouterContext',
	
	  mixins: [(0, _ContextUtils.ContextProvider)('router')],
	
	  propTypes: {
	    router: object.isRequired,
	    location: object.isRequired,
	    routes: array.isRequired,
	    params: object.isRequired,
	    components: array.isRequired,
	    createElement: func.isRequired
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      createElement: _react2.default.createElement
	    };
	  },
	
	  childContextTypes: {
	    router: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    return {
	      router: this.props.router
	    };
	  },
	  createElement: function createElement(component, props) {
	    return component == null ? null : this.props.createElement(component, props);
	  },
	  render: function render() {
	    var _this = this;
	
	    var _props = this.props,
	        location = _props.location,
	        routes = _props.routes,
	        params = _props.params,
	        components = _props.components,
	        router = _props.router;
	
	    var element = null;
	
	    if (components) {
	      element = components.reduceRight(function (element, components, index) {
	        if (components == null) return element; // Don't create new children; use the grandchildren.
	
	        var route = routes[index];
	        var routeParams = (0, _getRouteParams2.default)(route, params);
	        var props = {
	          location: location,
	          params: params,
	          route: route,
	          router: router,
	          routeParams: routeParams,
	          routes: routes
	        };
	
	        if ((0, _RouteUtils.isReactChildren)(element)) {
	          props.children = element;
	        } else if (element) {
	          for (var prop in element) {
	            if (Object.prototype.hasOwnProperty.call(element, prop)) props[prop] = element[prop];
	          }
	        }
	
	        if ((typeof components === 'undefined' ? 'undefined' : _typeof(components)) === 'object') {
	          var elements = {};
	
	          for (var key in components) {
	            if (Object.prototype.hasOwnProperty.call(components, key)) {
	              // Pass through the key as a prop to createElement to allow
	              // custom createElement functions to know which named component
	              // they're rendering, for e.g. matching up to fetched data.
	              elements[key] = _this.createElement(components[key], _extends({
	                key: key }, props));
	            }
	          }
	
	          return elements;
	        }
	
	        return _this.createElement(components, props);
	      }, element);
	    }
	
	    !(element === null || element === false || _react2.default.isValidElement(element)) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The root route must render a single element') : (0, _invariant2.default)(false) : void 0;
	
	    return element;
	  }
	});
	
	exports.default = RouterContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(188);
	
	/**
	 * Extracts an object of params the given route cares about from
	 * the given params object.
	 */
	function getRouteParams(route, params) {
	  var routeParams = {};
	
	  if (!route.path) return routeParams;
	
	  (0, _PatternUtils.getParamNames)(route.path).forEach(function (p) {
	    if (Object.prototype.hasOwnProperty.call(params, p)) {
	      routeParams[p] = params[p];
	    }
	  });
	
	  return routeParams;
	}
	
	exports.default = getRouteParams;
	module.exports = exports['default'];

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ContextProvider = ContextProvider;
	exports.ContextSubscriber = ContextSubscriber;
	
	var _react = __webpack_require__(8);
	
	// Works around issues with context updates failing to propagate.
	// Caveat: the context value is expected to never change its identity.
	// https://github.com/facebook/react/issues/2517
	// https://github.com/reactjs/react-router/issues/470
	
	var contextProviderShape = _react.PropTypes.shape({
	  subscribe: _react.PropTypes.func.isRequired,
	  eventIndex: _react.PropTypes.number.isRequired
	});
	
	function makeContextName(name) {
	  return '@@contextSubscriber/' + name;
	}
	
	function ContextProvider(name) {
	  var _childContextTypes, _ref2;
	
	  var contextName = makeContextName(name);
	  var listenersKey = contextName + '/listeners';
	  var eventIndexKey = contextName + '/eventIndex';
	  var subscribeKey = contextName + '/subscribe';
	
	  return _ref2 = {
	    childContextTypes: (_childContextTypes = {}, _childContextTypes[contextName] = contextProviderShape.isRequired, _childContextTypes),
	
	    getChildContext: function getChildContext() {
	      var _ref;
	
	      return _ref = {}, _ref[contextName] = {
	        eventIndex: this[eventIndexKey],
	        subscribe: this[subscribeKey]
	      }, _ref;
	    },
	    componentWillMount: function componentWillMount() {
	      this[listenersKey] = [];
	      this[eventIndexKey] = 0;
	    },
	    componentWillReceiveProps: function componentWillReceiveProps() {
	      this[eventIndexKey]++;
	    },
	    componentDidUpdate: function componentDidUpdate() {
	      var _this = this;
	
	      this[listenersKey].forEach(function (listener) {
	        return listener(_this[eventIndexKey]);
	      });
	    }
	  }, _ref2[subscribeKey] = function (listener) {
	    var _this2 = this;
	
	    // No need to immediately call listener here.
	    this[listenersKey].push(listener);
	
	    return function () {
	      _this2[listenersKey] = _this2[listenersKey].filter(function (item) {
	        return item !== listener;
	      });
	    };
	  }, _ref2;
	}
	
	function ContextSubscriber(name) {
	  var _contextTypes, _ref4;
	
	  var contextName = makeContextName(name);
	  var lastRenderedEventIndexKey = contextName + '/lastRenderedEventIndex';
	  var handleContextUpdateKey = contextName + '/handleContextUpdate';
	  var unsubscribeKey = contextName + '/unsubscribe';
	
	  return _ref4 = {
	    contextTypes: (_contextTypes = {}, _contextTypes[contextName] = contextProviderShape, _contextTypes),
	
	    getInitialState: function getInitialState() {
	      var _ref3;
	
	      if (!this.context[contextName]) {
	        return {};
	      }
	
	      return _ref3 = {}, _ref3[lastRenderedEventIndexKey] = this.context[contextName].eventIndex, _ref3;
	    },
	    componentDidMount: function componentDidMount() {
	      if (!this.context[contextName]) {
	        return;
	      }
	
	      this[unsubscribeKey] = this.context[contextName].subscribe(this[handleContextUpdateKey]);
	    },
	    componentWillReceiveProps: function componentWillReceiveProps() {
	      var _setState;
	
	      if (!this.context[contextName]) {
	        return;
	      }
	
	      this.setState((_setState = {}, _setState[lastRenderedEventIndexKey] = this.context[contextName].eventIndex, _setState));
	    },
	    componentWillUnmount: function componentWillUnmount() {
	      if (!this[unsubscribeKey]) {
	        return;
	      }
	
	      this[unsubscribeKey]();
	      this[unsubscribeKey] = null;
	    }
	  }, _ref4[handleContextUpdateKey] = function (eventIndex) {
	    if (eventIndex !== this.state[lastRenderedEventIndexKey]) {
	      var _setState2;
	
	      this.setState((_setState2 = {}, _setState2[lastRenderedEventIndexKey] = eventIndex, _setState2));
	    }
	  }, _ref4;
	}

/***/ },
/* 205 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.createRouterObject = createRouterObject;
	exports.assignRouterState = assignRouterState;
	function createRouterObject(history, transitionManager, state) {
	  var router = _extends({}, history, {
	    setRouteLeaveHook: transitionManager.listenBeforeLeavingRoute,
	    isActive: transitionManager.isActive
	  });
	
	  return assignRouterState(router, state);
	}
	
	function assignRouterState(router, _ref) {
	  var location = _ref.location,
	      params = _ref.params,
	      routes = _ref.routes;
	
	  router.location = location;
	  router.params = params;
	  router.routes = routes;
	
	  return router;
	}

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PropTypes = __webpack_require__(187);
	
	var _ContextUtils = __webpack_require__(204);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	var _React$PropTypes = _react2.default.PropTypes,
	    bool = _React$PropTypes.bool,
	    object = _React$PropTypes.object,
	    string = _React$PropTypes.string,
	    func = _React$PropTypes.func,
	    oneOfType = _React$PropTypes.oneOfType;
	
	function isLeftClickEvent(event) {
	  return event.button === 0;
	}
	
	function isModifiedEvent(event) {
	  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
	}
	
	// TODO: De-duplicate against hasAnyProperties in createTransitionManager.
	function isEmptyObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return false;
	  }return true;
	}
	
	function resolveToLocation(to, router) {
	  return typeof to === 'function' ? to(router.location) : to;
	}
	
	/**
	 * A <Link> is used to create an <a> element that links to a route.
	 * When that route is active, the link gets the value of its
	 * activeClassName prop.
	 *
	 * For example, assuming you have the following route:
	 *
	 *   <Route path="/posts/:postID" component={Post} />
	 *
	 * You could use the following component to link to that route:
	 *
	 *   <Link to={`/posts/${post.id}`} />
	 *
	 * Links may pass along location state and/or query string parameters
	 * in the state/query props, respectively.
	 *
	 *   <Link ... query={{ show: true }} state={{ the: 'state' }} />
	 */
	var Link = _react2.default.createClass({
	  displayName: 'Link',
	
	  mixins: [(0, _ContextUtils.ContextSubscriber)('router')],
	
	  contextTypes: {
	    router: _PropTypes.routerShape
	  },
	
	  propTypes: {
	    to: oneOfType([string, object, func]),
	    query: object,
	    hash: string,
	    state: object,
	    activeStyle: object,
	    activeClassName: string,
	    onlyActiveOnIndex: bool.isRequired,
	    onClick: func,
	    target: string
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      onlyActiveOnIndex: false,
	      style: {}
	    };
	  },
	  handleClick: function handleClick(event) {
	    if (this.props.onClick) this.props.onClick(event);
	
	    if (event.defaultPrevented) return;
	
	    var router = this.context.router;
	
	    !router ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Link>s rendered outside of a router context cannot navigate.') : (0, _invariant2.default)(false) : void 0;
	
	    if (isModifiedEvent(event) || !isLeftClickEvent(event)) return;
	
	    // If target prop is set (e.g. to "_blank"), let browser handle link.
	    /* istanbul ignore if: untestable with Karma */
	    if (this.props.target) return;
	
	    event.preventDefault();
	
	    router.push(resolveToLocation(this.props.to, router));
	  },
	  render: function render() {
	    var _props = this.props,
	        to = _props.to,
	        activeClassName = _props.activeClassName,
	        activeStyle = _props.activeStyle,
	        onlyActiveOnIndex = _props.onlyActiveOnIndex,
	        props = _objectWithoutProperties(_props, ['to', 'activeClassName', 'activeStyle', 'onlyActiveOnIndex']);
	
	    // Ignore if rendered outside the context of router to simplify unit testing.
	
	
	    var router = this.context.router;
	
	    if (router) {
	      // If user does not specify a `to` prop, return an empty anchor tag.
	      if (to == null) {
	        return _react2.default.createElement('a', props);
	      }
	
	      var toLocation = resolveToLocation(to, router);
	      props.href = router.createHref(toLocation);
	
	      if (activeClassName || activeStyle != null && !isEmptyObject(activeStyle)) {
	        if (router.isActive(toLocation, onlyActiveOnIndex)) {
	          if (activeClassName) {
	            if (props.className) {
	              props.className += ' ' + activeClassName;
	            } else {
	              props.className = activeClassName;
	            }
	          }
	
	          if (activeStyle) props.style = _extends({}, props.style, activeStyle);
	        }
	      }
	    }
	
	    return _react2.default.createElement('a', _extends({}, props, { onClick: this.handleClick }));
	  }
	});
	
	exports.default = Link;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Link = __webpack_require__(206);
	
	var _Link2 = _interopRequireDefault(_Link);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	/**
	 * An <IndexLink> is used to link to an <IndexRoute>.
	 */
	var IndexLink = _react2.default.createClass({
	  displayName: 'IndexLink',
	  render: function render() {
	    return _react2.default.createElement(_Link2.default, _extends({}, this.props, { onlyActiveOnIndex: true }));
	  }
	});
	
	exports.default = IndexLink;
	module.exports = exports['default'];

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.default = withRouter;
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _hoistNonReactStatics = __webpack_require__(209);
	
	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
	
	var _ContextUtils = __webpack_require__(204);
	
	var _PropTypes = __webpack_require__(187);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	function withRouter(WrappedComponent, options) {
	  var withRef = options && options.withRef;
	
	  var WithRouter = _react2.default.createClass({
	    displayName: 'WithRouter',
	
	    mixins: [(0, _ContextUtils.ContextSubscriber)('router')],
	
	    contextTypes: { router: _PropTypes.routerShape },
	    propTypes: { router: _PropTypes.routerShape },
	
	    getWrappedInstance: function getWrappedInstance() {
	      !withRef ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'To access the wrapped instance, you need to specify ' + '`{ withRef: true }` as the second argument of the withRouter() call.') : (0, _invariant2.default)(false) : void 0;
	
	      return this.wrappedInstance;
	    },
	    render: function render() {
	      var _this = this;
	
	      var router = this.props.router || this.context.router;
	      var params = router.params,
	          location = router.location,
	          routes = router.routes;
	
	      var props = _extends({}, this.props, { router: router, params: params, location: location, routes: routes });
	
	      if (withRef) {
	        props.ref = function (c) {
	          _this.wrappedInstance = c;
	        };
	      }
	
	      return _react2.default.createElement(WrappedComponent, props);
	    }
	  });
	
	  WithRouter.displayName = 'withRouter(' + getDisplayName(WrappedComponent) + ')';
	  WithRouter.WrappedComponent = WrappedComponent;
	
	  return (0, _hoistNonReactStatics2.default)(WithRouter, WrappedComponent);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 209 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';
	
	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};
	
	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};
	
	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';
	
	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') {
	        // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);
	
	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }
	
	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {}
	            }
	        }
	    }
	
	    return targetComponent;
	};

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(192);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Redirect = __webpack_require__(211);
	
	var _Redirect2 = _interopRequireDefault(_Redirect);
	
	var _InternalPropTypes = __webpack_require__(201);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes,
	    string = _React$PropTypes.string,
	    object = _React$PropTypes.object;
	
	/**
	 * An <IndexRedirect> is used to redirect from an indexRoute.
	 */
	/* eslint-disable react/require-render-return */
	
	var IndexRedirect = _react2.default.createClass({
	  displayName: 'IndexRedirect',
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = _Redirect2.default.createRouteFromReactElement(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRedirect> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRedirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRedirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(186);
	
	var _PatternUtils = __webpack_require__(188);
	
	var _InternalPropTypes = __webpack_require__(201);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes,
	    string = _React$PropTypes.string,
	    object = _React$PropTypes.object;
	
	/**
	 * A <Redirect> is used to declare another URL path a client should
	 * be sent to when they request a given URL.
	 *
	 * Redirects are placed alongside routes in the route configuration
	 * and are traversed in the same manner.
	 */
	/* eslint-disable react/require-render-return */
	
	var Redirect = _react2.default.createClass({
	  displayName: 'Redirect',
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element) {
	      var route = (0, _RouteUtils.createRouteFromReactElement)(element);
	
	      if (route.from) route.path = route.from;
	
	      route.onEnter = function (nextState, replace) {
	        var location = nextState.location,
	            params = nextState.params;
	
	        var pathname = void 0;
	        if (route.to.charAt(0) === '/') {
	          pathname = (0, _PatternUtils.formatPattern)(route.to, params);
	        } else if (!route.to) {
	          pathname = location.pathname;
	        } else {
	          var routeIndex = nextState.routes.indexOf(route);
	          var parentPattern = Redirect.getRoutePattern(nextState.routes, routeIndex - 1);
	          var pattern = parentPattern.replace(/\/*$/, '/') + route.to;
	          pathname = (0, _PatternUtils.formatPattern)(pattern, params);
	        }
	
	        replace({
	          pathname: pathname,
	          query: route.query || location.query,
	          state: route.state || location.state
	        });
	      };
	
	      return route;
	    },
	    getRoutePattern: function getRoutePattern(routes, routeIndex) {
	      var parentPattern = '';
	
	      for (var i = routeIndex; i >= 0; i--) {
	        var route = routes[i];
	        var pattern = route.path || '';
	
	        parentPattern = pattern.replace(/\/*$/, '/') + parentPattern;
	
	        if (pattern.indexOf('/') === 0) break;
	      }
	
	      return '/' + parentPattern;
	    }
	  },
	
	  propTypes: {
	    path: string,
	    from: string, // Alias for path
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Redirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Redirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(192);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(186);
	
	var _InternalPropTypes = __webpack_require__(201);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var func = _react2.default.PropTypes.func;
	
	/**
	 * An <IndexRoute> is used to specify its parent's <Route indexRoute> in
	 * a JSX route config.
	 */
	/* eslint-disable react/require-render-return */
	
	var IndexRoute = _react2.default.createClass({
	  displayName: 'IndexRoute',
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = (0, _RouteUtils.createRouteFromReactElement)(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRoute> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    path: _InternalPropTypes.falsy,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRoute> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRoute;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(186);
	
	var _InternalPropTypes = __webpack_require__(201);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes,
	    string = _React$PropTypes.string,
	    func = _React$PropTypes.func;
	
	/**
	 * A <Route> is used to declare which components are rendered to the
	 * page when the URL matches a given pattern.
	 *
	 * Routes are arranged in a nested tree structure. When a new URL is
	 * requested, the tree is searched depth-first to find a route whose
	 * path matches the URL.  When one is found, all routes in the tree
	 * that lead to it are considered "active" and their components are
	 * rendered into the DOM, nested in the same order as in the tree.
	 */
	/* eslint-disable react/require-render-return */
	
	var Route = _react2.default.createClass({
	  displayName: 'Route',
	
	  statics: {
	    createRouteFromReactElement: _RouteUtils.createRouteFromReactElement
	  },
	
	  propTypes: {
	    path: string,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Route> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Route;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _Actions = __webpack_require__(215);
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _createMemoryHistory = __webpack_require__(216);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	var _createTransitionManager = __webpack_require__(191);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _RouteUtils = __webpack_require__(186);
	
	var _RouterUtils = __webpack_require__(205);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	/**
	 * A high-level API to be used for server-side rendering.
	 *
	 * This function matches a location to a set of routes and calls
	 * callback(error, redirectLocation, renderProps) when finished.
	 *
	 * Note: You probably don't want to use this in a browser unless you're using
	 * server-side rendering with async routes.
	 */
	function match(_ref, callback) {
	  var history = _ref.history,
	      routes = _ref.routes,
	      location = _ref.location,
	      options = _objectWithoutProperties(_ref, ['history', 'routes', 'location']);
	
	  !(history || location) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'match needs a history or a location') : (0, _invariant2.default)(false) : void 0;
	
	  history = history ? history : (0, _createMemoryHistory2.default)(options);
	  var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes));
	
	  if (location) {
	    // Allow match({ location: '/the/path', ... })
	    location = history.createLocation(location);
	  } else {
	    location = history.getCurrentLocation();
	  }
	
	  transitionManager.match(location, function (error, redirectLocation, nextState) {
	    var renderProps = void 0;
	
	    if (nextState) {
	      var router = (0, _RouterUtils.createRouterObject)(history, transitionManager, nextState);
	      renderProps = _extends({}, nextState, {
	        router: router,
	        matchContext: { transitionManager: transitionManager, router: router }
	      });
	    }
	
	    callback(error, redirectLocation && history.createLocation(redirectLocation, _Actions.REPLACE), renderProps);
	  });
	}
	
	exports.default = match;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 215 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	/**
	 * Indicates that navigation was caused by a call to history.push.
	 */
	var PUSH = exports.PUSH = 'PUSH';
	
	/**
	 * Indicates that navigation was caused by a call to history.replace.
	 */
	var REPLACE = exports.REPLACE = 'REPLACE';
	
	/**
	 * Indicates that navigation was caused by some other action such
	 * as using a browser's back/forward buttons and/or manually manipulating
	 * the URL in a browser's location bar. This is the default.
	 *
	 * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
	 * for more information.
	 */
	var POP = exports.POP = 'POP';

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = createMemoryHistory;
	
	var _useQueries = __webpack_require__(217);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(223);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	var _createMemoryHistory = __webpack_require__(224);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function createMemoryHistory(options) {
	  // signatures and type checking differ between `useQueries` and
	  // `createMemoryHistory`, have to create `memoryHistory` first because
	  // `useQueries` doesn't understand the signature
	  var memoryHistory = (0, _createMemoryHistory2.default)(options);
	  var createHistory = function createHistory() {
	    return memoryHistory;
	  };
	  var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	  return history;
	}
	module.exports = exports['default'];

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _queryString = __webpack_require__(218);
	
	var _runTransitionHook = __webpack_require__(220);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _LocationUtils = __webpack_require__(221);
	
	var _PathUtils = __webpack_require__(222);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var defaultStringifyQuery = function defaultStringifyQuery(query) {
	  return (0, _queryString.stringify)(query).replace(/%20/g, '+');
	};
	
	var defaultParseQueryString = _queryString.parse;
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know how to handle URL queries.
	 */
	var useQueries = function useQueries(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	    var stringifyQuery = options.stringifyQuery;
	    var parseQueryString = options.parseQueryString;
	
	    if (typeof stringifyQuery !== 'function') stringifyQuery = defaultStringifyQuery;
	
	    if (typeof parseQueryString !== 'function') parseQueryString = defaultParseQueryString;
	
	    var decodeQuery = function decodeQuery(location) {
	      if (!location) return location;
	
	      if (location.query == null) location.query = parseQueryString(location.search.substring(1));
	
	      return location;
	    };
	
	    var encodeQuery = function encodeQuery(location, query) {
	      if (query == null) return location;
	
	      var object = typeof location === 'string' ? (0, _PathUtils.parsePath)(location) : location;
	      var queryString = stringifyQuery(query);
	      var search = queryString ? '?' + queryString : '';
	
	      return _extends({}, object, {
	        search: search
	      });
	    };
	
	    // Override all read methods with query-aware versions.
	    var getCurrentLocation = function getCurrentLocation() {
	      return decodeQuery(history.getCurrentLocation());
	    };
	
	    var listenBefore = function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        return (0, _runTransitionHook2.default)(hook, decodeQuery(location), callback);
	      });
	    };
	
	    var listen = function listen(listener) {
	      return history.listen(function (location) {
	        return listener(decodeQuery(location));
	      });
	    };
	
	    // Override all write methods with query-aware versions.
	    var push = function push(location) {
	      return history.push(encodeQuery(location, location.query));
	    };
	
	    var replace = function replace(location) {
	      return history.replace(encodeQuery(location, location.query));
	    };
	
	    var createPath = function createPath(location) {
	      return history.createPath(encodeQuery(location, location.query));
	    };
	
	    var createHref = function createHref(location) {
	      return history.createHref(encodeQuery(location, location.query));
	    };
	
	    var createLocation = function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var newLocation = history.createLocation.apply(history, [encodeQuery(location, location.query)].concat(args));
	
	      if (location.query) newLocation.query = (0, _LocationUtils.createQuery)(location.query);
	
	      return decodeQuery(newLocation);
	    };
	
	    return _extends({}, history, {
	      getCurrentLocation: getCurrentLocation,
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation
	    });
	  };
	};
	
	exports.default = useQueries;

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var strictUriEncode = __webpack_require__(219);
	var objectAssign = __webpack_require__(11);
	
	function encode(value, opts) {
		if (opts.encode) {
			return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
		}
	
		return value;
	}
	
	exports.extract = function (str) {
		return str.split('?')[1] || '';
	};
	
	exports.parse = function (str) {
		// Create an object with no prototype
		// https://github.com/sindresorhus/query-string/issues/47
		var ret = Object.create(null);
	
		if (typeof str !== 'string') {
			return ret;
		}
	
		str = str.trim().replace(/^(\?|#|&)/, '');
	
		if (!str) {
			return ret;
		}
	
		str.split('&').forEach(function (param) {
			var parts = param.replace(/\+/g, ' ').split('=');
			// Firefox (pre 40) decodes `%3D` to `=`
			// https://github.com/sindresorhus/query-string/pull/37
			var key = parts.shift();
			var val = parts.length > 0 ? parts.join('=') : undefined;
	
			key = decodeURIComponent(key);
	
			// missing `=` should be `null`:
			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
			val = val === undefined ? null : decodeURIComponent(val);
	
			if (ret[key] === undefined) {
				ret[key] = val;
			} else if (Array.isArray(ret[key])) {
				ret[key].push(val);
			} else {
				ret[key] = [ret[key], val];
			}
		});
	
		return ret;
	};
	
	exports.stringify = function (obj, opts) {
		var defaults = {
			encode: true,
			strict: true
		};
	
		opts = objectAssign(defaults, opts);
	
		return obj ? Object.keys(obj).sort().map(function (key) {
			var val = obj[key];
	
			if (val === undefined) {
				return '';
			}
	
			if (val === null) {
				return encode(key, opts);
			}
	
			if (Array.isArray(val)) {
				var result = [];
	
				val.slice().forEach(function (val2) {
					if (val2 === undefined) {
						return;
					}
	
					if (val2 === null) {
						result.push(encode(key, opts));
					} else {
						result.push(encode(key, opts) + '=' + encode(val2, opts));
					}
				});
	
				return result.join('&');
			}
	
			return encode(key, opts) + '=' + encode(val, opts);
		}).filter(function (x) {
			return x.length > 0;
		}).join('&') : '';
	};

/***/ },
/* 219 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (str) {
		return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
			return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		});
	};

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _warning = __webpack_require__(193);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var runTransitionHook = function runTransitionHook(hook, location, callback) {
	  var result = hook(location, callback);
	
	  if (hook.length < 2) {
	    // Assume the hook runs synchronously and automatically
	    // call the callback with the return value.
	    callback(result);
	  } else {
	    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(result === undefined, 'You should not "return" in a transition hook with a callback argument; ' + 'call the callback instead') : void 0;
	  }
	};
	
	exports.default = runTransitionHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	exports.locationsAreEqual = exports.statesAreEqual = exports.createLocation = exports.createQuery = undefined;
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _warning = __webpack_require__(193);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _PathUtils = __webpack_require__(222);
	
	var _Actions = __webpack_require__(215);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var createQuery = exports.createQuery = function createQuery(props) {
	  return _extends(Object.create(null), props);
	};
	
	var createLocation = exports.createLocation = function createLocation() {
	  var input = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
	  var action = arguments.length <= 1 || arguments[1] === undefined ? _Actions.POP : arguments[1];
	  var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	  var object = typeof input === 'string' ? (0, _PathUtils.parsePath)(input) : input;
	
	  process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(!object.path, 'Location descriptor objects should have a `pathname`, not a `path`.') : void 0;
	
	  var pathname = object.pathname || '/';
	  var search = object.search || '';
	  var hash = object.hash || '';
	  var state = object.state;
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash,
	    state: state,
	    action: action,
	    key: key
	  };
	};
	
	var isDate = function isDate(object) {
	  return Object.prototype.toString.call(object) === '[object Date]';
	};
	
	var statesAreEqual = exports.statesAreEqual = function statesAreEqual(a, b) {
	  if (a === b) return true;
	
	  var typeofA = typeof a === 'undefined' ? 'undefined' : _typeof(a);
	  var typeofB = typeof b === 'undefined' ? 'undefined' : _typeof(b);
	
	  if (typeofA !== typeofB) return false;
	
	  !(typeofA !== 'function') ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You must not store functions in location state') : (0, _invariant2.default)(false) : void 0;
	
	  // Not the same object, but same type.
	  if (typeofA === 'object') {
	    !!(isDate(a) && isDate(b)) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You must not store Date objects in location state') : (0, _invariant2.default)(false) : void 0;
	
	    if (!Array.isArray(a)) {
	      var keysofA = Object.keys(a);
	      var keysofB = Object.keys(b);
	      return keysofA.length === keysofB.length && keysofA.every(function (key) {
	        return statesAreEqual(a[key], b[key]);
	      });
	    }
	
	    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
	      return statesAreEqual(item, b[index]);
	    });
	  }
	
	  // All other serializable types (string, number, boolean)
	  // should be strict equal.
	  return false;
	};
	
	var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
	  return a.key === b.key &&
	  // a.action === b.action && // Different action !== location change.
	  a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && statesAreEqual(a.state, b.state);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.createPath = exports.parsePath = exports.getQueryStringValueFromPath = exports.stripQueryStringValueFromPath = exports.addQueryStringValueToPath = undefined;
	
	var _warning = __webpack_require__(193);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var addQueryStringValueToPath = exports.addQueryStringValueToPath = function addQueryStringValueToPath(path, key, value) {
	  var _parsePath = parsePath(path);
	
	  var pathname = _parsePath.pathname;
	  var search = _parsePath.search;
	  var hash = _parsePath.hash;
	
	  return createPath({
	    pathname: pathname,
	    search: search + (search.indexOf('?') === -1 ? '?' : '&') + key + '=' + value,
	    hash: hash
	  });
	};
	
	var stripQueryStringValueFromPath = exports.stripQueryStringValueFromPath = function stripQueryStringValueFromPath(path, key) {
	  var _parsePath2 = parsePath(path);
	
	  var pathname = _parsePath2.pathname;
	  var search = _parsePath2.search;
	  var hash = _parsePath2.hash;
	
	  return createPath({
	    pathname: pathname,
	    search: search.replace(new RegExp('([?&])' + key + '=[a-zA-Z0-9]+(&?)'), function (match, prefix, suffix) {
	      return prefix === '?' ? prefix : suffix;
	    }),
	    hash: hash
	  });
	};
	
	var getQueryStringValueFromPath = exports.getQueryStringValueFromPath = function getQueryStringValueFromPath(path, key) {
	  var _parsePath3 = parsePath(path);
	
	  var search = _parsePath3.search;
	
	  var match = search.match(new RegExp('[?&]' + key + '=([a-zA-Z0-9]+)'));
	  return match && match[1];
	};
	
	var extractPath = function extractPath(string) {
	  var match = string.match(/^(https?:)?\/\/[^\/]*/);
	  return match == null ? string : string.substring(match[0].length);
	};
	
	var parsePath = exports.parsePath = function parsePath(path) {
	  var pathname = extractPath(path);
	  var search = '';
	  var hash = '';
	
	  process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(path === pathname, 'A path must be pathname + search + hash only, not a full URL like "%s"', path) : void 0;
	
	  var hashIndex = pathname.indexOf('#');
	  if (hashIndex !== -1) {
	    hash = pathname.substring(hashIndex);
	    pathname = pathname.substring(0, hashIndex);
	  }
	
	  var searchIndex = pathname.indexOf('?');
	  if (searchIndex !== -1) {
	    search = pathname.substring(searchIndex);
	    pathname = pathname.substring(0, searchIndex);
	  }
	
	  if (pathname === '') pathname = '/';
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash
	  };
	};
	
	var createPath = exports.createPath = function createPath(location) {
	  if (location == null || typeof location === 'string') return location;
	
	  var basename = location.basename;
	  var pathname = location.pathname;
	  var search = location.search;
	  var hash = location.hash;
	
	  var path = (basename || '') + pathname;
	
	  if (search && search !== '?') path += search;
	
	  if (hash) path += hash;
	
	  return path;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _runTransitionHook = __webpack_require__(220);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _PathUtils = __webpack_require__(222);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var useBasename = function useBasename(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	    var basename = options.basename;
	
	    var addBasename = function addBasename(location) {
	      if (!location) return location;
	
	      if (basename && location.basename == null) {
	        if (location.pathname.indexOf(basename) === 0) {
	          location.pathname = location.pathname.substring(basename.length);
	          location.basename = basename;
	
	          if (location.pathname === '') location.pathname = '/';
	        } else {
	          location.basename = '';
	        }
	      }
	
	      return location;
	    };
	
	    var prependBasename = function prependBasename(location) {
	      if (!basename) return location;
	
	      var object = typeof location === 'string' ? (0, _PathUtils.parsePath)(location) : location;
	      var pname = object.pathname;
	      var normalizedBasename = basename.slice(-1) === '/' ? basename : basename + '/';
	      var normalizedPathname = pname.charAt(0) === '/' ? pname.slice(1) : pname;
	      var pathname = normalizedBasename + normalizedPathname;
	
	      return _extends({}, object, {
	        pathname: pathname
	      });
	    };
	
	    // Override all read methods with basename-aware versions.
	    var getCurrentLocation = function getCurrentLocation() {
	      return addBasename(history.getCurrentLocation());
	    };
	
	    var listenBefore = function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        return (0, _runTransitionHook2.default)(hook, addBasename(location), callback);
	      });
	    };
	
	    var listen = function listen(listener) {
	      return history.listen(function (location) {
	        return listener(addBasename(location));
	      });
	    };
	
	    // Override all write methods with basename-aware versions.
	    var push = function push(location) {
	      return history.push(prependBasename(location));
	    };
	
	    var replace = function replace(location) {
	      return history.replace(prependBasename(location));
	    };
	
	    var createPath = function createPath(location) {
	      return history.createPath(prependBasename(location));
	    };
	
	    var createHref = function createHref(location) {
	      return history.createHref(prependBasename(location));
	    };
	
	    var createLocation = function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      return addBasename(history.createLocation.apply(history, [prependBasename(location)].concat(args)));
	    };
	
	    return _extends({}, history, {
	      getCurrentLocation: getCurrentLocation,
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation
	    });
	  };
	};
	
	exports.default = useBasename;

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _warning = __webpack_require__(193);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _LocationUtils = __webpack_require__(221);
	
	var _PathUtils = __webpack_require__(222);
	
	var _createHistory = __webpack_require__(225);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	var _Actions = __webpack_require__(215);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var createStateStorage = function createStateStorage(entries) {
	  return entries.filter(function (entry) {
	    return entry.state;
	  }).reduce(function (memo, entry) {
	    memo[entry.key] = entry.state;
	    return memo;
	  }, {});
	};
	
	var createMemoryHistory = function createMemoryHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  if (Array.isArray(options)) {
	    options = { entries: options };
	  } else if (typeof options === 'string') {
	    options = { entries: [options] };
	  }
	
	  var getCurrentLocation = function getCurrentLocation() {
	    var entry = entries[current];
	    var path = (0, _PathUtils.createPath)(entry);
	
	    var key = void 0,
	        state = void 0;
	    if (entry.key) {
	      key = entry.key;
	      state = readState(key);
	    }
	
	    var init = (0, _PathUtils.parsePath)(path);
	
	    return (0, _LocationUtils.createLocation)(_extends({}, init, { state: state }), undefined, key);
	  };
	
	  var canGo = function canGo(n) {
	    var index = current + n;
	    return index >= 0 && index < entries.length;
	  };
	
	  var go = function go(n) {
	    if (!n) return;
	
	    if (!canGo(n)) {
	      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, 'Cannot go(%s) there is not enough history', n) : void 0;
	
	      return;
	    }
	
	    current += n;
	    var currentLocation = getCurrentLocation();
	
	    // Change action to POP
	    history.transitionTo(_extends({}, currentLocation, { action: _Actions.POP }));
	  };
	
	  var pushLocation = function pushLocation(location) {
	    current += 1;
	
	    if (current < entries.length) entries.splice(current);
	
	    entries.push(location);
	
	    saveState(location.key, location.state);
	  };
	
	  var replaceLocation = function replaceLocation(location) {
	    entries[current] = location;
	    saveState(location.key, location.state);
	  };
	
	  var history = (0, _createHistory2.default)(_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    pushLocation: pushLocation,
	    replaceLocation: replaceLocation,
	    go: go
	  }));
	
	  var _options = options;
	  var entries = _options.entries;
	  var current = _options.current;
	
	  if (typeof entries === 'string') {
	    entries = [entries];
	  } else if (!Array.isArray(entries)) {
	    entries = ['/'];
	  }
	
	  entries = entries.map(function (entry) {
	    return (0, _LocationUtils.createLocation)(entry);
	  });
	
	  if (current == null) {
	    current = entries.length - 1;
	  } else {
	    !(current >= 0 && current < entries.length) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Current index must be >= 0 and < %s, was %s', entries.length, current) : (0, _invariant2.default)(false) : void 0;
	  }
	
	  var storage = createStateStorage(entries);
	
	  var saveState = function saveState(key, state) {
	    return storage[key] = state;
	  };
	
	  var readState = function readState(key) {
	    return storage[key];
	  };
	
	  return _extends({}, history, {
	    canGo: canGo
	  });
	};
	
	exports.default = createMemoryHistory;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _AsyncUtils = __webpack_require__(226);
	
	var _PathUtils = __webpack_require__(222);
	
	var _runTransitionHook = __webpack_require__(220);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _Actions = __webpack_require__(215);
	
	var _LocationUtils = __webpack_require__(221);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var createHistory = function createHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var getCurrentLocation = options.getCurrentLocation;
	  var getUserConfirmation = options.getUserConfirmation;
	  var pushLocation = options.pushLocation;
	  var replaceLocation = options.replaceLocation;
	  var go = options.go;
	  var keyLength = options.keyLength;
	
	  var currentLocation = void 0;
	  var pendingLocation = void 0;
	  var beforeListeners = [];
	  var listeners = [];
	  var allKeys = [];
	
	  var getCurrentIndex = function getCurrentIndex() {
	    if (pendingLocation && pendingLocation.action === _Actions.POP) return allKeys.indexOf(pendingLocation.key);
	
	    if (currentLocation) return allKeys.indexOf(currentLocation.key);
	
	    return -1;
	  };
	
	  var updateLocation = function updateLocation(nextLocation) {
	    var currentIndex = getCurrentIndex();
	
	    currentLocation = nextLocation;
	
	    if (currentLocation.action === _Actions.PUSH) {
	      allKeys = [].concat(allKeys.slice(0, currentIndex + 1), [currentLocation.key]);
	    } else if (currentLocation.action === _Actions.REPLACE) {
	      allKeys[currentIndex] = currentLocation.key;
	    }
	
	    listeners.forEach(function (listener) {
	      return listener(currentLocation);
	    });
	  };
	
	  var listenBefore = function listenBefore(listener) {
	    beforeListeners.push(listener);
	
	    return function () {
	      return beforeListeners = beforeListeners.filter(function (item) {
	        return item !== listener;
	      });
	    };
	  };
	
	  var listen = function listen(listener) {
	    listeners.push(listener);
	
	    return function () {
	      return listeners = listeners.filter(function (item) {
	        return item !== listener;
	      });
	    };
	  };
	
	  var confirmTransitionTo = function confirmTransitionTo(location, callback) {
	    (0, _AsyncUtils.loopAsync)(beforeListeners.length, function (index, next, done) {
	      (0, _runTransitionHook2.default)(beforeListeners[index], location, function (result) {
	        return result != null ? done(result) : next();
	      });
	    }, function (message) {
	      if (getUserConfirmation && typeof message === 'string') {
	        getUserConfirmation(message, function (ok) {
	          return callback(ok !== false);
	        });
	      } else {
	        callback(message !== false);
	      }
	    });
	  };
	
	  var transitionTo = function transitionTo(nextLocation) {
	    if (currentLocation && (0, _LocationUtils.locationsAreEqual)(currentLocation, nextLocation) || pendingLocation && (0, _LocationUtils.locationsAreEqual)(pendingLocation, nextLocation)) return; // Nothing to do
	
	    pendingLocation = nextLocation;
	
	    confirmTransitionTo(nextLocation, function (ok) {
	      if (pendingLocation !== nextLocation) return; // Transition was interrupted during confirmation
	
	      pendingLocation = null;
	
	      if (ok) {
	        // Treat PUSH to same path like REPLACE to be consistent with browsers
	        if (nextLocation.action === _Actions.PUSH) {
	          var prevPath = (0, _PathUtils.createPath)(currentLocation);
	          var nextPath = (0, _PathUtils.createPath)(nextLocation);
	
	          if (nextPath === prevPath && (0, _LocationUtils.statesAreEqual)(currentLocation.state, nextLocation.state)) nextLocation.action = _Actions.REPLACE;
	        }
	
	        if (nextLocation.action === _Actions.POP) {
	          updateLocation(nextLocation);
	        } else if (nextLocation.action === _Actions.PUSH) {
	          if (pushLocation(nextLocation) !== false) updateLocation(nextLocation);
	        } else if (nextLocation.action === _Actions.REPLACE) {
	          if (replaceLocation(nextLocation) !== false) updateLocation(nextLocation);
	        }
	      } else if (currentLocation && nextLocation.action === _Actions.POP) {
	        var prevIndex = allKeys.indexOf(currentLocation.key);
	        var nextIndex = allKeys.indexOf(nextLocation.key);
	
	        if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL
	      }
	    });
	  };
	
	  var push = function push(input) {
	    return transitionTo(createLocation(input, _Actions.PUSH));
	  };
	
	  var replace = function replace(input) {
	    return transitionTo(createLocation(input, _Actions.REPLACE));
	  };
	
	  var goBack = function goBack() {
	    return go(-1);
	  };
	
	  var goForward = function goForward() {
	    return go(1);
	  };
	
	  var createKey = function createKey() {
	    return Math.random().toString(36).substr(2, keyLength || 6);
	  };
	
	  var createHref = function createHref(location) {
	    return (0, _PathUtils.createPath)(location);
	  };
	
	  var createLocation = function createLocation(location, action) {
	    var key = arguments.length <= 2 || arguments[2] === undefined ? createKey() : arguments[2];
	    return (0, _LocationUtils.createLocation)(location, action, key);
	  };
	
	  return {
	    getCurrentLocation: getCurrentLocation,
	    listenBefore: listenBefore,
	    listen: listen,
	    transitionTo: transitionTo,
	    push: push,
	    replace: replace,
	    go: go,
	    goBack: goBack,
	    goForward: goForward,
	    createKey: createKey,
	    createPath: _PathUtils.createPath,
	    createHref: createHref,
	    createLocation: createLocation
	  };
	};
	
	exports.default = createHistory;

/***/ },
/* 226 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	var loopAsync = exports.loopAsync = function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var isSync = false,
	      hasNext = false,
	      doneArgs = void 0;
	
	  var done = function done() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    isDone = true;
	
	    if (isSync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = args;
	      return;
	    }
	
	    callback.apply(undefined, args);
	  };
	
	  var next = function next() {
	    if (isDone) return;
	
	    hasNext = true;
	
	    if (isSync) return; // Iterate instead of recursing if possible.
	
	    isSync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work(currentTurn++, next, done);
	    }
	
	    isSync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(undefined, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  };
	
	  next();
	};

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = useRouterHistory;
	
	var _useQueries = __webpack_require__(217);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(223);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function useRouterHistory(createHistory) {
	  return function (options) {
	    var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	    return history;
	  };
	}
	module.exports = exports['default'];

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(202);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(192);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.default = function () {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    middlewares.forEach(function (middleware, index) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(middleware.renderRouterContext || middleware.renderRouteComponent, 'The middleware specified at index ' + index + ' does not appear to be ' + 'a valid React Router middleware.') : void 0;
	    });
	  }
	
	  var withContext = middlewares.map(function (middleware) {
	    return middleware.renderRouterContext;
	  }).filter(Boolean);
	  var withComponent = middlewares.map(function (middleware) {
	    return middleware.renderRouteComponent;
	  }).filter(Boolean);
	
	  var makeCreateElement = function makeCreateElement() {
	    var baseCreateElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _react.createElement;
	    return function (Component, props) {
	      return withComponent.reduceRight(function (previous, renderRouteComponent) {
	        return renderRouteComponent(previous, props);
	      }, baseCreateElement(Component, props));
	    };
	  };
	
	  return function (renderProps) {
	    return withContext.reduceRight(function (previous, renderRouterContext) {
	      return renderRouterContext(previous, renderProps);
	    }, _react2.default.createElement(_RouterContext2.default, _extends({}, renderProps, {
	      createElement: makeCreateElement(renderProps.createElement)
	    })));
	  };
	};
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createBrowserHistory = __webpack_require__(230);
	
	var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);
	
	var _createRouterHistory = __webpack_require__(236);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.default = (0, _createRouterHistory2.default)(_createBrowserHistory2.default);
	module.exports = exports['default'];

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ExecutionEnvironment = __webpack_require__(231);
	
	var _BrowserProtocol = __webpack_require__(232);
	
	var BrowserProtocol = _interopRequireWildcard(_BrowserProtocol);
	
	var _RefreshProtocol = __webpack_require__(235);
	
	var RefreshProtocol = _interopRequireWildcard(_RefreshProtocol);
	
	var _DOMUtils = __webpack_require__(233);
	
	var _createHistory = __webpack_require__(225);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function _interopRequireWildcard(obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }newObj.default = obj;return newObj;
	  }
	}
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	/**
	 * Creates and returns a history object that uses HTML5's history API
	 * (pushState, replaceState, and the popstate event) to manage history.
	 * This is the recommended method of managing history in browsers because
	 * it provides the cleanest URLs.
	 *
	 * Note: In browsers that do not support the HTML5 history API full
	 * page reloads will be used to preserve clean URLs. You can force this
	 * behavior using { forceRefresh: true } in options.
	 */
	var createBrowserHistory = function createBrowserHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Browser history needs a DOM') : (0, _invariant2.default)(false) : void 0;
	
	  var useRefresh = options.forceRefresh || !(0, _DOMUtils.supportsHistory)();
	  var Protocol = useRefresh ? RefreshProtocol : BrowserProtocol;
	
	  var getUserConfirmation = Protocol.getUserConfirmation;
	  var getCurrentLocation = Protocol.getCurrentLocation;
	  var pushLocation = Protocol.pushLocation;
	  var replaceLocation = Protocol.replaceLocation;
	  var go = Protocol.go;
	
	  var history = (0, _createHistory2.default)(_extends({
	    getUserConfirmation: getUserConfirmation }, options, {
	    getCurrentLocation: getCurrentLocation,
	    pushLocation: pushLocation,
	    replaceLocation: replaceLocation,
	    go: go
	  }));
	
	  var listenerCount = 0,
	      stopListener = void 0;
	
	  var startListener = function startListener(listener, before) {
	    if (++listenerCount === 1) stopListener = BrowserProtocol.startListener(history.transitionTo);
	
	    var unlisten = before ? history.listenBefore(listener) : history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopListener();
	    };
	  };
	
	  var listenBefore = function listenBefore(listener) {
	    return startListener(listener, true);
	  };
	
	  var listen = function listen(listener) {
	    return startListener(listener, false);
	  };
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen
	  });
	};
	
	exports.default = createBrowserHistory;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 231 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.go = exports.replaceLocation = exports.pushLocation = exports.startListener = exports.getUserConfirmation = exports.getCurrentLocation = undefined;
	
	var _LocationUtils = __webpack_require__(221);
	
	var _DOMUtils = __webpack_require__(233);
	
	var _DOMStateStorage = __webpack_require__(234);
	
	var _PathUtils = __webpack_require__(222);
	
	var _ExecutionEnvironment = __webpack_require__(231);
	
	var PopStateEvent = 'popstate';
	var HashChangeEvent = 'hashchange';
	
	var needsHashchangeListener = _ExecutionEnvironment.canUseDOM && !(0, _DOMUtils.supportsPopstateOnHashchange)();
	
	var _createLocation = function _createLocation(historyState) {
	  var key = historyState && historyState.key;
	
	  return (0, _LocationUtils.createLocation)({
	    pathname: window.location.pathname,
	    search: window.location.search,
	    hash: window.location.hash,
	    state: key ? (0, _DOMStateStorage.readState)(key) : undefined
	  }, undefined, key);
	};
	
	var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation() {
	  var historyState = void 0;
	  try {
	    historyState = window.history.state || {};
	  } catch (error) {
	    // IE 11 sometimes throws when accessing window.history.state
	    // See https://github.com/ReactTraining/history/pull/289
	    historyState = {};
	  }
	
	  return _createLocation(historyState);
	};
	
	var getUserConfirmation = exports.getUserConfirmation = function getUserConfirmation(message, callback) {
	  return callback(window.confirm(message));
	}; // eslint-disable-line no-alert
	
	var startListener = exports.startListener = function startListener(listener) {
	  var handlePopState = function handlePopState(event) {
	    if (event.state !== undefined) // Ignore extraneous popstate events in WebKit
	      listener(_createLocation(event.state));
	  };
	
	  (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);
	
	  var handleUnpoppedHashChange = function handleUnpoppedHashChange() {
	    return listener(getCurrentLocation());
	  };
	
	  if (needsHashchangeListener) {
	    (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleUnpoppedHashChange);
	  }
	
	  return function () {
	    (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);
	
	    if (needsHashchangeListener) {
	      (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleUnpoppedHashChange);
	    }
	  };
	};
	
	var updateLocation = function updateLocation(location, updateState) {
	  var state = location.state;
	  var key = location.key;
	
	  if (state !== undefined) (0, _DOMStateStorage.saveState)(key, state);
	
	  updateState({ key: key }, (0, _PathUtils.createPath)(location));
	};
	
	var pushLocation = exports.pushLocation = function pushLocation(location) {
	  return updateLocation(location, function (state, path) {
	    return window.history.pushState(state, null, path);
	  });
	};
	
	var replaceLocation = exports.replaceLocation = function replaceLocation(location) {
	  return updateLocation(location, function (state, path) {
	    return window.history.replaceState(state, null, path);
	  });
	};
	
	var go = exports.go = function go(n) {
	  if (n) window.history.go(n);
	};

/***/ },
/* 233 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
	  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
	};
	
	var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
	  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
	};
	
	/**
	 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
	 *
	 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
	 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
	 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
	 */
	var supportsHistory = exports.supportsHistory = function supportsHistory() {
	  var ua = window.navigator.userAgent;
	
	  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;
	
	  return window.history && 'pushState' in window.history;
	};
	
	/**
	 * Returns false if using go(n) with hash history causes a full page reload.
	 */
	var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
	  return window.navigator.userAgent.indexOf('Firefox') === -1;
	};
	
	/**
	 * Returns true if browser fires popstate on hash change.
	 * IE10 and IE11 do not.
	 */
	var supportsPopstateOnHashchange = exports.supportsPopstateOnHashchange = function supportsPopstateOnHashchange() {
	  return window.navigator.userAgent.indexOf('Trident') === -1;
	};

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.readState = exports.saveState = undefined;
	
	var _warning = __webpack_require__(193);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var QuotaExceededErrors = {
	  QuotaExceededError: true,
	  QUOTA_EXCEEDED_ERR: true
	};
	
	var SecurityErrors = {
	  SecurityError: true
	};
	
	var KeyPrefix = '@@History/';
	
	var createKey = function createKey(key) {
	  return KeyPrefix + key;
	};
	
	var saveState = exports.saveState = function saveState(key, state) {
	  if (!window.sessionStorage) {
	    // Session storage is not available or hidden.
	    // sessionStorage is undefined in Internet Explorer when served via file protocol.
	    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available') : void 0;
	
	    return;
	  }
	
	  try {
	    if (state == null) {
	      window.sessionStorage.removeItem(createKey(key));
	    } else {
	      window.sessionStorage.setItem(createKey(key), JSON.stringify(state));
	    }
	  } catch (error) {
	    if (SecurityErrors[error.name]) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available due to security settings') : void 0;
	
	      return;
	    }
	
	    if (QuotaExceededErrors[error.name] && window.sessionStorage.length === 0) {
	      // Safari "private mode" throws QuotaExceededError.
	      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available in Safari private mode') : void 0;
	
	      return;
	    }
	
	    throw error;
	  }
	};
	
	var readState = exports.readState = function readState(key) {
	  var json = void 0;
	  try {
	    json = window.sessionStorage.getItem(createKey(key));
	  } catch (error) {
	    if (SecurityErrors[error.name]) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to read state; sessionStorage is not available due to security settings') : void 0;
	
	      return undefined;
	    }
	  }
	
	  if (json) {
	    try {
	      return JSON.parse(json);
	    } catch (error) {
	      // Ignore invalid JSON.
	    }
	  }
	
	  return undefined;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.replaceLocation = exports.pushLocation = exports.getCurrentLocation = exports.go = exports.getUserConfirmation = undefined;
	
	var _BrowserProtocol = __webpack_require__(232);
	
	Object.defineProperty(exports, 'getUserConfirmation', {
	  enumerable: true,
	  get: function get() {
	    return _BrowserProtocol.getUserConfirmation;
	  }
	});
	Object.defineProperty(exports, 'go', {
	  enumerable: true,
	  get: function get() {
	    return _BrowserProtocol.go;
	  }
	});
	
	var _LocationUtils = __webpack_require__(221);
	
	var _PathUtils = __webpack_require__(222);
	
	var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation() {
	  return (0, _LocationUtils.createLocation)(window.location);
	};
	
	var pushLocation = exports.pushLocation = function pushLocation(location) {
	  window.location.href = (0, _PathUtils.createPath)(location);
	  return false; // Don't update location
	};
	
	var replaceLocation = exports.replaceLocation = function replaceLocation(location) {
	  window.location.replace((0, _PathUtils.createPath)(location));
	  return false; // Don't update location
	};

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	exports.default = function (createHistory) {
	  var history = void 0;
	  if (canUseDOM) history = (0, _useRouterHistory2.default)(createHistory)();
	  return history;
	};
	
	var _useRouterHistory = __webpack_require__(227);
	
	var _useRouterHistory2 = _interopRequireDefault(_useRouterHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	module.exports = exports['default'];

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createHashHistory = __webpack_require__(238);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _createRouterHistory = __webpack_require__(236);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.default = (0, _createRouterHistory2.default)(_createHashHistory2.default);
	module.exports = exports['default'];

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _warning = __webpack_require__(193);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ExecutionEnvironment = __webpack_require__(231);
	
	var _DOMUtils = __webpack_require__(233);
	
	var _HashProtocol = __webpack_require__(239);
	
	var HashProtocol = _interopRequireWildcard(_HashProtocol);
	
	var _createHistory = __webpack_require__(225);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function _interopRequireWildcard(obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }newObj.default = obj;return newObj;
	  }
	}
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var DefaultQueryKey = '_k';
	
	var addLeadingSlash = function addLeadingSlash(path) {
	  return path.charAt(0) === '/' ? path : '/' + path;
	};
	
	var HashPathCoders = {
	  hashbang: {
	    encodePath: function encodePath(path) {
	      return path.charAt(0) === '!' ? path : '!' + path;
	    },
	    decodePath: function decodePath(path) {
	      return path.charAt(0) === '!' ? path.substring(1) : path;
	    }
	  },
	  noslash: {
	    encodePath: function encodePath(path) {
	      return path.charAt(0) === '/' ? path.substring(1) : path;
	    },
	    decodePath: addLeadingSlash
	  },
	  slash: {
	    encodePath: addLeadingSlash,
	    decodePath: addLeadingSlash
	  }
	};
	
	var createHashHistory = function createHashHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Hash history needs a DOM') : (0, _invariant2.default)(false) : void 0;
	
	  var queryKey = options.queryKey;
	  var hashType = options.hashType;
	
	  process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(queryKey !== false, 'Using { queryKey: false } no longer works. Instead, just don\'t ' + 'use location state if you don\'t want a key in your URL query string') : void 0;
	
	  if (typeof queryKey !== 'string') queryKey = DefaultQueryKey;
	
	  if (hashType == null) hashType = 'slash';
	
	  if (!(hashType in HashPathCoders)) {
	    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, 'Invalid hash type: %s', hashType) : void 0;
	
	    hashType = 'slash';
	  }
	
	  var pathCoder = HashPathCoders[hashType];
	
	  var getUserConfirmation = HashProtocol.getUserConfirmation;
	
	  var getCurrentLocation = function getCurrentLocation() {
	    return HashProtocol.getCurrentLocation(pathCoder, queryKey);
	  };
	
	  var pushLocation = function pushLocation(location) {
	    return HashProtocol.pushLocation(location, pathCoder, queryKey);
	  };
	
	  var replaceLocation = function replaceLocation(location) {
	    return HashProtocol.replaceLocation(location, pathCoder, queryKey);
	  };
	
	  var history = (0, _createHistory2.default)(_extends({
	    getUserConfirmation: getUserConfirmation }, options, {
	    getCurrentLocation: getCurrentLocation,
	    pushLocation: pushLocation,
	    replaceLocation: replaceLocation,
	    go: HashProtocol.go
	  }));
	
	  var listenerCount = 0,
	      stopListener = void 0;
	
	  var startListener = function startListener(listener, before) {
	    if (++listenerCount === 1) stopListener = HashProtocol.startListener(history.transitionTo, pathCoder, queryKey);
	
	    var unlisten = before ? history.listenBefore(listener) : history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopListener();
	    };
	  };
	
	  var listenBefore = function listenBefore(listener) {
	    return startListener(listener, true);
	  };
	
	  var listen = function listen(listener) {
	    return startListener(listener, false);
	  };
	
	  var goIsSupportedWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();
	
	  var go = function go(n) {
	    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : void 0;
	
	    history.go(n);
	  };
	
	  var createHref = function createHref(path) {
	    return '#' + pathCoder.encodePath(history.createHref(path));
	  };
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    go: go,
	    createHref: createHref
	  });
	};
	
	exports.default = createHashHistory;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.replaceLocation = exports.pushLocation = exports.startListener = exports.getCurrentLocation = exports.go = exports.getUserConfirmation = undefined;
	
	var _BrowserProtocol = __webpack_require__(232);
	
	Object.defineProperty(exports, 'getUserConfirmation', {
	  enumerable: true,
	  get: function get() {
	    return _BrowserProtocol.getUserConfirmation;
	  }
	});
	Object.defineProperty(exports, 'go', {
	  enumerable: true,
	  get: function get() {
	    return _BrowserProtocol.go;
	  }
	});
	
	var _warning = __webpack_require__(193);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _LocationUtils = __webpack_require__(221);
	
	var _DOMUtils = __webpack_require__(233);
	
	var _DOMStateStorage = __webpack_require__(234);
	
	var _PathUtils = __webpack_require__(222);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var HashChangeEvent = 'hashchange';
	
	var getHashPath = function getHashPath() {
	  // We can't use window.location.hash here because it's not
	  // consistent across browsers - Firefox will pre-decode it!
	  var href = window.location.href;
	  var hashIndex = href.indexOf('#');
	  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
	};
	
	var pushHashPath = function pushHashPath(path) {
	  return window.location.hash = path;
	};
	
	var replaceHashPath = function replaceHashPath(path) {
	  var hashIndex = window.location.href.indexOf('#');
	
	  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
	};
	
	var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation(pathCoder, queryKey) {
	  var path = pathCoder.decodePath(getHashPath());
	  var key = (0, _PathUtils.getQueryStringValueFromPath)(path, queryKey);
	
	  var state = void 0;
	  if (key) {
	    path = (0, _PathUtils.stripQueryStringValueFromPath)(path, queryKey);
	    state = (0, _DOMStateStorage.readState)(key);
	  }
	
	  var init = (0, _PathUtils.parsePath)(path);
	  init.state = state;
	
	  return (0, _LocationUtils.createLocation)(init, undefined, key);
	};
	
	var prevLocation = void 0;
	
	var startListener = exports.startListener = function startListener(listener, pathCoder, queryKey) {
	  var handleHashChange = function handleHashChange() {
	    var path = getHashPath();
	    var encodedPath = pathCoder.encodePath(path);
	
	    if (path !== encodedPath) {
	      // Always be sure we have a properly-encoded hash.
	      replaceHashPath(encodedPath);
	    } else {
	      var currentLocation = getCurrentLocation(pathCoder, queryKey);
	
	      if (prevLocation && currentLocation.key && prevLocation.key === currentLocation.key) return; // Ignore extraneous hashchange events
	
	      prevLocation = currentLocation;
	
	      listener(currentLocation);
	    }
	  };
	
	  // Ensure the hash is encoded properly.
	  var path = getHashPath();
	  var encodedPath = pathCoder.encodePath(path);
	
	  if (path !== encodedPath) replaceHashPath(encodedPath);
	
	  (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
	
	  return function () {
	    return (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
	  };
	};
	
	var updateLocation = function updateLocation(location, pathCoder, queryKey, updateHash) {
	  var state = location.state;
	  var key = location.key;
	
	  var path = pathCoder.encodePath((0, _PathUtils.createPath)(location));
	
	  if (state !== undefined) {
	    path = (0, _PathUtils.addQueryStringValueToPath)(path, queryKey, key);
	    (0, _DOMStateStorage.saveState)(key, state);
	  }
	
	  prevLocation = location;
	
	  updateHash(path);
	};
	
	var pushLocation = exports.pushLocation = function pushLocation(location, pathCoder, queryKey) {
	  return updateLocation(location, pathCoder, queryKey, function (path) {
	    if (getHashPath() !== path) {
	      pushHashPath(path);
	    } else {
	      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, 'You cannot PUSH the same path using hash history') : void 0;
	    }
	  });
	};
	
	var replaceLocation = exports.replaceLocation = function replaceLocation(location, pathCoder, queryKey) {
	  return updateLocation(location, pathCoder, queryKey, function (path) {
	    if (getHashPath() !== path) replaceHashPath(path);
	  });
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Nav = __webpack_require__(241);
	
	var _Nav2 = _interopRequireDefault(_Nav);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Main = function Main(props) {
	    return _react2.default.createElement(
	        'div',
	        null,
	        _react2.default.createElement(_Nav2.default, null),
	        _react2.default.createElement(
	            'div',
	            { className: 'row' },
	            _react2.default.createElement(
	                'div',
	                { className: 'columns medium-6 large-4 small-centered' },
	                props.children
	            )
	        )
	    );
	};
	
	exports.default = Main;

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRouter = __webpack_require__(185);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Nav = _react2.default.createClass({
	    displayName: 'Nav',
	
	    onSearch: function onSearch(e) {
	        e.preventDefault();
	        alert("not yet wired up");
	    },
	    render: function render() {
	        return _react2.default.createElement(
	            'div',
	            { className: 'top-bar' },
	            _react2.default.createElement(
	                'div',
	                { className: 'top-bar' },
	                _react2.default.createElement(
	                    'ul',
	                    { className: 'menu' },
	                    _react2.default.createElement(
	                        'li',
	                        { className: 'menu-text' },
	                        'React Weather App'
	                    ),
	                    _react2.default.createElement(
	                        'li',
	                        null,
	                        _react2.default.createElement(
	                            _reactRouter.IndexLink,
	                            { to: '/', activeClassName: 'active', activeStyle: { fontWeight: 'bold' } },
	                            'Get Weather'
	                        )
	                    ),
	                    _react2.default.createElement(
	                        'li',
	                        null,
	                        _react2.default.createElement(
	                            _reactRouter.Link,
	                            { to: '/about', activeClassName: 'active', activeStyle: { fontWeight: 'bold' } },
	                            'About'
	                        )
	                    ),
	                    _react2.default.createElement(
	                        'li',
	                        null,
	                        _react2.default.createElement(
	                            _reactRouter.Link,
	                            { to: '/examples', activeClassName: 'active', activeStyle: { fontWeight: 'bold' } },
	                            'Examples'
	                        )
	                    )
	                )
	            ),
	            _react2.default.createElement(
	                'div',
	                { className: 'top-bar-right' },
	                _react2.default.createElement(
	                    'form',
	                    { onSubmit: this.onSearch },
	                    _react2.default.createElement(
	                        'ul',
	                        { className: 'menu' },
	                        _react2.default.createElement(
	                            'li',
	                            null,
	                            _react2.default.createElement('input', { type: 'search', placeholder: 'Search by city' })
	                        ),
	                        _react2.default.createElement(
	                            'li',
	                            null,
	                            _react2.default.createElement('input', { type: 'submit', className: 'button', value: 'Get Weather' })
	                        )
	                    )
	                )
	            )
	        );
	    }
	});
	
	exports.default = Nav;

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _WeatherForm = __webpack_require__(243);
	
	var _WeatherForm2 = _interopRequireDefault(_WeatherForm);
	
	var _WeatherMessage = __webpack_require__(244);
	
	var _WeatherMessage2 = _interopRequireDefault(_WeatherMessage);
	
	var _openWeatherMap = __webpack_require__(245);
	
	var _ErrorModal = __webpack_require__(271);
	
	var _ErrorModal2 = _interopRequireDefault(_ErrorModal);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Weather = _react2.default.createClass({
	    displayName: 'Weather',
	
	    getInitialState: function getInitialState() {
	        return {
	            location: '',
	            temp: '',
	            isLoading: false,
	            error: ''
	        };
	    },
	    handleSearch: function handleSearch(location) {
	        var that = this;
	
	        this.setState({ isLoading: true, error: '' });
	
	        (0, _openWeatherMap.getTemp)(location).then(function (temp) {
	            that.setState({
	                location: location,
	                temp: temp,
	                isLoading: false
	            });
	        }, function (e) {
	            that.setState({ isLoading: false, error: e.message });
	        });
	    },
	    render: function render() {
	        var _state = this.state,
	            location = _state.location,
	            temp = _state.temp,
	            isLoading = _state.isLoading,
	            error = _state.error;
	
	
	        function renderMessage() {
	            if (isLoading) {
	                return _react2.default.createElement(
	                    'h1',
	                    { className: 'text-center' },
	                    'Fetching weather...'
	                );
	            } else if (temp && location) {
	                return _react2.default.createElement(_WeatherMessage2.default, { location: location, temp: temp });
	            }
	        }
	
	        function renderError() {
	            if (error) {
	                return _react2.default.createElement(_ErrorModal2.default, { message: error });
	            }
	        }
	
	        return _react2.default.createElement(
	            'div',
	            null,
	            _react2.default.createElement(
	                'h1',
	                { className: 'text-center page-title' },
	                'Get Weather'
	            ),
	            _react2.default.createElement(_WeatherForm2.default, { onSearch: this.handleSearch }),
	            renderMessage(),
	            renderError()
	        );
	    }
	});
	
	exports.default = Weather;

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var WeatherForm = _react2.default.createClass({
	    displayName: 'WeatherForm',
	
	    onFormSubmit: function onFormSubmit(e) {
	        e.preventDefault();
	
	        var location = this.refs.location.value;
	
	        if (location.length > 0) {
	            this.refs.location.value = '';
	            this.props.onSearch(location);
	        }
	    },
	    render: function render() {
	        return _react2.default.createElement(
	            'div',
	            null,
	            _react2.default.createElement(
	                'form',
	                { onSubmit: this.onFormSubmit },
	                _react2.default.createElement('input', { type: 'search', ref: 'location', placeholder: 'Search by city' }),
	                _react2.default.createElement(
	                    'button',
	                    { className: 'button expanded hollow' },
	                    'Get Weather'
	                )
	            )
	        );
	    }
	});
	
	exports.default = WeatherForm;

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var WeatherMessage = function WeatherMessage(_ref) {
	    var location = _ref.location,
	        temp = _ref.temp;
	
	    return _react2.default.createElement(
	        "div",
	        null,
	        _react2.default.createElement(
	            "h3",
	            { className: "text-center" },
	            "it is ",
	            temp,
	            " degrees in ",
	            location
	        )
	    );
	};
	
	exports.default = WeatherMessage;

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.getTemp = undefined;
	
	var _axios = __webpack_require__(246);
	
	var _axios2 = _interopRequireDefault(_axios);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var OPEN_WEATHER_MAP_URL = 'http://api.openweathermap.org/data/2.5/weather?units=imperial';
	var APIKEY = '&appid=e44c5649f45af39a98dbc84ea47e9949';
	
	var getTemp = exports.getTemp = function getTemp(location) {
	    var encodedLocation = encodeURIComponent(location);
	    var requestUrl = '' + OPEN_WEATHER_MAP_URL + APIKEY + '&q=' + encodedLocation;
	
	    return _axios2.default.get(requestUrl).then(function (res) {
	        if (res.data.cod && res.data.message) {
	            throw new Error(res.data.message);
	        } else {
	            return res.data.main.temp;
	        }
	    }, function (res) {
	        throw new Error(res.data.message);
	    });
	};

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(247);

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(248);
	var bind = __webpack_require__(249);
	var Axios = __webpack_require__(250);
	
	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 * @return {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  var context = new Axios(defaultConfig);
	  var instance = bind(Axios.prototype.request, context);
	
	  // Copy axios.prototype to instance
	  utils.extend(instance, Axios.prototype, context);
	
	  // Copy context to instance
	  utils.extend(instance, context);
	
	  return instance;
	}
	
	// Create the default instance to be exported
	var axios = createInstance();
	
	// Expose Axios class to allow class inheritance
	axios.Axios = Axios;
	
	// Factory for creating new instances
	axios.create = function create(defaultConfig) {
	  return createInstance(defaultConfig);
	};
	
	// Expose Cancel & CancelToken
	axios.Cancel = __webpack_require__(268);
	axios.CancelToken = __webpack_require__(269);
	axios.isCancel = __webpack_require__(265);
	
	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = __webpack_require__(270);
	
	module.exports = axios;
	
	// Allow use of default import syntax in TypeScript
	module.exports.default = axios;

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var bind = __webpack_require__(249);
	
	/*global toString:true*/
	
	// utils is a library of generic helper functions non-specific to axios
	
	var toString = Object.prototype.toString;
	
	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	function isArray(val) {
	  return toString.call(val) === '[object Array]';
	}
	
	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	function isArrayBuffer(val) {
	  return toString.call(val) === '[object ArrayBuffer]';
	}
	
	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	function isFormData(val) {
	  return typeof FormData !== 'undefined' && val instanceof FormData;
	}
	
	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  var result;
	  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
	  }
	  return result;
	}
	
	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	function isString(val) {
	  return typeof val === 'string';
	}
	
	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	function isNumber(val) {
	  return typeof val === 'number';
	}
	
	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	function isUndefined(val) {
	  return typeof val === 'undefined';
	}
	
	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	function isObject(val) {
	  return val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object';
	}
	
	/**
	 * Determine if a value is a Date
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	function isDate(val) {
	  return toString.call(val) === '[object Date]';
	}
	
	/**
	 * Determine if a value is a File
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	function isFile(val) {
	  return toString.call(val) === '[object File]';
	}
	
	/**
	 * Determine if a value is a Blob
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	function isBlob(val) {
	  return toString.call(val) === '[object Blob]';
	}
	
	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	function isFunction(val) {
	  return toString.call(val) === '[object Function]';
	}
	
	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	function isStream(val) {
	  return isObject(val) && isFunction(val.pipe);
	}
	
	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	function isURLSearchParams(val) {
	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
	}
	
	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */
	function trim(str) {
	  return str.replace(/^\s*/, '').replace(/\s*$/, '');
	}
	
	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  typeof document.createElement -> undefined
	 */
	function isStandardBrowserEnv() {
	  return typeof window !== 'undefined' && typeof document !== 'undefined' && typeof document.createElement === 'function';
	}
	
	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */
	function forEach(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }
	
	  // Force an array if not already something iterable
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' && !isArray(obj)) {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }
	
	  if (isArray(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}
	
	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function merge() /* obj1, obj2, obj3, ... */{
	  var result = {};
	  function assignValue(val, key) {
	    if (_typeof(result[key]) === 'object' && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
	      result[key] = merge(result[key], val);
	    } else {
	      result[key] = val;
	    }
	  }
	
	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }
	  return result;
	}
	
	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */
	function extend(a, b, thisArg) {
	  forEach(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}
	
	module.exports = {
	  isArray: isArray,
	  isArrayBuffer: isArrayBuffer,
	  isFormData: isFormData,
	  isArrayBufferView: isArrayBufferView,
	  isString: isString,
	  isNumber: isNumber,
	  isObject: isObject,
	  isUndefined: isUndefined,
	  isDate: isDate,
	  isFile: isFile,
	  isBlob: isBlob,
	  isFunction: isFunction,
	  isStream: isStream,
	  isURLSearchParams: isURLSearchParams,
	  isStandardBrowserEnv: isStandardBrowserEnv,
	  forEach: forEach,
	  merge: merge,
	  extend: extend,
	  trim: trim
	};

/***/ },
/* 249 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    return fn.apply(thisArg, args);
	  };
	};

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var defaults = __webpack_require__(251);
	var utils = __webpack_require__(248);
	var InterceptorManager = __webpack_require__(262);
	var dispatchRequest = __webpack_require__(263);
	var isAbsoluteURL = __webpack_require__(266);
	var combineURLs = __webpack_require__(267);
	
	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 */
	function Axios(defaultConfig) {
	  this.defaults = utils.merge(defaults, defaultConfig);
	  this.interceptors = {
	    request: new InterceptorManager(),
	    response: new InterceptorManager()
	  };
	}
	
	/**
	 * Dispatch a request
	 *
	 * @param {Object} config The config specific for this request (merged with this.defaults)
	 */
	Axios.prototype.request = function request(config) {
	  /*eslint no-param-reassign:0*/
	  // Allow for axios('example/url'[, config]) a la fetch API
	  if (typeof config === 'string') {
	    config = utils.merge({
	      url: arguments[0]
	    }, arguments[1]);
	  }
	
	  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);
	
	  // Support baseURL config
	  if (config.baseURL && !isAbsoluteURL(config.url)) {
	    config.url = combineURLs(config.baseURL, config.url);
	  }
	
	  // Hook up interceptors middleware
	  var chain = [dispatchRequest, undefined];
	  var promise = Promise.resolve(config);
	
	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    chain.unshift(interceptor.fulfilled, interceptor.rejected);
	  });
	
	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    chain.push(interceptor.fulfilled, interceptor.rejected);
	  });
	
	  while (chain.length) {
	    promise = promise.then(chain.shift(), chain.shift());
	  }
	
	  return promise;
	};
	
	// Provide aliases for supported request methods
	utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function (url, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url
	    }));
	  };
	});
	
	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function (url, data, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url,
	      data: data
	    }));
	  };
	});
	
	module.exports = Axios;

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var utils = __webpack_require__(248);
	var normalizeHeaderName = __webpack_require__(252);
	
	var PROTECTION_PREFIX = /^\)\]\}',?\n/;
	var DEFAULT_CONTENT_TYPE = {
	  'Content-Type': 'application/x-www-form-urlencoded'
	};
	
	function setContentTypeIfUnset(headers, value) {
	  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
	    headers['Content-Type'] = value;
	  }
	}
	
	function getDefaultAdapter() {
	  var adapter;
	  if (typeof XMLHttpRequest !== 'undefined') {
	    // For browsers use XHR adapter
	    adapter = __webpack_require__(253);
	  } else if (typeof process !== 'undefined') {
	    // For node use HTTP adapter
	    adapter = __webpack_require__(253);
	  }
	  return adapter;
	}
	
	module.exports = {
	  adapter: getDefaultAdapter(),
	
	  transformRequest: [function transformRequest(data, headers) {
	    normalizeHeaderName(headers, 'Content-Type');
	    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
	      return data;
	    }
	    if (utils.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils.isURLSearchParams(data)) {
	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	      return data.toString();
	    }
	    if (utils.isObject(data)) {
	      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
	      return JSON.stringify(data);
	    }
	    return data;
	  }],
	
	  transformResponse: [function transformResponse(data) {
	    /*eslint no-param-reassign:0*/
	    if (typeof data === 'string') {
	      data = data.replace(PROTECTION_PREFIX, '');
	      try {
	        data = JSON.parse(data);
	      } catch (e) {/* Ignore */}
	    }
	    return data;
	  }],
	
	  headers: {
	    common: {
	      'Accept': 'application/json, text/plain, */*'
	    },
	    patch: utils.merge(DEFAULT_CONTENT_TYPE),
	    post: utils.merge(DEFAULT_CONTENT_TYPE),
	    put: utils.merge(DEFAULT_CONTENT_TYPE)
	  },
	
	  timeout: 0,
	
	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',
	
	  maxContentLength: -1,
	
	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(248);
	
	module.exports = function normalizeHeaderName(headers, normalizedName) {
	  utils.forEach(headers, function processHeader(value, name) {
	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	      headers[normalizedName] = value;
	      delete headers[name];
	    }
	  });
	};

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var utils = __webpack_require__(248);
	var settle = __webpack_require__(254);
	var buildURL = __webpack_require__(257);
	var parseHeaders = __webpack_require__(258);
	var isURLSameOrigin = __webpack_require__(259);
	var createError = __webpack_require__(255);
	var btoa = typeof window !== 'undefined' && window.btoa || __webpack_require__(260);
	
	module.exports = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;
	
	    if (utils.isFormData(requestData)) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }
	
	    var request = new XMLHttpRequest();
	    var loadEvent = 'onreadystatechange';
	    var xDomain = false;
	
	    // For IE 8/9 CORS support
	    // Only supports POST and GET calls and doesn't returns the response headers.
	    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
	    if (process.env.NODE_ENV !== 'test' && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {
	      request = new window.XDomainRequest();
	      loadEvent = 'onload';
	      xDomain = true;
	      request.onprogress = function handleProgress() {};
	      request.ontimeout = function handleTimeout() {};
	    }
	
	    // HTTP basic authentication
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }
	
	    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);
	
	    // Set the request timeout in MS
	    request.timeout = config.timeout;
	
	    // Listen for ready state
	    request[loadEvent] = function handleLoad() {
	      if (!request || request.readyState !== 4 && !xDomain) {
	        return;
	      }
	
	      // The request errored out and we didn't get a response, this will be
	      // handled by onerror instead
	      // With one exception: request that using file: protocol, most browsers
	      // will return status as 0 even though it's a successful request
	      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	        return;
	      }
	
	      // Prepare the response
	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
	      var response = {
	        data: responseData,
	        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
	        status: request.status === 1223 ? 204 : request.status,
	        statusText: request.status === 1223 ? 'No Content' : request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };
	
	      settle(resolve, reject, response);
	
	      // Clean up request
	      request = null;
	    };
	
	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(createError('Network Error', config));
	
	      // Clean up request
	      request = null;
	    };
	
	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED'));
	
	      // Clean up request
	      request = null;
	    };
	
	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (utils.isStandardBrowserEnv()) {
	      var cookies = __webpack_require__(261);
	
	      // Add xsrf header
	      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;
	
	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    }
	
	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    }
	
	    // Add withCredentials to request if needed
	    if (config.withCredentials) {
	      request.withCredentials = true;
	    }
	
	    // Add responseType to request if needed
	    if (config.responseType) {
	      try {
	        request.responseType = config.responseType;
	      } catch (e) {
	        if (request.responseType !== 'json') {
	          throw e;
	        }
	      }
	    }
	
	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', config.onDownloadProgress);
	    }
	
	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', config.onUploadProgress);
	    }
	
	    if (config.cancelToken) {
	      // Handle cancellation
	      config.cancelToken.promise.then(function onCanceled(cancel) {
	        if (!request) {
	          return;
	        }
	
	        request.abort();
	        reject(cancel);
	        // Clean up request
	        request = null;
	      });
	    }
	
	    if (requestData === undefined) {
	      requestData = null;
	    }
	
	    // Send the request
	    request.send(requestData);
	  });
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var createError = __webpack_require__(255);
	
	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */
	module.exports = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;
	  // Note: status is not exposed by XDomainRequest
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(createError('Request failed with status code ' + response.status, response.config, null, response));
	  }
	};

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var enhanceError = __webpack_require__(256);
	
	/**
	 * Create an Error with the specified message, config, error code, and response.
	 *
	 * @param {string} message The error message.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 @ @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */
	module.exports = function createError(message, config, code, response) {
	  var error = new Error(message);
	  return enhanceError(error, config, code, response);
	};

/***/ },
/* 256 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Update an Error with the specified config, error code, and response.
	 *
	 * @param {Error} error The error to update.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 @ @param {Object} [response] The response.
	 * @returns {Error} The error.
	 */
	
	module.exports = function enhanceError(error, config, code, response) {
	  error.config = config;
	  if (code) {
	    error.code = code;
	  }
	  error.response = response;
	  return error;
	};

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(248);
	
	function encode(val) {
	  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
	}
	
	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */
	module.exports = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }
	
	  var serializedParams;
	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];
	
	    utils.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }
	
	      if (utils.isArray(val)) {
	        key = key + '[]';
	      }
	
	      if (!utils.isArray(val)) {
	        val = [val];
	      }
	
	      utils.forEach(val, function parseValue(v) {
	        if (utils.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils.isObject(v)) {
	          v = JSON.stringify(v);
	        }
	        parts.push(encode(key) + '=' + encode(v));
	      });
	    });
	
	    serializedParams = parts.join('&');
	  }
	
	  if (serializedParams) {
	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }
	
	  return url;
	};

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(248);
	
	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */
	module.exports = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;
	
	  if (!headers) {
	    return parsed;
	  }
	
	  utils.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils.trim(line.substr(0, i)).toLowerCase();
	    val = utils.trim(line.substr(i + 1));
	
	    if (key) {
	      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	    }
	  });
	
	  return parsed;
	};

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(248);
	
	module.exports = utils.isStandardBrowserEnv() ?
	
	// Standard browser envs have full support of the APIs needed to test
	// whether the request URL is of the same origin as current location.
	function standardBrowserEnv() {
	  var msie = /(msie|trident)/i.test(navigator.userAgent);
	  var urlParsingNode = document.createElement('a');
	  var originURL;
	
	  /**
	  * Parse a URL to discover it's components
	  *
	  * @param {String} url The URL to be parsed
	  * @returns {Object}
	  */
	  function resolveURL(url) {
	    var href = url;
	
	    if (msie) {
	      // IE needs attribute set twice to normalize properties
	      urlParsingNode.setAttribute('href', href);
	      href = urlParsingNode.href;
	    }
	
	    urlParsingNode.setAttribute('href', href);
	
	    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	    return {
	      href: urlParsingNode.href,
	      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	      host: urlParsingNode.host,
	      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	      hostname: urlParsingNode.hostname,
	      port: urlParsingNode.port,
	      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
	    };
	  }
	
	  originURL = resolveURL(window.location.href);
	
	  /**
	  * Determine if a URL shares the same origin as the current location
	  *
	  * @param {String} requestURL The URL to test
	  * @returns {boolean} True if URL shares the same origin, otherwise false
	  */
	  return function isURLSameOrigin(requestURL) {
	    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
	    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
	  };
	}() :
	
	// Non standard browser envs (web workers, react-native) lack needed support.
	function nonStandardBrowserEnv() {
	  return function isURLSameOrigin() {
	    return true;
	  };
	}();

/***/ },
/* 260 */
/***/ function(module, exports) {

	'use strict';
	
	// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js
	
	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	
	function E() {
	  this.message = 'String contains an invalid character';
	}
	E.prototype = new Error();
	E.prototype.code = 5;
	E.prototype.name = 'InvalidCharacterError';
	
	function btoa(input) {
	  var str = String(input);
	  var output = '';
	  for (
	  // initialize result and counter
	  var block, charCode, idx = 0, map = chars;
	  // if the next str index does not exist:
	  //   change the mapping table to "="
	  //   check if d has no fractional digits
	  str.charAt(idx | 0) || (map = '=', idx % 1);
	  // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
	    charCode = str.charCodeAt(idx += 3 / 4);
	    if (charCode > 0xFF) {
	      throw new E();
	    }
	    block = block << 8 | charCode;
	  }
	  return output;
	}
	
	module.exports = btoa;

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(248);
	
	module.exports = utils.isStandardBrowserEnv() ?
	
	// Standard browser envs support document.cookie
	function standardBrowserEnv() {
	  return {
	    write: function write(name, value, expires, path, domain, secure) {
	      var cookie = [];
	      cookie.push(name + '=' + encodeURIComponent(value));
	
	      if (utils.isNumber(expires)) {
	        cookie.push('expires=' + new Date(expires).toGMTString());
	      }
	
	      if (utils.isString(path)) {
	        cookie.push('path=' + path);
	      }
	
	      if (utils.isString(domain)) {
	        cookie.push('domain=' + domain);
	      }
	
	      if (secure === true) {
	        cookie.push('secure');
	      }
	
	      document.cookie = cookie.join('; ');
	    },
	
	    read: function read(name) {
	      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	      return match ? decodeURIComponent(match[3]) : null;
	    },
	
	    remove: function remove(name) {
	      this.write(name, '', Date.now() - 86400000);
	    }
	  };
	}() :
	
	// Non standard browser env (web workers, react-native) lack needed support.
	function nonStandardBrowserEnv() {
	  return {
	    write: function write() {},
	    read: function read() {
	      return null;
	    },
	    remove: function remove() {}
	  };
	}();

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(248);
	
	function InterceptorManager() {
	  this.handlers = [];
	}
	
	/**
	 * Add a new interceptor to the stack
	 *
	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	 *
	 * @return {Number} An ID used to remove interceptor later
	 */
	InterceptorManager.prototype.use = function use(fulfilled, rejected) {
	  this.handlers.push({
	    fulfilled: fulfilled,
	    rejected: rejected
	  });
	  return this.handlers.length - 1;
	};
	
	/**
	 * Remove an interceptor from the stack
	 *
	 * @param {Number} id The ID that was returned by `use`
	 */
	InterceptorManager.prototype.eject = function eject(id) {
	  if (this.handlers[id]) {
	    this.handlers[id] = null;
	  }
	};
	
	/**
	 * Iterate over all the registered interceptors
	 *
	 * This method is particularly useful for skipping over any
	 * interceptors that may have become `null` calling `eject`.
	 *
	 * @param {Function} fn The function to call for each interceptor
	 */
	InterceptorManager.prototype.forEach = function forEach(fn) {
	  utils.forEach(this.handlers, function forEachHandler(h) {
	    if (h !== null) {
	      fn(h);
	    }
	  });
	};
	
	module.exports = InterceptorManager;

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(248);
	var transformData = __webpack_require__(264);
	var isCancel = __webpack_require__(265);
	var defaults = __webpack_require__(251);
	
	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	}
	
	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 * @returns {Promise} The Promise to be fulfilled
	 */
	module.exports = function dispatchRequest(config) {
	  throwIfCancellationRequested(config);
	
	  // Ensure headers exist
	  config.headers = config.headers || {};
	
	  // Transform request data
	  config.data = transformData(config.data, config.headers, config.transformRequest);
	
	  // Flatten headers
	  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});
	
	  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
	    delete config.headers[method];
	  });
	
	  var adapter = config.adapter || defaults.adapter;
	
	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);
	
	    // Transform response data
	    response.data = transformData(response.data, response.headers, config.transformResponse);
	
	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config);
	
	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
	      }
	    }
	
	    return Promise.reject(reason);
	  });
	};

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(248);
	
	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Object|String} data The data to be transformed
	 * @param {Array} headers The headers for the request or response
	 * @param {Array|Function} fns A single function or Array of functions
	 * @returns {*} The resulting transformed data
	 */
	module.exports = function transformData(data, headers, fns) {
	  /*eslint no-param-reassign:0*/
	  utils.forEach(fns, function transform(fn) {
	    data = fn(data, headers);
	  });
	
	  return data;
	};

/***/ },
/* 265 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	};

/***/ },
/* 266 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	
	module.exports = function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return (/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
	  );
	};

/***/ },
/* 267 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 * @returns {string} The combined URL
	 */
	
	module.exports = function combineURLs(baseURL, relativeURL) {
	  return baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '');
	};

/***/ },
/* 268 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * A `Cancel` is an object that is thrown when an operation is canceled.
	 *
	 * @class
	 * @param {string=} message The message.
	 */
	
	function Cancel(message) {
	  this.message = message;
	}
	
	Cancel.prototype.toString = function toString() {
	  return 'Cancel' + (this.message ? ': ' + this.message : '');
	};
	
	Cancel.prototype.__CANCEL__ = true;
	
	module.exports = Cancel;

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Cancel = __webpack_require__(268);
	
	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @class
	 * @param {Function} executor The executor function.
	 */
	function CancelToken(executor) {
	  if (typeof executor !== 'function') {
	    throw new TypeError('executor must be a function.');
	  }
	
	  var resolvePromise;
	  this.promise = new Promise(function promiseExecutor(resolve) {
	    resolvePromise = resolve;
	  });
	
	  var token = this;
	  executor(function cancel(message) {
	    if (token.reason) {
	      // Cancellation has already been requested
	      return;
	    }
	
	    token.reason = new Cancel(message);
	    resolvePromise(token.reason);
	  });
	}
	
	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
	  if (this.reason) {
	    throw this.reason;
	  }
	};
	
	/**
	 * Returns an object that contains a new `CancelToken` and a function that, when called,
	 * cancels the `CancelToken`.
	 */
	CancelToken.source = function source() {
	  var cancel;
	  var token = new CancelToken(function executor(c) {
	    cancel = c;
	  });
	  return {
	    token: token,
	    cancel: cancel
	  };
	};
	
	module.exports = CancelToken;

/***/ },
/* 270 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */
	
	module.exports = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ErrorModal = _react2.default.createClass({
	    displayName: 'ErrorModal',
	
	    getDefaultProps: function getDefaultProps() {
	        return {
	            title: 'Error'
	        };
	    },
	    propTypes: {
	        title: _react2.default.PropTypes.string,
	        message: _react2.default.PropTypes.string.isRequired
	    },
	    componentDidMount: function componentDidMount() {
	        var modal = new Foundation.Reveal($('#error-modal'));
	        modal.open();
	    },
	    render: function render() {
	        var _props = this.props,
	            title = _props.title,
	            message = _props.message;
	
	        return _react2.default.createElement(
	            'div',
	            { id: 'error-modal', className: 'reveal tiny', 'data-reveal': '' },
	            _react2.default.createElement(
	                'h4',
	                null,
	                title
	            ),
	            _react2.default.createElement(
	                'p',
	                null,
	                message
	            ),
	            _react2.default.createElement(
	                'p',
	                null,
	                _react2.default.createElement(
	                    'button',
	                    { className: 'button hollow', 'data-close': '' },
	                    'Okay'
	                )
	            )
	        );
	    }
	});
	
	exports.default = ErrorModal;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var About = function About() {
	    return _react2.default.createElement(
	        "div",
	        null,
	        _react2.default.createElement(
	            "h1",
	            { className: "text-centered page-title" },
	            "About"
	        ),
	        _react2.default.createElement(
	            "p",
	            null,
	            "A react weather app"
	        ),
	        _react2.default.createElement(
	            "ul",
	            null,
	            _react2.default.createElement(
	                "li",
	                null,
	                _react2.default.createElement(
	                    "a",
	                    { href: "https://github.com/FunkSoulNinja/ReactWeather" },
	                    "Source code"
	                )
	            )
	        )
	    );
	};
	
	exports.default = About;

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRouter = __webpack_require__(185);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Examples = function Examples() {
	    return _react2.default.createElement(
	        'div',
	        null,
	        _react2.default.createElement(
	            'h1',
	            { className: 'text-centered page-title' },
	            'Examples'
	        ),
	        _react2.default.createElement(
	            'p',
	            null,
	            'Here are a few examples locations to try out'
	        ),
	        _react2.default.createElement(
	            'ol',
	            null,
	            _react2.default.createElement(
	                'li',
	                null,
	                _react2.default.createElement(
	                    _reactRouter.Link,
	                    { to: '/?location=las%20vegas' },
	                    'Las Vegas'
	                )
	            ),
	            _react2.default.createElement(
	                'li',
	                null,
	                _react2.default.createElement(
	                    _reactRouter.Link,
	                    { to: '/?location=Tokyo' },
	                    'Tokyo'
	                )
	            )
	        )
	    );
	};
	
	exports.default = Examples;

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(275);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(277)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./foundation.min.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./foundation.min.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(276)();
	// imports
	
	
	// module
	exports.push([module.id, "@charset \"UTF-8\";\n/*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}.foundation-mq{font-family:\"small=0em&medium=40em&large=64em&xlarge=75em&xxlarge=90em\"}html{font-size:100%;box-sizing:border-box}*,:after,:before{box-sizing:inherit}body{padding:0;margin:0;font-family:Helvetica Neue,Helvetica,Roboto,Arial,sans-serif;font-weight:400;line-height:1.5;color:#0a0a0a;background:#fefefe;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}img{max-width:100%;height:auto;-ms-interpolation-mode:bicubic;display:inline-block;vertical-align:middle}textarea{height:auto;min-height:50px;border-radius:0}select{width:100%;border-radius:0}#map_canvas embed,#map_canvas img,#map_canvas object,.map_canvas embed,.map_canvas img,.map_canvas object,.mqa-display embed,.mqa-display img,.mqa-display object{max-width:none!important}button{-webkit-appearance:none;-moz-appearance:none;background:transparent;padding:0;border:0;border-radius:0;line-height:1}.is-visible{display:block!important}.is-hidden{display:none!important}.row{max-width:75rem;margin-left:auto;margin-right:auto}.row:after,.row:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.row:after{clear:both}.row.collapse>.column,.row.collapse>.columns{padding-left:0;padding-right:0}.row .row{margin-left:-.625rem;margin-right:-.625rem}@media screen and (min-width:40em){.row .row{margin-left:-.9375rem;margin-right:-.9375rem}}.row .row.collapse{margin-left:0;margin-right:0}.row.expanded{max-width:none}.row.expanded .row{margin-left:auto;margin-right:auto}.column,.columns{width:100%;float:left;padding-left:.625rem;padding-right:.625rem}@media screen and (min-width:40em){.column,.columns{padding-left:.9375rem;padding-right:.9375rem}}.column:last-child:not(:first-child),.columns:last-child:not(:first-child){float:right}.column.end:last-child:last-child,.end.columns:last-child:last-child{float:left}.column.row.row,.row.row.columns{float:none}.row .column.row.row,.row .row.row.columns{padding-left:0;padding-right:0;margin-left:0;margin-right:0}.small-1{width:8.33333%}.small-push-1{position:relative;left:8.33333%}.small-pull-1{position:relative;left:-8.33333%}.small-offset-0{margin-left:0}.small-2{width:16.66667%}.small-push-2{position:relative;left:16.66667%}.small-pull-2{position:relative;left:-16.66667%}.small-offset-1{margin-left:8.33333%}.small-3{width:25%}.small-push-3{position:relative;left:25%}.small-pull-3{position:relative;left:-25%}.small-offset-2{margin-left:16.66667%}.small-4{width:33.33333%}.small-push-4{position:relative;left:33.33333%}.small-pull-4{position:relative;left:-33.33333%}.small-offset-3{margin-left:25%}.small-5{width:41.66667%}.small-push-5{position:relative;left:41.66667%}.small-pull-5{position:relative;left:-41.66667%}.small-offset-4{margin-left:33.33333%}.small-6{width:50%}.small-push-6{position:relative;left:50%}.small-pull-6{position:relative;left:-50%}.small-offset-5{margin-left:41.66667%}.small-7{width:58.33333%}.small-push-7{position:relative;left:58.33333%}.small-pull-7{position:relative;left:-58.33333%}.small-offset-6{margin-left:50%}.small-8{width:66.66667%}.small-push-8{position:relative;left:66.66667%}.small-pull-8{position:relative;left:-66.66667%}.small-offset-7{margin-left:58.33333%}.small-9{width:75%}.small-push-9{position:relative;left:75%}.small-pull-9{position:relative;left:-75%}.small-offset-8{margin-left:66.66667%}.small-10{width:83.33333%}.small-push-10{position:relative;left:83.33333%}.small-pull-10{position:relative;left:-83.33333%}.small-offset-9{margin-left:75%}.small-11{width:91.66667%}.small-push-11{position:relative;left:91.66667%}.small-pull-11{position:relative;left:-91.66667%}.small-offset-10{margin-left:83.33333%}.small-12{width:100%}.small-offset-11{margin-left:91.66667%}.small-up-1>.column,.small-up-1>.columns{width:100%;float:left}.small-up-1>.column:nth-of-type(1n),.small-up-1>.columns:nth-of-type(1n){clear:none}.small-up-1>.column:nth-of-type(1n+1),.small-up-1>.columns:nth-of-type(1n+1){clear:both}.small-up-1>.column:last-child,.small-up-1>.columns:last-child{float:left}.small-up-2>.column,.small-up-2>.columns{width:50%;float:left}.small-up-2>.column:nth-of-type(1n),.small-up-2>.columns:nth-of-type(1n){clear:none}.small-up-2>.column:nth-of-type(2n+1),.small-up-2>.columns:nth-of-type(2n+1){clear:both}.small-up-2>.column:last-child,.small-up-2>.columns:last-child{float:left}.small-up-3>.column,.small-up-3>.columns{width:33.33333%;float:left}.small-up-3>.column:nth-of-type(1n),.small-up-3>.columns:nth-of-type(1n){clear:none}.small-up-3>.column:nth-of-type(3n+1),.small-up-3>.columns:nth-of-type(3n+1){clear:both}.small-up-3>.column:last-child,.small-up-3>.columns:last-child{float:left}.small-up-4>.column,.small-up-4>.columns{width:25%;float:left}.small-up-4>.column:nth-of-type(1n),.small-up-4>.columns:nth-of-type(1n){clear:none}.small-up-4>.column:nth-of-type(4n+1),.small-up-4>.columns:nth-of-type(4n+1){clear:both}.small-up-4>.column:last-child,.small-up-4>.columns:last-child{float:left}.small-up-5>.column,.small-up-5>.columns{width:20%;float:left}.small-up-5>.column:nth-of-type(1n),.small-up-5>.columns:nth-of-type(1n){clear:none}.small-up-5>.column:nth-of-type(5n+1),.small-up-5>.columns:nth-of-type(5n+1){clear:both}.small-up-5>.column:last-child,.small-up-5>.columns:last-child{float:left}.small-up-6>.column,.small-up-6>.columns{width:16.66667%;float:left}.small-up-6>.column:nth-of-type(1n),.small-up-6>.columns:nth-of-type(1n){clear:none}.small-up-6>.column:nth-of-type(6n+1),.small-up-6>.columns:nth-of-type(6n+1){clear:both}.small-up-6>.column:last-child,.small-up-6>.columns:last-child{float:left}.small-up-7>.column,.small-up-7>.columns{width:14.28571%;float:left}.small-up-7>.column:nth-of-type(1n),.small-up-7>.columns:nth-of-type(1n){clear:none}.small-up-7>.column:nth-of-type(7n+1),.small-up-7>.columns:nth-of-type(7n+1){clear:both}.small-up-7>.column:last-child,.small-up-7>.columns:last-child{float:left}.small-up-8>.column,.small-up-8>.columns{width:12.5%;float:left}.small-up-8>.column:nth-of-type(1n),.small-up-8>.columns:nth-of-type(1n){clear:none}.small-up-8>.column:nth-of-type(8n+1),.small-up-8>.columns:nth-of-type(8n+1){clear:both}.small-up-8>.column:last-child,.small-up-8>.columns:last-child{float:left}.small-collapse>.column,.small-collapse>.columns{padding-left:0;padding-right:0}.small-collapse .row{margin-left:0;margin-right:0}.small-uncollapse>.column,.small-uncollapse>.columns{padding-left:.625rem;padding-right:.625rem}.small-centered{float:none;margin-left:auto;margin-right:auto}.small-pull-0,.small-push-0,.small-uncentered{position:static;margin-left:0;margin-right:0;float:left}@media screen and (min-width:40em){.medium-1{width:8.33333%}.medium-push-1{position:relative;left:8.33333%}.medium-pull-1{position:relative;left:-8.33333%}.medium-offset-0{margin-left:0}.medium-2{width:16.66667%}.medium-push-2{position:relative;left:16.66667%}.medium-pull-2{position:relative;left:-16.66667%}.medium-offset-1{margin-left:8.33333%}.medium-3{width:25%}.medium-push-3{position:relative;left:25%}.medium-pull-3{position:relative;left:-25%}.medium-offset-2{margin-left:16.66667%}.medium-4{width:33.33333%}.medium-push-4{position:relative;left:33.33333%}.medium-pull-4{position:relative;left:-33.33333%}.medium-offset-3{margin-left:25%}.medium-5{width:41.66667%}.medium-push-5{position:relative;left:41.66667%}.medium-pull-5{position:relative;left:-41.66667%}.medium-offset-4{margin-left:33.33333%}.medium-6{width:50%}.medium-push-6{position:relative;left:50%}.medium-pull-6{position:relative;left:-50%}.medium-offset-5{margin-left:41.66667%}.medium-7{width:58.33333%}.medium-push-7{position:relative;left:58.33333%}.medium-pull-7{position:relative;left:-58.33333%}.medium-offset-6{margin-left:50%}.medium-8{width:66.66667%}.medium-push-8{position:relative;left:66.66667%}.medium-pull-8{position:relative;left:-66.66667%}.medium-offset-7{margin-left:58.33333%}.medium-9{width:75%}.medium-push-9{position:relative;left:75%}.medium-pull-9{position:relative;left:-75%}.medium-offset-8{margin-left:66.66667%}.medium-10{width:83.33333%}.medium-push-10{position:relative;left:83.33333%}.medium-pull-10{position:relative;left:-83.33333%}.medium-offset-9{margin-left:75%}.medium-11{width:91.66667%}.medium-push-11{position:relative;left:91.66667%}.medium-pull-11{position:relative;left:-91.66667%}.medium-offset-10{margin-left:83.33333%}.medium-12{width:100%}.medium-offset-11{margin-left:91.66667%}.medium-up-1>.column,.medium-up-1>.columns{width:100%;float:left}.medium-up-1>.column:nth-of-type(1n),.medium-up-1>.columns:nth-of-type(1n){clear:none}.medium-up-1>.column:nth-of-type(1n+1),.medium-up-1>.columns:nth-of-type(1n+1){clear:both}.medium-up-1>.column:last-child,.medium-up-1>.columns:last-child{float:left}.medium-up-2>.column,.medium-up-2>.columns{width:50%;float:left}.medium-up-2>.column:nth-of-type(1n),.medium-up-2>.columns:nth-of-type(1n){clear:none}.medium-up-2>.column:nth-of-type(2n+1),.medium-up-2>.columns:nth-of-type(2n+1){clear:both}.medium-up-2>.column:last-child,.medium-up-2>.columns:last-child{float:left}.medium-up-3>.column,.medium-up-3>.columns{width:33.33333%;float:left}.medium-up-3>.column:nth-of-type(1n),.medium-up-3>.columns:nth-of-type(1n){clear:none}.medium-up-3>.column:nth-of-type(3n+1),.medium-up-3>.columns:nth-of-type(3n+1){clear:both}.medium-up-3>.column:last-child,.medium-up-3>.columns:last-child{float:left}.medium-up-4>.column,.medium-up-4>.columns{width:25%;float:left}.medium-up-4>.column:nth-of-type(1n),.medium-up-4>.columns:nth-of-type(1n){clear:none}.medium-up-4>.column:nth-of-type(4n+1),.medium-up-4>.columns:nth-of-type(4n+1){clear:both}.medium-up-4>.column:last-child,.medium-up-4>.columns:last-child{float:left}.medium-up-5>.column,.medium-up-5>.columns{width:20%;float:left}.medium-up-5>.column:nth-of-type(1n),.medium-up-5>.columns:nth-of-type(1n){clear:none}.medium-up-5>.column:nth-of-type(5n+1),.medium-up-5>.columns:nth-of-type(5n+1){clear:both}.medium-up-5>.column:last-child,.medium-up-5>.columns:last-child{float:left}.medium-up-6>.column,.medium-up-6>.columns{width:16.66667%;float:left}.medium-up-6>.column:nth-of-type(1n),.medium-up-6>.columns:nth-of-type(1n){clear:none}.medium-up-6>.column:nth-of-type(6n+1),.medium-up-6>.columns:nth-of-type(6n+1){clear:both}.medium-up-6>.column:last-child,.medium-up-6>.columns:last-child{float:left}.medium-up-7>.column,.medium-up-7>.columns{width:14.28571%;float:left}.medium-up-7>.column:nth-of-type(1n),.medium-up-7>.columns:nth-of-type(1n){clear:none}.medium-up-7>.column:nth-of-type(7n+1),.medium-up-7>.columns:nth-of-type(7n+1){clear:both}.medium-up-7>.column:last-child,.medium-up-7>.columns:last-child{float:left}.medium-up-8>.column,.medium-up-8>.columns{width:12.5%;float:left}.medium-up-8>.column:nth-of-type(1n),.medium-up-8>.columns:nth-of-type(1n){clear:none}.medium-up-8>.column:nth-of-type(8n+1),.medium-up-8>.columns:nth-of-type(8n+1){clear:both}.medium-up-8>.column:last-child,.medium-up-8>.columns:last-child{float:left}.medium-collapse>.column,.medium-collapse>.columns{padding-left:0;padding-right:0}.medium-collapse .row{margin-left:0;margin-right:0}.medium-uncollapse>.column,.medium-uncollapse>.columns{padding-left:.9375rem;padding-right:.9375rem}.medium-centered{float:none;margin-left:auto;margin-right:auto}.medium-pull-0,.medium-push-0,.medium-uncentered{position:static;margin-left:0;margin-right:0;float:left}}@media screen and (min-width:64em){.large-1{width:8.33333%}.large-push-1{position:relative;left:8.33333%}.large-pull-1{position:relative;left:-8.33333%}.large-offset-0{margin-left:0}.large-2{width:16.66667%}.large-push-2{position:relative;left:16.66667%}.large-pull-2{position:relative;left:-16.66667%}.large-offset-1{margin-left:8.33333%}.large-3{width:25%}.large-push-3{position:relative;left:25%}.large-pull-3{position:relative;left:-25%}.large-offset-2{margin-left:16.66667%}.large-4{width:33.33333%}.large-push-4{position:relative;left:33.33333%}.large-pull-4{position:relative;left:-33.33333%}.large-offset-3{margin-left:25%}.large-5{width:41.66667%}.large-push-5{position:relative;left:41.66667%}.large-pull-5{position:relative;left:-41.66667%}.large-offset-4{margin-left:33.33333%}.large-6{width:50%}.large-push-6{position:relative;left:50%}.large-pull-6{position:relative;left:-50%}.large-offset-5{margin-left:41.66667%}.large-7{width:58.33333%}.large-push-7{position:relative;left:58.33333%}.large-pull-7{position:relative;left:-58.33333%}.large-offset-6{margin-left:50%}.large-8{width:66.66667%}.large-push-8{position:relative;left:66.66667%}.large-pull-8{position:relative;left:-66.66667%}.large-offset-7{margin-left:58.33333%}.large-9{width:75%}.large-push-9{position:relative;left:75%}.large-pull-9{position:relative;left:-75%}.large-offset-8{margin-left:66.66667%}.large-10{width:83.33333%}.large-push-10{position:relative;left:83.33333%}.large-pull-10{position:relative;left:-83.33333%}.large-offset-9{margin-left:75%}.large-11{width:91.66667%}.large-push-11{position:relative;left:91.66667%}.large-pull-11{position:relative;left:-91.66667%}.large-offset-10{margin-left:83.33333%}.large-12{width:100%}.large-offset-11{margin-left:91.66667%}.large-up-1>.column,.large-up-1>.columns{width:100%;float:left}.large-up-1>.column:nth-of-type(1n),.large-up-1>.columns:nth-of-type(1n){clear:none}.large-up-1>.column:nth-of-type(1n+1),.large-up-1>.columns:nth-of-type(1n+1){clear:both}.large-up-1>.column:last-child,.large-up-1>.columns:last-child{float:left}.large-up-2>.column,.large-up-2>.columns{width:50%;float:left}.large-up-2>.column:nth-of-type(1n),.large-up-2>.columns:nth-of-type(1n){clear:none}.large-up-2>.column:nth-of-type(2n+1),.large-up-2>.columns:nth-of-type(2n+1){clear:both}.large-up-2>.column:last-child,.large-up-2>.columns:last-child{float:left}.large-up-3>.column,.large-up-3>.columns{width:33.33333%;float:left}.large-up-3>.column:nth-of-type(1n),.large-up-3>.columns:nth-of-type(1n){clear:none}.large-up-3>.column:nth-of-type(3n+1),.large-up-3>.columns:nth-of-type(3n+1){clear:both}.large-up-3>.column:last-child,.large-up-3>.columns:last-child{float:left}.large-up-4>.column,.large-up-4>.columns{width:25%;float:left}.large-up-4>.column:nth-of-type(1n),.large-up-4>.columns:nth-of-type(1n){clear:none}.large-up-4>.column:nth-of-type(4n+1),.large-up-4>.columns:nth-of-type(4n+1){clear:both}.large-up-4>.column:last-child,.large-up-4>.columns:last-child{float:left}.large-up-5>.column,.large-up-5>.columns{width:20%;float:left}.large-up-5>.column:nth-of-type(1n),.large-up-5>.columns:nth-of-type(1n){clear:none}.large-up-5>.column:nth-of-type(5n+1),.large-up-5>.columns:nth-of-type(5n+1){clear:both}.large-up-5>.column:last-child,.large-up-5>.columns:last-child{float:left}.large-up-6>.column,.large-up-6>.columns{width:16.66667%;float:left}.large-up-6>.column:nth-of-type(1n),.large-up-6>.columns:nth-of-type(1n){clear:none}.large-up-6>.column:nth-of-type(6n+1),.large-up-6>.columns:nth-of-type(6n+1){clear:both}.large-up-6>.column:last-child,.large-up-6>.columns:last-child{float:left}.large-up-7>.column,.large-up-7>.columns{width:14.28571%;float:left}.large-up-7>.column:nth-of-type(1n),.large-up-7>.columns:nth-of-type(1n){clear:none}.large-up-7>.column:nth-of-type(7n+1),.large-up-7>.columns:nth-of-type(7n+1){clear:both}.large-up-7>.column:last-child,.large-up-7>.columns:last-child{float:left}.large-up-8>.column,.large-up-8>.columns{width:12.5%;float:left}.large-up-8>.column:nth-of-type(1n),.large-up-8>.columns:nth-of-type(1n){clear:none}.large-up-8>.column:nth-of-type(8n+1),.large-up-8>.columns:nth-of-type(8n+1){clear:both}.large-up-8>.column:last-child,.large-up-8>.columns:last-child{float:left}.large-collapse>.column,.large-collapse>.columns{padding-left:0;padding-right:0}.large-collapse .row{margin-left:0;margin-right:0}.large-uncollapse>.column,.large-uncollapse>.columns{padding-left:.9375rem;padding-right:.9375rem}.large-centered{float:none;margin-left:auto;margin-right:auto}.large-pull-0,.large-push-0,.large-uncentered{position:static;margin-left:0;margin-right:0;float:left}}blockquote,dd,div,dl,dt,form,h1,h2,h3,h4,h5,h6,li,ol,p,pre,td,th,ul{margin:0;padding:0}p{font-size:inherit;line-height:1.6;margin-bottom:1rem;text-rendering:optimizeLegibility}em,i{font-style:italic}b,em,i,strong{line-height:inherit}b,strong{font-weight:700}small{font-size:80%;line-height:inherit}h1,h2,h3,h4,h5,h6{font-family:Helvetica Neue,Helvetica,Roboto,Arial,sans-serif;font-weight:400;font-style:normal;color:inherit;text-rendering:optimizeLegibility;margin-top:0;margin-bottom:.5rem;line-height:1.4}h1 small,h2 small,h3 small,h4 small,h5 small,h6 small{color:#cacaca;line-height:0}h1{font-size:1.5rem}h2{font-size:1.25rem}h3{font-size:1.1875rem}h4{font-size:1.125rem}h5{font-size:1.0625rem}h6{font-size:1rem}@media screen and (min-width:40em){h1{font-size:3rem}h2{font-size:2.5rem}h3{font-size:1.9375rem}h4{font-size:1.5625rem}h5{font-size:1.25rem}h6{font-size:1rem}}a{color:#2199e8;text-decoration:none;line-height:inherit;cursor:pointer}a:focus,a:hover{color:#1585cf}a img{border:0}hr{max-width:75rem;height:0;border-right:0;border-top:0;border-bottom:1px solid #cacaca;border-left:0;margin:1.25rem auto;clear:both}dl,ol,ul{line-height:1.6;margin-bottom:1rem;list-style-position:outside}li{font-size:inherit}ul{list-style-type:disc}ol,ul{margin-left:1.25rem}ol ol,ol ul,ul ol,ul ul{margin-left:1.25rem;margin-bottom:0}dl{margin-bottom:1rem}dl dt{margin-bottom:.3rem;font-weight:700}blockquote{margin:0 0 1rem;padding:.5625rem 1.25rem 0 1.1875rem;border-left:1px solid #cacaca}blockquote,blockquote p{line-height:1.6;color:#8a8a8a}cite{display:block;font-size:.8125rem;color:#8a8a8a}cite:before{content:'\\2014    '}abbr{color:#0a0a0a;cursor:help;border-bottom:1px dotted #0a0a0a}code{font-weight:400;border:1px solid #cacaca;padding:.125rem .3125rem .0625rem}code,kbd{font-family:Consolas,Liberation Mono,Courier,monospace;color:#0a0a0a;background-color:#e6e6e6}kbd{padding:.125rem .25rem 0;margin:0}.subheader{margin-top:.2rem;margin-bottom:.5rem;font-weight:400;line-height:1.4;color:#8a8a8a}.lead{font-size:125%;line-height:1.6}.stat{font-size:2.5rem;line-height:1}p+.stat{margin-top:-1rem}.no-bullet{margin-left:0;list-style:none}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.text-justify{text-align:justify}@media screen and (min-width:40em){.medium-text-left{text-align:left}.medium-text-right{text-align:right}.medium-text-center{text-align:center}.medium-text-justify{text-align:justify}}@media screen and (min-width:64em){.large-text-left{text-align:left}.large-text-right{text-align:right}.large-text-center{text-align:center}.large-text-justify{text-align:justify}}.show-for-print{display:none!important}@media print{*{background:transparent!important;color:#000!important;box-shadow:none!important;text-shadow:none!important}.show-for-print{display:block!important}.hide-for-print{display:none!important}table.show-for-print{display:table!important}thead.show-for-print{display:table-header-group!important}tbody.show-for-print{display:table-row-group!important}tr.show-for-print{display:table-row!important}td.show-for-print,th.show-for-print{display:table-cell!important}a,a:visited{text-decoration:underline}a[href]:after{content:\" (\" attr(href) \")\"}.ir a:after,a[href^='#']:after,a[href^='javascript:']:after{content:''}abbr[title]:after{content:\" (\" attr(title) \")\"}blockquote,pre{border:1px solid #8a8a8a;page-break-inside:avoid}thead{display:table-header-group}img,tr{page-break-inside:avoid}img{max-width:100%!important}@page{margin:.5cm}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}}[type=color],[type=date],[type=datetime-local],[type=datetime],[type=email],[type=month],[type=number],[type=password],[type=search],[type=tel],[type=text],[type=time],[type=url],[type=week],textarea{display:block;box-sizing:border-box;width:100%;height:2.4375rem;padding:.5rem;border:1px solid #cacaca;margin:0 0 1rem;font-family:inherit;font-size:1rem;color:#0a0a0a;background-color:#fefefe;box-shadow:inset 0 1px 2px hsla(0,0%,4%,.1);border-radius:0;transition:box-shadow .5s,border-color .25s ease-in-out;-webkit-appearance:none;-moz-appearance:none}[type=color]:focus,[type=date]:focus,[type=datetime-local]:focus,[type=datetime]:focus,[type=email]:focus,[type=month]:focus,[type=number]:focus,[type=password]:focus,[type=search]:focus,[type=tel]:focus,[type=text]:focus,[type=time]:focus,[type=url]:focus,[type=week]:focus,textarea:focus{border:1px solid #8a8a8a;background-color:#fefefe;outline:none;box-shadow:0 0 5px #cacaca;transition:box-shadow .5s,border-color .25s ease-in-out}textarea{max-width:100%}textarea[rows]{height:auto}input::-webkit-input-placeholder,textarea::-webkit-input-placeholder{color:#cacaca}input::-moz-placeholder,textarea::-moz-placeholder{color:#cacaca}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#cacaca}input::placeholder,textarea::placeholder{color:#cacaca}input:disabled,input[readonly],textarea:disabled,textarea[readonly]{background-color:#e6e6e6;cursor:default}[type=button],[type=submit]{border-radius:0;-webkit-appearance:none;-moz-appearance:none}input[type=search]{box-sizing:border-box}[type=checkbox],[type=file],[type=radio]{margin:0 0 1rem}[type=checkbox]+label,[type=radio]+label{display:inline-block;margin-left:.5rem;margin-right:1rem;margin-bottom:0;vertical-align:baseline}label>[type=checkbox],label>[type=radio]{margin-right:.5rem}[type=file]{width:100%}label{display:block;margin:0;font-size:.875rem;font-weight:400;line-height:1.8;color:#0a0a0a}label.middle{margin:0 0 1rem;padding:.5625rem 0}.help-text{margin-top:-.5rem;font-size:.8125rem;font-style:italic;color:#0a0a0a}.input-group{display:table;width:100%;margin-bottom:1rem}.input-group>:first-child,.input-group>:last-child>*{border-radius:0 0 0 0}.input-group-button,.input-group-field,.input-group-label{margin:0;display:table-cell;vertical-align:middle}.input-group-label{text-align:center;padding:0 1rem;background:#e6e6e6;color:#0a0a0a;border:1px solid #cacaca;white-space:nowrap;width:1%;height:100%}.input-group-label:first-child{border-right:0}.input-group-label:last-child{border-left:0}.input-group-field{border-radius:0;height:2.5rem}.input-group-button{padding-top:0;padding-bottom:0;text-align:center;height:100%;width:1%}.input-group-button a,.input-group-button button,.input-group-button input{margin:0}.input-group .input-group-button{display:table-cell}fieldset{border:0;padding:0;margin:0}legend{margin-bottom:.5rem;max-width:100%}.fieldset{border:1px solid #cacaca;padding:1.25rem;margin:1.125rem 0}.fieldset legend{background:#fefefe;padding:0 .1875rem;margin:0;margin-left:-.1875rem}select{height:2.4375rem;padding:.5rem;border:1px solid #cacaca;margin:0 0 1rem;font-size:1rem;font-family:inherit;line-height:normal;color:#0a0a0a;background-color:#fefefe;border-radius:0;-webkit-appearance:none;-moz-appearance:none;background-image:url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"32\" height=\"24\" viewBox=\"0 0 32 24\"><polygon points=\"0,0 32,0 16,24\" style=\"fill: rgb%28138, 138, 138%29\"></polygon></svg>');background-size:9px 6px;background-position:100%;background-origin:content-box;background-repeat:no-repeat}@media screen and (min-width:0\\0){select{background-image:url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAYCAYAAACbU/80AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAIpJREFUeNrEkckNgDAMBBfRkEt0ObRBBdsGXUDgmQfK4XhH2m8czQAAy27R3tsw4Qfe2x8uOO6oYLb6GlOor3GF+swURAOmUJ+RwtEJs9WvTGEYxBXqI1MQAZhCfUQKRzDMVj+TwrAIV6jvSUEkYAr1LSkcyTBb/V+KYfX7xAeusq3sLDtGH3kEGACPWIflNZfhRQAAAABJRU5ErkJggg==\")}}select:disabled{background-color:#e6e6e6;cursor:default}select::-ms-expand{display:none}select[multiple]{height:auto}.is-invalid-input:not(:focus){background-color:rgba(236,88,64,.1);border-color:#ec5840}.form-error,.is-invalid-label{color:#ec5840}.form-error{display:none;margin-top:-.5rem;margin-bottom:1rem;font-size:.75rem;font-weight:700}.form-error.is-visible{display:block}.button{display:inline-block;text-align:center;line-height:1;cursor:pointer;-webkit-appearance:none;transition:background-color .25s ease-out,color .25s ease-out;vertical-align:middle;border:1px solid transparent;border-radius:0;padding:.85em 1em;margin:0 0 1rem;font-size:.9rem;background-color:#2199e8;color:#fefefe}[data-whatinput=mouse] .button{outline:0}.button:focus,.button:hover{background-color:#1583cc;color:#fefefe}.button.tiny{font-size:.6rem}.button.small{font-size:.75rem}.button.large{font-size:1.25rem}.button.expanded{display:block;width:100%;margin-left:0;margin-right:0}.button.primary{background-color:#2199e8;color:#fefefe}.button.primary:focus,.button.primary:hover{background-color:#147cc0;color:#fefefe}.button.secondary{background-color:#777;color:#fefefe}.button.secondary:focus,.button.secondary:hover{background-color:#5f5f5f;color:#fefefe}.button.success{background-color:#3adb76;color:#fefefe}.button.success:focus,.button.success:hover{background-color:#22bb5b;color:#fefefe}.button.warning{background-color:#ffae00;color:#fefefe}.button.warning:focus,.button.warning:hover{background-color:#cc8b00;color:#fefefe}.button.alert{background-color:#ec5840;color:#fefefe}.button.alert:focus,.button.alert:hover{background-color:#da3116;color:#fefefe}.button.hollow{border:1px solid #2199e8;color:#2199e8}.button.hollow,.button.hollow:focus,.button.hollow:hover{background-color:transparent}.button.hollow:focus,.button.hollow:hover{border-color:#0c4d78;color:#0c4d78}.button.hollow.primary{border:1px solid #2199e8;color:#2199e8}.button.hollow.primary:focus,.button.hollow.primary:hover{border-color:#0c4d78;color:#0c4d78}.button.hollow.secondary{border:1px solid #777;color:#777}.button.hollow.secondary:focus,.button.hollow.secondary:hover{border-color:#3c3c3c;color:#3c3c3c}.button.hollow.success{border:1px solid #3adb76;color:#3adb76}.button.hollow.success:focus,.button.hollow.success:hover{border-color:#157539;color:#157539}.button.hollow.warning{border:1px solid #ffae00;color:#ffae00}.button.hollow.warning:focus,.button.hollow.warning:hover{border-color:#805700;color:#805700}.button.hollow.alert{border:1px solid #ec5840;color:#ec5840}.button.hollow.alert:focus,.button.hollow.alert:hover{border-color:#881f0e;color:#881f0e}.button.disabled,.button[disabled]{opacity:.25;cursor:not-allowed;pointer-events:none}.button.dropdown:after{content:'';display:block;width:0;height:0;border:.4em inset;border-color:#fefefe transparent transparent;border-top-style:solid;border-bottom-width:0;position:relative;top:.4em;float:right;margin-left:1em;display:inline-block}.button.arrow-only:after{margin-left:0;float:none;top:-.1em}.accordion{list-style-type:none;background:#fefefe;border:1px solid #e6e6e6;border-bottom:0;border-radius:0;margin-left:0}.accordion-title{display:block;padding:1.25rem 1rem;line-height:1;font-size:.75rem;color:#2199e8;position:relative;border-bottom:1px solid #e6e6e6}.accordion-title:focus,.accordion-title:hover{background-color:#e6e6e6}.accordion-title:before{content:'+';position:absolute;right:1rem;top:50%;margin-top:-.5rem}.is-active>.accordion-title:before{content:'\\2013'}.accordion-content{padding:1rem;display:none;border-bottom:1px solid #e6e6e6;background-color:#fefefe}.is-accordion-submenu-parent>a{position:relative}.is-accordion-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:6px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;position:absolute;top:50%;margin-top:-4px;right:1rem}.is-accordion-submenu-parent[aria-expanded=true]>a:after{-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-transform:scaleY(-1);transform:scaleY(-1)}.badge{display:inline-block;padding:.3em;min-width:2.1em;font-size:.6rem;text-align:center;border-radius:50%;background:#2199e8;color:#fefefe}.badge.secondary{background:#777;color:#fefefe}.badge.success{background:#3adb76;color:#fefefe}.badge.warning{background:#ffae00;color:#fefefe}.badge.alert{background:#ec5840;color:#fefefe}.breadcrumbs{list-style:none;margin:0 0 1rem}.breadcrumbs:after,.breadcrumbs:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.breadcrumbs:after{clear:both}.breadcrumbs li{float:left;color:#0a0a0a;font-size:.6875rem;cursor:default;text-transform:uppercase}.breadcrumbs li:not(:last-child):after{color:#cacaca;content:\"/\";margin:0 .75rem;position:relative;top:1px;opacity:1}.breadcrumbs a{color:#2199e8}.breadcrumbs a:hover{text-decoration:underline}.breadcrumbs .disabled{color:#cacaca}.button-group{margin-bottom:1rem;font-size:0}.button-group:after,.button-group:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.button-group:after{clear:both}.button-group .button{margin:0;font-size:.9rem;float:left}.button-group .button:not(:last-child){border-right:1px solid #fefefe}.button-group.tiny .button{font-size:.6rem}.button-group.small .button{font-size:.75rem}.button-group.large .button{font-size:1.25rem}.button-group.expanded{margin-right:-1px}.button-group.expanded:after,.button-group.expanded:before{display:none}.button-group.expanded .button:first-child:nth-last-child(2),.button-group.expanded .button:first-child:nth-last-child(2):first-child:nth-last-child(2)~.button{display:inline-block;width:calc(50% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(3),.button-group.expanded .button:first-child:nth-last-child(3):first-child:nth-last-child(3)~.button{display:inline-block;width:calc(33.33333% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(4),.button-group.expanded .button:first-child:nth-last-child(4):first-child:nth-last-child(4)~.button{display:inline-block;width:calc(25% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(5),.button-group.expanded .button:first-child:nth-last-child(5):first-child:nth-last-child(5)~.button{display:inline-block;width:calc(20% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(6),.button-group.expanded .button:first-child:nth-last-child(6):first-child:nth-last-child(6)~.button{display:inline-block;width:calc(16.66667% - 1px);margin-right:1px}.button-group.primary .button{background-color:#2199e8;color:#fefefe}.button-group.primary .button:focus,.button-group.primary .button:hover{background-color:#147cc0;color:#fefefe}.button-group.secondary .button{background-color:#777;color:#fefefe}.button-group.secondary .button:focus,.button-group.secondary .button:hover{background-color:#5f5f5f;color:#fefefe}.button-group.success .button{background-color:#3adb76;color:#fefefe}.button-group.success .button:focus,.button-group.success .button:hover{background-color:#22bb5b;color:#fefefe}.button-group.warning .button{background-color:#ffae00;color:#fefefe}.button-group.warning .button:focus,.button-group.warning .button:hover{background-color:#cc8b00;color:#fefefe}.button-group.alert .button{background-color:#ec5840;color:#fefefe}.button-group.alert .button:focus,.button-group.alert .button:hover{background-color:#da3116;color:#fefefe}.button-group.stacked-for-medium .button,.button-group.stacked-for-small .button,.button-group.stacked .button{width:100%}.button-group.stacked-for-medium .button:not(:last-child),.button-group.stacked-for-small .button:not(:last-child),.button-group.stacked .button:not(:last-child){margin-right:0}@media screen and (min-width:40em){.button-group.stacked-for-small .button{width:auto}.button-group.stacked-for-small .button:not(:last-child){margin-right:1px}}@media screen and (min-width:64em){.button-group.stacked-for-medium .button{width:auto}.button-group.stacked-for-medium .button:not(:last-child){margin-right:1px}}@media screen and (max-width:39.9375em){.button-group.stacked-for-small.expanded{display:block}.button-group.stacked-for-small.expanded .button{display:block;margin-right:0}}.callout{margin:0 0 1rem;padding:1rem;border:1px solid hsla(0,0%,4%,.25);border-radius:0;position:relative;color:#0a0a0a;background-color:#fff}.callout>:first-child{margin-top:0}.callout>:last-child{margin-bottom:0}.callout.primary{background-color:#def0fc}.callout.secondary{background-color:#ebebeb}.callout.success{background-color:#e1faea}.callout.warning{background-color:#fff3d9}.callout.alert{background-color:#fce6e2}.callout.small{padding:.5rem}.callout.large{padding:3rem}.close-button{position:absolute;color:#8a8a8a;right:1rem;top:.5rem;font-size:2em;line-height:1;cursor:pointer}[data-whatinput=mouse] .close-button{outline:0}.close-button:focus,.close-button:hover{color:#0a0a0a}.menu{margin:0;list-style-type:none}.menu>li{display:table-cell;vertical-align:middle}[data-whatinput=mouse] .menu>li{outline:0}.menu>li>a{display:block;padding:.7rem 1rem;line-height:1}.menu a,.menu button,.menu input{margin-bottom:0}.menu>li>a i,.menu>li>a i+span,.menu>li>a img,.menu>li>a img+span{vertical-align:middle}.menu>li>a i,.menu>li>a img{margin-right:.25rem;display:inline-block}.menu>li{display:table-cell}.menu.vertical>li{display:block}@media screen and (min-width:40em){.menu.medium-horizontal>li{display:table-cell}.menu.medium-vertical>li{display:block}}@media screen and (min-width:64em){.menu.large-horizontal>li{display:table-cell}.menu.large-vertical>li{display:block}}.menu.simple li{line-height:1;display:inline-block;margin-right:1rem}.menu.simple a{padding:0}.menu.align-right:after,.menu.align-right:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.menu.align-right:after{clear:both}.menu.align-right>li{float:right}.menu.expanded{width:100%;display:table;table-layout:fixed}.menu.expanded>li:first-child:last-child{width:100%}.menu.icon-top>li>a{text-align:center}.menu.icon-top>li>a i,.menu.icon-top>li>a img{display:block;margin:0 auto .25rem}.menu.nested{margin-left:1rem}.menu .active>a{color:#fefefe;background:#2199e8}.menu-text{font-weight:700;color:inherit;line-height:1;padding-top:0;padding-bottom:0;padding:.7rem 1rem}.menu-centered{text-align:center}.menu-centered>.menu{display:inline-block}.no-js [data-responsive-menu] ul{display:none}.menu-icon{position:relative;display:inline-block;vertical-align:middle;cursor:pointer;width:20px;height:16px}.menu-icon:after{content:'';position:absolute;display:block;width:100%;height:2px;background:#fefefe;top:0;left:0;box-shadow:0 7px 0 #fefefe,0 14px 0 #fefefe}.menu-icon:hover:after{background:#cacaca;box-shadow:0 7px 0 #cacaca,0 14px 0 #cacaca}.is-drilldown{position:relative;overflow:hidden}.is-drilldown li{display:block!important}.is-drilldown-submenu{position:absolute;top:0;left:100%;z-index:-1;height:100%;width:100%;background:#fefefe;transition:-webkit-transform .15s linear;transition:transform .15s linear}.is-drilldown-submenu.is-active{z-index:1;display:block;-webkit-transform:translateX(-100%);transform:translateX(-100%)}.is-drilldown-submenu.is-closing{-webkit-transform:translateX(100%);transform:translateX(100%)}.is-drilldown-submenu-parent>a{position:relative}.is-drilldown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:6px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0;position:absolute;top:50%;margin-top:-6px;right:1rem}.js-drilldown-back>a:before{content:'';display:block;width:0;height:0;border:6px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0;display:inline-block;vertical-align:middle;margin-right:.75rem}.dropdown-pane{background-color:#fefefe;border:1px solid #cacaca;border-radius:0;display:block;font-size:1rem;padding:1rem;position:absolute;visibility:hidden;width:300px;z-index:3}.dropdown-pane.is-open{visibility:visible}.dropdown-pane.tiny{width:100px}.dropdown-pane.small{width:200px}.dropdown-pane.large{width:400px}.dropdown.menu>li.opens-left>.is-dropdown-submenu{left:auto;right:0;top:100%}.dropdown.menu>li.opens-right>.is-dropdown-submenu{right:auto;left:0;top:100%}.dropdown.menu>li.is-dropdown-submenu-parent>a{padding-right:1.5rem;position:relative}.dropdown.menu>li.is-dropdown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;right:5px;margin-top:-2px}[data-whatinput=mouse] .dropdown.menu a{outline:0}.no-js .dropdown.menu ul{display:none}.dropdown.menu.vertical>li .is-dropdown-submenu{top:0}.dropdown.menu.vertical>li.opens-left .is-dropdown-submenu{left:auto;right:100%}.dropdown.menu.vertical>li.opens-right .is-dropdown-submenu{right:auto;left:100%}.dropdown.menu.vertical>li>a:after{right:14px;margin-top:-3px}.dropdown.menu.vertical>li.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.dropdown.menu.vertical>li.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}@media screen and (min-width:40em){.dropdown.menu.medium-horizontal>li.opens-left>.is-dropdown-submenu{left:auto;right:0;top:100%}.dropdown.menu.medium-horizontal>li.opens-right>.is-dropdown-submenu{right:auto;left:0;top:100%}.dropdown.menu.medium-horizontal>li.is-dropdown-submenu-parent>a{padding-right:1.5rem;position:relative}.dropdown.menu.medium-horizontal>li.is-dropdown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;right:5px;margin-top:-2px}.dropdown.menu.medium-vertical>li .is-dropdown-submenu{top:0}.dropdown.menu.medium-vertical>li.opens-left .is-dropdown-submenu{left:auto;right:100%}.dropdown.menu.medium-vertical>li.opens-right .is-dropdown-submenu{right:auto;left:100%}.dropdown.menu.medium-vertical>li>a:after{right:14px;margin-top:-3px}.dropdown.menu.medium-vertical>li.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.dropdown.menu.medium-vertical>li.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}}@media screen and (min-width:64em){.dropdown.menu.large-horizontal>li.opens-left>.is-dropdown-submenu{left:auto;right:0;top:100%}.dropdown.menu.large-horizontal>li.opens-right>.is-dropdown-submenu{right:auto;left:0;top:100%}.dropdown.menu.large-horizontal>li.is-dropdown-submenu-parent>a{padding-right:1.5rem;position:relative}.dropdown.menu.large-horizontal>li.is-dropdown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;right:5px;margin-top:-2px}.dropdown.menu.large-vertical>li .is-dropdown-submenu{top:0}.dropdown.menu.large-vertical>li.opens-left .is-dropdown-submenu{left:auto;right:100%}.dropdown.menu.large-vertical>li.opens-right .is-dropdown-submenu{right:auto;left:100%}.dropdown.menu.large-vertical>li>a:after{right:14px;margin-top:-3px}.dropdown.menu.large-vertical>li.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.dropdown.menu.large-vertical>li.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}}.dropdown.menu.align-right .is-dropdown-submenu.first-sub{top:100%;left:auto;right:0}.is-dropdown-menu.vertical{width:100px}.is-dropdown-menu.vertical.align-right{float:right}.is-dropdown-submenu-parent{position:relative}.is-dropdown-submenu-parent a:after{position:absolute;top:50%;right:5px;margin-top:-2px}.is-dropdown-submenu-parent.opens-inner .is-dropdown-submenu{top:100%}.is-dropdown-submenu-parent.opens-left .is-dropdown-submenu{left:auto;right:0;top:100%}.is-dropdown-submenu{display:none;position:absolute;top:0;left:100%;min-width:200px;z-index:1;background:#fefefe;border:1px solid #cacaca}.is-dropdown-submenu .is-dropdown-submenu-parent>a:after{right:14px;margin-top:-3px}.is-dropdown-submenu .is-dropdown-submenu-parent.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.is-dropdown-submenu .is-dropdown-submenu-parent.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}.is-dropdown-submenu .is-dropdown-submenu{margin-top:-1px}.is-dropdown-submenu>li{width:100%}.is-dropdown-submenu.js-dropdown-active,.is-dropdown-submenu:not(.js-dropdown-nohover)>.is-dropdown-submenu-parent:hover>.is-dropdown-submenu{display:block}.flex-video{position:relative;height:0;padding-bottom:75%;margin-bottom:1rem;overflow:hidden}.flex-video embed,.flex-video iframe,.flex-video object,.flex-video video{position:absolute;top:0;left:0;width:100%;height:100%}.flex-video.widescreen{padding-bottom:56.25%}.flex-video.vimeo{padding-top:0}.label{display:inline-block;padding:.33333rem .5rem;font-size:.8rem;line-height:1;white-space:nowrap;cursor:default;border-radius:0;background:#2199e8;color:#fefefe}.label.secondary{background:#777;color:#fefefe}.label.success{background:#3adb76;color:#fefefe}.label.warning{background:#ffae00;color:#fefefe}.label.alert{background:#ec5840;color:#fefefe}.media-object{margin-bottom:1rem;display:block}.media-object img{max-width:none}@media screen and (max-width:39.9375em){.media-object.stack-for-small .media-object-section{padding:0;padding-bottom:1rem;display:block}.media-object.stack-for-small .media-object-section img{width:100%}}.media-object-section{display:table-cell;vertical-align:top}.media-object-section:first-child{padding-right:1rem}.media-object-section:last-child:not(:nth-child(2)){padding-left:1rem}.media-object-section.middle{vertical-align:middle}.media-object-section.bottom{vertical-align:bottom}body,html{height:100%}.off-canvas-wrapper{width:100%;overflow-x:hidden;position:relative;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-overflow-scrolling:auto}.off-canvas-wrapper-inner{position:relative;width:100%;transition:-webkit-transform .5s ease;transition:transform .5s ease}.off-canvas-wrapper-inner:after,.off-canvas-wrapper-inner:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.off-canvas-wrapper-inner:after{clear:both}.off-canvas-content{min-height:100%;background:#fefefe;transition:-webkit-transform .5s ease;transition:transform .5s ease;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;padding-bottom:.1px;box-shadow:0 0 10px hsla(0,0%,4%,.5)}.js-off-canvas-exit{display:none;position:absolute;top:0;left:0;width:100%;height:100%;background:hsla(0,0%,100%,.25);cursor:pointer;transition:background .5s ease}.off-canvas{position:absolute;background:#e6e6e6;z-index:-1;max-height:100%;overflow-y:auto;-webkit-transform:translateX(0);transform:translateX(0)}[data-whatinput=mouse] .off-canvas{outline:0}.off-canvas.position-left{left:-250px;top:0;width:250px}.is-open-left{-webkit-transform:translateX(250px);transform:translateX(250px)}.off-canvas.position-right{right:-250px;top:0;width:250px}.is-open-right{-webkit-transform:translateX(-250px);transform:translateX(-250px)}@media screen and (min-width:40em){.position-left.reveal-for-medium{left:0;z-index:auto;position:fixed}.position-left.reveal-for-medium~.off-canvas-content{margin-left:250px}.position-right.reveal-for-medium{right:0;z-index:auto;position:fixed}.position-right.reveal-for-medium~.off-canvas-content{margin-right:250px}}@media screen and (min-width:64em){.position-left.reveal-for-large{left:0;z-index:auto;position:fixed}.position-left.reveal-for-large~.off-canvas-content{margin-left:250px}.position-right.reveal-for-large{right:0;z-index:auto;position:fixed}.position-right.reveal-for-large~.off-canvas-content{margin-right:250px}}.orbit,.orbit-container{position:relative}.orbit-container{margin:0;overflow:hidden;list-style:none}.orbit-slide{width:100%;max-height:100%}.orbit-slide.no-motionui.is-active{top:0;left:0}.orbit-figure{margin:0}.orbit-image{margin:0;width:100%;max-width:100%}.orbit-caption{bottom:0;width:100%;margin-bottom:0;background-color:hsla(0,0%,4%,.5)}.orbit-caption,.orbit-next,.orbit-previous{position:absolute;padding:1rem;color:#fefefe}.orbit-next,.orbit-previous{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);z-index:3}[data-whatinput=mouse] .orbit-next,[data-whatinput=mouse] .orbit-previous{outline:0}.orbit-next:active,.orbit-next:focus,.orbit-next:hover,.orbit-previous:active,.orbit-previous:focus,.orbit-previous:hover{background-color:hsla(0,0%,4%,.5)}.orbit-previous{left:0}.orbit-next{left:auto;right:0}.orbit-bullets{position:relative;margin-top:.8rem;margin-bottom:.8rem;text-align:center}[data-whatinput=mouse] .orbit-bullets{outline:0}.orbit-bullets button{width:1.2rem;height:1.2rem;margin:.1rem;background-color:#cacaca;border-radius:50%}.orbit-bullets button.is-active,.orbit-bullets button:hover{background-color:#8a8a8a}.pagination{margin-left:0;margin-bottom:1rem}.pagination:after,.pagination:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.pagination:after{clear:both}.pagination li{font-size:.875rem;margin-right:.0625rem;border-radius:0;display:none}.pagination li:first-child,.pagination li:last-child{display:inline-block}@media screen and (min-width:40em){.pagination li{display:inline-block}}.pagination a,.pagination button{color:#0a0a0a;display:block;padding:.1875rem .625rem;border-radius:0}.pagination a:hover,.pagination button:hover{background:#e6e6e6}.pagination .current{padding:.1875rem .625rem;background:#2199e8;color:#fefefe;cursor:default}.pagination .disabled{padding:.1875rem .625rem;color:#cacaca;cursor:default}.pagination .disabled:hover{background:transparent}.pagination .ellipsis:after{content:'\\2026';padding:.1875rem .625rem;color:#0a0a0a}.pagination-previous.disabled:before,.pagination-previous a:before{content:'\\AB';display:inline-block;margin-right:.5rem}.pagination-next.disabled:after,.pagination-next a:after{content:'\\BB';display:inline-block;margin-left:.5rem}.progress{background-color:#cacaca;height:1rem;margin-bottom:1rem;border-radius:0}.progress.primary .progress-meter{background-color:#2199e8}.progress.secondary .progress-meter{background-color:#777}.progress.success .progress-meter{background-color:#3adb76}.progress.warning .progress-meter{background-color:#ffae00}.progress.alert .progress-meter{background-color:#ec5840}.progress-meter{position:relative;display:block;width:0;height:100%;background-color:#2199e8}.progress-meter-text{top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);position:absolute;margin:0;font-size:.75rem;font-weight:700;color:#fefefe;white-space:nowrap}.slider{position:relative;height:.5rem;margin-top:1.25rem;margin-bottom:2.25rem;background-color:#e6e6e6;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-touch-action:none;touch-action:none}.slider-fill{position:absolute;top:0;left:0;display:inline-block;max-width:100%;height:.5rem;background-color:#cacaca;transition:all .2s ease-in-out}.slider-fill.is-dragging{transition:all 0s linear}.slider-handle{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);position:absolute;left:0;z-index:1;display:inline-block;width:1.4rem;height:1.4rem;background-color:#2199e8;transition:all .2s ease-in-out;-ms-touch-action:manipulation;touch-action:manipulation;border-radius:0}[data-whatinput=mouse] .slider-handle{outline:0}.slider-handle:hover{background-color:#1583cc}.slider-handle.is-dragging{transition:all 0s linear}.slider.disabled,.slider[disabled]{opacity:.25;cursor:not-allowed}.slider.vertical{display:inline-block;width:.5rem;height:12.5rem;margin:0 1.25rem;-webkit-transform:scaleY(-1);transform:scaleY(-1)}.slider.vertical .slider-fill{top:0;width:.5rem;max-height:100%}.slider.vertical .slider-handle{position:absolute;top:0;left:50%;width:1.4rem;height:1.4rem;-webkit-transform:translateX(-50%);transform:translateX(-50%)}.sticky-container{position:relative}.sticky{position:absolute;z-index:0;-webkit-transform:translateZ(0);transform:translateZ(0)}.sticky.is-stuck{position:fixed;z-index:2}.sticky.is-stuck.is-at-top{top:0}.sticky.is-stuck.is-at-bottom{bottom:0}.sticky.is-anchored{position:absolute;left:auto;right:auto}.sticky.is-anchored.is-at-bottom{bottom:0}body.is-reveal-open{overflow:hidden}.reveal-overlay{display:none;position:fixed;top:0;bottom:0;left:0;right:0;z-index:4;background-color:hsla(0,0%,4%,.45);overflow-y:scroll}.reveal{display:none;z-index:5;padding:1rem;border:1px solid #cacaca;background-color:#fefefe;border-radius:0;position:relative;top:100px;margin-left:auto;margin-right:auto;overflow-y:auto}[data-whatinput=mouse] .reveal{outline:0}@media screen and (min-width:40em){.reveal{min-height:0}}.reveal .column,.reveal .columns{min-width:0}.reveal>:last-child{margin-bottom:0}@media screen and (min-width:40em){.reveal{width:600px;max-width:75rem}}@media screen and (min-width:40em){.reveal .reveal{left:auto;right:auto;margin:0 auto}}.reveal.collapse{padding:0}@media screen and (min-width:40em){.reveal.tiny{width:30%;max-width:75rem}}@media screen and (min-width:40em){.reveal.small{width:50%;max-width:75rem}}@media screen and (min-width:40em){.reveal.large{width:90%;max-width:75rem}}.reveal.full{top:0;left:0;width:100%;height:100%;height:100vh;min-height:100vh;max-width:none;margin-left:0;border:0}@media screen and (max-width:39.9375em){.reveal{top:0;left:0;width:100%;height:100%;height:100vh;min-height:100vh;max-width:none;margin-left:0;border:0}}.reveal.without-overlay{position:fixed}.switch{margin-bottom:1rem;outline:0;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;color:#fefefe;font-weight:700;font-size:.875rem}.switch-input{opacity:0;position:absolute}.switch-paddle{background:#cacaca;cursor:pointer;display:block;position:relative;width:4rem;height:2rem;transition:all .25s ease-out;border-radius:0;color:inherit;font-weight:inherit}input+.switch-paddle{margin:0}.switch-paddle:after{background:#fefefe;content:'';display:block;position:absolute;height:1.5rem;left:.25rem;top:.25rem;width:1.5rem;transition:all .25s ease-out;-webkit-transform:translateZ(0);transform:translateZ(0);border-radius:0}input:checked~.switch-paddle{background:#2199e8}input:checked~.switch-paddle:after{left:2.25rem}[data-whatinput=mouse] input:focus~.switch-paddle{outline:0}.switch-active,.switch-inactive{position:absolute;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.switch-active{left:8%;display:none}input:checked+label>.switch-active{display:block}.switch-inactive{right:15%}input:checked+label>.switch-inactive{display:none}.switch.tiny .switch-paddle{width:3rem;height:1.5rem;font-size:.625rem}.switch.tiny .switch-paddle:after{width:1rem;height:1rem}.switch.tiny input:checked~.switch-paddle:after{left:1.75rem}.switch.small .switch-paddle{width:3.5rem;height:1.75rem;font-size:.75rem}.switch.small .switch-paddle:after{width:1.25rem;height:1.25rem}.switch.small input:checked~.switch-paddle:after{left:2rem}.switch.large .switch-paddle{width:5rem;height:2.5rem;font-size:1rem}.switch.large .switch-paddle:after{width:2rem;height:2rem}.switch.large input:checked~.switch-paddle:after{left:2.75rem}table{width:100%;margin-bottom:1rem;border-radius:0}table tbody,table tfoot,table thead{border:1px solid #f1f1f1;background-color:#fefefe}table caption{font-weight:700;padding:.5rem .625rem .625rem}table tfoot,table thead{background:#f8f8f8;color:#0a0a0a}table tfoot tr,table thead tr{background:transparent}table tfoot td,table tfoot th,table thead td,table thead th{padding:.5rem .625rem .625rem;font-weight:700;text-align:left}table tbody tr:nth-child(even){background-color:#f1f1f1}table tbody td,table tbody th{padding:.5rem .625rem .625rem}@media screen and (max-width:63.9375em){table.stack tfoot,table.stack thead{display:none}table.stack td,table.stack th,table.stack tr{display:block}table.stack td{border-top:0}}table.scroll{display:block;width:100%;overflow-x:auto}table.hover tr:hover{background-color:#f9f9f9}table.hover tr:nth-of-type(even):hover{background-color:#ececec}.table-scroll{overflow-x:auto}.table-scroll table{width:auto}.tabs{margin:0;list-style-type:none;background:#fefefe;border:1px solid #e6e6e6}.tabs:after,.tabs:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.tabs:after{clear:both}.tabs.vertical>li{width:auto;float:none;display:block}.tabs.simple>li>a{padding:0}.tabs.simple>li>a:hover{background:transparent}.tabs.primary{background:#2199e8}.tabs.primary>li>a{color:#fefefe}.tabs.primary>li>a:focus,.tabs.primary>li>a:hover{background:#1893e4}.tabs-title{float:left}.tabs-title>a{display:block;padding:1.25rem 1.5rem;line-height:1;font-size:.75rem}.tabs-title>a:hover{background:#fefefe}.tabs-title>a:focus,.tabs-title>a[aria-selected=true]{background:#e6e6e6}.tabs-content{background:#fefefe;transition:all .5s ease;border:1px solid #e6e6e6;border-top:0}.tabs-content.vertical{border:1px solid #e6e6e6;border-left:0}.tabs-panel{display:none;padding:1rem}.tabs-panel.is-active{display:block}.thumbnail{border:4px solid #fefefe;box-shadow:0 0 0 1px hsla(0,0%,4%,.2);display:inline-block;line-height:0;max-width:100%;transition:box-shadow .2s ease-out;border-radius:0;margin-bottom:1rem}.thumbnail:focus,.thumbnail:hover{box-shadow:0 0 6px 1px rgba(33,153,232,.5)}.title-bar{background:#0a0a0a;color:#fefefe;padding:.5rem}.title-bar:after,.title-bar:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.title-bar:after{clear:both}.title-bar .menu-icon{margin-left:.25rem;margin-right:.5rem}.title-bar-left{float:left}.title-bar-right{float:right;text-align:right}.title-bar-title{font-weight:700}.menu-icon.dark,.title-bar-title{vertical-align:middle;display:inline-block}.menu-icon.dark{position:relative;cursor:pointer;width:20px;height:16px}.menu-icon.dark:after{content:'';position:absolute;display:block;width:100%;height:2px;background:#0a0a0a;top:0;left:0;box-shadow:0 7px 0 #0a0a0a,0 14px 0 #0a0a0a}.menu-icon.dark:hover:after{background:#8a8a8a;box-shadow:0 7px 0 #8a8a8a,0 14px 0 #8a8a8a}.has-tip{border-bottom:1px dotted #8a8a8a;font-weight:700;position:relative;display:inline-block;cursor:help}.tooltip{background-color:#0a0a0a;color:#fefefe;font-size:80%;padding:.75rem;position:absolute;z-index:3;top:calc(100% + .6495rem);max-width:10rem!important;border-radius:0}.tooltip:before{border-color:transparent transparent #0a0a0a;border-bottom-style:solid;border-top-width:0;bottom:100%;position:absolute;left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}.tooltip.top:before,.tooltip:before{content:'';display:block;width:0;height:0;border:.75rem inset}.tooltip.top:before{border-color:#0a0a0a transparent transparent;border-top-style:solid;border-bottom-width:0;top:100%;bottom:auto}.tooltip.left:before{border-color:transparent transparent transparent #0a0a0a;border-left-style:solid;border-right-width:0;left:100%}.tooltip.left:before,.tooltip.right:before{content:'';display:block;width:0;height:0;border:.75rem inset;bottom:auto;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.tooltip.right:before{border-color:transparent #0a0a0a transparent transparent;border-right-style:solid;border-left-width:0;left:auto;right:100%}.top-bar{padding:.5rem}.top-bar:after,.top-bar:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.top-bar:after{clear:both}.top-bar,.top-bar ul{background-color:#e6e6e6}.top-bar input{width:200px;margin-right:1rem}.top-bar .input-group-field{width:100%;margin-right:0}.top-bar input.button{width:auto}@media screen and (max-width:39.9375em){.stacked-for-small .top-bar-left,.stacked-for-small .top-bar-right{width:100%}}@media screen and (max-width:63.9375em){.stacked-for-medium .top-bar-left,.stacked-for-medium .top-bar-right{width:100%}}@media screen and (max-width:74.9375em){.stacked-for-large .top-bar-left,.stacked-for-large .top-bar-right{width:100%}}.top-bar-left,.top-bar-right{width:100%}@media screen and (min-width:40em){.top-bar-left,.top-bar-right{width:auto}}.top-bar-title{float:left;margin-right:1rem}.top-bar-left{float:left}.top-bar-right{float:right}.hide{display:none!important}.invisible{visibility:hidden}@media screen and (max-width:39.9375em){.hide-for-small-only{display:none!important}}@media screen and (max-width:0em),screen and (min-width:40em){.show-for-small-only{display:none!important}}@media screen and (min-width:40em){.hide-for-medium{display:none!important}}@media screen and (max-width:39.9375em){.show-for-medium{display:none!important}}@media screen and (min-width:40em) and (max-width:63.9375em){.hide-for-medium-only{display:none!important}}@media screen and (max-width:39.9375em),screen and (min-width:64em){.show-for-medium-only{display:none!important}}@media screen and (min-width:64em){.hide-for-large{display:none!important}}@media screen and (max-width:63.9375em){.show-for-large{display:none!important}}@media screen and (min-width:64em) and (max-width:74.9375em){.hide-for-large-only{display:none!important}}@media screen and (max-width:63.9375em),screen and (min-width:75em){.show-for-large-only{display:none!important}}.show-for-sr,.show-on-focus{position:absolute!important;width:1px;height:1px;overflow:hidden;clip:rect(0,0,0,0)}.show-on-focus:active,.show-on-focus:focus{position:static!important;height:auto;width:auto;overflow:visible;clip:auto}.hide-for-portrait,.show-for-landscape{display:block!important}@media screen and (orientation:landscape){.hide-for-portrait,.show-for-landscape{display:block!important}}@media screen and (orientation:portrait){.hide-for-portrait,.show-for-landscape{display:none!important}}.hide-for-landscape,.show-for-portrait{display:none!important}@media screen and (orientation:landscape){.hide-for-landscape,.show-for-portrait{display:none!important}}@media screen and (orientation:portrait){.hide-for-landscape,.show-for-portrait{display:block!important}}.float-left{float:left!important}.float-right{float:right!important}.float-center{display:block;margin-left:auto;margin-right:auto}.clearfix:after,.clearfix:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.clearfix:after{clear:both}", ""]);
	
	// exports


/***/ },
/* 276 */
/***/ function(module, exports) {

	"use strict";
	
	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function () {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for (var i = 0; i < this.length; i++) {
				var item = this[i];
				if (item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function (modules, mediaQuery) {
			if (typeof modules === "string") modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for (var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if (typeof id === "number") alreadyImportedModules[id] = true;
			}
			for (i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if (mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if (mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(279);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(277)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./app.scss", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./app.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(276)();
	// imports
	
	
	// module
	exports.push([module.id, ".page-title {\n  margin-top: 2.5rem;\n  margin-bottom: 2.5rem;\n  color: #555; }\n\ninput[type=search] {\n  box-shadow: none; }\n", ""]);
	
	// exports


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgOWI1ZDdmNzA2MWJjMDBjZDhkMzciLCJ3ZWJwYWNrOi8vLy4vfi9qcXVlcnkvZGlzdC9qcXVlcnkubWluLmpzPzViNGIiLCJ3ZWJwYWNrOi8vLy4vfi9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvZm91bmRhdGlvbi5taW4uanM/NjdkNSIsIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvYXBwLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImpRdWVyeVwiIiwid2VicGFjazovLy8uL34vcmVhY3QvcmVhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvaW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2NhbkRlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudFN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEl0ZXJhdG9yRm4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvS2V5RXNjYXBlVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3ROb29wVXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFB1cmVDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL29ubHlDaGlsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET00uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29tcG9uZW50VHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9ET01Qcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01Db21wb25lbnRGbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3REZWZhdWx0SW5qZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9BUklBRE9NUHJvcGVydHlDb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0V2ZW50UHJvcGFnYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luSHViLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9FdmVudFBsdWdpblJlZ2lzdHJ5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9FdmVudFBsdWdpblV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEVycm9yVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2FjY3VtdWxhdGVJbnRvLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9Qb29sZWRDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvZ2V0VGV4dENvbnRlbnRBY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0lucHV0RXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0NoYW5nZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdFVwZGF0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0NhbGxiYWNrUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RmVhdHVyZUZsYWdzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdFJlY29uY2lsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0UmVmLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdE93bmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEluc3RydW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3REZWJ1Z1Rvb2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9wZXJmb3JtYW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvVHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2dldEV2ZW50VGFyZ2V0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9pc0V2ZW50U3VwcG9ydGVkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9FbnRlckxlYXZlRXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY01vdXNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1VJRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1ZpZXdwb3J0TWV0cmljcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvZ2V0RXZlbnRNb2RpZmllclN0YXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9ET01DaGlsZHJlbk9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0RPTUxhenlUcmVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9ET01OYW1lc3BhY2VzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9zZXRJbm5lckhUTUwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL3NldFRleHRDb250ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0Rhbmdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NyZWF0ZUFycmF5RnJvbU1peGVkLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvZ2V0TWFya3VwV3JhcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01JRE9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9BdXRvRm9jdXNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9DU1NQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvY2FtZWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvRE9NUHJvcGVydHlPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvTGlua2VkVmFsdWVVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NT3B0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTVNlbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01UZXh0YXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RNdWx0aUNoaWxkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEluc3RhbmNlTWFwLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdENoaWxkUmVjb25jaWxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RDb21wb3NpdGVDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0Tm9kZVR5cGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RFbXB0eUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RIb3N0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9nZXROZXh0RGVidWdJRC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvS2V5RXNjYXBlVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RWxlbWVudFN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvZmxhdHRlbkNoaWxkcmVuLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdFVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi92YWxpZGF0ZURPTU5lc3RpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NRW1wdHlDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NVHJlZVRyYXZlcnNhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01UZXh0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEV2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0SW5qZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdElucHV0U2VsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTVNlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2lzVGV4dE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9pc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvU2VsZWN0RXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNBbmltYXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljQ2xpcGJvYXJkRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2dldEV2ZW50Q2hhckNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2dldEV2ZW50S2V5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNEcmFnRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1RyYW5zaXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljV2hlZWxFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RNb3VudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01Db250YWluZXJJbmZvLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUZlYXR1cmVGbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvYWRsZXIzMi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RWZXJzaW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9maW5kRE9NTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01JbnZhbGlkQVJJQUhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Qcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1BhdHRlcm5VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ludmFyaWFudC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9yb3V0ZXJXYXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vd2FybmluZy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9jb21wdXRlQ2hhbmdlZFJvdXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvVHJhbnNpdGlvblV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Bc3luY1V0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9pc0FjdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvZ2V0Q29tcG9uZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUHJvbWlzZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaFJvdXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvSW50ZXJuYWxQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlckNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2dldFJvdXRlUGFyYW1zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Db250ZXh0VXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlclV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9MaW5rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9JbmRleExpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL3dpdGhSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSZWRpcmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4Um91dGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL0FjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi91c2VRdWVyaWVzLmpzIiwid2VicGFjazovLy8uL34vcXVlcnktc3RyaW5nL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc3RyaWN0LXVyaS1lbmNvZGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9ydW5UcmFuc2l0aW9uSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL0xvY2F0aW9uVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9QYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi91c2VCYXNlbmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9jcmVhdGVIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvQXN5bmNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvdXNlUm91dGVySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvYXBwbHlSb3V0ZXJNaWRkbGV3YXJlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9icm93c2VySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9Ccm93c2VyUHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9ET01VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL0RPTVN0YXRlU3RvcmFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL1JlZnJlc2hQcm90b2NvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvY3JlYXRlUm91dGVySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvaGFzaEhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9jcmVhdGVIYXNoSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL0hhc2hQcm90b2NvbC5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy9NYWluLmpzIiwid2VicGFjazovLy8uL2FwcC9jb21wb25lbnRzL05hdi5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy9XZWF0aGVyLmpzIiwid2VicGFjazovLy8uL2FwcC9jb21wb25lbnRzL1dlYXRoZXJGb3JtLmpzIiwid2VicGFjazovLy8uL2FwcC9jb21wb25lbnRzL1dlYXRoZXJNZXNzYWdlLmpzIiwid2VicGFjazovLy8uL2FwcC9hcGkvb3BlbldlYXRoZXJNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9heGlvcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2J0b2EuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvRXJyb3JNb2RhbC5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy9BYm91dC5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy9FeGFtcGxlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLm1pbi5jc3M/NWQwZSIsIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLm1pbi5jc3MiLCJ3ZWJwYWNrOi8vLy4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3N0eWxlcy9hcHAuc2Nzcz9iMjlmIiwid2VicGFjazovLy8uL2FwcC9zdHlsZXMvYXBwLnNjc3MiXSwibmFtZXMiOlsicmVxdWlyZSIsIiQiLCJkb2N1bWVudCIsImZvdW5kYXRpb24iLCJyZW5kZXIiLCJnZXRFbGVtZW50QnlJZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJfYXNzaWduIiwiUmVhY3RDaGlsZHJlbiIsIlJlYWN0Q29tcG9uZW50IiwiUmVhY3RQdXJlQ29tcG9uZW50IiwiUmVhY3RDbGFzcyIsIlJlYWN0RE9NRmFjdG9yaWVzIiwiUmVhY3RFbGVtZW50IiwiUmVhY3RQcm9wVHlwZXMiLCJSZWFjdFZlcnNpb24iLCJvbmx5Q2hpbGQiLCJ3YXJuaW5nIiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZUZhY3RvcnkiLCJjbG9uZUVsZW1lbnQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJSZWFjdEVsZW1lbnRWYWxpZGF0b3IiLCJfX3NwcmVhZCIsIndhcm5lZCIsImFwcGx5IiwiYXJndW1lbnRzIiwiUmVhY3QiLCJDaGlsZHJlbiIsIm1hcCIsImZvckVhY2giLCJjb3VudCIsInRvQXJyYXkiLCJvbmx5IiwiQ29tcG9uZW50IiwiUHVyZUNvbXBvbmVudCIsImlzVmFsaWRFbGVtZW50IiwiUHJvcFR5cGVzIiwiY3JlYXRlQ2xhc3MiLCJjcmVhdGVNaXhpbiIsIm1peGluIiwiRE9NIiwidmVyc2lvbiIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiRXJyb3IiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImUiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwiY2FsbCIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJsZW4iLCJydW4iLCJuZXh0VGljayIsImFyZ3MiLCJBcnJheSIsImkiLCJwdXNoIiwiSXRlbSIsImFycmF5IiwicHJvdG90eXBlIiwidGl0bGUiLCJicm93c2VyIiwiYXJndiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwiYmluZGluZyIsIm5hbWUiLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwiaGFzT3duUHJvcGVydHkiLCJPYmplY3QiLCJwcm9wSXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJ0b09iamVjdCIsInZhbCIsInVuZGVmaW5lZCIsIlR5cGVFcnJvciIsInNob3VsZFVzZU5hdGl2ZSIsImFzc2lnbiIsInRlc3QxIiwiU3RyaW5nIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInRlc3QyIiwiZnJvbUNoYXJDb2RlIiwib3JkZXIyIiwibiIsImpvaW4iLCJ0ZXN0MyIsInNwbGl0IiwibGV0dGVyIiwia2V5cyIsInRhcmdldCIsInNvdXJjZSIsImZyb20iLCJ0byIsInN5bWJvbHMiLCJzIiwia2V5IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiUG9vbGVkQ2xhc3MiLCJlbXB0eUZ1bmN0aW9uIiwidHJhdmVyc2VBbGxDaGlsZHJlbiIsInR3b0FyZ3VtZW50UG9vbGVyIiwiZm91ckFyZ3VtZW50UG9vbGVyIiwidXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgiLCJlc2NhcGVVc2VyUHJvdmlkZWRLZXkiLCJ0ZXh0IiwicmVwbGFjZSIsIkZvckVhY2hCb29rS2VlcGluZyIsImZvckVhY2hGdW5jdGlvbiIsImZvckVhY2hDb250ZXh0IiwiZnVuYyIsImNvbnRleHQiLCJkZXN0cnVjdG9yIiwiYWRkUG9vbGluZ1RvIiwiZm9yRWFjaFNpbmdsZUNoaWxkIiwiYm9va0tlZXBpbmciLCJjaGlsZCIsImZvckVhY2hDaGlsZHJlbiIsImNoaWxkcmVuIiwiZm9yRWFjaEZ1bmMiLCJ0cmF2ZXJzZUNvbnRleHQiLCJnZXRQb29sZWQiLCJyZWxlYXNlIiwiTWFwQm9va0tlZXBpbmciLCJtYXBSZXN1bHQiLCJrZXlQcmVmaXgiLCJtYXBGdW5jdGlvbiIsIm1hcENvbnRleHQiLCJyZXN1bHQiLCJtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0IiwiY2hpbGRLZXkiLCJtYXBwZWRDaGlsZCIsImlzQXJyYXkiLCJtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsIiwidGhhdFJldHVybnNBcmd1bWVudCIsImNsb25lQW5kUmVwbGFjZUtleSIsInByZWZpeCIsImVzY2FwZWRQcmVmaXgiLCJtYXBDaGlsZHJlbiIsImZvckVhY2hTaW5nbGVDaGlsZER1bW15IiwiY291bnRDaGlsZHJlbiIsIl9wcm9kSW52YXJpYW50IiwiaW52YXJpYW50Iiwib25lQXJndW1lbnRQb29sZXIiLCJjb3B5RmllbGRzRnJvbSIsIktsYXNzIiwiaW5zdGFuY2VQb29sIiwiaW5zdGFuY2UiLCJwb3AiLCJhMSIsImEyIiwidGhyZWVBcmd1bWVudFBvb2xlciIsImEzIiwiYTQiLCJmaXZlQXJndW1lbnRQb29sZXIiLCJhNSIsInN0YW5kYXJkUmVsZWFzZXIiLCJwb29sU2l6ZSIsIkRFRkFVTFRfUE9PTF9TSVpFIiwiREVGQVVMVF9QT09MRVIiLCJDb3B5Q29uc3RydWN0b3IiLCJwb29sZXIiLCJOZXdLbGFzcyIsInJlYWN0UHJvZEludmFyaWFudCIsImNvZGUiLCJhcmdDb3VudCIsIm1lc3NhZ2UiLCJhcmdJZHgiLCJlbmNvZGVVUklDb21wb25lbnQiLCJlcnJvciIsImZyYW1lc1RvUG9wIiwiY29uZGl0aW9uIiwiZm9ybWF0IiwiYSIsImIiLCJjIiwiZCIsImYiLCJhcmdJbmRleCIsIlJlYWN0Q3VycmVudE93bmVyIiwiY2FuRGVmaW5lUHJvcGVydHkiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJSRVNFUlZFRF9QUk9QUyIsInJlZiIsIl9fc2VsZiIsIl9fc291cmNlIiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biIsImhhc1ZhbGlkUmVmIiwiY29uZmlnIiwiZ2V0dGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0IiwiaXNSZWFjdFdhcm5pbmciLCJoYXNWYWxpZEtleSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwicHJvcHMiLCJkaXNwbGF5TmFtZSIsIndhcm5BYm91dEFjY2Vzc2luZ0tleSIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJ0eXBlIiwic2VsZiIsIm93bmVyIiwiZWxlbWVudCIsIiQkdHlwZW9mIiwiX293bmVyIiwiX3N0b3JlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwidmFsdWUiLCJ2YWxpZGF0ZWQiLCJfc2VsZiIsIl9zb3VyY2UiLCJmcmVlemUiLCJwcm9wTmFtZSIsImNoaWxkcmVuTGVuZ3RoIiwiY2hpbGRBcnJheSIsImRlZmF1bHRQcm9wcyIsImN1cnJlbnQiLCJmYWN0b3J5IiwiYmluZCIsIm9sZEVsZW1lbnQiLCJuZXdLZXkiLCJuZXdFbGVtZW50Iiwib2JqZWN0IiwicHJpbnRXYXJuaW5nIiwiX2xlbiIsIl9rZXkiLCJjb25zb2xlIiwieCIsImluZGV4T2YiLCJfbGVuMiIsIl9rZXkyIiwibWFrZUVtcHR5RnVuY3Rpb24iLCJhcmciLCJ0aGF0UmV0dXJucyIsInRoYXRSZXR1cm5zRmFsc2UiLCJ0aGF0UmV0dXJuc1RydWUiLCJ0aGF0UmV0dXJuc051bGwiLCJ0aGF0UmV0dXJuc1RoaXMiLCJTeW1ib2wiLCJnZXRJdGVyYXRvckZuIiwiS2V5RXNjYXBlVXRpbHMiLCJTRVBBUkFUT1IiLCJTVUJTRVBBUkFUT1IiLCJkaWRXYXJuQWJvdXRNYXBzIiwiZ2V0Q29tcG9uZW50S2V5IiwiY29tcG9uZW50IiwiaW5kZXgiLCJlc2NhcGUiLCJ0b1N0cmluZyIsInRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsIiwibmFtZVNvRmFyIiwiY2FsbGJhY2siLCJuZXh0TmFtZSIsInN1YnRyZWVDb3VudCIsIm5leHROYW1lUHJlZml4IiwiaXRlcmF0b3JGbiIsIml0ZXJhdG9yIiwic3RlcCIsImVudHJpZXMiLCJpaSIsIm5leHQiLCJkb25lIiwibWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSIsIm1hcHNBc0NoaWxkcmVuT3duZXJOYW1lIiwiZ2V0TmFtZSIsImVudHJ5IiwiYWRkZW5kdW0iLCJfaXNSZWFjdEVsZW1lbnQiLCJjaGlsZHJlblN0cmluZyIsIklURVJBVE9SX1NZTUJPTCIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwibWF5YmVJdGVyYWJsZSIsImVzY2FwZVJlZ2V4IiwiZXNjYXBlckxvb2t1cCIsImVzY2FwZWRTdHJpbmciLCJtYXRjaCIsInVuZXNjYXBlIiwidW5lc2NhcGVSZWdleCIsInVuZXNjYXBlckxvb2t1cCIsImtleVN1YnN0cmluZyIsInN1YnN0cmluZyIsIlJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIiwiZW1wdHlPYmplY3QiLCJ1cGRhdGVyIiwicmVmcyIsImlzUmVhY3RDb21wb25lbnQiLCJzZXRTdGF0ZSIsInBhcnRpYWxTdGF0ZSIsImVucXVldWVTZXRTdGF0ZSIsImVucXVldWVDYWxsYmFjayIsImZvcmNlVXBkYXRlIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwiZGVwcmVjYXRlZEFQSXMiLCJpc01vdW50ZWQiLCJyZXBsYWNlU3RhdGUiLCJkZWZpbmVEZXByZWNhdGlvbldhcm5pbmciLCJtZXRob2ROYW1lIiwiaW5mbyIsImZuTmFtZSIsIndhcm5Ob29wIiwicHVibGljSW5zdGFuY2UiLCJjYWxsZXJOYW1lIiwiY29uc3RydWN0b3IiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiY29tcGxldGVTdGF0ZSIsIkNvbXBvbmVudER1bW15IiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyIsIk1JWElOU19LRVkiLCJpZGVudGl0eSIsImZuIiwiaW5qZWN0ZWRNaXhpbnMiLCJSZWFjdENsYXNzSW50ZXJmYWNlIiwibWl4aW5zIiwic3RhdGljcyIsInByb3BUeXBlcyIsImNvbnRleHRUeXBlcyIsImNoaWxkQ29udGV4dFR5cGVzIiwiZ2V0RGVmYXVsdFByb3BzIiwiZ2V0SW5pdGlhbFN0YXRlIiwiZ2V0Q2hpbGRDb250ZXh0IiwiY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwidXBkYXRlQ29tcG9uZW50IiwiUkVTRVJWRURfU1BFQ19LRVlTIiwiQ29uc3RydWN0b3IiLCJtaXhTcGVjSW50b0NvbXBvbmVudCIsInZhbGlkYXRlVHlwZURlZiIsImNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uIiwibWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQiLCJhdXRvYmluZCIsInR5cGVEZWYiLCJsb2NhdGlvbiIsInZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUiLCJpc0FscmVhZHlEZWZpbmVkIiwic3BlY1BvbGljeSIsIlJlYWN0Q2xhc3NNaXhpbiIsInNwZWMiLCJ0eXBlb2ZTcGVjIiwiaXNNaXhpblZhbGlkIiwicHJvdG8iLCJhdXRvQmluZFBhaXJzIiwiX19yZWFjdEF1dG9CaW5kUGFpcnMiLCJwcm9wZXJ0eSIsImlzUmVhY3RDbGFzc01ldGhvZCIsImlzRnVuY3Rpb24iLCJzaG91bGRBdXRvQmluZCIsImNyZWF0ZUNoYWluZWRGdW5jdGlvbiIsImlzUmVzZXJ2ZWQiLCJpc0luaGVyaXRlZCIsIm1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMiLCJvbmUiLCJ0d28iLCJtZXJnZWRSZXN1bHQiLCJjaGFpbmVkRnVuY3Rpb24iLCJiaW5kQXV0b0JpbmRNZXRob2QiLCJtZXRob2QiLCJib3VuZE1ldGhvZCIsIl9fcmVhY3RCb3VuZENvbnRleHQiLCJfX3JlYWN0Qm91bmRNZXRob2QiLCJfX3JlYWN0Qm91bmRBcmd1bWVudHMiLCJjb21wb25lbnROYW1lIiwiX2JpbmQiLCJuZXdUaGlzIiwicmVib3VuZE1ldGhvZCIsImJpbmRBdXRvQmluZE1ldGhvZHMiLCJwYWlycyIsImF1dG9CaW5kS2V5IiwibmV3U3RhdGUiLCJSZWFjdENsYXNzQ29tcG9uZW50Iiwic3RhdGUiLCJpbml0aWFsU3RhdGUiLCJfaXNNb2NrRnVuY3Rpb24iLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJpbmplY3Rpb24iLCJpbmplY3RNaXhpbiIsInByb3AiLCJjaGlsZENvbnRleHQiLCJjcmVhdGVET01GYWN0b3J5IiwiYWJiciIsImFkZHJlc3MiLCJhcmVhIiwiYXJ0aWNsZSIsImFzaWRlIiwiYXVkaW8iLCJiYXNlIiwiYmRpIiwiYmRvIiwiYmlnIiwiYmxvY2txdW90ZSIsImJvZHkiLCJiciIsImJ1dHRvbiIsImNhbnZhcyIsImNhcHRpb24iLCJjaXRlIiwiY29sIiwiY29sZ3JvdXAiLCJkYXRhIiwiZGF0YWxpc3QiLCJkZCIsImRlbCIsImRldGFpbHMiLCJkZm4iLCJkaWFsb2ciLCJkaXYiLCJkbCIsImR0IiwiZW0iLCJlbWJlZCIsImZpZWxkc2V0IiwiZmlnY2FwdGlvbiIsImZpZ3VyZSIsImZvb3RlciIsImZvcm0iLCJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiLCJoZWFkIiwiaGVhZGVyIiwiaGdyb3VwIiwiaHIiLCJodG1sIiwiaWZyYW1lIiwiaW1nIiwiaW5wdXQiLCJpbnMiLCJrYmQiLCJrZXlnZW4iLCJsYWJlbCIsImxlZ2VuZCIsImxpIiwibGluayIsIm1haW4iLCJtYXJrIiwibWVudSIsIm1lbnVpdGVtIiwibWV0YSIsIm1ldGVyIiwibmF2Iiwibm9zY3JpcHQiLCJvbCIsIm9wdGdyb3VwIiwib3B0aW9uIiwib3V0cHV0IiwicCIsInBhcmFtIiwicGljdHVyZSIsInByZSIsInByb2dyZXNzIiwicSIsInJwIiwicnQiLCJydWJ5Iiwic2FtcCIsInNjcmlwdCIsInNlY3Rpb24iLCJzZWxlY3QiLCJzbWFsbCIsInNwYW4iLCJzdHJvbmciLCJzdHlsZSIsInN1YiIsInN1bW1hcnkiLCJzdXAiLCJ0YWJsZSIsInRib2R5IiwidGQiLCJ0ZXh0YXJlYSIsInRmb290IiwidGgiLCJ0aGVhZCIsInRpbWUiLCJ0ciIsInRyYWNrIiwidSIsInVsIiwidmlkZW8iLCJ3YnIiLCJjaXJjbGUiLCJjbGlwUGF0aCIsImRlZnMiLCJlbGxpcHNlIiwiZyIsImltYWdlIiwibGluZSIsImxpbmVhckdyYWRpZW50IiwibWFzayIsInBhdGgiLCJwYXR0ZXJuIiwicG9seWdvbiIsInBvbHlsaW5lIiwicmFkaWFsR3JhZGllbnQiLCJyZWN0Iiwic3RvcCIsInN2ZyIsInRzcGFuIiwiUmVhY3RDb21wb25lbnRUcmVlSG9vayIsImNoZWNrUmVhY3RUeXBlU3BlYyIsImdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsImdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJwYXJlbnRUeXBlIiwicGFyZW50TmFtZSIsInZhbGlkYXRlRXhwbGljaXRLZXkiLCJtZW1vaXplciIsInVuaXF1ZUtleSIsImN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJjaGlsZE93bmVyIiwiZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW0iLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJ2YWxpZGF0ZVByb3BUeXBlcyIsImNvbXBvbmVudENsYXNzIiwidmFsaWRUeXBlIiwidmFsaWRhdGVkRmFjdG9yeSIsImlzTmF0aXZlIiwiZnVuY1RvU3RyaW5nIiwiRnVuY3Rpb24iLCJyZUlzTmF0aXZlIiwiUmVnRXhwIiwidGVzdCIsImVyciIsImNhblVzZUNvbGxlY3Rpb25zIiwiTWFwIiwiU2V0IiwiaXRlbU1hcCIsInJvb3RJRFNldCIsInNldEl0ZW0iLCJpZCIsIml0ZW0iLCJzZXQiLCJnZXRJdGVtIiwicmVtb3ZlSXRlbSIsImdldEl0ZW1JRHMiLCJhZGRSb290IiwiYWRkIiwicmVtb3ZlUm9vdCIsImdldFJvb3RJRHMiLCJpdGVtQnlLZXkiLCJyb290QnlLZXkiLCJnZXRLZXlGcm9tSUQiLCJnZXRJREZyb21LZXkiLCJwYXJzZUludCIsInN1YnN0ciIsInVubW91bnRlZElEcyIsInB1cmdlRGVlcCIsImNoaWxkSURzIiwiZGVzY3JpYmVDb21wb25lbnRGcmFtZSIsIm93bmVyTmFtZSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsImdldERpc3BsYXlOYW1lIiwiZGVzY3JpYmVJRCIsImdldEVsZW1lbnQiLCJvd25lcklEIiwiZ2V0T3duZXJJRCIsIm9uU2V0Q2hpbGRyZW4iLCJuZXh0Q2hpbGRJRHMiLCJuZXh0Q2hpbGRJRCIsIm5leHRDaGlsZCIsInBhcmVudElEIiwib25CZWZvcmVNb3VudENvbXBvbmVudCIsInVwZGF0ZUNvdW50Iiwib25CZWZvcmVVcGRhdGVDb21wb25lbnQiLCJvbk1vdW50Q29tcG9uZW50IiwiaXNSb290Iiwib25VcGRhdGVDb21wb25lbnQiLCJvblVubW91bnRDb21wb25lbnQiLCJwdXJnZVVubW91bnRlZENvbXBvbmVudHMiLCJfcHJldmVudFB1cmdpbmciLCJ0b3BFbGVtZW50IiwiY3VycmVudE93bmVyIiwiX2RlYnVnSUQiLCJnZXRTdGFja0FkZGVuZHVtQnlJRCIsImdldFBhcmVudElEIiwiZ2V0Q2hpbGRJRHMiLCJnZXRTb3VyY2UiLCJnZXRUZXh0IiwiZ2V0VXBkYXRlQ291bnQiLCJnZXRSZWdpc3RlcmVkSURzIiwiUmVhY3RQcm9wVHlwZXNTZWNyZXQiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJkZWJ1Z0lEIiwidHlwZVNwZWNOYW1lIiwiZXgiLCJjb21wb25lbnRTdGFja0luZm8iLCJBTk9OWU1PVVMiLCJjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlciIsImJvb2wiLCJudW1iZXIiLCJzdHJpbmciLCJzeW1ib2wiLCJhbnkiLCJjcmVhdGVBbnlUeXBlQ2hlY2tlciIsImFycmF5T2YiLCJjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIiLCJjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIiLCJpbnN0YW5jZU9mIiwiY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlciIsImNyZWF0ZU5vZGVDaGVja2VyIiwib2JqZWN0T2YiLCJjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyIiwib25lT2YiLCJjcmVhdGVFbnVtVHlwZUNoZWNrZXIiLCJvbmVPZlR5cGUiLCJjcmVhdGVVbmlvblR5cGVDaGVja2VyIiwic2hhcGUiLCJjcmVhdGVTaGFwZVR5cGVDaGVja2VyIiwiaXMiLCJ5IiwiUHJvcFR5cGVFcnJvciIsInN0YWNrIiwiY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIiLCJ2YWxpZGF0ZSIsIm1hbnVhbFByb3BUeXBlQ2FsbENhY2hlIiwiY2hlY2tUeXBlIiwiaXNSZXF1aXJlZCIsInByb3BGdWxsTmFtZSIsInNlY3JldCIsImNhY2hlS2V5IiwibG9jYXRpb25OYW1lIiwiY2hhaW5lZENoZWNrVHlwZSIsImV4cGVjdGVkVHlwZSIsInByb3BWYWx1ZSIsInByb3BUeXBlIiwiZ2V0UHJvcFR5cGUiLCJwcmVjaXNlVHlwZSIsImdldFByZWNpc2VUeXBlIiwidHlwZUNoZWNrZXIiLCJleHBlY3RlZENsYXNzIiwiZXhwZWN0ZWRDbGFzc05hbWUiLCJhY3R1YWxDbGFzc05hbWUiLCJnZXRDbGFzc05hbWUiLCJleHBlY3RlZFZhbHVlcyIsInZhbHVlc1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJhcnJheU9mVHlwZUNoZWNrZXJzIiwiY2hlY2tlciIsImlzTm9kZSIsInNoYXBlVHlwZXMiLCJldmVyeSIsImlzU3ltYm9sIiwiRGF0ZSIsIlJlYWN0RE9NQ29tcG9uZW50VHJlZSIsIlJlYWN0RGVmYXVsdEluamVjdGlvbiIsIlJlYWN0TW91bnQiLCJSZWFjdFJlY29uY2lsZXIiLCJSZWFjdFVwZGF0ZXMiLCJmaW5kRE9NTm9kZSIsImdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlIiwicmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJpbmplY3QiLCJSZWFjdERPTSIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsImJhdGNoZWRVcGRhdGVzIiwidW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJDb21wb25lbnRUcmVlIiwiZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUiLCJnZXROb2RlRnJvbUluc3RhbmNlIiwiaW5zdCIsIl9yZW5kZXJlZENvbXBvbmVudCIsIk1vdW50IiwiUmVjb25jaWxlciIsIkV4ZWN1dGlvbkVudmlyb25tZW50IiwiY2FuVXNlRE9NIiwid2luZG93IiwidG9wIiwibmF2aWdhdG9yIiwidXNlckFnZW50Iiwic2hvd0ZpbGVVcmxNZXNzYWdlIiwicHJvdG9jb2wiLCJkZWJ1ZyIsInRlc3RGdW5jIiwidGVzdEZuIiwiaWVDb21wYXRpYmlsaXR5TW9kZSIsImRvY3VtZW50TW9kZSIsImV4cGVjdGVkRmVhdHVyZXMiLCJub3ciLCJ0cmltIiwiUmVhY3RJbnN0cnVtZW50YXRpb24iLCJSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2siLCJSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2siLCJSZWFjdERPTUludmFsaWRBUklBSG9vayIsImRlYnVnVG9vbCIsImFkZEhvb2siLCJET01Qcm9wZXJ0eSIsIlJlYWN0RE9NQ29tcG9uZW50RmxhZ3MiLCJBVFRSX05BTUUiLCJJRF9BVFRSSUJVVEVfTkFNRSIsIkZsYWdzIiwiaW50ZXJuYWxJbnN0YW5jZUtleSIsIk1hdGgiLCJyYW5kb20iLCJzbGljZSIsImdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQiLCJyZW5kZXJlZCIsInByZWNhY2hlTm9kZSIsImhvc3RJbnN0IiwiX2hvc3ROb2RlIiwidW5jYWNoZU5vZGUiLCJwcmVjYWNoZUNoaWxkTm9kZXMiLCJfZmxhZ3MiLCJoYXNDYWNoZWRDaGlsZE5vZGVzIiwiX3JlbmRlcmVkQ2hpbGRyZW4iLCJjaGlsZE5vZGUiLCJmaXJzdENoaWxkIiwib3V0ZXIiLCJjaGlsZEluc3QiLCJjaGlsZElEIiwiX2RvbUlEIiwibmV4dFNpYmxpbmciLCJub2RlVHlwZSIsImdldEF0dHJpYnV0ZSIsIm5vZGVWYWx1ZSIsInBhcmVudHMiLCJwYXJlbnROb2RlIiwiY2xvc2VzdCIsImdldEluc3RhbmNlRnJvbU5vZGUiLCJfaG9zdFBhcmVudCIsImNoZWNrTWFzayIsImJpdG1hc2siLCJET01Qcm9wZXJ0eUluamVjdGlvbiIsIk1VU1RfVVNFX1BST1BFUlRZIiwiSEFTX0JPT0xFQU5fVkFMVUUiLCJIQVNfTlVNRVJJQ19WQUxVRSIsIkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFIiwiSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSIsImluamVjdERPTVByb3BlcnR5Q29uZmlnIiwiZG9tUHJvcGVydHlDb25maWciLCJJbmplY3Rpb24iLCJQcm9wZXJ0aWVzIiwiRE9NQXR0cmlidXRlTmFtZXNwYWNlcyIsIkRPTUF0dHJpYnV0ZU5hbWVzIiwiRE9NUHJvcGVydHlOYW1lcyIsIkRPTU11dGF0aW9uTWV0aG9kcyIsImlzQ3VzdG9tQXR0cmlidXRlIiwiX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zIiwicHJvcGVydGllcyIsImxvd2VyQ2FzZWQiLCJ0b0xvd2VyQ2FzZSIsInByb3BDb25maWciLCJwcm9wZXJ0eUluZm8iLCJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlTmFtZXNwYWNlIiwicHJvcGVydHlOYW1lIiwibXV0YXRpb25NZXRob2QiLCJtdXN0VXNlUHJvcGVydHkiLCJoYXNCb29sZWFuVmFsdWUiLCJoYXNOdW1lcmljVmFsdWUiLCJoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSIsImhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUiLCJnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZSIsIkFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIiLCJST09UX0FUVFJJQlVURV9OQU1FIiwiQVRUUklCVVRFX05BTUVfQ0hBUiIsImF1dG9mb2N1cyIsImlzQ3VzdG9tQXR0cmlidXRlRm4iLCJBUklBRE9NUHJvcGVydHlDb25maWciLCJCZWZvcmVJbnB1dEV2ZW50UGx1Z2luIiwiQ2hhbmdlRXZlbnRQbHVnaW4iLCJEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciIsIkVudGVyTGVhdmVFdmVudFBsdWdpbiIsIkhUTUxET01Qcm9wZXJ0eUNvbmZpZyIsIlJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50IiwiUmVhY3RET01Db21wb25lbnQiLCJSZWFjdERPTUVtcHR5Q29tcG9uZW50IiwiUmVhY3RET01UcmVlVHJhdmVyc2FsIiwiUmVhY3RET01UZXh0Q29tcG9uZW50IiwiUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSIsIlJlYWN0RXZlbnRMaXN0ZW5lciIsIlJlYWN0SW5qZWN0aW9uIiwiUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiIsIlNWR0RPTVByb3BlcnR5Q29uZmlnIiwiU2VsZWN0RXZlbnRQbHVnaW4iLCJTaW1wbGVFdmVudFBsdWdpbiIsImFscmVhZHlJbmplY3RlZCIsIkV2ZW50RW1pdHRlciIsImluamVjdFJlYWN0RXZlbnRMaXN0ZW5lciIsIkV2ZW50UGx1Z2luSHViIiwiaW5qZWN0RXZlbnRQbHVnaW5PcmRlciIsIkV2ZW50UGx1Z2luVXRpbHMiLCJpbmplY3RDb21wb25lbnRUcmVlIiwiaW5qZWN0VHJlZVRyYXZlcnNhbCIsImluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSIsIkhvc3RDb21wb25lbnQiLCJpbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MiLCJpbmplY3RUZXh0Q29tcG9uZW50Q2xhc3MiLCJFbXB0eUNvbXBvbmVudCIsImluamVjdEVtcHR5Q29tcG9uZW50RmFjdG9yeSIsImluc3RhbnRpYXRlIiwiVXBkYXRlcyIsImluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uIiwiaW5qZWN0QmF0Y2hpbmdTdHJhdGVneSIsImluamVjdEVudmlyb25tZW50IiwiRXZlbnRQcm9wYWdhdG9ycyIsIkZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSIsIlN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQiLCJTeW50aGV0aWNJbnB1dEV2ZW50IiwiRU5EX0tFWUNPREVTIiwiU1RBUlRfS0VZQ09ERSIsImNhblVzZUNvbXBvc2l0aW9uRXZlbnQiLCJjYW5Vc2VUZXh0SW5wdXRFdmVudCIsImlzUHJlc3RvIiwidXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEiLCJvcGVyYSIsIlNQQUNFQkFSX0NPREUiLCJTUEFDRUJBUl9DSEFSIiwiZXZlbnRUeXBlcyIsImJlZm9yZUlucHV0IiwicGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMiLCJidWJibGVkIiwiY2FwdHVyZWQiLCJkZXBlbmRlbmNpZXMiLCJjb21wb3NpdGlvbkVuZCIsImNvbXBvc2l0aW9uU3RhcnQiLCJjb21wb3NpdGlvblVwZGF0ZSIsImhhc1NwYWNlS2V5cHJlc3MiLCJpc0tleXByZXNzQ29tbWFuZCIsIm5hdGl2ZUV2ZW50IiwiY3RybEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSIsInRvcExldmVsVHlwZSIsImlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0Iiwia2V5Q29kZSIsImlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCIsImdldERhdGFGcm9tQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJjdXJyZW50Q29tcG9zaXRpb24iLCJleHRyYWN0Q29tcG9zaXRpb25FdmVudCIsInRhcmdldEluc3QiLCJuYXRpdmVFdmVudFRhcmdldCIsImV2ZW50VHlwZSIsImZhbGxiYWNrRGF0YSIsImdldERhdGEiLCJldmVudCIsImN1c3RvbURhdGEiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzIiwiZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyIsIndoaWNoIiwiY2hhcnMiLCJnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMiLCJleHRyYWN0QmVmb3JlSW5wdXRFdmVudCIsImV4dHJhY3RFdmVudHMiLCJhY2N1bXVsYXRlSW50byIsImZvckVhY2hBY2N1bXVsYXRlZCIsImdldExpc3RlbmVyIiwibGlzdGVuZXJBdFBoYXNlIiwicHJvcGFnYXRpb25QaGFzZSIsInJlZ2lzdHJhdGlvbk5hbWUiLCJkaXNwYXRjaENvbmZpZyIsImFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMiLCJwaGFzZSIsImxpc3RlbmVyIiwiX2Rpc3BhdGNoTGlzdGVuZXJzIiwiX2Rpc3BhdGNoSW5zdGFuY2VzIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSIsInRyYXZlcnNlVHdvUGhhc2UiLCJfdGFyZ2V0SW5zdCIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0IiwicGFyZW50SW5zdCIsImdldFBhcmVudEluc3RhbmNlIiwiYWNjdW11bGF0ZURpc3BhdGNoZXMiLCJpZ25vcmVkRGlyZWN0aW9uIiwiYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUiLCJldmVudHMiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCIsImFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyIsImxlYXZlIiwiZW50ZXIiLCJ0cmF2ZXJzZUVudGVyTGVhdmUiLCJhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyIsIkV2ZW50UGx1Z2luUmVnaXN0cnkiLCJSZWFjdEVycm9yVXRpbHMiLCJsaXN0ZW5lckJhbmsiLCJldmVudFF1ZXVlIiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlIiwic2ltdWxhdGVkIiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyIiwiaXNQZXJzaXN0ZW50IiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkIiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwiLCJnZXREaWN0aW9uYXJ5S2V5IiwiX3Jvb3ROb2RlSUQiLCJwdXRMaXN0ZW5lciIsImJhbmtGb3JSZWdpc3RyYXRpb25OYW1lIiwiUGx1Z2luTW9kdWxlIiwicmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMiLCJkaWRQdXRMaXN0ZW5lciIsImRlbGV0ZUxpc3RlbmVyIiwid2lsbERlbGV0ZUxpc3RlbmVyIiwiZGVsZXRlQWxsTGlzdGVuZXJzIiwicGx1Z2lucyIsInBvc3NpYmxlUGx1Z2luIiwiZXh0cmFjdGVkRXZlbnRzIiwiZW5xdWV1ZUV2ZW50cyIsInByb2Nlc3NFdmVudFF1ZXVlIiwicHJvY2Vzc2luZ0V2ZW50UXVldWUiLCJyZXRocm93Q2F1Z2h0RXJyb3IiLCJfX3B1cmdlIiwiX19nZXRMaXN0ZW5lckJhbmsiLCJldmVudFBsdWdpbk9yZGVyIiwibmFtZXNUb1BsdWdpbnMiLCJyZWNvbXB1dGVQbHVnaW5PcmRlcmluZyIsInBsdWdpbk5hbWUiLCJwbHVnaW5Nb2R1bGUiLCJwbHVnaW5JbmRleCIsInB1Ymxpc2hlZEV2ZW50cyIsImV2ZW50TmFtZSIsInB1Ymxpc2hFdmVudEZvclBsdWdpbiIsImV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyIsInBoYXNlTmFtZSIsInBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUiLCJwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZSIsInJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMiLCJsb3dlckNhc2VkTmFtZSIsInBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMiLCJvbmRibGNsaWNrIiwiaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyIiwiaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyIsImlzT3JkZXJpbmdEaXJ0eSIsImdldFBsdWdpbk1vZHVsZUZvckV2ZW50IiwiX3Jlc2V0RXZlbnRQbHVnaW5zIiwiVHJlZVRyYXZlcnNhbCIsIkluamVjdGVkIiwiaXNBbmNlc3RvciIsImdldExvd2VzdENvbW1vbkFuY2VzdG9yIiwiaXNFbmRpc2giLCJpc01vdmVpc2giLCJpc1N0YXJ0aXNoIiwidmFsaWRhdGVFdmVudERpc3BhdGNoZXMiLCJkaXNwYXRjaExpc3RlbmVycyIsImRpc3BhdGNoSW5zdGFuY2VzIiwibGlzdGVuZXJzSXNBcnIiLCJsaXN0ZW5lcnNMZW4iLCJpbnN0YW5jZXNJc0FyciIsImluc3RhbmNlc0xlbiIsImV4ZWN1dGVEaXNwYXRjaCIsImN1cnJlbnRUYXJnZXQiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2giLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2siLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsIiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSIsInJldCIsImV4ZWN1dGVEaXJlY3REaXNwYXRjaCIsImRpc3BhdGNoTGlzdGVuZXIiLCJkaXNwYXRjaEluc3RhbmNlIiwicmVzIiwiaGFzRGlzcGF0Y2hlcyIsImFyZ0Zyb20iLCJhcmdUbyIsImNhdWdodEVycm9yIiwiZGlzcGF0Y2hFdmVudCIsImNyZWF0ZUV2ZW50IiwiZmFrZU5vZGUiLCJib3VuZEZ1bmMiLCJldnRUeXBlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2dCIsImluaXRFdmVudCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhcnIiLCJjYiIsInNjb3BlIiwiY2FuVXNlV29ya2VycyIsIldvcmtlciIsImNhblVzZUV2ZW50TGlzdGVuZXJzIiwiYXR0YWNoRXZlbnQiLCJjYW5Vc2VWaWV3cG9ydCIsInNjcmVlbiIsImlzSW5Xb3JrZXIiLCJnZXRUZXh0Q29udGVudEFjY2Vzc29yIiwicm9vdCIsIl9yb290IiwiX3N0YXJ0VGV4dCIsIl9mYWxsYmFja1RleHQiLCJzdGFydCIsInN0YXJ0VmFsdWUiLCJzdGFydExlbmd0aCIsImVuZCIsImVuZFZhbHVlIiwiZW5kTGVuZ3RoIiwibWluRW5kIiwic2xpY2VUYWlsIiwiY29udGVudEtleSIsImRvY3VtZW50RWxlbWVudCIsIlN5bnRoZXRpY0V2ZW50IiwiQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSIsImRpc3BhdGNoTWFya2VyIiwiYXVnbWVudENsYXNzIiwiZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkiLCJpc1Byb3h5U3VwcG9ydGVkIiwiUHJveHkiLCJzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcyIsIkV2ZW50SW50ZXJmYWNlIiwiZXZlbnRQaGFzZSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwidGltZVN0YW1wIiwiZGVmYXVsdFByZXZlbnRlZCIsImlzVHJ1c3RlZCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiSW50ZXJmYWNlIiwibm9ybWFsaXplIiwicmV0dXJuVmFsdWUiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJjYW5jZWxCdWJibGUiLCJwZXJzaXN0IiwiZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbiIsImNvbnN0cnVjdCIsImNyZWF0ZSIsInRoYXQiLCJDbGFzcyIsIlN1cGVyIiwiRSIsImdldFZhbCIsImFjdGlvbiIsIndhcm4iLCJ3YXJuaW5nQ29uZGl0aW9uIiwiSW5wdXRFdmVudEludGVyZmFjZSIsImdldEV2ZW50VGFyZ2V0IiwiaXNFdmVudFN1cHBvcnRlZCIsImlzVGV4dElucHV0RWxlbWVudCIsImNoYW5nZSIsImFjdGl2ZUVsZW1lbnQiLCJhY3RpdmVFbGVtZW50SW5zdCIsImFjdGl2ZUVsZW1lbnRWYWx1ZSIsImFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AiLCJzaG91bGRVc2VDaGFuZ2VFdmVudCIsImVsZW0iLCJub2RlTmFtZSIsImRvZXNDaGFuZ2VFdmVudEJ1YmJsZSIsIm1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQiLCJydW5FdmVudEluQmF0Y2giLCJzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgiLCJzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCIsImRldGFjaEV2ZW50IiwiZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50IiwiaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTgiLCJpc0lucHV0RXZlbnRTdXBwb3J0ZWQiLCJuZXdWYWx1ZVByb3AiLCJzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UiLCJoYW5kbGVQcm9wZXJ0eUNoYW5nZSIsInN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwic3JjRWxlbWVudCIsImdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50IiwiaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudElFIiwiZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRJRSIsInNob3VsZFVzZUNsaWNrRXZlbnQiLCJnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCIsInRhcmdldE5vZGUiLCJnZXRUYXJnZXRJbnN0RnVuYyIsImhhbmRsZUV2ZW50RnVuYyIsIkNhbGxiYWNrUXVldWUiLCJSZWFjdEZlYXR1cmVGbGFncyIsIlRyYW5zYWN0aW9uIiwiZGlydHlDb21wb25lbnRzIiwidXBkYXRlQmF0Y2hOdW1iZXIiLCJhc2FwQ2FsbGJhY2tRdWV1ZSIsImFzYXBFbnF1ZXVlZCIsImJhdGNoaW5nU3RyYXRlZ3kiLCJlbnN1cmVJbmplY3RlZCIsIk5FU1RFRF9VUERBVEVTIiwiaW5pdGlhbGl6ZSIsImRpcnR5Q29tcG9uZW50c0xlbmd0aCIsImNsb3NlIiwic3BsaWNlIiwiZmx1c2hCYXRjaGVkVXBkYXRlcyIsIlVQREFURV9RVUVVRUlORyIsImNhbGxiYWNrUXVldWUiLCJyZXNldCIsIm5vdGlmeUFsbCIsIlRSQU5TQUNUSU9OX1dSQVBQRVJTIiwiUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbiIsInJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uIiwicmVjb25jaWxlVHJhbnNhY3Rpb24iLCJnZXRUcmFuc2FjdGlvbldyYXBwZXJzIiwicGVyZm9ybSIsIm1vdW50T3JkZXJDb21wYXJhdG9yIiwiYzEiLCJjMiIsIl9tb3VudE9yZGVyIiwicnVuQmF0Y2hlZFVwZGF0ZXMiLCJ0cmFuc2FjdGlvbiIsInNvcnQiLCJjYWxsYmFja3MiLCJfcGVuZGluZ0NhbGxiYWNrcyIsIm1hcmtlck5hbWUiLCJsb2dUb3BMZXZlbFJlbmRlcnMiLCJuYW1lZENvbXBvbmVudCIsIl9jdXJyZW50RWxlbWVudCIsImlzUmVhY3RUb3BMZXZlbFdyYXBwZXIiLCJwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkiLCJ0aW1lRW5kIiwiaiIsImVucXVldWUiLCJnZXRQdWJsaWNJbnN0YW5jZSIsImVucXVldWVVcGRhdGUiLCJpc0JhdGNoaW5nVXBkYXRlcyIsIl91cGRhdGVCYXRjaE51bWJlciIsImFzYXAiLCJSZWFjdFVwZGF0ZXNJbmplY3Rpb24iLCJSZWNvbmNpbGVUcmFuc2FjdGlvbiIsIl9iYXRjaGluZ1N0cmF0ZWd5IiwiX2NsYXNzQ2FsbENoZWNrIiwiX2NhbGxiYWNrcyIsIl9jb250ZXh0cyIsIl9hcmciLCJjb250ZXh0cyIsImNoZWNrcG9pbnQiLCJyb2xsYmFjayIsIlJlYWN0UmVmIiwiYXR0YWNoUmVmcyIsIm1vdW50Q29tcG9uZW50IiwiaW50ZXJuYWxJbnN0YW5jZSIsImhvc3RQYXJlbnQiLCJob3N0Q29udGFpbmVySW5mbyIsInBhcmVudERlYnVnSUQiLCJtYXJrdXAiLCJnZXRSZWFjdE1vdW50UmVhZHkiLCJnZXRIb3N0Tm9kZSIsInVubW91bnRDb21wb25lbnQiLCJzYWZlbHkiLCJvbkJlZm9yZVVubW91bnRDb21wb25lbnQiLCJkZXRhY2hSZWZzIiwicmVjZWl2ZUNvbXBvbmVudCIsIm5leHRFbGVtZW50IiwicHJldkVsZW1lbnQiLCJfY29udGV4dCIsInJlZnNDaGFuZ2VkIiwic2hvdWxkVXBkYXRlUmVmcyIsIlJlYWN0T3duZXIiLCJhdHRhY2hSZWYiLCJhZGRDb21wb25lbnRBc1JlZlRvIiwiZGV0YWNoUmVmIiwicmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tIiwicHJldlJlZiIsInByZXZPd25lciIsIm5leHRSZWYiLCJuZXh0T3duZXIiLCJpc1ZhbGlkT3duZXIiLCJvd25lclB1YmxpY0luc3RhbmNlIiwiUmVhY3REZWJ1Z1Rvb2wiLCJSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rIiwiUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2siLCJwZXJmb3JtYW5jZU5vdyIsImhvb2tzIiwiZGlkSG9va1Rocm93Rm9yRXZlbnQiLCJjYWxsSG9vayIsImFyZzEiLCJhcmcyIiwiYXJnMyIsImFyZzQiLCJhcmc1IiwiZW1pdEV2ZW50IiwiaG9vayIsImlzUHJvZmlsaW5nIiwiZmx1c2hIaXN0b3J5IiwibGlmZUN5Y2xlVGltZXJTdGFjayIsImN1cnJlbnRGbHVzaE5lc3RpbmciLCJjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMiLCJjdXJyZW50Rmx1c2hTdGFydFRpbWUiLCJjdXJyZW50VGltZXJEZWJ1Z0lEIiwiY3VycmVudFRpbWVyU3RhcnRUaW1lIiwiY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiIsImN1cnJlbnRUaW1lclR5cGUiLCJsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCIsImNsZWFySGlzdG9yeSIsImdldFRyZWVTbmFwc2hvdCIsInJlZ2lzdGVyZWRJRHMiLCJyZWR1Y2UiLCJ0cmVlIiwicmVzZXRNZWFzdXJlbWVudHMiLCJwcmV2aW91c1N0YXJ0VGltZSIsInByZXZpb3VzTWVhc3VyZW1lbnRzIiwicHJldmlvdXNPcGVyYXRpb25zIiwiZ2V0SGlzdG9yeSIsImR1cmF0aW9uIiwibWVhc3VyZW1lbnRzIiwib3BlcmF0aW9ucyIsInRyZWVTbmFwc2hvdCIsImNoZWNrRGVidWdJRCIsImFsbG93Um9vdCIsImJlZ2luTGlmZUN5Y2xlVGltZXIiLCJ0aW1lclR5cGUiLCJlbmRMaWZlQ3ljbGVUaW1lciIsImluc3RhbmNlSUQiLCJwYXVzZUN1cnJlbnRMaWZlQ3ljbGVUaW1lciIsImN1cnJlbnRUaW1lciIsInN0YXJ0VGltZSIsIm5lc3RlZEZsdXNoU3RhcnRUaW1lIiwicmVzdW1lQ3VycmVudExpZmVDeWNsZVRpbWVyIiwiX2xpZmVDeWNsZVRpbWVyU3RhY2skIiwibmVzdGVkRmx1c2hEdXJhdGlvbiIsImxhc3RNYXJrVGltZVN0YW1wIiwiY2FuVXNlUGVyZm9ybWFuY2VNZWFzdXJlIiwicGVyZm9ybWFuY2UiLCJjbGVhck1hcmtzIiwibWVhc3VyZSIsImNsZWFyTWVhc3VyZXMiLCJzaG91bGRNYXJrIiwiaXNIb3N0RWxlbWVudCIsIm1hcmtCZWdpbiIsIm1hcmtUeXBlIiwibWFya05hbWUiLCJtYXJrRW5kIiwibWVhc3VyZW1lbnROYW1lIiwicmVtb3ZlSG9vayIsImJlZ2luUHJvZmlsaW5nIiwiZW5kUHJvZmlsaW5nIiwiZ2V0Rmx1c2hIaXN0b3J5Iiwib25CZWdpbkZsdXNoIiwib25FbmRGbHVzaCIsIm9uQmVnaW5MaWZlQ3ljbGVUaW1lciIsIm9uRW5kTGlmZUN5Y2xlVGltZXIiLCJvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCIsIm9uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCIsIm9uSG9zdE9wZXJhdGlvbiIsIm9wZXJhdGlvbiIsIm9uU2V0U3RhdGUiLCJjaGlsZERlYnVnSURzIiwib25UZXN0RXZlbnQiLCJhZGREZXZ0b29sIiwicmVtb3ZlRGV2dG9vbCIsInVybCIsImhyZWYiLCJwcm9jZXNzaW5nQ2hpbGRDb250ZXh0Iiwid2FybkludmFsaWRTZXRTdGF0ZSIsImhpc3RvcnkiLCJfcHJldmVudENsZWFyaW5nIiwibXNQZXJmb3JtYW5jZSIsIndlYmtpdFBlcmZvcm1hbmNlIiwiT0JTRVJWRURfRVJST1IiLCJUcmFuc2FjdGlvbkltcGwiLCJ0cmFuc2FjdGlvbldyYXBwZXJzIiwid3JhcHBlckluaXREYXRhIiwiX2lzSW5UcmFuc2FjdGlvbiIsImlzSW5UcmFuc2FjdGlvbiIsImVycm9yVGhyb3duIiwiaW5pdGlhbGl6ZUFsbCIsImNsb3NlQWxsIiwic3RhcnRJbmRleCIsIndyYXBwZXIiLCJpbml0RGF0YSIsImNvcnJlc3BvbmRpbmdVc2VFbGVtZW50IiwidXNlSGFzRmVhdHVyZSIsImltcGxlbWVudGF0aW9uIiwiaGFzRmVhdHVyZSIsImV2ZW50TmFtZVN1ZmZpeCIsImNhcHR1cmUiLCJpc1N1cHBvcnRlZCIsInNldEF0dHJpYnV0ZSIsInN1cHBvcnRlZElucHV0VHlwZXMiLCJTeW50aGV0aWNNb3VzZUV2ZW50IiwibW91c2VFbnRlciIsIm1vdXNlTGVhdmUiLCJyZWxhdGVkVGFyZ2V0IiwiZnJvbUVsZW1lbnQiLCJ3aW4iLCJkb2MiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJwYXJlbnRXaW5kb3ciLCJyZWxhdGVkIiwidG9FbGVtZW50IiwiZnJvbU5vZGUiLCJ0b05vZGUiLCJTeW50aGV0aWNVSUV2ZW50IiwiVmlld3BvcnRNZXRyaWNzIiwiZ2V0RXZlbnRNb2RpZmllclN0YXRlIiwiTW91c2VFdmVudEludGVyZmFjZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2xpZW50WCIsImNsaWVudFkiLCJzaGlmdEtleSIsImdldE1vZGlmaWVyU3RhdGUiLCJidXR0b25zIiwicGFnZVgiLCJjdXJyZW50U2Nyb2xsTGVmdCIsInBhZ2VZIiwiY3VycmVudFNjcm9sbFRvcCIsIlVJRXZlbnRJbnRlcmZhY2UiLCJ2aWV3IiwicmVmcmVzaFNjcm9sbFZhbHVlcyIsInNjcm9sbFBvc2l0aW9uIiwibW9kaWZpZXJLZXlUb1Byb3AiLCJtb2RpZmllclN0YXRlR2V0dGVyIiwia2V5QXJnIiwic3ludGhldGljRXZlbnQiLCJrZXlQcm9wIiwiYWNjZXB0IiwiYWNjZXB0Q2hhcnNldCIsImFjY2Vzc0tleSIsImFsbG93RnVsbFNjcmVlbiIsImFsbG93VHJhbnNwYXJlbmN5IiwiYWx0IiwiYXMiLCJhc3luYyIsImF1dG9Db21wbGV0ZSIsImF1dG9QbGF5IiwiY2VsbFBhZGRpbmciLCJjZWxsU3BhY2luZyIsImNoYXJTZXQiLCJjaGFsbGVuZ2UiLCJjaGVja2VkIiwiY2xhc3NJRCIsImNsYXNzTmFtZSIsImNvbHMiLCJjb2xTcGFuIiwiY29udGVudCIsImNvbnRlbnRFZGl0YWJsZSIsImNvbnRleHRNZW51IiwiY29udHJvbHMiLCJjb29yZHMiLCJjcm9zc09yaWdpbiIsImRhdGVUaW1lIiwiZGVmZXIiLCJkaXNhYmxlZCIsImRvd25sb2FkIiwiZHJhZ2dhYmxlIiwiZW5jVHlwZSIsImZvcm1BY3Rpb24iLCJmb3JtRW5jVHlwZSIsImZvcm1NZXRob2QiLCJmb3JtTm9WYWxpZGF0ZSIsImZvcm1UYXJnZXQiLCJmcmFtZUJvcmRlciIsImhlYWRlcnMiLCJoZWlnaHQiLCJoaWRkZW4iLCJoaWdoIiwiaHJlZkxhbmciLCJodG1sRm9yIiwiaHR0cEVxdWl2IiwiaWNvbiIsImlucHV0TW9kZSIsImludGVncml0eSIsImtleVBhcmFtcyIsImtleVR5cGUiLCJraW5kIiwibGFuZyIsImxpc3QiLCJsb29wIiwibG93IiwibWFuaWZlc3QiLCJtYXJnaW5IZWlnaHQiLCJtYXJnaW5XaWR0aCIsIm1heCIsIm1heExlbmd0aCIsIm1lZGlhIiwibWVkaWFHcm91cCIsIm1pbiIsIm1pbkxlbmd0aCIsIm11bHRpcGxlIiwibXV0ZWQiLCJub25jZSIsIm5vVmFsaWRhdGUiLCJvcGVuIiwib3B0aW11bSIsInBsYWNlaG9sZGVyIiwicGxheXNJbmxpbmUiLCJwb3N0ZXIiLCJwcmVsb2FkIiwicHJvZmlsZSIsInJhZGlvR3JvdXAiLCJyZWFkT25seSIsInJlZmVycmVyUG9saWN5IiwicmVsIiwicmVxdWlyZWQiLCJyZXZlcnNlZCIsInJvbGUiLCJyb3dzIiwicm93U3BhbiIsInNhbmRib3giLCJzY29wZWQiLCJzY3JvbGxpbmciLCJzZWFtbGVzcyIsInNlbGVjdGVkIiwic2l6ZSIsInNpemVzIiwic3BlbGxDaGVjayIsInNyYyIsInNyY0RvYyIsInNyY0xhbmciLCJzcmNTZXQiLCJ0YWJJbmRleCIsInVzZU1hcCIsIndpZHRoIiwid21vZGUiLCJ3cmFwIiwiYWJvdXQiLCJkYXRhdHlwZSIsImlubGlzdCIsInJlc291cmNlIiwidm9jYWIiLCJhdXRvQ2FwaXRhbGl6ZSIsImF1dG9Db3JyZWN0IiwiYXV0b1NhdmUiLCJjb2xvciIsIml0ZW1Qcm9wIiwiaXRlbVNjb3BlIiwiaXRlbVR5cGUiLCJpdGVtSUQiLCJpdGVtUmVmIiwicmVzdWx0cyIsInNlY3VyaXR5IiwidW5zZWxlY3RhYmxlIiwiRE9NQ2hpbGRyZW5PcGVyYXRpb25zIiwiUmVhY3RET01JRE9wZXJhdGlvbnMiLCJwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzIiwiZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzIiwicmVwbGFjZU5vZGVXaXRoTWFya3VwIiwiZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAiLCJET01MYXp5VHJlZSIsIkRhbmdlciIsImNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24iLCJzZXRJbm5lckhUTUwiLCJzZXRUZXh0Q29udGVudCIsImdldE5vZGVBZnRlciIsImluc2VydENoaWxkQXQiLCJyZWZlcmVuY2VOb2RlIiwiaW5zZXJ0QmVmb3JlIiwiaW5zZXJ0TGF6eVRyZWVDaGlsZEF0IiwiY2hpbGRUcmVlIiwiaW5zZXJ0VHJlZUJlZm9yZSIsIm1vdmVDaGlsZCIsIm1vdmVEZWxpbWl0ZWRUZXh0IiwicmVtb3ZlQ2hpbGQiLCJjbG9zaW5nQ29tbWVudCIsInJlbW92ZURlbGltaXRlZFRleHQiLCJvcGVuaW5nQ29tbWVudCIsIm5leHROb2RlIiwic3RhcnROb2RlIiwicmVwbGFjZURlbGltaXRlZFRleHQiLCJzdHJpbmdUZXh0Iiwibm9kZUFmdGVyQ29tbWVudCIsImNyZWF0ZVRleHROb2RlIiwicGF5bG9hZCIsIm9sZENoaWxkIiwicHJldkluc3RhbmNlIiwibmV4dEluc3RhbmNlIiwicHJvY2Vzc1VwZGF0ZXMiLCJ1cGRhdGVzIiwicGFyZW50Tm9kZURlYnVnSUQiLCJrIiwidXBkYXRlIiwiYWZ0ZXJOb2RlIiwidG9JbmRleCIsImZyb21JbmRleCIsIkRPTU5hbWVzcGFjZXMiLCJFTEVNRU5UX05PREVfVFlQRSIsIkRPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSIsImVuYWJsZUxhenkiLCJpbnNlcnRUcmVlQ2hpbGRyZW4iLCJuYW1lc3BhY2VVUkkiLCJyZXBsYWNlQ2hpbGRXaXRoVHJlZSIsIm9sZE5vZGUiLCJuZXdUcmVlIiwicmVwbGFjZUNoaWxkIiwicXVldWVDaGlsZCIsInBhcmVudFRyZWUiLCJhcHBlbmRDaGlsZCIsInF1ZXVlSFRNTCIsInF1ZXVlVGV4dCIsIm1hdGhtbCIsIldISVRFU1BBQ0VfVEVTVCIsIk5PTlZJU0lCTEVfVEVTVCIsInJldXNhYmxlU1ZHQ29udGFpbmVyIiwiaW5uZXJIVE1MIiwic3ZnTm9kZSIsInRlc3RFbGVtZW50IiwidGV4dE5vZGUiLCJkZWxldGVEYXRhIiwiTVNBcHAiLCJleGVjVW5zYWZlTG9jYWxGdW5jdGlvbiIsImFyZzAiLCJlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIiLCJsYXN0Q2hpbGQiLCJ0ZXh0Q29udGVudCIsIm1hdGNoSHRtbFJlZ0V4cCIsImVzY2FwZUh0bWwiLCJzdHIiLCJleGVjIiwibGFzdEluZGV4IiwiY2hhckNvZGVBdCIsImNyZWF0ZU5vZGVzRnJvbU1hcmt1cCIsIm5ld0NoaWxkIiwiY3JlYXRlQXJyYXlGcm9tTWl4ZWQiLCJnZXRNYXJrdXBXcmFwIiwiZHVtbXlOb2RlIiwibm9kZU5hbWVQYXR0ZXJuIiwiZ2V0Tm9kZU5hbWUiLCJub2RlTmFtZU1hdGNoIiwiaGFuZGxlU2NyaXB0Iiwid3JhcERlcHRoIiwic2NyaXB0cyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwibm9kZXMiLCJjaGlsZE5vZGVzIiwib2JqIiwiY2FsbGVlIiwiaGFzQXJyYXlOYXR1cmUiLCJzaG91bGRXcmFwIiwic2VsZWN0V3JhcCIsInRhYmxlV3JhcCIsInRyV3JhcCIsInN2Z1dyYXAiLCJtYXJrdXBXcmFwIiwic3ZnRWxlbWVudHMiLCJBdXRvRm9jdXNVdGlscyIsIkNTU1Byb3BlcnR5T3BlcmF0aW9ucyIsIkRPTVByb3BlcnR5T3BlcmF0aW9ucyIsIlJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciIsIlJlYWN0RE9NSW5wdXQiLCJSZWFjdERPTU9wdGlvbiIsIlJlYWN0RE9NU2VsZWN0IiwiUmVhY3RET01UZXh0YXJlYSIsIlJlYWN0TXVsdGlDaGlsZCIsIlJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24iLCJzaGFsbG93RXF1YWwiLCJ2YWxpZGF0ZURPTU5lc3RpbmciLCJnZXROb2RlIiwibGlzdGVuVG8iLCJDT05URU5UX1RZUEVTIiwiU1RZTEUiLCJIVE1MIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmciLCJET0NfRlJBR01FTlRfVFlQRSIsImZyaWVuZGx5U3RyaW5naWZ5Iiwia2V5RXNjYXBlZCIsInN0eWxlTXV0YXRpb25XYXJuaW5nIiwiY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlIiwic3R5bGUxIiwic3R5bGUyIiwiX3RhZyIsImhhc2giLCJhc3NlcnRWYWxpZFByb3BzIiwidm9pZEVsZW1lbnRUYWdzIiwib25Gb2N1c0luIiwib25Gb2N1c091dCIsImVucXVldWVQdXRMaXN0ZW5lciIsImNvbnRhaW5lckluZm8iLCJfaG9zdENvbnRhaW5lckluZm8iLCJpc0RvY3VtZW50RnJhZ21lbnQiLCJfbm9kZSIsIl9vd25lckRvY3VtZW50IiwibGlzdGVuZXJUb1B1dCIsImlucHV0UG9zdE1vdW50IiwicG9zdE1vdW50V3JhcHBlciIsInRleHRhcmVhUG9zdE1vdW50Iiwib3B0aW9uUG9zdE1vdW50Iiwic2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYiLCJoYXNFeGlzdGluZ0NvbnRlbnQiLCJfY29udGVudERlYnVnSUQiLCJjb250ZW50RGVidWdJRCIsIl9hbmNlc3RvckluZm8iLCJtZWRpYUV2ZW50cyIsInRvcEFib3J0IiwidG9wQ2FuUGxheSIsInRvcENhblBsYXlUaHJvdWdoIiwidG9wRHVyYXRpb25DaGFuZ2UiLCJ0b3BFbXB0aWVkIiwidG9wRW5jcnlwdGVkIiwidG9wRW5kZWQiLCJ0b3BFcnJvciIsInRvcExvYWRlZERhdGEiLCJ0b3BMb2FkZWRNZXRhZGF0YSIsInRvcExvYWRTdGFydCIsInRvcFBhdXNlIiwidG9wUGxheSIsInRvcFBsYXlpbmciLCJ0b3BQcm9ncmVzcyIsInRvcFJhdGVDaGFuZ2UiLCJ0b3BTZWVrZWQiLCJ0b3BTZWVraW5nIiwidG9wU3RhbGxlZCIsInRvcFN1c3BlbmQiLCJ0b3BUaW1lVXBkYXRlIiwidG9wVm9sdW1lQ2hhbmdlIiwidG9wV2FpdGluZyIsInRyYXBCdWJibGVkRXZlbnRzTG9jYWwiLCJfd3JhcHBlclN0YXRlIiwibGlzdGVuZXJzIiwidHJhcEJ1YmJsZWRFdmVudCIsInBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyIiwicG9zdFVwZGF0ZVdyYXBwZXIiLCJvbWl0dGVkQ2xvc2VUYWdzIiwibmV3bGluZUVhdGluZ1RhZ3MiLCJWQUxJRF9UQUdfUkVHRVgiLCJ2YWxpZGF0ZWRUYWdDYWNoZSIsInZhbGlkYXRlRGFuZ2Vyb3VzVGFnIiwidGFnIiwiaXNDdXN0b21Db21wb25lbnQiLCJ0YWdOYW1lIiwiZ2xvYmFsSWRDb3VudGVyIiwiX25hbWVzcGFjZVVSSSIsIl9wcmV2aW91c1N0eWxlIiwiX3ByZXZpb3VzU3R5bGVDb3B5IiwiX3RvcExldmVsV3JhcHBlciIsIk1peGluIiwiX2lkQ291bnRlciIsIm1vdW50V3JhcHBlciIsImdldEhvc3RQcm9wcyIsInBhcmVudFRhZyIsInBhcmVudEluZm8iLCJ1cGRhdGVkQW5jZXN0b3JJbmZvIiwibW91bnRJbWFnZSIsInVzZUNyZWF0ZUVsZW1lbnQiLCJlbCIsImNyZWF0ZUVsZW1lbnROUyIsInNldEF0dHJpYnV0ZUZvclJvb3QiLCJfdXBkYXRlRE9NUHJvcGVydGllcyIsImxhenlUcmVlIiwiX2NyZWF0ZUluaXRpYWxDaGlsZHJlbiIsInRhZ09wZW4iLCJfY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVycyIsInRhZ0NvbnRlbnQiLCJfY3JlYXRlQ29udGVudE1hcmt1cCIsImF1dG9Gb2N1cyIsImZvY3VzRE9NQ29tcG9uZW50IiwicHJvcEtleSIsImNyZWF0ZU1hcmt1cEZvclN0eWxlcyIsImNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZSIsImNyZWF0ZU1hcmt1cEZvclByb3BlcnR5IiwicmVuZGVyVG9TdGF0aWNNYXJrdXAiLCJjcmVhdGVNYXJrdXBGb3JSb290IiwiY3JlYXRlTWFya3VwRm9ySUQiLCJfX2h0bWwiLCJjb250ZW50VG9Vc2UiLCJjaGlsZHJlblRvVXNlIiwibW91bnRJbWFnZXMiLCJtb3VudENoaWxkcmVuIiwiY2hhckF0IiwibGFzdFByb3BzIiwibmV4dFByb3BzIiwiX3VwZGF0ZURPTUNoaWxkcmVuIiwidXBkYXRlV3JhcHBlciIsInN0eWxlTmFtZSIsInN0eWxlVXBkYXRlcyIsImxhc3RTdHlsZSIsImRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlIiwiZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSIsIm5leHRQcm9wIiwibGFzdFByb3AiLCJzZXRWYWx1ZUZvckF0dHJpYnV0ZSIsInNldFZhbHVlRm9yUHJvcGVydHkiLCJzZXRWYWx1ZUZvclN0eWxlcyIsImxhc3RDb250ZW50IiwibmV4dENvbnRlbnQiLCJsYXN0SHRtbCIsIm5leHRIdG1sIiwibGFzdENoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwibGFzdEhhc0NvbnRlbnRPckh0bWwiLCJuZXh0SGFzQ29udGVudE9ySHRtbCIsInVwZGF0ZUNoaWxkcmVuIiwidXBkYXRlVGV4dENvbnRlbnQiLCJ1cGRhdGVNYXJrdXAiLCJyZW1vdmUiLCJ1bm1vdW50Q2hpbGRyZW4iLCJmb2N1c05vZGUiLCJmb2N1cyIsIkNTU1Byb3BlcnR5IiwiY2FtZWxpemVTdHlsZU5hbWUiLCJkYW5nZXJvdXNTdHlsZVZhbHVlIiwiaHlwaGVuYXRlU3R5bGVOYW1lIiwibWVtb2l6ZVN0cmluZ09ubHkiLCJwcm9jZXNzU3R5bGVOYW1lIiwiaGFzU2hvcnRoYW5kUHJvcGVydHlCdWciLCJzdHlsZUZsb2F0QWNjZXNzb3IiLCJ0ZW1wU3R5bGUiLCJmb250IiwiY3NzRmxvYXQiLCJiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4iLCJiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4iLCJ3YXJuZWRTdHlsZU5hbWVzIiwid2FybmVkU3R5bGVWYWx1ZXMiLCJ3YXJuZWRGb3JOYU5WYWx1ZSIsIndhcm5IeXBoZW5hdGVkU3R5bGVOYW1lIiwiY2hlY2tSZW5kZXJNZXNzYWdlIiwid2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lIiwidG9VcHBlckNhc2UiLCJ3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24iLCJ3YXJuU3R5bGVWYWx1ZUlzTmFOIiwid2FyblZhbGlkU3R5bGUiLCJpc05hTiIsInN0eWxlcyIsInNlcmlhbGl6ZWQiLCJzdHlsZVZhbHVlIiwiZXhwYW5zaW9uIiwic2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zIiwiaW5kaXZpZHVhbFN0eWxlTmFtZSIsImlzVW5pdGxlc3NOdW1iZXIiLCJhbmltYXRpb25JdGVyYXRpb25Db3VudCIsImJvcmRlckltYWdlT3V0c2V0IiwiYm9yZGVySW1hZ2VTbGljZSIsImJvcmRlckltYWdlV2lkdGgiLCJib3hGbGV4IiwiYm94RmxleEdyb3VwIiwiYm94T3JkaW5hbEdyb3VwIiwiY29sdW1uQ291bnQiLCJmbGV4IiwiZmxleEdyb3ciLCJmbGV4UG9zaXRpdmUiLCJmbGV4U2hyaW5rIiwiZmxleE5lZ2F0aXZlIiwiZmxleE9yZGVyIiwiZ3JpZFJvdyIsImdyaWRDb2x1bW4iLCJmb250V2VpZ2h0IiwibGluZUNsYW1wIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsImZpbGxPcGFjaXR5IiwiZmxvb2RPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlTWl0ZXJsaW1pdCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsInByZWZpeEtleSIsInByZWZpeGVzIiwiYmFja2dyb3VuZCIsImJhY2tncm91bmRBdHRhY2htZW50IiwiYmFja2dyb3VuZENvbG9yIiwiYmFja2dyb3VuZEltYWdlIiwiYmFja2dyb3VuZFBvc2l0aW9uWCIsImJhY2tncm91bmRQb3NpdGlvblkiLCJiYWNrZ3JvdW5kUmVwZWF0IiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYm9yZGVyIiwiYm9yZGVyV2lkdGgiLCJib3JkZXJTdHlsZSIsImJvcmRlckNvbG9yIiwiYm9yZGVyQm90dG9tIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJib3JkZXJCb3R0b21TdHlsZSIsImJvcmRlckJvdHRvbUNvbG9yIiwiYm9yZGVyTGVmdCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlckxlZnRTdHlsZSIsImJvcmRlckxlZnRDb2xvciIsImJvcmRlclJpZ2h0IiwiYm9yZGVyUmlnaHRXaWR0aCIsImJvcmRlclJpZ2h0U3R5bGUiLCJib3JkZXJSaWdodENvbG9yIiwiYm9yZGVyVG9wIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJUb3BTdHlsZSIsImJvcmRlclRvcENvbG9yIiwiZm9udFN0eWxlIiwiZm9udFZhcmlhbnQiLCJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJvdXRsaW5lIiwib3V0bGluZVdpZHRoIiwib3V0bGluZVN0eWxlIiwib3V0bGluZUNvbG9yIiwiY2FtZWxpemUiLCJtc1BhdHRlcm4iLCJfaHlwaGVuUGF0dGVybiIsIl8iLCJjaGFyYWN0ZXIiLCJzdHlsZVdhcm5pbmdzIiwiaXNFbXB0eSIsImlzTm9uTnVtZXJpYyIsIndhcm5pbmdzIiwiaHlwaGVuYXRlIiwiX3VwcGVyY2FzZVBhdHRlcm4iLCJjYWNoZSIsInF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyIiwiVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgiLCJpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlIiwidmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlIiwiaXNBdHRyaWJ1dGVOYW1lU2FmZSIsInNob3VsZElnbm9yZVZhbHVlIiwic2V0QXR0cmlidXRlRm9ySUQiLCJuYW1lc3BhY2UiLCJzZXRBdHRyaWJ1dGVOUyIsInJlbW92ZUF0dHJpYnV0ZSIsIlJlYWN0RXZlbnRFbWl0dGVyTWl4aW4iLCJnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSIsImhhc0V2ZW50UGFnZVhZIiwiYWxyZWFkeUxpc3RlbmluZ1RvIiwiaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUiLCJyZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIiLCJ0b3BFdmVudE1hcHBpbmciLCJ0b3BBbmltYXRpb25FbmQiLCJ0b3BBbmltYXRpb25JdGVyYXRpb24iLCJ0b3BBbmltYXRpb25TdGFydCIsInRvcEJsdXIiLCJ0b3BDaGFuZ2UiLCJ0b3BDbGljayIsInRvcENvbXBvc2l0aW9uRW5kIiwidG9wQ29tcG9zaXRpb25TdGFydCIsInRvcENvbXBvc2l0aW9uVXBkYXRlIiwidG9wQ29udGV4dE1lbnUiLCJ0b3BDb3B5IiwidG9wQ3V0IiwidG9wRG91YmxlQ2xpY2siLCJ0b3BEcmFnIiwidG9wRHJhZ0VuZCIsInRvcERyYWdFbnRlciIsInRvcERyYWdFeGl0IiwidG9wRHJhZ0xlYXZlIiwidG9wRHJhZ092ZXIiLCJ0b3BEcmFnU3RhcnQiLCJ0b3BEcm9wIiwidG9wRm9jdXMiLCJ0b3BJbnB1dCIsInRvcEtleURvd24iLCJ0b3BLZXlQcmVzcyIsInRvcEtleVVwIiwidG9wTW91c2VEb3duIiwidG9wTW91c2VNb3ZlIiwidG9wTW91c2VPdXQiLCJ0b3BNb3VzZU92ZXIiLCJ0b3BNb3VzZVVwIiwidG9wUGFzdGUiLCJ0b3BTY3JvbGwiLCJ0b3BTZWxlY3Rpb25DaGFuZ2UiLCJ0b3BUZXh0SW5wdXQiLCJ0b3BUb3VjaENhbmNlbCIsInRvcFRvdWNoRW5kIiwidG9wVG91Y2hNb3ZlIiwidG9wVG91Y2hTdGFydCIsInRvcFRyYW5zaXRpb25FbmQiLCJ0b3BXaGVlbCIsInRvcExpc3RlbmVyc0lES2V5IiwiZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQiLCJtb3VudEF0Iiwic2V0SGFuZGxlVG9wTGV2ZWwiLCJoYW5kbGVUb3BMZXZlbCIsInNldEVuYWJsZWQiLCJlbmFibGVkIiwiaXNFbmFibGVkIiwiY29udGVudERvY3VtZW50SGFuZGxlIiwiaXNMaXN0ZW5pbmciLCJkZXBlbmRlbmN5IiwidHJhcENhcHR1cmVkRXZlbnQiLCJXSU5ET1dfSEFORExFIiwiaGFuZGxlckJhc2VOYW1lIiwiaGFuZGxlIiwic3VwcG9ydHNFdmVudFBhZ2VYWSIsImV2IiwiZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nIiwicmVmcmVzaCIsIm1vbml0b3JTY3JvbGxWYWx1ZSIsInJ1bkV2ZW50UXVldWVJbkJhdGNoIiwibWFrZVByZWZpeE1hcCIsInN0eWxlUHJvcCIsInZlbmRvclByZWZpeGVzIiwiYW5pbWF0aW9uZW5kIiwiYW5pbWF0aW9uaXRlcmF0aW9uIiwiYW5pbWF0aW9uc3RhcnQiLCJ0cmFuc2l0aW9uZW5kIiwicHJlZml4ZWRFdmVudE5hbWVzIiwiYW5pbWF0aW9uIiwidHJhbnNpdGlvbiIsInByZWZpeE1hcCIsIkxpbmtlZFZhbHVlVXRpbHMiLCJkaWRXYXJuVmFsdWVMaW5rIiwiZGlkV2FybkNoZWNrZWRMaW5rIiwiZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlIiwiZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCIsImRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQiLCJkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkIiwiZm9yY2VVcGRhdGVJZk1vdW50ZWQiLCJpc0NvbnRyb2xsZWQiLCJ1c2VzQ2hlY2tlZCIsImdldFZhbHVlIiwiZ2V0Q2hlY2tlZCIsImhvc3RQcm9wcyIsImRlZmF1bHRDaGVja2VkIiwiZGVmYXVsdFZhbHVlIiwiaW5pdGlhbFZhbHVlIiwiaW5pdGlhbENoZWNrZWQiLCJvbkNoYW5nZSIsImNoZWNrUHJvcFR5cGVzIiwidmFsdWVMaW5rIiwiY2hlY2tlZExpbmsiLCJfaGFuZGxlQ2hhbmdlIiwiY29udHJvbGxlZCIsIm5ld1ZhbHVlIiwiZXhlY3V0ZU9uQ2hhbmdlIiwicm9vdE5vZGUiLCJxdWVyeVJvb3QiLCJncm91cCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJvdGhlck5vZGUiLCJvdGhlckluc3RhbmNlIiwiaGFzUmVhZE9ubHlWYWx1ZSIsIl9hc3NlcnRTaW5nbGVMaW5rIiwiaW5wdXRQcm9wcyIsIl9hc3NlcnRWYWx1ZUxpbmsiLCJfYXNzZXJ0Q2hlY2tlZExpbmsiLCJyZXF1ZXN0Q2hhbmdlIiwiZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiIsImZsYXR0ZW5DaGlsZHJlbiIsInNlbGVjdFZhbHVlIiwic2VsZWN0UGFyZW50IiwiZ2V0U2VsZWN0VmFsdWVDb250ZXh0IiwidXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQiLCJwZW5kaW5nVXBkYXRlIiwidXBkYXRlT3B0aW9ucyIsIkJvb2xlYW4iLCJ2YWx1ZVByb3BOYW1lcyIsImNoZWNrU2VsZWN0UHJvcFR5cGVzIiwic2VsZWN0ZWRWYWx1ZSIsIm9wdGlvbnMiLCJ3YXNNdWx0aXBsZSIsImRpZFdhcm5WYWxEZWZhdWx0VmFsIiwiUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCIsIlJlYWN0SW5zdGFuY2VNYXAiLCJSZWFjdENoaWxkUmVjb25jaWxlciIsIm1ha2VJbnNlcnRNYXJrdXAiLCJtYWtlTW92ZSIsIl9tb3VudEluZGV4IiwibWFrZVJlbW92ZSIsIm1ha2VTZXRNYXJrdXAiLCJtYWtlVGV4dENvbnRlbnQiLCJwcm9jZXNzUXVldWUiLCJ1cGRhdGVRdWV1ZSIsInNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uIiwiZ2V0RGVidWdJRCIsImludGVybmFsIiwiX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuIiwibmVzdGVkQ2hpbGRyZW4iLCJzZWxmRGVidWdJRCIsImluc3RhbnRpYXRlQ2hpbGRyZW4iLCJfcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuIiwicHJldkNoaWxkcmVuIiwibmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMiLCJyZW1vdmVkTm9kZXMiLCJuZXh0TWFya3VwIiwiX3VwZGF0ZUNoaWxkcmVuIiwibmV4dEluZGV4IiwibmV4dE1vdW50SW5kZXgiLCJsYXN0UGxhY2VkTm9kZSIsInByZXZDaGlsZCIsIl9tb3VudENoaWxkQXRJbmRleCIsIl91bm1vdW50Q2hpbGQiLCJyZW5kZXJlZENoaWxkcmVuIiwiY3JlYXRlQ2hpbGQiLCJpbmplY3RlZCIsImVudmlyb25tZW50IiwiX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSIsImhhcyIsImluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQiLCJzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCIsImluc3RhbnRpYXRlQ2hpbGQiLCJjaGlsZEluc3RhbmNlcyIsImtleVVuaXF1ZSIsIm5lc3RlZENoaWxkTm9kZXMiLCJjaGlsZEluc3RzIiwibmV4dENoaWxkSW5zdGFuY2UiLCJuZXh0Q2hpbGRNb3VudEltYWdlIiwicmVuZGVyZWRDaGlsZCIsIlJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IiwiUmVhY3RFbXB0eUNvbXBvbmVudCIsIlJlYWN0SG9zdENvbXBvbmVudCIsImdldE5leHREZWJ1Z0lEIiwiUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyIiwiX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQiLCJpc0ludGVybmFsQ29tcG9uZW50VHlwZSIsInNob3VsZEhhdmVEZWJ1Z0lEIiwiY3JlYXRlSW50ZXJuYWxDb21wb25lbnQiLCJnZXROYXRpdmVOb2RlIiwiY3JlYXRlSW5zdGFuY2VGb3JUZXh0IiwiX21vdW50SW1hZ2UiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsIlJlYWN0Tm9kZVR5cGVzIiwiQ29tcG9zaXRlVHlwZXMiLCJJbXB1cmVDbGFzcyIsIlB1cmVDbGFzcyIsIlN0YXRlbGVzc0Z1bmN0aW9uYWwiLCJTdGF0ZWxlc3NDb21wb25lbnQiLCJ3YXJuSWZJbnZhbGlkRWxlbWVudCIsInNob3VsZENvbnN0cnVjdCIsImlzUHVyZUNvbXBvbmVudCIsIm1lYXN1cmVMaWZlQ3ljbGVQZXJmIiwibmV4dE1vdW50SUQiLCJfY29tcG9zaXRlVHlwZSIsIl9pbnN0YW5jZSIsIl9wZW5kaW5nRWxlbWVudCIsIl9wZW5kaW5nU3RhdGVRdWV1ZSIsIl9wZW5kaW5nUmVwbGFjZVN0YXRlIiwiX3BlbmRpbmdGb3JjZVVwZGF0ZSIsIl9yZW5kZXJlZE5vZGVUeXBlIiwiX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50IiwiX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyIiwiX3RoaXMiLCJwdWJsaWNQcm9wcyIsInB1YmxpY0NvbnRleHQiLCJfcHJvY2Vzc0NvbnRleHQiLCJnZXRVcGRhdGVRdWV1ZSIsImRvQ29uc3RydWN0IiwiX2NvbnN0cnVjdENvbXBvbmVudCIsInJlbmRlcmVkRWxlbWVudCIsInByb3BzTXV0YXRlZCIsImNvbXBvbmVudERpZFVubW91bnQiLCJ1bnN0YWJsZV9oYW5kbGVFcnJvciIsInBlcmZvcm1Jbml0aWFsTW91bnRXaXRoRXJyb3JIYW5kbGluZyIsInBlcmZvcm1Jbml0aWFsTW91bnQiLCJfY29uc3RydWN0Q29tcG9uZW50V2l0aG91dE93bmVyIiwiX3Byb2Nlc3NQZW5kaW5nU3RhdGUiLCJfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50IiwiZ2V0VHlwZSIsIkVNUFRZIiwiX3Byb2Nlc3NDaGlsZENvbnRleHQiLCJfbWFza0NvbnRleHQiLCJtYXNrZWRDb250ZXh0IiwiY29udGV4dE5hbWUiLCJfY2hlY2tDb250ZXh0VHlwZXMiLCJjdXJyZW50Q29udGV4dCIsIm5leHRDb250ZXh0IiwicHJldkNvbnRleHQiLCJwcmV2UGFyZW50RWxlbWVudCIsIm5leHRQYXJlbnRFbGVtZW50IiwicHJldlVubWFza2VkQ29udGV4dCIsIm5leHRVbm1hc2tlZENvbnRleHQiLCJ3aWxsUmVjZWl2ZSIsInByZXZQcm9wcyIsIm5leHRTdGF0ZSIsInNob3VsZFVwZGF0ZSIsIl9wZXJmb3JtQ29tcG9uZW50VXBkYXRlIiwicGFydGlhbCIsInVubWFza2VkQ29udGV4dCIsIl90aGlzMiIsImhhc0NvbXBvbmVudERpZFVwZGF0ZSIsInByZXZTdGF0ZSIsIl91cGRhdGVSZW5kZXJlZENvbXBvbmVudCIsInByZXZDb21wb25lbnRJbnN0YW5jZSIsInByZXZSZW5kZXJlZEVsZW1lbnQiLCJuZXh0UmVuZGVyZWRFbGVtZW50Iiwib2xkSG9zdE5vZGUiLCJfcmVwbGFjZU5vZGVXaXRoTWFya3VwIiwiX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCIsInB1YmxpY0NvbXBvbmVudEluc3RhbmNlIiwiSE9TVCIsIkNPTVBPU0lURSIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzQiIsInByZXZFbXB0eSIsIm5leHRFbXB0eSIsInByZXZUeXBlIiwibmV4dFR5cGUiLCJlbXB0eUNvbXBvbmVudEZhY3RvcnkiLCJSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uIiwiZ2VuZXJpY0NvbXBvbmVudENsYXNzIiwidGFnVG9Db21wb25lbnRDbGFzcyIsInRleHRDb21wb25lbnRDbGFzcyIsIlJlYWN0SG9zdENvbXBvbmVudEluamVjdGlvbiIsImluamVjdENvbXBvbmVudENsYXNzZXMiLCJjb21wb25lbnRDbGFzc2VzIiwiaXNUZXh0Q29tcG9uZW50IiwibmV4dERlYnVnSUQiLCJmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCIsIlJlYWN0U2VydmVyVXBkYXRlUXVldWUiLCJub29wQ2FsbGJhY2tRdWV1ZSIsIlJlYWN0VXBkYXRlUXVldWUiLCJmb3JtYXRVbmV4cGVjdGVkQXJndW1lbnQiLCJnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUiLCJjdG9yIiwidmFsaWRhdGVDYWxsYmFjayIsImVucXVldWVDYWxsYmFja0ludGVybmFsIiwiZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbCIsInNwZWNpYWxUYWdzIiwiaW5TY29wZVRhZ3MiLCJidXR0b25TY29wZVRhZ3MiLCJpbXBsaWVkRW5kVGFncyIsImVtcHR5QW5jZXN0b3JJbmZvIiwiZm9ybVRhZyIsImFUYWdJblNjb3BlIiwiYnV0dG9uVGFnSW5TY29wZSIsIm5vYnJUYWdJblNjb3BlIiwicFRhZ0luQnV0dG9uU2NvcGUiLCJsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nIiwiZGxJdGVtVGFnQXV0b2Nsb3NpbmciLCJvbGRJbmZvIiwiYW5jZXN0b3JJbmZvIiwiaXNUYWdWYWxpZFdpdGhQYXJlbnQiLCJmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnIiwiZmluZE93bmVyU3RhY2siLCJyZXZlcnNlIiwiZGlkV2FybiIsImNoaWxkVGFnIiwiY2hpbGRUZXh0IiwiY2hpbGRJbnN0YW5jZSIsImludmFsaWRQYXJlbnQiLCJpbnZhbGlkQW5jZXN0b3IiLCJwcm9ibGVtYXRpYyIsImFuY2VzdG9yVGFnIiwiYW5jZXN0b3JJbnN0YW5jZSIsImFuY2VzdG9yT3duZXIiLCJjaGlsZE93bmVycyIsImFuY2VzdG9yT3duZXJzIiwibWluU3RhY2tMZW4iLCJkZWVwZXN0Q29tbW9uIiwiVU5LTk9XTiIsImNoaWxkT3duZXJOYW1lcyIsImFuY2VzdG9yT3duZXJOYW1lcyIsIm93bmVySW5mbyIsIndhcm5LZXkiLCJ0YWdEaXNwbGF5TmFtZSIsIndoaXRlc3BhY2VJbmZvIiwiaXNUYWdWYWxpZEluQ29udGV4dCIsImRvbUlEIiwiY3JlYXRlQ29tbWVudCIsImluc3RBIiwiaW5zdEIiLCJkZXB0aEEiLCJ0ZW1wQSIsImRlcHRoQiIsInRlbXBCIiwiZGVwdGgiLCJjb21tb24iLCJwYXRoRnJvbSIsInBhdGhUbyIsIl9zdHJpbmdUZXh0IiwiX2Nsb3NpbmdDb21tZW50IiwiX2NvbW1lbnROb2RlcyIsIm9wZW5pbmdWYWx1ZSIsImNsb3NpbmdWYWx1ZSIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJlc2NhcGVkVGV4dCIsIm5leHRUZXh0IiwibmV4dFN0cmluZ1RleHQiLCJjb21tZW50Tm9kZXMiLCJob3N0Tm9kZSIsIlJFU0VUX0JBVENIRURfVVBEQVRFUyIsIkZMVVNIX0JBVENIRURfVVBEQVRFUyIsIlJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbiIsImFscmVhZHlCYXRjaGluZ1VwZGF0ZXMiLCJFdmVudExpc3RlbmVyIiwiZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24iLCJmaW5kUGFyZW50IiwiY29udGFpbmVyIiwiVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nIiwiYW5jZXN0b3JzIiwiaGFuZGxlVG9wTGV2ZWxJbXBsIiwiYW5jZXN0b3IiLCJfaGFuZGxlVG9wTGV2ZWwiLCJzY3JvbGxWYWx1ZU1vbml0b3IiLCJfZW5hYmxlZCIsImxpc3RlbiIsInJlZ2lzdGVyRGVmYXVsdCIsInNjcm9sbGFibGUiLCJwYWdlWE9mZnNldCIsInNjcm9sbExlZnQiLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsIlJlYWN0SW5wdXRTZWxlY3Rpb24iLCJTRUxFQ1RJT05fUkVTVE9SQVRJT04iLCJnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbiIsInJlc3RvcmVTZWxlY3Rpb24iLCJFVkVOVF9TVVBQUkVTU0lPTiIsImN1cnJlbnRseUVuYWJsZWQiLCJwcmV2aW91c2x5RW5hYmxlZCIsIk9OX0RPTV9SRUFEWV9RVUVVRUlORyIsInJlYWN0TW91bnRSZWFkeSIsIlJlYWN0RE9NU2VsZWN0aW9uIiwiY29udGFpbnNOb2RlIiwiZ2V0QWN0aXZlRWxlbWVudCIsImlzSW5Eb2N1bWVudCIsImhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyIsImZvY3VzZWRFbGVtIiwic2VsZWN0aW9uUmFuZ2UiLCJnZXRTZWxlY3Rpb24iLCJwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uIiwiY3VyRm9jdXNlZEVsZW0iLCJwcmlvckZvY3VzZWRFbGVtIiwicHJpb3JTZWxlY3Rpb25SYW5nZSIsInNldFNlbGVjdGlvbiIsInNlbGVjdGlvbiIsInNlbGVjdGlvblN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwicmFuZ2UiLCJjcmVhdGVSYW5nZSIsInBhcmVudEVsZW1lbnQiLCJtb3ZlU3RhcnQiLCJtb3ZlRW5kIiwiZ2V0T2Zmc2V0cyIsIm9mZnNldHMiLCJjcmVhdGVUZXh0UmFuZ2UiLCJjb2xsYXBzZSIsInNldE9mZnNldHMiLCJnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0IiwiaXNDb2xsYXBzZWQiLCJhbmNob3JOb2RlIiwiYW5jaG9yT2Zmc2V0IiwiZm9jdXNPZmZzZXQiLCJnZXRJRU9mZnNldHMiLCJzZWxlY3RlZFJhbmdlIiwic2VsZWN0ZWRMZW5ndGgiLCJmcm9tU3RhcnQiLCJkdXBsaWNhdGUiLCJtb3ZlVG9FbGVtZW50VGV4dCIsInNldEVuZFBvaW50Iiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJnZXRNb2Rlcm5PZmZzZXRzIiwicmFuZ2VDb3VudCIsImN1cnJlbnRSYW5nZSIsImdldFJhbmdlQXQiLCJzdGFydENvbnRhaW5lciIsImVuZENvbnRhaW5lciIsImlzU2VsZWN0aW9uQ29sbGFwc2VkIiwicmFuZ2VMZW5ndGgiLCJ0ZW1wUmFuZ2UiLCJjbG9uZVJhbmdlIiwic2VsZWN0Tm9kZUNvbnRlbnRzIiwic2V0RW5kIiwiaXNUZW1wUmFuZ2VDb2xsYXBzZWQiLCJkZXRlY3Rpb25SYW5nZSIsInNldFN0YXJ0IiwiaXNCYWNrd2FyZCIsImNvbGxhcHNlZCIsInNldElFT2Zmc2V0cyIsInNldE1vZGVybk9mZnNldHMiLCJleHRlbmQiLCJ0ZW1wIiwic3RhcnRNYXJrZXIiLCJlbmRNYXJrZXIiLCJvZmZzZXQiLCJyZW1vdmVBbGxSYW5nZXMiLCJhZGRSYW5nZSIsInVzZUlFT2Zmc2V0cyIsImdldExlYWZOb2RlIiwiZ2V0U2libGluZ05vZGUiLCJub2RlU3RhcnQiLCJub2RlRW5kIiwiaXNUZXh0Tm9kZSIsIm91dGVyTm9kZSIsImlubmVyTm9kZSIsImNvbnRhaW5zIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJOb2RlIiwiTlMiLCJ4bGluayIsInhtbCIsIkFUVFJTIiwiYWNjZW50SGVpZ2h0IiwiYWNjdW11bGF0ZSIsImFkZGl0aXZlIiwiYWxpZ25tZW50QmFzZWxpbmUiLCJhbGxvd1Jlb3JkZXIiLCJhbHBoYWJldGljIiwiYW1wbGl0dWRlIiwiYXJhYmljRm9ybSIsImFzY2VudCIsImF0dHJpYnV0ZVR5cGUiLCJhdXRvUmV2ZXJzZSIsImF6aW11dGgiLCJiYXNlRnJlcXVlbmN5IiwiYmFzZVByb2ZpbGUiLCJiYXNlbGluZVNoaWZ0IiwiYmJveCIsImJlZ2luIiwiYmlhcyIsImJ5IiwiY2FsY01vZGUiLCJjYXBIZWlnaHQiLCJjbGlwIiwiY2xpcFJ1bGUiLCJjbGlwUGF0aFVuaXRzIiwiY29sb3JJbnRlcnBvbGF0aW9uIiwiY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycyIsImNvbG9yUHJvZmlsZSIsImNvbG9yUmVuZGVyaW5nIiwiY29udGVudFNjcmlwdFR5cGUiLCJjb250ZW50U3R5bGVUeXBlIiwiY3Vyc29yIiwiY3giLCJjeSIsImRlY2VsZXJhdGUiLCJkZXNjZW50IiwiZGlmZnVzZUNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGlzcGxheSIsImRpdmlzb3IiLCJkb21pbmFudEJhc2VsaW5lIiwiZHVyIiwiZHgiLCJkeSIsImVkZ2VNb2RlIiwiZWxldmF0aW9uIiwiZW5hYmxlQmFja2dyb3VuZCIsImV4cG9uZW50IiwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCIsImZpbGwiLCJmaWxsUnVsZSIsImZpbHRlciIsImZpbHRlclJlcyIsImZpbHRlclVuaXRzIiwiZmxvb2RDb2xvciIsImZvY3VzYWJsZSIsImZvbnRTaXplQWRqdXN0IiwiZm9udFN0cmV0Y2giLCJmeCIsImZ5IiwiZzEiLCJnMiIsImdseXBoTmFtZSIsImdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsIiwiZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsIiwiZ2x5cGhSZWYiLCJncmFkaWVudFRyYW5zZm9ybSIsImdyYWRpZW50VW5pdHMiLCJoYW5naW5nIiwiaG9yaXpBZHZYIiwiaG9yaXpPcmlnaW5YIiwiaWRlb2dyYXBoaWMiLCJpbWFnZVJlbmRlcmluZyIsImluMiIsImludGVyY2VwdCIsImsxIiwiazIiLCJrMyIsIms0Iiwia2VybmVsTWF0cml4Iiwia2VybmVsVW5pdExlbmd0aCIsImtlcm5pbmciLCJrZXlQb2ludHMiLCJrZXlTcGxpbmVzIiwia2V5VGltZXMiLCJsZW5ndGhBZGp1c3QiLCJsZXR0ZXJTcGFjaW5nIiwibGlnaHRpbmdDb2xvciIsImxpbWl0aW5nQ29uZUFuZ2xlIiwibG9jYWwiLCJtYXJrZXJFbmQiLCJtYXJrZXJNaWQiLCJtYXJrZXJTdGFydCIsIm1hcmtlckhlaWdodCIsIm1hcmtlclVuaXRzIiwibWFya2VyV2lkdGgiLCJtYXNrQ29udGVudFVuaXRzIiwibWFza1VuaXRzIiwibWF0aGVtYXRpY2FsIiwibW9kZSIsIm51bU9jdGF2ZXMiLCJvcGVyYXRvciIsIm9yaWVudCIsIm9yaWVudGF0aW9uIiwib3JpZ2luIiwib3ZlcmZsb3ciLCJvdmVybGluZVBvc2l0aW9uIiwib3ZlcmxpbmVUaGlja25lc3MiLCJwYWludE9yZGVyIiwicGFub3NlMSIsInBhdGhMZW5ndGgiLCJwYXR0ZXJuQ29udGVudFVuaXRzIiwicGF0dGVyblRyYW5zZm9ybSIsInBhdHRlcm5Vbml0cyIsInBvaW50ZXJFdmVudHMiLCJwb2ludHMiLCJwb2ludHNBdFgiLCJwb2ludHNBdFkiLCJwb2ludHNBdFoiLCJwcmVzZXJ2ZUFscGhhIiwicHJlc2VydmVBc3BlY3RSYXRpbyIsInByaW1pdGl2ZVVuaXRzIiwiciIsInJhZGl1cyIsInJlZlgiLCJyZWZZIiwicmVuZGVyaW5nSW50ZW50IiwicmVwZWF0Q291bnQiLCJyZXBlYXREdXIiLCJyZXF1aXJlZEV4dGVuc2lvbnMiLCJyZXF1aXJlZEZlYXR1cmVzIiwicmVzdGFydCIsInJvdGF0ZSIsInJ4IiwicnkiLCJzY2FsZSIsInNlZWQiLCJzaGFwZVJlbmRlcmluZyIsInNsb3BlIiwic3BhY2luZyIsInNwZWN1bGFyQ29uc3RhbnQiLCJzcGVjdWxhckV4cG9uZW50Iiwic3BlZWQiLCJzcHJlYWRNZXRob2QiLCJzdGREZXZpYXRpb24iLCJzdGVtaCIsInN0ZW12Iiwic3RpdGNoVGlsZXMiLCJzdG9wQ29sb3IiLCJzdHJpa2V0aHJvdWdoUG9zaXRpb24iLCJzdHJpa2V0aHJvdWdoVGhpY2tuZXNzIiwic3Ryb2tlIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIiwic3VyZmFjZVNjYWxlIiwic3lzdGVtTGFuZ3VhZ2UiLCJ0YWJsZVZhbHVlcyIsInRhcmdldFgiLCJ0YXJnZXRZIiwidGV4dEFuY2hvciIsInRleHREZWNvcmF0aW9uIiwidGV4dFJlbmRlcmluZyIsInRleHRMZW5ndGgiLCJ0cmFuc2Zvcm0iLCJ1MSIsInUyIiwidW5kZXJsaW5lUG9zaXRpb24iLCJ1bmRlcmxpbmVUaGlja25lc3MiLCJ1bmljb2RlIiwidW5pY29kZUJpZGkiLCJ1bmljb2RlUmFuZ2UiLCJ1bml0c1BlckVtIiwidkFscGhhYmV0aWMiLCJ2SGFuZ2luZyIsInZJZGVvZ3JhcGhpYyIsInZNYXRoZW1hdGljYWwiLCJ2ZWN0b3JFZmZlY3QiLCJ2ZXJ0QWR2WSIsInZlcnRPcmlnaW5YIiwidmVydE9yaWdpblkiLCJ2aWV3Qm94Iiwidmlld1RhcmdldCIsInZpc2liaWxpdHkiLCJ3aWR0aHMiLCJ3b3JkU3BhY2luZyIsIndyaXRpbmdNb2RlIiwieEhlaWdodCIsIngxIiwieDIiLCJ4Q2hhbm5lbFNlbGVjdG9yIiwieGxpbmtBY3R1YXRlIiwieGxpbmtBcmNyb2xlIiwieGxpbmtIcmVmIiwieGxpbmtSb2xlIiwieGxpbmtTaG93IiwieGxpbmtUaXRsZSIsInhsaW5rVHlwZSIsInhtbEJhc2UiLCJ4bWxucyIsInhtbG5zWGxpbmsiLCJ4bWxMYW5nIiwieG1sU3BhY2UiLCJ5MSIsInkyIiwieUNoYW5uZWxTZWxlY3RvciIsInoiLCJ6b29tQW5kUGFuIiwic2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50IiwibGFzdFNlbGVjdGlvbiIsIm1vdXNlRG93biIsImhhc0xpc3RlbmVyIiwiYm91bmRpbmdUb3AiLCJsZWZ0IiwiYm91bmRpbmdMZWZ0IiwiY29uc3RydWN0U2VsZWN0RXZlbnQiLCJjdXJyZW50U2VsZWN0aW9uIiwiU3ludGhldGljQW5pbWF0aW9uRXZlbnQiLCJTeW50aGV0aWNDbGlwYm9hcmRFdmVudCIsIlN5bnRoZXRpY0ZvY3VzRXZlbnQiLCJTeW50aGV0aWNLZXlib2FyZEV2ZW50IiwiU3ludGhldGljRHJhZ0V2ZW50IiwiU3ludGhldGljVG91Y2hFdmVudCIsIlN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCIsIlN5bnRoZXRpY1doZWVsRXZlbnQiLCJnZXRFdmVudENoYXJDb2RlIiwidG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnIiwiY2FwaXRhbGl6ZWRFdmVudCIsIm9uRXZlbnQiLCJ0b3BFdmVudCIsIm9uQ2xpY2tMaXN0ZW5lcnMiLCJpc0ludGVyYWN0aXZlIiwic2hvdWxkUHJldmVudE1vdXNlRXZlbnQiLCJFdmVudENvbnN0cnVjdG9yIiwiQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UiLCJhbmltYXRpb25OYW1lIiwiZWxhcHNlZFRpbWUiLCJwc2V1ZG9FbGVtZW50IiwiQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UiLCJjbGlwYm9hcmREYXRhIiwiRm9jdXNFdmVudEludGVyZmFjZSIsImdldEV2ZW50S2V5IiwiS2V5Ym9hcmRFdmVudEludGVyZmFjZSIsInJlcGVhdCIsImxvY2FsZSIsImNoYXJDb2RlIiwibm9ybWFsaXplS2V5IiwidHJhbnNsYXRlVG9LZXkiLCJEcmFnRXZlbnRJbnRlcmZhY2UiLCJkYXRhVHJhbnNmZXIiLCJUb3VjaEV2ZW50SW50ZXJmYWNlIiwidG91Y2hlcyIsInRhcmdldFRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsIlRyYW5zaXRpb25FdmVudEludGVyZmFjZSIsIldoZWVsRXZlbnRJbnRlcmZhY2UiLCJkZWx0YVgiLCJ3aGVlbERlbHRhWCIsImRlbHRhWSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YSIsImRlbHRhWiIsImRlbHRhTW9kZSIsIlJlYWN0RE9NQ29udGFpbmVySW5mbyIsIlJlYWN0RE9NRmVhdHVyZUZsYWdzIiwiUmVhY3RNYXJrdXBDaGVja3N1bSIsIlJPT1RfQVRUUl9OQU1FIiwiRE9DX05PREVfVFlQRSIsImluc3RhbmNlc0J5UmVhY3RSb290SUQiLCJmaXJzdERpZmZlcmVuY2VJbmRleCIsInN0cmluZzEiLCJzdHJpbmcyIiwibWluTGVuIiwiZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyIiwiaW50ZXJuYWxHZXRJRCIsIm1vdW50Q29tcG9uZW50SW50b05vZGUiLCJ3cmFwcGVySW5zdGFuY2UiLCJzaG91bGRSZXVzZU1hcmt1cCIsIndyYXBwZWRFbGVtZW50IiwiX21vdW50SW1hZ2VJbnRvTm9kZSIsImJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlIiwiY29tcG9uZW50SW5zdGFuY2UiLCJ1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUiLCJoYXNOb25Sb290UmVhY3RDaGlsZCIsInJvb3RFbCIsIm5vZGVJc1JlbmRlcmVkQnlPdGhlckluc3RhbmNlIiwiaXNSZWFjdE5vZGUiLCJpc1ZhbGlkQ29udGFpbmVyIiwiaGFzQXR0cmlidXRlIiwiZ2V0SG9zdFJvb3RJbnN0YW5jZUluQ29udGFpbmVyIiwicHJldkhvc3RJbnN0YW5jZSIsImdldFRvcExldmVsV3JhcHBlckluQ29udGFpbmVyIiwidG9wTGV2ZWxSb290Q291bnRlciIsIlRvcExldmVsV3JhcHBlciIsInJvb3RJRCIsIl9pbnN0YW5jZXNCeVJlYWN0Um9vdElEIiwic2Nyb2xsTW9uaXRvciIsInJlbmRlckNhbGxiYWNrIiwiX3VwZGF0ZVJvb3RDb21wb25lbnQiLCJwcmV2Q29tcG9uZW50IiwiX3JlbmRlck5ld1Jvb3RDb21wb25lbnQiLCJ3cmFwcGVySUQiLCJwYXJlbnRDb21wb25lbnQiLCJfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJuZXh0V3JhcHBlZEVsZW1lbnQiLCJwcmV2V3JhcHBlZEVsZW1lbnQiLCJwdWJsaWNJbnN0IiwidXBkYXRlZENhbGxiYWNrIiwicmVhY3RSb290RWxlbWVudCIsImNvbnRhaW5lckhhc1JlYWN0TWFya3VwIiwiY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQiLCJyb290RWxlbWVudFNpYmxpbmciLCJpc0NvbnRhaW5lclJlYWN0Um9vdCIsInJvb3RFbGVtZW50IiwiY2FuUmV1c2VNYXJrdXAiLCJjaGVja3N1bSIsIkNIRUNLU1VNX0FUVFJfTkFNRSIsInJvb3RNYXJrdXAiLCJvdXRlckhUTUwiLCJub3JtYWxpemVkTWFya3VwIiwibm9ybWFsaXplciIsImNvbnRlbnREb2N1bWVudCIsIndyaXRlIiwiZGlmZkluZGV4IiwiZGlmZmVyZW5jZSIsInRvcExldmVsV3JhcHBlciIsInVzZUZpYmVyIiwiYWRsZXIzMiIsIlRBR19FTkQiLCJDT01NRU5UX1NUQVJUIiwiYWRkQ2hlY2tzdW1Ub01hcmt1cCIsImV4aXN0aW5nQ2hlY2tzdW0iLCJtYXJrdXBDaGVja3N1bSIsIk1PRCIsImwiLCJtIiwiY29tcG9uZW50T3JFbGVtZW50IiwicmVhY3RQcm9wcyIsIndhcm5lZFByb3BlcnRpZXMiLCJ2YWxpZGF0ZVByb3BlcnR5Iiwic3RhbmRhcmROYW1lIiwid2FyblVua25vd25Qcm9wZXJ0aWVzIiwidW5rbm93blByb3BzIiwiaXNWYWxpZCIsInVua25vd25Qcm9wU3RyaW5nIiwiaGFuZGxlRWxlbWVudCIsImRpZFdhcm5WYWx1ZU51bGwiLCJyQVJJQSIsIndhcm5JbnZhbGlkQVJJQVByb3BzIiwiaW52YWxpZFByb3BzIiwiX19lc01vZHVsZSIsImNyZWF0ZU1lbW9yeUhpc3RvcnkiLCJoYXNoSGlzdG9yeSIsImJyb3dzZXJIaXN0b3J5IiwiYXBwbHlSb3V0ZXJNaWRkbGV3YXJlIiwiZm9ybWF0UGF0dGVybiIsInVzZVJvdXRlckhpc3RvcnkiLCJyb3V0ZXJTaGFwZSIsImxvY2F0aW9uU2hhcGUiLCJSb3V0ZXJDb250ZXh0IiwiY3JlYXRlUm91dGVzIiwiUm91dGUiLCJSZWRpcmVjdCIsIkluZGV4Um91dGUiLCJJbmRleFJlZGlyZWN0Iiwid2l0aFJvdXRlciIsIkluZGV4TGluayIsIkxpbmsiLCJSb3V0ZXIiLCJfUm91dGVVdGlscyIsIl9Qcm9wVHlwZXMiLCJfUGF0dGVyblV0aWxzIiwiX1JvdXRlcjIiLCJfUm91dGVyMyIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfTGluazIiLCJfTGluazMiLCJfSW5kZXhMaW5rMiIsIl9JbmRleExpbmszIiwiX3dpdGhSb3V0ZXIyIiwiX3dpdGhSb3V0ZXIzIiwiX0luZGV4UmVkaXJlY3QyIiwiX0luZGV4UmVkaXJlY3QzIiwiX0luZGV4Um91dGUyIiwiX0luZGV4Um91dGUzIiwiX1JlZGlyZWN0MiIsIl9SZWRpcmVjdDMiLCJfUm91dGUyIiwiX1JvdXRlMyIsIl9Sb3V0ZXJDb250ZXh0MiIsIl9Sb3V0ZXJDb250ZXh0MyIsIl9tYXRjaDIiLCJfbWF0Y2gzIiwiX3VzZVJvdXRlckhpc3RvcnkyIiwiX3VzZVJvdXRlckhpc3RvcnkzIiwiX2FwcGx5Um91dGVyTWlkZGxld2FyZTIiLCJfYXBwbHlSb3V0ZXJNaWRkbGV3YXJlMyIsIl9icm93c2VySGlzdG9yeTIiLCJfYnJvd3Nlckhpc3RvcnkzIiwiX2hhc2hIaXN0b3J5MiIsIl9oYXNoSGlzdG9yeTMiLCJfY3JlYXRlTWVtb3J5SGlzdG9yeTIiLCJfY3JlYXRlTWVtb3J5SGlzdG9yeTMiLCJkZWZhdWx0IiwiX2V4dGVuZHMiLCJpc1JlYWN0Q2hpbGRyZW4iLCJjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQiLCJjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbiIsIl9yZWFjdCIsIl9yZWFjdDIiLCJpc1ZhbGlkQ2hpbGQiLCJjcmVhdGVSb3V0ZSIsInJvdXRlIiwiY2hpbGRSb3V0ZXMiLCJwYXJlbnRSb3V0ZSIsInJvdXRlcyIsImdvIiwiZ29CYWNrIiwiZ29Gb3J3YXJkIiwic2V0Um91dGVMZWF2ZUhvb2siLCJpc0FjdGl2ZSIsInBhdGhuYW1lIiwic2VhcmNoIiwiY29tcGlsZVBhdHRlcm4iLCJtYXRjaFBhdHRlcm4iLCJnZXRQYXJhbU5hbWVzIiwiZ2V0UGFyYW1zIiwiX2ludmFyaWFudCIsIl9pbnZhcmlhbnQyIiwiZXNjYXBlUmVnRXhwIiwiX2NvbXBpbGVQYXR0ZXJuIiwicmVnZXhwU291cmNlIiwicGFyYW1OYW1lcyIsInRva2VucyIsIm1hdGNoZXIiLCJDb21waWxlZFBhdHRlcm5zQ2FjaGUiLCJfY29tcGlsZVBhdHRlcm4yIiwibWF0Y2hlZFBhdGgiLCJyZW1haW5pbmdQYXRobmFtZSIsInBhcmFtVmFsdWVzIiwidiIsImRlY29kZVVSSUNvbXBvbmVudCIsInBhcmFtcyIsInBhcmFtTmFtZSIsIl9jb21waWxlUGF0dGVybjMiLCJwYXJlbkNvdW50Iiwic3BsYXRJbmRleCIsInBhcmVuSGlzdG9yeSIsInRva2VuIiwicGFyYW1WYWx1ZSIsInNwbGF0IiwiZW5jb2RlVVJJIiwicGFyZW5UZXh0IiwiY3VyVG9rZW5JZHgiLCJ0b2tlbnNTdWJzZXQiLCJuZXh0UGFyZW5JZHgiLCJfaSIsIl9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIiLCJfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIzIiwiX0ludGVybmFsUHJvcFR5cGVzIiwiX1JvdXRlckNvbnRleHQiLCJfUm91dGVyVXRpbHMiLCJfcm91dGVyV2FybmluZyIsIl9yb3V0ZXJXYXJuaW5nMiIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsIl9SZWFjdCRQcm9wVHlwZXMiLCJvbkVycm9yIiwib25VcGRhdGUiLCJtYXRjaENvbnRleHQiLCJjb21wb25lbnRzIiwiaGFuZGxlRXJyb3IiLCJjcmVhdGVSb3V0ZXJPYmplY3QiLCJyb3V0ZXIiLCJ0cmFuc2l0aW9uTWFuYWdlciIsImNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIiwiX3Byb3BzIiwiZ2V0Q3VycmVudExvY2F0aW9uIiwiX3VubGlzdGVuIiwiYXNzaWduUm91dGVyU3RhdGUiLCJfc3RhdGUiLCJfcHJvcHMyIiwiX2NvbXB1dGVDaGFuZ2VkUm91dGVzMiIsIl9jb21wdXRlQ2hhbmdlZFJvdXRlczMiLCJfVHJhbnNpdGlvblV0aWxzIiwiX2lzQWN0aXZlMiIsIl9pc0FjdGl2ZTMiLCJfZ2V0Q29tcG9uZW50cyIsIl9nZXRDb21wb25lbnRzMiIsIl9tYXRjaFJvdXRlcyIsIl9tYXRjaFJvdXRlczIiLCJoYXNBbnlQcm9wZXJ0aWVzIiwiaW5kZXhPbmx5IiwiY3JlYXRlTG9jYXRpb24iLCJwYXJ0aWFsTmV4dFN0YXRlIiwiZmluaXNoTWF0Y2giLCJfY29tcHV0ZUNoYW5nZWRSb3V0ZXMiLCJsZWF2ZVJvdXRlcyIsImNoYW5nZVJvdXRlcyIsImVudGVyUm91dGVzIiwicnVuTGVhdmVIb29rcyIsInJlbW92ZUxpc3RlbkJlZm9yZUhvb2tzRm9yUm91dGUiLCJydW5DaGFuZ2VIb29rcyIsInJlZGlyZWN0SW5mbyIsImhhbmRsZUVycm9yT3JSZWRpcmVjdCIsInJ1bkVudGVySG9va3MiLCJmaW5pc2hFbnRlckhvb2tzIiwiUm91dGVHdWlkIiwiZ2V0Um91dGVJRCIsIl9faWRfXyIsIlJvdXRlSG9va3MiLCJnZXRSb3V0ZUhvb2tzRm9yUm91dGVzIiwidHJhbnNpdGlvbkhvb2siLCJiZWZvcmVVbmxvYWRIb29rIiwidW5saXN0ZW5CZWZvcmUiLCJ1bmxpc3RlbkJlZm9yZVVubG9hZCIsInJvdXRlSUQiLCJsaXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUiLCJ0aGVyZVdlcmVOb1JvdXRlSG9va3MiLCJsaXN0ZW5CZWZvcmUiLCJsaXN0ZW5CZWZvcmVVbmxvYWQiLCJoaXN0b3J5TGlzdGVuZXIiLCJyZWRpcmVjdExvY2F0aW9uIiwidW5zdWJzY3JpYmUiLCJyb3V0ZXJXYXJuaW5nIiwiX3Jlc2V0V2FybmVkIiwiX3dhcm5pbmciLCJfd2FybmluZzIiLCJmYWxzZVRvV2FybiIsInJvdXRlUGFyYW1zQ2hhbmdlZCIsInNvbWUiLCJjb21wdXRlQ2hhbmdlZFJvdXRlcyIsInByZXZSb3V0ZXMiLCJuZXh0Um91dGVzIiwicGFyZW50SXNMZWF2aW5nIiwiaXNMZWF2aW5nIiwiaXNOZXciLCJwYXJhbXNDaGFuZ2VkIiwiX0FzeW5jVXRpbHMiLCJQZW5kaW5nSG9va3MiLCJoIiwiY2xlYXIiLCJlbnRlckhvb2tzIiwiY2hhbmdlSG9va3MiLCJjcmVhdGVUcmFuc2l0aW9uSG9vayIsImFzeW5jQXJpdHkiLCJwZW5kaW5nSG9va3MiLCJpc1N5bmMiLCJnZXRFbnRlckhvb2tzIiwib25FbnRlciIsImdldENoYW5nZUhvb2tzIiwicnVuVHJhbnNpdGlvbkhvb2tzIiwiaXRlciIsImxvb3BBc3luYyIsIndyYXBwZWROZXh0Iiwib25MZWF2ZSIsIm1hcEFzeW5jIiwidHVybnMiLCJ3b3JrIiwiY3VycmVudFR1cm4iLCJpc0RvbmUiLCJzeW5jIiwiaGFzTmV4dCIsImRvbmVBcmdzIiwiZG9uZUNvdW50IiwiX3R5cGVvZiIsImRlZXBFcXVhbCIsInBhdGhJc0FjdGl2ZSIsImN1cnJlbnRQYXRobmFtZSIsInJvdXRlSXNBY3RpdmUiLCJtYXRjaGVkIiwicXVlcnlJc0FjdGl2ZSIsInF1ZXJ5IiwiYWN0aXZlUXVlcnkiLCJfcmVmIiwiY3VycmVudExvY2F0aW9uIiwiX1Byb21pc2VVdGlscyIsImdldENvbXBvbmVudHNGb3JSb3V0ZSIsImdldENvbXBvbmVudCIsImdldENvbXBvbmVudHMiLCJjb21wb25lbnRSZXR1cm4iLCJpc1Byb21pc2UiLCJ0aGVuIiwibWF0Y2hSb3V0ZXMiLCJnZXRDaGlsZFJvdXRlcyIsImNyZWF0ZVBhcmFtcyIsImNoaWxkUm91dGVzUmV0dXJuIiwiZ2V0SW5kZXhSb3V0ZSIsImluZGV4Um91dGUiLCJpbmRleFJvdXRlc1JldHVybiIsInBhdGhsZXNzIiwiY2hpbGRSb3V0ZSIsImFzc2lnblBhcmFtcyIsIm1hdGNoUm91dGVEZWVwIiwiX3JldDIiLCJfbWF0Y2gkcm91dGVzIiwib25DaGlsZFJvdXRlcyIsInVuc2hpZnQiLCJmYWxzeSIsIl9nZXRSb3V0ZVBhcmFtcyIsIl9nZXRSb3V0ZVBhcmFtczIiLCJfQ29udGV4dFV0aWxzIiwiQ29udGV4dFByb3ZpZGVyIiwicmVkdWNlUmlnaHQiLCJyb3V0ZVBhcmFtcyIsImVsZW1lbnRzIiwiZ2V0Um91dGVQYXJhbXMiLCJDb250ZXh0U3Vic2NyaWJlciIsImNvbnRleHRQcm92aWRlclNoYXBlIiwic3Vic2NyaWJlIiwiZXZlbnRJbmRleCIsIm1ha2VDb250ZXh0TmFtZSIsIl9jaGlsZENvbnRleHRUeXBlcyIsIl9yZWYyIiwibGlzdGVuZXJzS2V5IiwiZXZlbnRJbmRleEtleSIsInN1YnNjcmliZUtleSIsIl9jb250ZXh0VHlwZXMiLCJfcmVmNCIsImxhc3RSZW5kZXJlZEV2ZW50SW5kZXhLZXkiLCJoYW5kbGVDb250ZXh0VXBkYXRlS2V5IiwidW5zdWJzY3JpYmVLZXkiLCJfcmVmMyIsIl9zZXRTdGF0ZSIsIl9zZXRTdGF0ZTIiLCJpc0xlZnRDbGlja0V2ZW50IiwiaXNNb2RpZmllZEV2ZW50IiwiaXNFbXB0eU9iamVjdCIsInJlc29sdmVUb0xvY2F0aW9uIiwiYWN0aXZlU3R5bGUiLCJhY3RpdmVDbGFzc05hbWUiLCJvbmx5QWN0aXZlT25JbmRleCIsIm9uQ2xpY2siLCJoYW5kbGVDbGljayIsInRvTG9jYXRpb24iLCJjcmVhdGVIcmVmIiwiX0xpbmsiLCJfaG9pc3ROb25SZWFjdFN0YXRpY3MiLCJfaG9pc3ROb25SZWFjdFN0YXRpY3MyIiwiV3JhcHBlZENvbXBvbmVudCIsIndpdGhSZWYiLCJXaXRoUm91dGVyIiwiZ2V0V3JhcHBlZEluc3RhbmNlIiwid3JhcHBlZEluc3RhbmNlIiwiUkVBQ1RfU1RBVElDUyIsIktOT1dOX1NUQVRJQ1MiLCJjYWxsZXIiLCJhcml0eSIsImlzR2V0T3duUHJvcGVydHlTeW1ib2xzQXZhaWxhYmxlIiwiaG9pc3ROb25SZWFjdFN0YXRpY3MiLCJ0YXJnZXRDb21wb25lbnQiLCJzb3VyY2VDb21wb25lbnQiLCJjdXN0b21TdGF0aWNzIiwiX1JlZGlyZWN0Iiwicm91dGVJbmRleCIsInBhcmVudFBhdHRlcm4iLCJnZXRSb3V0ZVBhdHRlcm4iLCJfQWN0aW9ucyIsIl9jcmVhdGVNZW1vcnlIaXN0b3J5IiwiX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIiwicmVuZGVyUHJvcHMiLCJSRVBMQUNFIiwiUFVTSCIsIlBPUCIsIl91c2VRdWVyaWVzIiwiX3VzZVF1ZXJpZXMyIiwiX3VzZUJhc2VuYW1lIiwiX3VzZUJhc2VuYW1lMiIsIm1lbW9yeUhpc3RvcnkiLCJjcmVhdGVIaXN0b3J5IiwiX3F1ZXJ5U3RyaW5nIiwiX3J1blRyYW5zaXRpb25Ib29rIiwiX3J1blRyYW5zaXRpb25Ib29rMiIsIl9Mb2NhdGlvblV0aWxzIiwiX1BhdGhVdGlscyIsImRlZmF1bHRTdHJpbmdpZnlRdWVyeSIsImRlZmF1bHRQYXJzZVF1ZXJ5U3RyaW5nIiwicGFyc2UiLCJ1c2VRdWVyaWVzIiwic3RyaW5naWZ5UXVlcnkiLCJwYXJzZVF1ZXJ5U3RyaW5nIiwiZGVjb2RlUXVlcnkiLCJlbmNvZGVRdWVyeSIsInBhcnNlUGF0aCIsInF1ZXJ5U3RyaW5nIiwiY3JlYXRlUGF0aCIsIm5ld0xvY2F0aW9uIiwiY3JlYXRlUXVlcnkiLCJzdHJpY3RVcmlFbmNvZGUiLCJvYmplY3RBc3NpZ24iLCJlbmNvZGUiLCJvcHRzIiwic3RyaWN0IiwiZXh0cmFjdCIsInBhcnRzIiwic2hpZnQiLCJkZWZhdWx0cyIsInZhbDIiLCJydW5UcmFuc2l0aW9uSG9vayIsImxvY2F0aW9uc0FyZUVxdWFsIiwic3RhdGVzQXJlRXF1YWwiLCJpc0RhdGUiLCJ0eXBlb2ZBIiwidHlwZW9mQiIsImtleXNvZkEiLCJrZXlzb2ZCIiwiZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoIiwic3RyaXBRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgiLCJhZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoIiwiX3BhcnNlUGF0aCIsIl9wYXJzZVBhdGgyIiwic3VmZml4IiwiX3BhcnNlUGF0aDMiLCJleHRyYWN0UGF0aCIsImhhc2hJbmRleCIsInNlYXJjaEluZGV4IiwiYmFzZW5hbWUiLCJ1c2VCYXNlbmFtZSIsImFkZEJhc2VuYW1lIiwicHJlcGVuZEJhc2VuYW1lIiwicG5hbWUiLCJub3JtYWxpemVkQmFzZW5hbWUiLCJub3JtYWxpemVkUGF0aG5hbWUiLCJfY3JlYXRlSGlzdG9yeSIsIl9jcmVhdGVIaXN0b3J5MiIsImNyZWF0ZVN0YXRlU3RvcmFnZSIsIm1lbW8iLCJyZWFkU3RhdGUiLCJpbml0IiwiY2FuR28iLCJ0cmFuc2l0aW9uVG8iLCJwdXNoTG9jYXRpb24iLCJzYXZlU3RhdGUiLCJyZXBsYWNlTG9jYXRpb24iLCJfb3B0aW9ucyIsInN0b3JhZ2UiLCJnZXRVc2VyQ29uZmlybWF0aW9uIiwia2V5TGVuZ3RoIiwicGVuZGluZ0xvY2F0aW9uIiwiYmVmb3JlTGlzdGVuZXJzIiwiYWxsS2V5cyIsImdldEN1cnJlbnRJbmRleCIsInVwZGF0ZUxvY2F0aW9uIiwibmV4dExvY2F0aW9uIiwiY3VycmVudEluZGV4IiwiY29uZmlybVRyYW5zaXRpb25UbyIsIm9rIiwicHJldlBhdGgiLCJuZXh0UGF0aCIsInByZXZJbmRleCIsImNyZWF0ZUtleSIsIm1pZGRsZXdhcmVzIiwibWlkZGxld2FyZSIsInJlbmRlclJvdXRlckNvbnRleHQiLCJyZW5kZXJSb3V0ZUNvbXBvbmVudCIsIndpdGhDb250ZXh0Iiwid2l0aENvbXBvbmVudCIsIm1ha2VDcmVhdGVFbGVtZW50IiwiYmFzZUNyZWF0ZUVsZW1lbnQiLCJwcmV2aW91cyIsIl9jcmVhdGVCcm93c2VySGlzdG9yeSIsIl9jcmVhdGVCcm93c2VySGlzdG9yeTIiLCJfY3JlYXRlUm91dGVySGlzdG9yeSIsIl9jcmVhdGVSb3V0ZXJIaXN0b3J5MiIsIl9FeGVjdXRpb25FbnZpcm9ubWVudCIsIl9Ccm93c2VyUHJvdG9jb2wiLCJCcm93c2VyUHJvdG9jb2wiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsIl9SZWZyZXNoUHJvdG9jb2wiLCJSZWZyZXNoUHJvdG9jb2wiLCJfRE9NVXRpbHMiLCJuZXdPYmoiLCJjcmVhdGVCcm93c2VySGlzdG9yeSIsInVzZVJlZnJlc2giLCJmb3JjZVJlZnJlc2giLCJzdXBwb3J0c0hpc3RvcnkiLCJQcm90b2NvbCIsImxpc3RlbmVyQ291bnQiLCJzdG9wTGlzdGVuZXIiLCJzdGFydExpc3RlbmVyIiwiYmVmb3JlIiwidW5saXN0ZW4iLCJfRE9NU3RhdGVTdG9yYWdlIiwiUG9wU3RhdGVFdmVudCIsIkhhc2hDaGFuZ2VFdmVudCIsIm5lZWRzSGFzaGNoYW5nZUxpc3RlbmVyIiwic3VwcG9ydHNQb3BzdGF0ZU9uSGFzaGNoYW5nZSIsIl9jcmVhdGVMb2NhdGlvbiIsImhpc3RvcnlTdGF0ZSIsImNvbmZpcm0iLCJoYW5kbGVQb3BTdGF0ZSIsImhhbmRsZVVucG9wcGVkSGFzaENoYW5nZSIsInVwZGF0ZVN0YXRlIiwicHVzaFN0YXRlIiwidWEiLCJzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCIsIlF1b3RhRXhjZWVkZWRFcnJvcnMiLCJRdW90YUV4Y2VlZGVkRXJyb3IiLCJRVU9UQV9FWENFRURFRF9FUlIiLCJTZWN1cml0eUVycm9ycyIsIlNlY3VyaXR5RXJyb3IiLCJLZXlQcmVmaXgiLCJzZXNzaW9uU3RvcmFnZSIsImpzb24iLCJfdXNlUm91dGVySGlzdG9yeSIsIl9jcmVhdGVIYXNoSGlzdG9yeSIsIl9jcmVhdGVIYXNoSGlzdG9yeTIiLCJfSGFzaFByb3RvY29sIiwiSGFzaFByb3RvY29sIiwiRGVmYXVsdFF1ZXJ5S2V5IiwiYWRkTGVhZGluZ1NsYXNoIiwiSGFzaFBhdGhDb2RlcnMiLCJoYXNoYmFuZyIsImVuY29kZVBhdGgiLCJkZWNvZGVQYXRoIiwibm9zbGFzaCIsInNsYXNoIiwiY3JlYXRlSGFzaEhpc3RvcnkiLCJxdWVyeUtleSIsImhhc2hUeXBlIiwicGF0aENvZGVyIiwiZ29Jc1N1cHBvcnRlZFdpdGhvdXRSZWxvYWQiLCJnZXRIYXNoUGF0aCIsInB1c2hIYXNoUGF0aCIsInJlcGxhY2VIYXNoUGF0aCIsInByZXZMb2NhdGlvbiIsImhhbmRsZUhhc2hDaGFuZ2UiLCJlbmNvZGVkUGF0aCIsInVwZGF0ZUhhc2giLCJNYWluIiwiTmF2Iiwib25TZWFyY2giLCJhbGVydCIsIldlYXRoZXIiLCJpc0xvYWRpbmciLCJoYW5kbGVTZWFyY2giLCJyZW5kZXJNZXNzYWdlIiwicmVuZGVyRXJyb3IiLCJXZWF0aGVyRm9ybSIsIm9uRm9ybVN1Ym1pdCIsIldlYXRoZXJNZXNzYWdlIiwiT1BFTl9XRUFUSEVSX01BUF9VUkwiLCJBUElLRVkiLCJnZXRUZW1wIiwiZW5jb2RlZExvY2F0aW9uIiwicmVxdWVzdFVybCIsImNvZCIsInV0aWxzIiwiQXhpb3MiLCJjcmVhdGVJbnN0YW5jZSIsImRlZmF1bHRDb25maWciLCJyZXF1ZXN0IiwiYXhpb3MiLCJDYW5jZWwiLCJDYW5jZWxUb2tlbiIsImlzQ2FuY2VsIiwiYWxsIiwicHJvbWlzZXMiLCJQcm9taXNlIiwic3ByZWFkIiwiaXNBcnJheUJ1ZmZlciIsImlzRm9ybURhdGEiLCJGb3JtRGF0YSIsImlzQXJyYXlCdWZmZXJWaWV3IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJidWZmZXIiLCJpc1N0cmluZyIsImlzTnVtYmVyIiwiaXNVbmRlZmluZWQiLCJpc09iamVjdCIsImlzRmlsZSIsImlzQmxvYiIsImlzU3RyZWFtIiwicGlwZSIsImlzVVJMU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiaXNTdGFuZGFyZEJyb3dzZXJFbnYiLCJtZXJnZSIsImFzc2lnblZhbHVlIiwidGhpc0FyZyIsIkludGVyY2VwdG9yTWFuYWdlciIsImRpc3BhdGNoUmVxdWVzdCIsImlzQWJzb2x1dGVVUkwiLCJjb21iaW5lVVJMcyIsImludGVyY2VwdG9ycyIsInJlc3BvbnNlIiwiYmFzZVVSTCIsImNoYWluIiwicHJvbWlzZSIsInJlc29sdmUiLCJ1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyIsImludGVyY2VwdG9yIiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMiLCJmb3JFYWNoTWV0aG9kTm9EYXRhIiwiZm9yRWFjaE1ldGhvZFdpdGhEYXRhIiwibm9ybWFsaXplSGVhZGVyTmFtZSIsIlBST1RFQ1RJT05fUFJFRklYIiwiREVGQVVMVF9DT05URU5UX1RZUEUiLCJzZXRDb250ZW50VHlwZUlmVW5zZXQiLCJnZXREZWZhdWx0QWRhcHRlciIsImFkYXB0ZXIiLCJYTUxIdHRwUmVxdWVzdCIsInRyYW5zZm9ybVJlcXVlc3QiLCJ0cmFuc2Zvcm1SZXNwb25zZSIsInBhdGNoIiwicG9zdCIsInB1dCIsInhzcmZDb29raWVOYW1lIiwieHNyZkhlYWRlck5hbWUiLCJtYXhDb250ZW50TGVuZ3RoIiwidmFsaWRhdGVTdGF0dXMiLCJzdGF0dXMiLCJub3JtYWxpemVkTmFtZSIsInByb2Nlc3NIZWFkZXIiLCJzZXR0bGUiLCJidWlsZFVSTCIsInBhcnNlSGVhZGVycyIsImlzVVJMU2FtZU9yaWdpbiIsImNyZWF0ZUVycm9yIiwiYnRvYSIsInhockFkYXB0ZXIiLCJkaXNwYXRjaFhoclJlcXVlc3QiLCJyZWplY3QiLCJyZXF1ZXN0RGF0YSIsInJlcXVlc3RIZWFkZXJzIiwibG9hZEV2ZW50IiwieERvbWFpbiIsIlhEb21haW5SZXF1ZXN0Iiwib25wcm9ncmVzcyIsImhhbmRsZVByb2dyZXNzIiwib250aW1lb3V0IiwiaGFuZGxlVGltZW91dCIsImF1dGgiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiQXV0aG9yaXphdGlvbiIsInBhcmFtc1NlcmlhbGl6ZXIiLCJoYW5kbGVMb2FkIiwicmVhZHlTdGF0ZSIsInJlc3BvbnNlVVJMIiwicmVzcG9uc2VIZWFkZXJzIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwicmVzcG9uc2VEYXRhIiwicmVzcG9uc2VUeXBlIiwicmVzcG9uc2VUZXh0Iiwic3RhdHVzVGV4dCIsIm9uZXJyb3IiLCJjb29raWVzIiwieHNyZlZhbHVlIiwid2l0aENyZWRlbnRpYWxzIiwicmVhZCIsInNldFJlcXVlc3RIZWFkZXIiLCJvbkRvd25sb2FkUHJvZ3Jlc3MiLCJvblVwbG9hZFByb2dyZXNzIiwidXBsb2FkIiwiY2FuY2VsVG9rZW4iLCJvbkNhbmNlbGVkIiwiY2FuY2VsIiwiYWJvcnQiLCJzZW5kIiwiZW5oYW5jZUVycm9yIiwic2VyaWFsaXplZFBhcmFtcyIsInNlcmlhbGl6ZSIsInBhcnNlVmFsdWUiLCJ0b0lTT1N0cmluZyIsInBhcnNlZCIsInBhcnNlciIsInN0YW5kYXJkQnJvd3NlckVudiIsIm1zaWUiLCJ1cmxQYXJzaW5nTm9kZSIsIm9yaWdpblVSTCIsInJlc29sdmVVUkwiLCJob3N0IiwiaG9zdG5hbWUiLCJwb3J0IiwicmVxdWVzdFVSTCIsIm5vblN0YW5kYXJkQnJvd3NlckVudiIsImJsb2NrIiwiaWR4IiwiZXhwaXJlcyIsImRvbWFpbiIsInNlY3VyZSIsImNvb2tpZSIsInRvR01UU3RyaW5nIiwiaGFuZGxlcnMiLCJ1c2UiLCJlamVjdCIsImZvckVhY2hIYW5kbGVyIiwidHJhbnNmb3JtRGF0YSIsInRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQiLCJ0aHJvd0lmUmVxdWVzdGVkIiwiY2xlYW5IZWFkZXJDb25maWciLCJvbkFkYXB0ZXJSZXNvbHV0aW9uIiwib25BZGFwdGVyUmVqZWN0aW9uIiwicmVhc29uIiwiZm5zIiwiX19DQU5DRUxfXyIsInJlbGF0aXZlVVJMIiwiZXhlY3V0b3IiLCJyZXNvbHZlUHJvbWlzZSIsInByb21pc2VFeGVjdXRvciIsIkVycm9yTW9kYWwiLCJtb2RhbCIsIkZvdW5kYXRpb24iLCJSZXZlYWwiLCJBYm91dCIsIkV4YW1wbGVzIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDQSw2Q0FBa1csRTs7Ozs7O0FDQWxXO0FBQ0E7QUFD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QkFBa0IsU0FBUyxlQUFlLGtCQUFrQixVQUFVLGlCQUFpQixzQkFBc0IsVUFBVSxnQkFBZ0IsZUFBZSxrQkFBa0IsZUFBZSxlQUFlLGtCQUFrQixnQkFBZ0IsaUJBQWlCLGdCQUFnQixVQUFVLGdCQUFnQixlQUFlLGtCQUFrQixlQUFlLGVBQWUsa0JBQWtCLGdCQUFnQixpQkFBaUIsc0JBQXNCLFVBQVUsVUFBVSxlQUFlLGtCQUFrQixTQUFTLGVBQWUsa0JBQWtCLFVBQVUsaUJBQWlCLHNCQUFzQixVQUFVLGdCQUFnQixlQUFlLGtCQUFrQixlQUFlLGVBQWUsa0JBQWtCLGdCQUFnQixpQkFBaUIsZ0JBQWdCLFVBQVUsZ0JBQWdCLGVBQWUsa0JBQWtCLGVBQWUsZUFBZSxrQkFBa0IsZ0JBQWdCLGlCQUFpQixzQkFBc0IsVUFBVSxVQUFVLGVBQWUsa0JBQWtCLFNBQVMsZUFBZSxrQkFBa0IsVUFBVSxpQkFBaUIsc0JBQXNCLFdBQVcsZ0JBQWdCLGdCQUFnQixrQkFBa0IsZUFBZSxnQkFBZ0Isa0JBQWtCLGdCQUFnQixpQkFBaUIsZ0JBQWdCLFdBQVcsZ0JBQWdCLGdCQUFnQixrQkFBa0IsZUFBZSxnQkFBZ0Isa0JBQWtCLGdCQUFnQixrQkFBa0Isc0JBQXNCLFdBQVcsV0FBVyxrQkFBa0Isc0JBQXNCLDJDQUEyQyxXQUFXLFdBQVcsMkVBQTJFLFdBQVcsK0VBQStFLFdBQVcsaUVBQWlFLFdBQVcsMkNBQTJDLFVBQVUsV0FBVywyRUFBMkUsV0FBVywrRUFBK0UsV0FBVyxpRUFBaUUsV0FBVywyQ0FBMkMsZ0JBQWdCLFdBQVcsMkVBQTJFLFdBQVcsK0VBQStFLFdBQVcsaUVBQWlFLFdBQVcsMkNBQTJDLFVBQVUsV0FBVywyRUFBMkUsV0FBVywrRUFBK0UsV0FBVyxpRUFBaUUsV0FBVywyQ0FBMkMsVUFBVSxXQUFXLDJFQUEyRSxXQUFXLCtFQUErRSxXQUFXLGlFQUFpRSxXQUFXLDJDQUEyQyxnQkFBZ0IsV0FBVywyRUFBMkUsV0FBVywrRUFBK0UsV0FBVyxpRUFBaUUsV0FBVywyQ0FBMkMsZ0JBQWdCLFdB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O0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF1RDtBQUN2RDs7QUFFQSw4QkFBNkIsbUJBQW1COztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2UEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxpQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEU7Ozs7OztBQ3BCQTtBQUNBOzs7QUFHQTtBQUNBLHdDQUF1Qyx1QkFBdUIsMEJBQTBCLGdCQUFnQixFQUFFLHdCQUF3QixxQkFBcUIsRUFBRTs7QUFFekoiLCJmaWxlIjoiLi9wdWJsaWMvYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgOWI1ZDdmNzA2MWJjMDBjZDhkMzciLCJyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxQYXJhZ29uXFxcXERlc2t0b3BcXFxccHJvamVjdHNcXFxccmVhY3RcXFxccmVhY3R3ZWF0aGVyXFxcXG5vZGVfbW9kdWxlc1xcXFxzY3JpcHQtbG9hZGVyXFxcXGFkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxQYXJhZ29uXFxcXERlc2t0b3BcXFxccHJvamVjdHNcXFxccmVhY3RcXFxccmVhY3R3ZWF0aGVyXFxcXG5vZGVfbW9kdWxlc1xcXFxyYXctbG9hZGVyXFxcXGluZGV4LmpzIUM6XFxcXFVzZXJzXFxcXFBhcmFnb25cXFxcRGVza3RvcFxcXFxwcm9qZWN0c1xcXFxyZWFjdFxcXFxyZWFjdHdlYXRoZXJcXFxcbm9kZV9tb2R1bGVzXFxcXGJhYmVsLWxvYWRlclxcXFxpbmRleC5qcz97XFxcInByZXNldHNcXFwiOltcXFwicmVhY3RcXFwiLFxcXCJlczIwMTVcXFwiXX0hQzpcXFxcVXNlcnNcXFxcUGFyYWdvblxcXFxEZXNrdG9wXFxcXHByb2plY3RzXFxcXHJlYWN0XFxcXHJlYWN0d2VhdGhlclxcXFxub2RlX21vZHVsZXNcXFxcanF1ZXJ5XFxcXGRpc3RcXFxcanF1ZXJ5Lm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vanF1ZXJ5L2Rpc3QvanF1ZXJ5Lm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNyYykge1xyXG5cdGlmICh0eXBlb2YgZXhlY1NjcmlwdCA9PT0gXCJmdW5jdGlvblwiKVxyXG5cdFx0ZXhlY1NjcmlwdChzcmMpO1xyXG5cdGVsc2VcclxuXHRcdGV2YWwuY2FsbChudWxsLCBzcmMpO1xyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTtcXG5cXG4vKiEgalF1ZXJ5IHYyLjIuMSB8IChjKSBqUXVlcnkgRm91bmRhdGlvbiB8IGpxdWVyeS5vcmcvbGljZW5zZSAqL1xcbiFmdW5jdGlvbiAoYSwgYikge1xcbiAgXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBtb2R1bGUgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKG1vZHVsZSkpICYmIFxcXCJvYmplY3RcXFwiID09IF90eXBlb2YobW9kdWxlLmV4cG9ydHMpID8gbW9kdWxlLmV4cG9ydHMgPSBhLmRvY3VtZW50ID8gYihhLCAhMCkgOiBmdW5jdGlvbiAoYSkge1xcbiAgICBpZiAoIWEuZG9jdW1lbnQpIHRocm93IG5ldyBFcnJvcihcXFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFxcXCIpO3JldHVybiBiKGEpO1xcbiAgfSA6IGIoYSk7XFxufShcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2Ygd2luZG93ID8gd2luZG93IDogdW5kZWZpbmVkLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgdmFyIGMgPSBbXSxcXG4gICAgICBkID0gYS5kb2N1bWVudCxcXG4gICAgICBlID0gYy5zbGljZSxcXG4gICAgICBmID0gYy5jb25jYXQsXFxuICAgICAgZyA9IGMucHVzaCxcXG4gICAgICBoID0gYy5pbmRleE9mLFxcbiAgICAgIGkgPSB7fSxcXG4gICAgICBqID0gaS50b1N0cmluZyxcXG4gICAgICBrID0gaS5oYXNPd25Qcm9wZXJ0eSxcXG4gICAgICBsID0ge30sXFxuICAgICAgbSA9IFxcXCIyLjIuMVxcXCIsXFxuICAgICAgbiA9IGZ1bmN0aW9uIG4oYSwgYikge1xcbiAgICByZXR1cm4gbmV3IG4uZm4uaW5pdChhLCBiKTtcXG4gIH0sXFxuICAgICAgbyA9IC9eW1xcXFxzXFxcXHVGRUZGXFxcXHhBMF0rfFtcXFxcc1xcXFx1RkVGRlxcXFx4QTBdKyQvZyxcXG4gICAgICBwID0gL14tbXMtLyxcXG4gICAgICBxID0gLy0oW1xcXFxkYS16XSkvZ2ksXFxuICAgICAgciA9IGZ1bmN0aW9uIHIoYSwgYikge1xcbiAgICByZXR1cm4gYi50b1VwcGVyQ2FzZSgpO1xcbiAgfTtuLmZuID0gbi5wcm90b3R5cGUgPSB7IGpxdWVyeTogbSwgY29uc3RydWN0b3I6IG4sIHNlbGVjdG9yOiBcXFwiXFxcIiwgbGVuZ3RoOiAwLCB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KCkge1xcbiAgICAgIHJldHVybiBlLmNhbGwodGhpcyk7XFxuICAgIH0sIGdldDogZnVuY3Rpb24gZ2V0KGEpIHtcXG4gICAgICByZXR1cm4gbnVsbCAhPSBhID8gMCA+IGEgPyB0aGlzW2EgKyB0aGlzLmxlbmd0aF0gOiB0aGlzW2FdIDogZS5jYWxsKHRoaXMpO1xcbiAgICB9LCBwdXNoU3RhY2s6IGZ1bmN0aW9uIHB1c2hTdGFjayhhKSB7XFxuICAgICAgdmFyIGIgPSBuLm1lcmdlKHRoaXMuY29uc3RydWN0b3IoKSwgYSk7cmV0dXJuIGIucHJldk9iamVjdCA9IHRoaXMsIGIuY29udGV4dCA9IHRoaXMuY29udGV4dCwgYjtcXG4gICAgfSwgZWFjaDogZnVuY3Rpb24gZWFjaChhKSB7XFxuICAgICAgcmV0dXJuIG4uZWFjaCh0aGlzLCBhKTtcXG4gICAgfSwgbWFwOiBmdW5jdGlvbiBtYXAoYSkge1xcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhuLm1hcCh0aGlzLCBmdW5jdGlvbiAoYiwgYykge1xcbiAgICAgICAgcmV0dXJuIGEuY2FsbChiLCBjLCBiKTtcXG4gICAgICB9KSk7XFxuICAgIH0sIHNsaWNlOiBmdW5jdGlvbiBzbGljZSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gICAgfSwgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KCkge1xcbiAgICAgIHJldHVybiB0aGlzLmVxKDApO1xcbiAgICB9LCBsYXN0OiBmdW5jdGlvbiBsYXN0KCkge1xcbiAgICAgIHJldHVybiB0aGlzLmVxKC0xKTtcXG4gICAgfSwgZXE6IGZ1bmN0aW9uIGVxKGEpIHtcXG4gICAgICB2YXIgYiA9IHRoaXMubGVuZ3RoLFxcbiAgICAgICAgICBjID0gK2EgKyAoMCA+IGEgPyBiIDogMCk7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGMgPj0gMCAmJiBiID4gYyA/IFt0aGlzW2NdXSA6IFtdKTtcXG4gICAgfSwgZW5kOiBmdW5jdGlvbiBlbmQoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XFxuICAgIH0sIHB1c2g6IGcsIHNvcnQ6IGMuc29ydCwgc3BsaWNlOiBjLnNwbGljZSB9LCBuLmV4dGVuZCA9IG4uZm4uZXh0ZW5kID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgYSxcXG4gICAgICAgIGIsXFxuICAgICAgICBjLFxcbiAgICAgICAgZCxcXG4gICAgICAgIGUsXFxuICAgICAgICBmLFxcbiAgICAgICAgZyA9IGFyZ3VtZW50c1swXSB8fCB7fSxcXG4gICAgICAgIGggPSAxLFxcbiAgICAgICAgaSA9IGFyZ3VtZW50cy5sZW5ndGgsXFxuICAgICAgICBqID0gITE7Zm9yIChcXFwiYm9vbGVhblxcXCIgPT0gdHlwZW9mIGcgJiYgKGogPSBnLCBnID0gYXJndW1lbnRzW2hdIHx8IHt9LCBoKyspLCBcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGcgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGcpKSB8fCBuLmlzRnVuY3Rpb24oZykgfHwgKGcgPSB7fSksIGggPT09IGkgJiYgKGcgPSB0aGlzLCBoLS0pOyBpID4gaDsgaCsrKSB7XFxuICAgICAgaWYgKG51bGwgIT0gKGEgPSBhcmd1bWVudHNbaF0pKSBmb3IgKGIgaW4gYSkge1xcbiAgICAgICAgYyA9IGdbYl0sIGQgPSBhW2JdLCBnICE9PSBkICYmIChqICYmIGQgJiYgKG4uaXNQbGFpbk9iamVjdChkKSB8fCAoZSA9IG4uaXNBcnJheShkKSkpID8gKGUgPyAoZSA9ICExLCBmID0gYyAmJiBuLmlzQXJyYXkoYykgPyBjIDogW10pIDogZiA9IGMgJiYgbi5pc1BsYWluT2JqZWN0KGMpID8gYyA6IHt9LCBnW2JdID0gbi5leHRlbmQoaiwgZiwgZCkpIDogdm9pZCAwICE9PSBkICYmIChnW2JdID0gZCkpO1xcbiAgICAgIH1cXG4gICAgfXJldHVybiBnO1xcbiAgfSwgbi5leHRlbmQoeyBleHBhbmRvOiBcXFwialF1ZXJ5XFxcIiArIChtICsgTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXFxcXEQvZywgXFxcIlxcXCIpLCBpc1JlYWR5OiAhMCwgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKGEpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYSk7XFxuICAgIH0sIG5vb3A6IGZ1bmN0aW9uIG5vb3AoKSB7fSwgaXNGdW5jdGlvbjogZnVuY3Rpb24gaXNGdW5jdGlvbihhKSB7XFxuICAgICAgcmV0dXJuIFxcXCJmdW5jdGlvblxcXCIgPT09IG4udHlwZShhKTtcXG4gICAgfSwgaXNBcnJheTogQXJyYXkuaXNBcnJheSwgaXNXaW5kb3c6IGZ1bmN0aW9uIGlzV2luZG93KGEpIHtcXG4gICAgICByZXR1cm4gbnVsbCAhPSBhICYmIGEgPT09IGEud2luZG93O1xcbiAgICB9LCBpc051bWVyaWM6IGZ1bmN0aW9uIGlzTnVtZXJpYyhhKSB7XFxuICAgICAgdmFyIGIgPSBhICYmIGEudG9TdHJpbmcoKTtyZXR1cm4gIW4uaXNBcnJheShhKSAmJiBiIC0gcGFyc2VGbG9hdChiKSArIDEgPj0gMDtcXG4gICAgfSwgaXNQbGFpbk9iamVjdDogZnVuY3Rpb24gaXNQbGFpbk9iamVjdChhKSB7XFxuICAgICAgcmV0dXJuIFxcXCJvYmplY3RcXFwiICE9PSBuLnR5cGUoYSkgfHwgYS5ub2RlVHlwZSB8fCBuLmlzV2luZG93KGEpID8gITEgOiBhLmNvbnN0cnVjdG9yICYmICFrLmNhbGwoYS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFxcXCJpc1Byb3RvdHlwZU9mXFxcIikgPyAhMSA6ICEwO1xcbiAgICB9LCBpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiBpc0VtcHR5T2JqZWN0KGEpIHtcXG4gICAgICB2YXIgYjtmb3IgKGIgaW4gYSkge1xcbiAgICAgICAgcmV0dXJuICExO1xcbiAgICAgIH1yZXR1cm4gITA7XFxuICAgIH0sIHR5cGU6IGZ1bmN0aW9uIHR5cGUoYSkge1xcbiAgICAgIHJldHVybiBudWxsID09IGEgPyBhICsgXFxcIlxcXCIgOiBcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGEgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGEpKSB8fCBcXFwiZnVuY3Rpb25cXFwiID09IHR5cGVvZiBhID8gaVtqLmNhbGwoYSldIHx8IFxcXCJvYmplY3RcXFwiIDogdHlwZW9mIGEgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGEpO1xcbiAgICB9LCBnbG9iYWxFdmFsOiBmdW5jdGlvbiBnbG9iYWxFdmFsKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgYyA9IGV2YWw7YSA9IG4udHJpbShhKSwgYSAmJiAoMSA9PT0gYS5pbmRleE9mKFxcXCJ1c2Ugc3RyaWN0XFxcIikgPyAoYiA9IGQuY3JlYXRlRWxlbWVudChcXFwic2NyaXB0XFxcIiksIGIudGV4dCA9IGEsIGQuaGVhZC5hcHBlbmRDaGlsZChiKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpKSA6IGMoYSkpO1xcbiAgICB9LCBjYW1lbENhc2U6IGZ1bmN0aW9uIGNhbWVsQ2FzZShhKSB7XFxuICAgICAgcmV0dXJuIGEucmVwbGFjZShwLCBcXFwibXMtXFxcIikucmVwbGFjZShxLCByKTtcXG4gICAgfSwgbm9kZU5hbWU6IGZ1bmN0aW9uIG5vZGVOYW1lKGEsIGIpIHtcXG4gICAgICByZXR1cm4gYS5ub2RlTmFtZSAmJiBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGIudG9Mb3dlckNhc2UoKTtcXG4gICAgfSwgZWFjaDogZnVuY3Rpb24gZWFjaChhLCBiKSB7XFxuICAgICAgdmFyIGMsXFxuICAgICAgICAgIGQgPSAwO2lmIChzKGEpKSB7XFxuICAgICAgICBmb3IgKGMgPSBhLmxlbmd0aDsgYyA+IGQ7IGQrKykge1xcbiAgICAgICAgICBpZiAoYi5jYWxsKGFbZF0sIGQsIGFbZF0pID09PSAhMSkgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGZvciAoZCBpbiBhKSB7XFxuICAgICAgICBpZiAoYi5jYWxsKGFbZF0sIGQsIGFbZF0pID09PSAhMSkgYnJlYWs7XFxuICAgICAgfXJldHVybiBhO1xcbiAgICB9LCB0cmltOiBmdW5jdGlvbiB0cmltKGEpIHtcXG4gICAgICByZXR1cm4gbnVsbCA9PSBhID8gXFxcIlxcXCIgOiAoYSArIFxcXCJcXFwiKS5yZXBsYWNlKG8sIFxcXCJcXFwiKTtcXG4gICAgfSwgbWFrZUFycmF5OiBmdW5jdGlvbiBtYWtlQXJyYXkoYSwgYikge1xcbiAgICAgIHZhciBjID0gYiB8fCBbXTtyZXR1cm4gbnVsbCAhPSBhICYmIChzKE9iamVjdChhKSkgPyBuLm1lcmdlKGMsIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhID8gW2FdIDogYSkgOiBnLmNhbGwoYywgYSkpLCBjO1xcbiAgICB9LCBpbkFycmF5OiBmdW5jdGlvbiBpbkFycmF5KGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gbnVsbCA9PSBiID8gLTEgOiBoLmNhbGwoYiwgYSwgYyk7XFxuICAgIH0sIG1lcmdlOiBmdW5jdGlvbiBtZXJnZShhLCBiKSB7XFxuICAgICAgZm9yICh2YXIgYyA9ICtiLmxlbmd0aCwgZCA9IDAsIGUgPSBhLmxlbmd0aDsgYyA+IGQ7IGQrKykge1xcbiAgICAgICAgYVtlKytdID0gYltkXTtcXG4gICAgICB9cmV0dXJuIGEubGVuZ3RoID0gZSwgYTtcXG4gICAgfSwgZ3JlcDogZnVuY3Rpb24gZ3JlcChhLCBiLCBjKSB7XFxuICAgICAgZm9yICh2YXIgZCwgZSA9IFtdLCBmID0gMCwgZyA9IGEubGVuZ3RoLCBoID0gIWM7IGcgPiBmOyBmKyspIHtcXG4gICAgICAgIGQgPSAhYihhW2ZdLCBmKSwgZCAhPT0gaCAmJiBlLnB1c2goYVtmXSk7XFxuICAgICAgfXJldHVybiBlO1xcbiAgICB9LCBtYXA6IGZ1bmN0aW9uIG1hcChhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGcgPSAwLFxcbiAgICAgICAgICBoID0gW107aWYgKHMoYSkpIGZvciAoZCA9IGEubGVuZ3RoOyBkID4gZzsgZysrKSB7XFxuICAgICAgICBlID0gYihhW2ddLCBnLCBjKSwgbnVsbCAhPSBlICYmIGgucHVzaChlKTtcXG4gICAgICB9IGVsc2UgZm9yIChnIGluIGEpIHtcXG4gICAgICAgIGUgPSBiKGFbZ10sIGcsIGMpLCBudWxsICE9IGUgJiYgaC5wdXNoKGUpO1xcbiAgICAgIH1yZXR1cm4gZi5hcHBseShbXSwgaCk7XFxuICAgIH0sIGd1aWQ6IDEsIHByb3h5OiBmdW5jdGlvbiBwcm94eShhLCBiKSB7XFxuICAgICAgdmFyIGMsIGQsIGY7cmV0dXJuIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBiICYmIChjID0gYVtiXSwgYiA9IGEsIGEgPSBjKSwgbi5pc0Z1bmN0aW9uKGEpID8gKGQgPSBlLmNhbGwoYXJndW1lbnRzLCAyKSwgZiA9IGZ1bmN0aW9uIGYoKSB7XFxuICAgICAgICByZXR1cm4gYS5hcHBseShiIHx8IHRoaXMsIGQuY29uY2F0KGUuY2FsbChhcmd1bWVudHMpKSk7XFxuICAgICAgfSwgZi5ndWlkID0gYS5ndWlkID0gYS5ndWlkIHx8IG4uZ3VpZCsrLCBmKSA6IHZvaWQgMDtcXG4gICAgfSwgbm93OiBEYXRlLm5vdywgc3VwcG9ydDogbCB9KSwgXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2YgU3ltYm9sICYmIChuLmZuW1N5bWJvbC5pdGVyYXRvcl0gPSBjW1N5bWJvbC5pdGVyYXRvcl0pLCBuLmVhY2goXFxcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXFxcIi5zcGxpdChcXFwiIFxcXCIpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBpW1xcXCJbb2JqZWN0IFxcXCIgKyBiICsgXFxcIl1cXFwiXSA9IGIudG9Mb3dlckNhc2UoKTtcXG4gIH0pO2Z1bmN0aW9uIHMoYSkge1xcbiAgICB2YXIgYiA9ICEhYSAmJiBcXFwibGVuZ3RoXFxcIiBpbiBhICYmIGEubGVuZ3RoLFxcbiAgICAgICAgYyA9IG4udHlwZShhKTtyZXR1cm4gXFxcImZ1bmN0aW9uXFxcIiA9PT0gYyB8fCBuLmlzV2luZG93KGEpID8gITEgOiBcXFwiYXJyYXlcXFwiID09PSBjIHx8IDAgPT09IGIgfHwgXFxcIm51bWJlclxcXCIgPT0gdHlwZW9mIGIgJiYgYiA+IDAgJiYgYiAtIDEgaW4gYTtcXG4gIH12YXIgdCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgIHZhciBiLFxcbiAgICAgICAgYyxcXG4gICAgICAgIGQsXFxuICAgICAgICBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcsXFxuICAgICAgICBoLFxcbiAgICAgICAgaSxcXG4gICAgICAgIGosXFxuICAgICAgICBrLFxcbiAgICAgICAgbCxcXG4gICAgICAgIG0sXFxuICAgICAgICBuLFxcbiAgICAgICAgbyxcXG4gICAgICAgIHAsXFxuICAgICAgICBxLFxcbiAgICAgICAgcixcXG4gICAgICAgIHMsXFxuICAgICAgICB0LFxcbiAgICAgICAgdSA9IFxcXCJzaXp6bGVcXFwiICsgMSAqIG5ldyBEYXRlKCksXFxuICAgICAgICB2ID0gYS5kb2N1bWVudCxcXG4gICAgICAgIHcgPSAwLFxcbiAgICAgICAgeCA9IDAsXFxuICAgICAgICB5ID0gZ2EoKSxcXG4gICAgICAgIHogPSBnYSgpLFxcbiAgICAgICAgQSA9IGdhKCksXFxuICAgICAgICBCID0gZnVuY3Rpb24gQihhLCBiKSB7XFxuICAgICAgcmV0dXJuIGEgPT09IGIgJiYgKGwgPSAhMCksIDA7XFxuICAgIH0sXFxuICAgICAgICBDID0gMSA8PCAzMSxcXG4gICAgICAgIEQgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcXG4gICAgICAgIEUgPSBbXSxcXG4gICAgICAgIEYgPSBFLnBvcCxcXG4gICAgICAgIEcgPSBFLnB1c2gsXFxuICAgICAgICBIID0gRS5wdXNoLFxcbiAgICAgICAgSSA9IEUuc2xpY2UsXFxuICAgICAgICBKID0gZnVuY3Rpb24gSihhLCBiKSB7XFxuICAgICAgZm9yICh2YXIgYyA9IDAsIGQgPSBhLmxlbmd0aDsgZCA+IGM7IGMrKykge1xcbiAgICAgICAgaWYgKGFbY10gPT09IGIpIHJldHVybiBjO1xcbiAgICAgIH1yZXR1cm4gLTE7XFxuICAgIH0sXFxuICAgICAgICBLID0gXFxcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXFxcIixcXG4gICAgICAgIEwgPSBcXFwiW1xcXFxcXFxceDIwXFxcXFxcXFx0XFxcXFxcXFxyXFxcXFxcXFxuXFxcXFxcXFxmXVxcXCIsXFxuICAgICAgICBNID0gXFxcIig/OlxcXFxcXFxcXFxcXFxcXFwufFtcXFxcXFxcXHctXXxbXlxcXFxcXFxceDAwLVxcXFxcXFxceGEwXSkrXFxcIixcXG4gICAgICAgIE4gPSBcXFwiXFxcXFxcXFxbXFxcIiArIEwgKyBcXFwiKihcXFwiICsgTSArIFxcXCIpKD86XFxcIiArIEwgKyBcXFwiKihbKl4kfCF+XT89KVxcXCIgKyBMICsgXFxcIiooPzonKCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXCddKSopJ3xcXFxcXFxcIigoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcIl0pKilcXFxcXFxcInwoXFxcIiArIE0gKyBcXFwiKSl8KVxcXCIgKyBMICsgXFxcIipcXFxcXFxcXF1cXFwiLFxcbiAgICAgICAgTyA9IFxcXCI6KFxcXCIgKyBNICsgXFxcIikoPzpcXFxcXFxcXCgoKCcoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcJ10pKiknfFxcXFxcXFwiKCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwiXSkqKVxcXFxcXFwiKXwoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcKClbXFxcXFxcXFxdXXxcXFwiICsgTiArIFxcXCIpKil8LiopXFxcXFxcXFwpfClcXFwiLFxcbiAgICAgICAgUCA9IG5ldyBSZWdFeHAoTCArIFxcXCIrXFxcIiwgXFxcImdcXFwiKSxcXG4gICAgICAgIFEgPSBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIEwgKyBcXFwiK3woKD86XnxbXlxcXFxcXFxcXFxcXFxcXFxdKSg/OlxcXFxcXFxcXFxcXFxcXFwuKSopXFxcIiArIEwgKyBcXFwiKyRcXFwiLCBcXFwiZ1xcXCIpLFxcbiAgICAgICAgUiA9IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgTCArIFxcXCIqLFxcXCIgKyBMICsgXFxcIipcXFwiKSxcXG4gICAgICAgIFMgPSBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIEwgKyBcXFwiKihbPit+XXxcXFwiICsgTCArIFxcXCIpXFxcIiArIEwgKyBcXFwiKlxcXCIpLFxcbiAgICAgICAgVCA9IG5ldyBSZWdFeHAoXFxcIj1cXFwiICsgTCArIFxcXCIqKFteXFxcXFxcXFxdJ1xcXFxcXFwiXSo/KVxcXCIgKyBMICsgXFxcIipcXFxcXFxcXF1cXFwiLCBcXFwiZ1xcXCIpLFxcbiAgICAgICAgVSA9IG5ldyBSZWdFeHAoTyksXFxuICAgICAgICBWID0gbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyBNICsgXFxcIiRcXFwiKSxcXG4gICAgICAgIFcgPSB7IElEOiBuZXcgUmVnRXhwKFxcXCJeIyhcXFwiICsgTSArIFxcXCIpXFxcIiksIENMQVNTOiBuZXcgUmVnRXhwKFxcXCJeXFxcXFxcXFwuKFxcXCIgKyBNICsgXFxcIilcXFwiKSwgVEFHOiBuZXcgUmVnRXhwKFxcXCJeKFxcXCIgKyBNICsgXFxcInxbKl0pXFxcIiksIEFUVFI6IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgTiksIFBTRVVETzogbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyBPKSwgQ0hJTEQ6IG5ldyBSZWdFeHAoXFxcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFxcXFxcKFxcXCIgKyBMICsgXFxcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXFxcXFxkKilufClcXFwiICsgTCArIFxcXCIqKD86KFsrLV18KVxcXCIgKyBMICsgXFxcIiooXFxcXFxcXFxkKyl8KSlcXFwiICsgTCArIFxcXCIqXFxcXFxcXFwpfClcXFwiLCBcXFwiaVxcXCIpLCBib29sOiBuZXcgUmVnRXhwKFxcXCJeKD86XFxcIiArIEsgKyBcXFwiKSRcXFwiLCBcXFwiaVxcXCIpLCBuZWVkc0NvbnRleHQ6IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgTCArIFxcXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcXFxcXChcXFwiICsgTCArIFxcXCIqKCg/Oi1cXFxcXFxcXGQpP1xcXFxcXFxcZCopXFxcIiArIEwgKyBcXFwiKlxcXFxcXFxcKXwpKD89W14tXXwkKVxcXCIsIFxcXCJpXFxcIikgfSxcXG4gICAgICAgIFggPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxcbiAgICAgICAgWSA9IC9eaFxcXFxkJC9pLFxcbiAgICAgICAgWiA9IC9eW157XStcXFxce1xcXFxzKlxcXFxbbmF0aXZlIFxcXFx3LyxcXG4gICAgICAgICQgPSAvXig/OiMoW1xcXFx3LV0rKXwoXFxcXHcrKXxcXFxcLihbXFxcXHctXSspKSQvLFxcbiAgICAgICAgXyA9IC9bK35dLyxcXG4gICAgICAgIGFhID0gLyd8XFxcXFxcXFwvZyxcXG4gICAgICAgIGJhID0gbmV3IFJlZ0V4cChcXFwiXFxcXFxcXFxcXFxcXFxcXChbXFxcXFxcXFxkYS1mXXsxLDZ9XFxcIiArIEwgKyBcXFwiP3woXFxcIiArIEwgKyBcXFwiKXwuKVxcXCIsIFxcXCJpZ1xcXCIpLFxcbiAgICAgICAgY2EgPSBmdW5jdGlvbiBjYShhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQgPSBcXFwiMHhcXFwiICsgYiAtIDY1NTM2O3JldHVybiBkICE9PSBkIHx8IGMgPyBiIDogMCA+IGQgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGQgKyA2NTUzNikgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGQgPj4gMTAgfCA1NTI5NiwgMTAyMyAmIGQgfCA1NjMyMCk7XFxuICAgIH0sXFxuICAgICAgICBkYSA9IGZ1bmN0aW9uIGRhKCkge1xcbiAgICAgIG0oKTtcXG4gICAgfTt0cnkge1xcbiAgICAgIEguYXBwbHkoRSA9IEkuY2FsbCh2LmNoaWxkTm9kZXMpLCB2LmNoaWxkTm9kZXMpLCBFW3YuY2hpbGROb2Rlcy5sZW5ndGhdLm5vZGVUeXBlO1xcbiAgICB9IGNhdGNoIChlYSkge1xcbiAgICAgIEggPSB7IGFwcGx5OiBFLmxlbmd0aCA/IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICAgIEcuYXBwbHkoYSwgSS5jYWxsKGIpKTtcXG4gICAgICAgIH0gOiBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgICB2YXIgYyA9IGEubGVuZ3RoLFxcbiAgICAgICAgICAgICAgZCA9IDA7d2hpbGUgKGFbYysrXSA9IGJbZCsrXSkge31hLmxlbmd0aCA9IGMgLSAxO1xcbiAgICAgICAgfSB9O1xcbiAgICB9ZnVuY3Rpb24gZmEoYSwgYiwgZCwgZSkge1xcbiAgICAgIHZhciBmLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrLFxcbiAgICAgICAgICBsLFxcbiAgICAgICAgICBvLFxcbiAgICAgICAgICByLFxcbiAgICAgICAgICBzLFxcbiAgICAgICAgICB3ID0gYiAmJiBiLm93bmVyRG9jdW1lbnQsXFxuICAgICAgICAgIHggPSBiID8gYi5ub2RlVHlwZSA6IDk7aWYgKGQgPSBkIHx8IFtdLCBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYSB8fCAhYSB8fCAxICE9PSB4ICYmIDkgIT09IHggJiYgMTEgIT09IHgpIHJldHVybiBkO2lmICghZSAmJiAoKGIgPyBiLm93bmVyRG9jdW1lbnQgfHwgYiA6IHYpICE9PSBuICYmIG0oYiksIGIgPSBiIHx8IG4sIHApKSB7XFxuICAgICAgICBpZiAoMTEgIT09IHggJiYgKG8gPSAkLmV4ZWMoYSkpKSBpZiAoZiA9IG9bMV0pIHtcXG4gICAgICAgICAgaWYgKDkgPT09IHgpIHtcXG4gICAgICAgICAgICBpZiAoIShqID0gYi5nZXRFbGVtZW50QnlJZChmKSkpIHJldHVybiBkO2lmIChqLmlkID09PSBmKSByZXR1cm4gZC5wdXNoKGopLCBkO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKHcgJiYgKGogPSB3LmdldEVsZW1lbnRCeUlkKGYpKSAmJiB0KGIsIGopICYmIGouaWQgPT09IGYpIHJldHVybiBkLnB1c2goaiksIGQ7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBpZiAob1syXSkgcmV0dXJuIEguYXBwbHkoZCwgYi5nZXRFbGVtZW50c0J5VGFnTmFtZShhKSksIGQ7aWYgKChmID0gb1szXSkgJiYgYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSkgcmV0dXJuIEguYXBwbHkoZCwgYi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGYpKSwgZDtcXG4gICAgICAgIH1pZiAoYy5xc2EgJiYgIUFbYSArIFxcXCIgXFxcIl0gJiYgKCFxIHx8ICFxLnRlc3QoYSkpKSB7XFxuICAgICAgICAgIGlmICgxICE9PSB4KSB3ID0gYiwgcyA9IGE7ZWxzZSBpZiAoXFxcIm9iamVjdFxcXCIgIT09IGIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xcbiAgICAgICAgICAgIChrID0gYi5nZXRBdHRyaWJ1dGUoXFxcImlkXFxcIikpID8gayA9IGsucmVwbGFjZShhYSwgXFxcIlxcXFxcXFxcJCZcXFwiKSA6IGIuc2V0QXR0cmlidXRlKFxcXCJpZFxcXCIsIGsgPSB1KSwgciA9IGcoYSksIGggPSByLmxlbmd0aCwgbCA9IFYudGVzdChrKSA/IFxcXCIjXFxcIiArIGsgOiBcXFwiW2lkPSdcXFwiICsgayArIFxcXCInXVxcXCI7d2hpbGUgKGgtLSkge1xcbiAgICAgICAgICAgICAgcltoXSA9IGwgKyBcXFwiIFxcXCIgKyBxYShyW2hdKTtcXG4gICAgICAgICAgICB9cyA9IHIuam9pbihcXFwiLFxcXCIpLCB3ID0gXy50ZXN0KGEpICYmIG9hKGIucGFyZW50Tm9kZSkgfHwgYjtcXG4gICAgICAgICAgfWlmIChzKSB0cnkge1xcbiAgICAgICAgICAgIHJldHVybiBILmFwcGx5KGQsIHcucXVlcnlTZWxlY3RvckFsbChzKSksIGQ7XFxuICAgICAgICAgIH0gY2F0Y2ggKHkpIHt9IGZpbmFsbHkge1xcbiAgICAgICAgICAgIGsgPT09IHUgJiYgYi5yZW1vdmVBdHRyaWJ1dGUoXFxcImlkXFxcIik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9cmV0dXJuIGkoYS5yZXBsYWNlKFEsIFxcXCIkMVxcXCIpLCBiLCBkLCBlKTtcXG4gICAgfWZ1bmN0aW9uIGdhKCkge1xcbiAgICAgIHZhciBhID0gW107ZnVuY3Rpb24gYihjLCBlKSB7XFxuICAgICAgICByZXR1cm4gYS5wdXNoKGMgKyBcXFwiIFxcXCIpID4gZC5jYWNoZUxlbmd0aCAmJiBkZWxldGUgYlthLnNoaWZ0KCldLCBiW2MgKyBcXFwiIFxcXCJdID0gZTtcXG4gICAgICB9cmV0dXJuIGI7XFxuICAgIH1mdW5jdGlvbiBoYShhKSB7XFxuICAgICAgcmV0dXJuIGFbdV0gPSAhMCwgYTtcXG4gICAgfWZ1bmN0aW9uIGlhKGEpIHtcXG4gICAgICB2YXIgYiA9IG4uY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7dHJ5IHtcXG4gICAgICAgIHJldHVybiAhIWEoYik7XFxuICAgICAgfSBjYXRjaCAoYykge1xcbiAgICAgICAgcmV0dXJuICExO1xcbiAgICAgIH0gZmluYWxseSB7XFxuICAgICAgICBiLnBhcmVudE5vZGUgJiYgYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpLCBiID0gbnVsbDtcXG4gICAgICB9XFxuICAgIH1mdW5jdGlvbiBqYShhLCBiKSB7XFxuICAgICAgdmFyIGMgPSBhLnNwbGl0KFxcXCJ8XFxcIiksXFxuICAgICAgICAgIGUgPSBjLmxlbmd0aDt3aGlsZSAoZS0tKSB7XFxuICAgICAgICBkLmF0dHJIYW5kbGVbY1tlXV0gPSBiO1xcbiAgICAgIH1cXG4gICAgfWZ1bmN0aW9uIGthKGEsIGIpIHtcXG4gICAgICB2YXIgYyA9IGIgJiYgYSxcXG4gICAgICAgICAgZCA9IGMgJiYgMSA9PT0gYS5ub2RlVHlwZSAmJiAxID09PSBiLm5vZGVUeXBlICYmICh+Yi5zb3VyY2VJbmRleCB8fCBDKSAtICh+YS5zb3VyY2VJbmRleCB8fCBDKTtpZiAoZCkgcmV0dXJuIGQ7aWYgKGMpIHdoaWxlIChjID0gYy5uZXh0U2libGluZykge1xcbiAgICAgICAgaWYgKGMgPT09IGIpIHJldHVybiAtMTtcXG4gICAgICB9cmV0dXJuIGEgPyAxIDogLTE7XFxuICAgIH1mdW5jdGlvbiBsYShhKSB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICB2YXIgYyA9IGIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gXFxcImlucHV0XFxcIiA9PT0gYyAmJiBiLnR5cGUgPT09IGE7XFxuICAgICAgfTtcXG4gICAgfWZ1bmN0aW9uIG1hKGEpIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgIHZhciBjID0gYi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybiAoXFxcImlucHV0XFxcIiA9PT0gYyB8fCBcXFwiYnV0dG9uXFxcIiA9PT0gYykgJiYgYi50eXBlID09PSBhO1xcbiAgICAgIH07XFxuICAgIH1mdW5jdGlvbiBuYShhKSB7XFxuICAgICAgcmV0dXJuIGhhKGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICByZXR1cm4gYiA9ICtiLCBoYShmdW5jdGlvbiAoYywgZCkge1xcbiAgICAgICAgICB2YXIgZSxcXG4gICAgICAgICAgICAgIGYgPSBhKFtdLCBjLmxlbmd0aCwgYiksXFxuICAgICAgICAgICAgICBnID0gZi5sZW5ndGg7d2hpbGUgKGctLSkge1xcbiAgICAgICAgICAgIGNbZSA9IGZbZ11dICYmIChjW2VdID0gIShkW2VdID0gY1tlXSkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgfWZ1bmN0aW9uIG9hKGEpIHtcXG4gICAgICByZXR1cm4gYSAmJiBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgYS5nZXRFbGVtZW50c0J5VGFnTmFtZSAmJiBhO1xcbiAgICB9YyA9IGZhLnN1cHBvcnQgPSB7fSwgZiA9IGZhLmlzWE1MID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICB2YXIgYiA9IGEgJiYgKGEub3duZXJEb2N1bWVudCB8fCBhKS5kb2N1bWVudEVsZW1lbnQ7cmV0dXJuIGIgPyBcXFwiSFRNTFxcXCIgIT09IGIubm9kZU5hbWUgOiAhMTtcXG4gICAgfSwgbSA9IGZhLnNldERvY3VtZW50ID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZyA9IGEgPyBhLm93bmVyRG9jdW1lbnQgfHwgYSA6IHY7cmV0dXJuIGcgIT09IG4gJiYgOSA9PT0gZy5ub2RlVHlwZSAmJiBnLmRvY3VtZW50RWxlbWVudCA/IChuID0gZywgbyA9IG4uZG9jdW1lbnRFbGVtZW50LCBwID0gIWYobiksIChlID0gbi5kZWZhdWx0VmlldykgJiYgZS50b3AgIT09IGUgJiYgKGUuYWRkRXZlbnRMaXN0ZW5lciA/IGUuYWRkRXZlbnRMaXN0ZW5lcihcXFwidW5sb2FkXFxcIiwgZGEsICExKSA6IGUuYXR0YWNoRXZlbnQgJiYgZS5hdHRhY2hFdmVudChcXFwib251bmxvYWRcXFwiLCBkYSkpLCBjLmF0dHJpYnV0ZXMgPSBpYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgcmV0dXJuIGEuY2xhc3NOYW1lID0gXFxcImlcXFwiLCAhYS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzTmFtZVxcXCIpO1xcbiAgICAgIH0pLCBjLmdldEVsZW1lbnRzQnlUYWdOYW1lID0gaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHJldHVybiBhLmFwcGVuZENoaWxkKG4uY3JlYXRlQ29tbWVudChcXFwiXFxcIikpLCAhYS5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiKlxcXCIpLmxlbmd0aDtcXG4gICAgICB9KSwgYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gWi50ZXN0KG4uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSksIGMuZ2V0QnlJZCA9IGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICByZXR1cm4gby5hcHBlbmRDaGlsZChhKS5pZCA9IHUsICFuLmdldEVsZW1lbnRzQnlOYW1lIHx8ICFuLmdldEVsZW1lbnRzQnlOYW1lKHUpLmxlbmd0aDtcXG4gICAgICB9KSwgYy5nZXRCeUlkID8gKGQuZmluZC5JRCA9IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICBpZiAoXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGIuZ2V0RWxlbWVudEJ5SWQgJiYgcCkge1xcbiAgICAgICAgICB2YXIgYyA9IGIuZ2V0RWxlbWVudEJ5SWQoYSk7cmV0dXJuIGMgPyBbY10gOiBbXTtcXG4gICAgICAgIH1cXG4gICAgICB9LCBkLmZpbHRlci5JRCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB2YXIgYiA9IGEucmVwbGFjZShiYSwgY2EpO3JldHVybiBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICByZXR1cm4gYS5nZXRBdHRyaWJ1dGUoXFxcImlkXFxcIikgPT09IGI7XFxuICAgICAgICB9O1xcbiAgICAgIH0pIDogKGRlbGV0ZSBkLmZpbmQuSUQsIGQuZmlsdGVyLklEID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHZhciBiID0gYS5yZXBsYWNlKGJhLCBjYSk7cmV0dXJuIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgIHZhciBjID0gXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGEuZ2V0QXR0cmlidXRlTm9kZSAmJiBhLmdldEF0dHJpYnV0ZU5vZGUoXFxcImlkXFxcIik7cmV0dXJuIGMgJiYgYy52YWx1ZSA9PT0gYjtcXG4gICAgICAgIH07XFxuICAgICAgfSksIGQuZmluZC5UQUcgPSBjLmdldEVsZW1lbnRzQnlUYWdOYW1lID8gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIHJldHVybiBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgYi5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSkgOiBjLnFzYSA/IGIucXVlcnlTZWxlY3RvckFsbChhKSA6IHZvaWQgMDtcXG4gICAgICB9IDogZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgIGQgPSBbXSxcXG4gICAgICAgICAgICBlID0gMCxcXG4gICAgICAgICAgICBmID0gYi5nZXRFbGVtZW50c0J5VGFnTmFtZShhKTtpZiAoXFxcIipcXFwiID09PSBhKSB7XFxuICAgICAgICAgIHdoaWxlIChjID0gZltlKytdKSB7XFxuICAgICAgICAgICAgMSA9PT0gYy5ub2RlVHlwZSAmJiBkLnB1c2goYyk7XFxuICAgICAgICAgIH1yZXR1cm4gZDtcXG4gICAgICAgIH1yZXR1cm4gZjtcXG4gICAgICB9LCBkLmZpbmQuQ0xBU1MgPSBjLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIHJldHVybiBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgYi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIHAgPyBiLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYSkgOiB2b2lkIDA7XFxuICAgICAgfSwgciA9IFtdLCBxID0gW10sIChjLnFzYSA9IFoudGVzdChuLnF1ZXJ5U2VsZWN0b3JBbGwpKSAmJiAoaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIG8uYXBwZW5kQ2hpbGQoYSkuaW5uZXJIVE1MID0gXFxcIjxhIGlkPSdcXFwiICsgdSArIFxcXCInPjwvYT48c2VsZWN0IGlkPSdcXFwiICsgdSArIFxcXCItXFxcXHJcXFxcXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+PG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cXFwiLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIlttc2FsbG93Y2FwdHVyZV49JyddXFxcIikubGVuZ3RoICYmIHEucHVzaChcXFwiWypeJF09XFxcIiArIEwgKyBcXFwiKig/OicnfFxcXFxcXFwiXFxcXFxcXCIpXFxcIiksIGEucXVlcnlTZWxlY3RvckFsbChcXFwiW3NlbGVjdGVkXVxcXCIpLmxlbmd0aCB8fCBxLnB1c2goXFxcIlxcXFxcXFxcW1xcXCIgKyBMICsgXFxcIiooPzp2YWx1ZXxcXFwiICsgSyArIFxcXCIpXFxcIiksIGEucXVlcnlTZWxlY3RvckFsbChcXFwiW2lkfj1cXFwiICsgdSArIFxcXCItXVxcXCIpLmxlbmd0aCB8fCBxLnB1c2goXFxcIn49XFxcIiksIGEucXVlcnlTZWxlY3RvckFsbChcXFwiOmNoZWNrZWRcXFwiKS5sZW5ndGggfHwgcS5wdXNoKFxcXCI6Y2hlY2tlZFxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcImEjXFxcIiArIHUgKyBcXFwiKypcXFwiKS5sZW5ndGggfHwgcS5wdXNoKFxcXCIuIy4rWyt+XVxcXCIpO1xcbiAgICAgIH0pLCBpYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgdmFyIGIgPSBuLmNyZWF0ZUVsZW1lbnQoXFxcImlucHV0XFxcIik7Yi5zZXRBdHRyaWJ1dGUoXFxcInR5cGVcXFwiLCBcXFwiaGlkZGVuXFxcIiksIGEuYXBwZW5kQ2hpbGQoYikuc2V0QXR0cmlidXRlKFxcXCJuYW1lXFxcIiwgXFxcIkRcXFwiKSwgYS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJbbmFtZT1kXVxcXCIpLmxlbmd0aCAmJiBxLnB1c2goXFxcIm5hbWVcXFwiICsgTCArIFxcXCIqWypeJHwhfl0/PVxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIjplbmFibGVkXFxcIikubGVuZ3RoIHx8IHEucHVzaChcXFwiOmVuYWJsZWRcXFwiLCBcXFwiOmRpc2FibGVkXFxcIiksIGEucXVlcnlTZWxlY3RvckFsbChcXFwiKiw6eFxcXCIpLCBxLnB1c2goXFxcIiwuKjpcXFwiKTtcXG4gICAgICB9KSksIChjLm1hdGNoZXNTZWxlY3RvciA9IFoudGVzdChzID0gby5tYXRjaGVzIHx8IG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IG8ubW96TWF0Y2hlc1NlbGVjdG9yIHx8IG8ub01hdGNoZXNTZWxlY3RvciB8fCBvLm1zTWF0Y2hlc1NlbGVjdG9yKSkgJiYgaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIGMuZGlzY29ubmVjdGVkTWF0Y2ggPSBzLmNhbGwoYSwgXFxcImRpdlxcXCIpLCBzLmNhbGwoYSwgXFxcIltzIT0nJ106eFxcXCIpLCByLnB1c2goXFxcIiE9XFxcIiwgTyk7XFxuICAgICAgfSksIHEgPSBxLmxlbmd0aCAmJiBuZXcgUmVnRXhwKHEuam9pbihcXFwifFxcXCIpKSwgciA9IHIubGVuZ3RoICYmIG5ldyBSZWdFeHAoci5qb2luKFxcXCJ8XFxcIikpLCBiID0gWi50ZXN0KG8uY29tcGFyZURvY3VtZW50UG9zaXRpb24pLCB0ID0gYiB8fCBaLnRlc3Qoby5jb250YWlucykgPyBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgdmFyIGMgPSA5ID09PSBhLm5vZGVUeXBlID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxcbiAgICAgICAgICAgIGQgPSBiICYmIGIucGFyZW50Tm9kZTtyZXR1cm4gYSA9PT0gZCB8fCAhKCFkIHx8IDEgIT09IGQubm9kZVR5cGUgfHwgIShjLmNvbnRhaW5zID8gYy5jb250YWlucyhkKSA6IGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgMTYgJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGQpKSk7XFxuICAgICAgfSA6IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICBpZiAoYikgd2hpbGUgKGIgPSBiLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgaWYgKGIgPT09IGEpIHJldHVybiAhMDtcXG4gICAgICAgIH1yZXR1cm4gITE7XFxuICAgICAgfSwgQiA9IGIgPyBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgaWYgKGEgPT09IGIpIHJldHVybiBsID0gITAsIDA7dmFyIGQgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO3JldHVybiBkID8gZCA6IChkID0gKGEub3duZXJEb2N1bWVudCB8fCBhKSA9PT0gKGIub3duZXJEb2N1bWVudCB8fCBiKSA/IGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgOiAxLCAxICYgZCB8fCAhYy5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihhKSA9PT0gZCA/IGEgPT09IG4gfHwgYS5vd25lckRvY3VtZW50ID09PSB2ICYmIHQodiwgYSkgPyAtMSA6IGIgPT09IG4gfHwgYi5vd25lckRvY3VtZW50ID09PSB2ICYmIHQodiwgYikgPyAxIDogayA/IEooaywgYSkgLSBKKGssIGIpIDogMCA6IDQgJiBkID8gLTEgOiAxKTtcXG4gICAgICB9IDogZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIGlmIChhID09PSBiKSByZXR1cm4gbCA9ICEwLCAwO3ZhciBjLFxcbiAgICAgICAgICAgIGQgPSAwLFxcbiAgICAgICAgICAgIGUgPSBhLnBhcmVudE5vZGUsXFxuICAgICAgICAgICAgZiA9IGIucGFyZW50Tm9kZSxcXG4gICAgICAgICAgICBnID0gW2FdLFxcbiAgICAgICAgICAgIGggPSBbYl07aWYgKCFlIHx8ICFmKSByZXR1cm4gYSA9PT0gbiA/IC0xIDogYiA9PT0gbiA/IDEgOiBlID8gLTEgOiBmID8gMSA6IGsgPyBKKGssIGEpIC0gSihrLCBiKSA6IDA7aWYgKGUgPT09IGYpIHJldHVybiBrYShhLCBiKTtjID0gYTt3aGlsZSAoYyA9IGMucGFyZW50Tm9kZSkge1xcbiAgICAgICAgICBnLnVuc2hpZnQoYyk7XFxuICAgICAgICB9YyA9IGI7d2hpbGUgKGMgPSBjLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgaC51bnNoaWZ0KGMpO1xcbiAgICAgICAgfXdoaWxlIChnW2RdID09PSBoW2RdKSB7XFxuICAgICAgICAgIGQrKztcXG4gICAgICAgIH1yZXR1cm4gZCA/IGthKGdbZF0sIGhbZF0pIDogZ1tkXSA9PT0gdiA/IC0xIDogaFtkXSA9PT0gdiA/IDEgOiAwO1xcbiAgICAgIH0sIG4pIDogbjtcXG4gICAgfSwgZmEubWF0Y2hlcyA9IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgcmV0dXJuIGZhKGEsIG51bGwsIG51bGwsIGIpO1xcbiAgICB9LCBmYS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIGlmICgoYS5vd25lckRvY3VtZW50IHx8IGEpICE9PSBuICYmIG0oYSksIGIgPSBiLnJlcGxhY2UoVCwgXFxcIj0nJDEnXVxcXCIpLCBjLm1hdGNoZXNTZWxlY3RvciAmJiBwICYmICFBW2IgKyBcXFwiIFxcXCJdICYmICghciB8fCAhci50ZXN0KGIpKSAmJiAoIXEgfHwgIXEudGVzdChiKSkpIHRyeSB7XFxuICAgICAgICB2YXIgZCA9IHMuY2FsbChhLCBiKTtpZiAoZCB8fCBjLmRpc2Nvbm5lY3RlZE1hdGNoIHx8IGEuZG9jdW1lbnQgJiYgMTEgIT09IGEuZG9jdW1lbnQubm9kZVR5cGUpIHJldHVybiBkO1xcbiAgICAgIH0gY2F0Y2ggKGUpIHt9cmV0dXJuIGZhKGIsIG4sIG51bGwsIFthXSkubGVuZ3RoID4gMDtcXG4gICAgfSwgZmEuY29udGFpbnMgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIHJldHVybiAoYS5vd25lckRvY3VtZW50IHx8IGEpICE9PSBuICYmIG0oYSksIHQoYSwgYik7XFxuICAgIH0sIGZhLmF0dHIgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIChhLm93bmVyRG9jdW1lbnQgfHwgYSkgIT09IG4gJiYgbShhKTt2YXIgZSA9IGQuYXR0ckhhbmRsZVtiLnRvTG93ZXJDYXNlKCldLFxcbiAgICAgICAgICBmID0gZSAmJiBELmNhbGwoZC5hdHRySGFuZGxlLCBiLnRvTG93ZXJDYXNlKCkpID8gZShhLCBiLCAhcCkgOiB2b2lkIDA7cmV0dXJuIHZvaWQgMCAhPT0gZiA/IGYgOiBjLmF0dHJpYnV0ZXMgfHwgIXAgPyBhLmdldEF0dHJpYnV0ZShiKSA6IChmID0gYS5nZXRBdHRyaWJ1dGVOb2RlKGIpKSAmJiBmLnNwZWNpZmllZCA/IGYudmFsdWUgOiBudWxsO1xcbiAgICB9LCBmYS5lcnJvciA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcXFwiICsgYSk7XFxuICAgIH0sIGZhLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBkID0gW10sXFxuICAgICAgICAgIGUgPSAwLFxcbiAgICAgICAgICBmID0gMDtpZiAobCA9ICFjLmRldGVjdER1cGxpY2F0ZXMsIGsgPSAhYy5zb3J0U3RhYmxlICYmIGEuc2xpY2UoMCksIGEuc29ydChCKSwgbCkge1xcbiAgICAgICAgd2hpbGUgKGIgPSBhW2YrK10pIHtcXG4gICAgICAgICAgYiA9PT0gYVtmXSAmJiAoZSA9IGQucHVzaChmKSk7XFxuICAgICAgICB9d2hpbGUgKGUtLSkge1xcbiAgICAgICAgICBhLnNwbGljZShkW2VdLCAxKTtcXG4gICAgICAgIH1cXG4gICAgICB9cmV0dXJuIGsgPSBudWxsLCBhO1xcbiAgICB9LCBlID0gZmEuZ2V0VGV4dCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGMgPSBcXFwiXFxcIixcXG4gICAgICAgICAgZCA9IDAsXFxuICAgICAgICAgIGYgPSBhLm5vZGVUeXBlO2lmIChmKSB7XFxuICAgICAgICBpZiAoMSA9PT0gZiB8fCA5ID09PSBmIHx8IDExID09PSBmKSB7XFxuICAgICAgICAgIGlmIChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYS50ZXh0Q29udGVudCkgcmV0dXJuIGEudGV4dENvbnRlbnQ7Zm9yIChhID0gYS5maXJzdENoaWxkOyBhOyBhID0gYS5uZXh0U2libGluZykge1xcbiAgICAgICAgICAgIGMgKz0gZShhKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmICgzID09PSBmIHx8IDQgPT09IGYpIHJldHVybiBhLm5vZGVWYWx1ZTtcXG4gICAgICB9IGVsc2Ugd2hpbGUgKGIgPSBhW2QrK10pIHtcXG4gICAgICAgIGMgKz0gZShiKTtcXG4gICAgICB9cmV0dXJuIGM7XFxuICAgIH0sIGQgPSBmYS5zZWxlY3RvcnMgPSB7IGNhY2hlTGVuZ3RoOiA1MCwgY3JlYXRlUHNldWRvOiBoYSwgbWF0Y2g6IFcsIGF0dHJIYW5kbGU6IHt9LCBmaW5kOiB7fSwgcmVsYXRpdmU6IHsgXFxcIj5cXFwiOiB7IGRpcjogXFxcInBhcmVudE5vZGVcXFwiLCBmaXJzdDogITAgfSwgXFxcIiBcXFwiOiB7IGRpcjogXFxcInBhcmVudE5vZGVcXFwiIH0sIFxcXCIrXFxcIjogeyBkaXI6IFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiLCBmaXJzdDogITAgfSwgXFxcIn5cXFwiOiB7IGRpcjogXFxcInByZXZpb3VzU2libGluZ1xcXCIgfSB9LCBwcmVGaWx0ZXI6IHsgQVRUUjogZnVuY3Rpb24gQVRUUihhKSB7XFxuICAgICAgICAgIHJldHVybiBhWzFdID0gYVsxXS5yZXBsYWNlKGJhLCBjYSksIGFbM10gPSAoYVszXSB8fCBhWzRdIHx8IGFbNV0gfHwgXFxcIlxcXCIpLnJlcGxhY2UoYmEsIGNhKSwgXFxcIn49XFxcIiA9PT0gYVsyXSAmJiAoYVszXSA9IFxcXCIgXFxcIiArIGFbM10gKyBcXFwiIFxcXCIpLCBhLnNsaWNlKDAsIDQpO1xcbiAgICAgICAgfSwgQ0hJTEQ6IGZ1bmN0aW9uIENISUxEKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGFbMV0gPSBhWzFdLnRvTG93ZXJDYXNlKCksIFxcXCJudGhcXFwiID09PSBhWzFdLnNsaWNlKDAsIDMpID8gKGFbM10gfHwgZmEuZXJyb3IoYVswXSksIGFbNF0gPSArKGFbNF0gPyBhWzVdICsgKGFbNl0gfHwgMSkgOiAyICogKFxcXCJldmVuXFxcIiA9PT0gYVszXSB8fCBcXFwib2RkXFxcIiA9PT0gYVszXSkpLCBhWzVdID0gKyhhWzddICsgYVs4XSB8fCBcXFwib2RkXFxcIiA9PT0gYVszXSkpIDogYVszXSAmJiBmYS5lcnJvcihhWzBdKSwgYTtcXG4gICAgICAgIH0sIFBTRVVETzogZnVuY3Rpb24gUFNFVURPKGEpIHtcXG4gICAgICAgICAgdmFyIGIsXFxuICAgICAgICAgICAgICBjID0gIWFbNl0gJiYgYVsyXTtyZXR1cm4gVy5DSElMRC50ZXN0KGFbMF0pID8gbnVsbCA6IChhWzNdID8gYVsyXSA9IGFbNF0gfHwgYVs1XSB8fCBcXFwiXFxcIiA6IGMgJiYgVS50ZXN0KGMpICYmIChiID0gZyhjLCAhMCkpICYmIChiID0gYy5pbmRleE9mKFxcXCIpXFxcIiwgYy5sZW5ndGggLSBiKSAtIGMubGVuZ3RoKSAmJiAoYVswXSA9IGFbMF0uc2xpY2UoMCwgYiksIGFbMl0gPSBjLnNsaWNlKDAsIGIpKSwgYS5zbGljZSgwLCAzKSk7XFxuICAgICAgICB9IH0sIGZpbHRlcjogeyBUQUc6IGZ1bmN0aW9uIFRBRyhhKSB7XFxuICAgICAgICAgIHZhciBiID0gYS5yZXBsYWNlKGJhLCBjYSkudG9Mb3dlckNhc2UoKTtyZXR1cm4gXFxcIipcXFwiID09PSBhID8gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJldHVybiAhMDtcXG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGEubm9kZU5hbWUgJiYgYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBiO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSwgQ0xBU1M6IGZ1bmN0aW9uIENMQVNTKGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSB5W2EgKyBcXFwiIFxcXCJdO3JldHVybiBiIHx8IChiID0gbmV3IFJlZ0V4cChcXFwiKF58XFxcIiArIEwgKyBcXFwiKVxcXCIgKyBhICsgXFxcIihcXFwiICsgTCArIFxcXCJ8JClcXFwiKSkgJiYgeShhLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICAgIHJldHVybiBiLnRlc3QoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGEuY2xhc3NOYW1lICYmIGEuY2xhc3NOYW1lIHx8IFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiBhLmdldEF0dHJpYnV0ZSAmJiBhLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKSB8fCBcXFwiXFxcIik7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSwgQVRUUjogZnVuY3Rpb24gQVRUUihhLCBiLCBjKSB7XFxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xcbiAgICAgICAgICAgIHZhciBlID0gZmEuYXR0cihkLCBhKTtyZXR1cm4gbnVsbCA9PSBlID8gXFxcIiE9XFxcIiA9PT0gYiA6IGIgPyAoZSArPSBcXFwiXFxcIiwgXFxcIj1cXFwiID09PSBiID8gZSA9PT0gYyA6IFxcXCIhPVxcXCIgPT09IGIgPyBlICE9PSBjIDogXFxcIl49XFxcIiA9PT0gYiA/IGMgJiYgMCA9PT0gZS5pbmRleE9mKGMpIDogXFxcIio9XFxcIiA9PT0gYiA/IGMgJiYgZS5pbmRleE9mKGMpID4gLTEgOiBcXFwiJD1cXFwiID09PSBiID8gYyAmJiBlLnNsaWNlKC1jLmxlbmd0aCkgPT09IGMgOiBcXFwifj1cXFwiID09PSBiID8gKFxcXCIgXFxcIiArIGUucmVwbGFjZShQLCBcXFwiIFxcXCIpICsgXFxcIiBcXFwiKS5pbmRleE9mKGMpID4gLTEgOiBcXFwifD1cXFwiID09PSBiID8gZSA9PT0gYyB8fCBlLnNsaWNlKDAsIGMubGVuZ3RoICsgMSkgPT09IGMgKyBcXFwiLVxcXCIgOiAhMSkgOiAhMDtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0sIENISUxEOiBmdW5jdGlvbiBDSElMRChhLCBiLCBjLCBkLCBlKSB7XFxuICAgICAgICAgIHZhciBmID0gXFxcIm50aFxcXCIgIT09IGEuc2xpY2UoMCwgMyksXFxuICAgICAgICAgICAgICBnID0gXFxcImxhc3RcXFwiICE9PSBhLnNsaWNlKC00KSxcXG4gICAgICAgICAgICAgIGggPSBcXFwib2YtdHlwZVxcXCIgPT09IGI7cmV0dXJuIDEgPT09IGQgJiYgMCA9PT0gZSA/IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgICAgcmV0dXJuICEhYS5wYXJlbnROb2RlO1xcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKGIsIGMsIGkpIHtcXG4gICAgICAgICAgICB2YXIgaixcXG4gICAgICAgICAgICAgICAgayxcXG4gICAgICAgICAgICAgICAgbCxcXG4gICAgICAgICAgICAgICAgbSxcXG4gICAgICAgICAgICAgICAgbixcXG4gICAgICAgICAgICAgICAgbyxcXG4gICAgICAgICAgICAgICAgcCA9IGYgIT09IGcgPyBcXFwibmV4dFNpYmxpbmdcXFwiIDogXFxcInByZXZpb3VzU2libGluZ1xcXCIsXFxuICAgICAgICAgICAgICAgIHEgPSBiLnBhcmVudE5vZGUsXFxuICAgICAgICAgICAgICAgIHIgPSBoICYmIGIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcXG4gICAgICAgICAgICAgICAgcyA9ICFpICYmICFoLFxcbiAgICAgICAgICAgICAgICB0ID0gITE7aWYgKHEpIHtcXG4gICAgICAgICAgICAgIGlmIChmKSB7XFxuICAgICAgICAgICAgICAgIHdoaWxlIChwKSB7XFxuICAgICAgICAgICAgICAgICAgbSA9IGI7d2hpbGUgKG0gPSBtW3BdKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoaCA/IG0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gciA6IDEgPT09IG0ubm9kZVR5cGUpIHJldHVybiAhMTtcXG4gICAgICAgICAgICAgICAgICB9byA9IHAgPSBcXFwib25seVxcXCIgPT09IGEgJiYgIW8gJiYgXFxcIm5leHRTaWJsaW5nXFxcIjtcXG4gICAgICAgICAgICAgICAgfXJldHVybiAhMDtcXG4gICAgICAgICAgICAgIH1pZiAobyA9IFtnID8gcS5maXJzdENoaWxkIDogcS5sYXN0Q2hpbGRdLCBnICYmIHMpIHtcXG4gICAgICAgICAgICAgICAgbSA9IHEsIGwgPSBtW3VdIHx8IChtW3VdID0ge30pLCBrID0gbFttLnVuaXF1ZUlEXSB8fCAobFttLnVuaXF1ZUlEXSA9IHt9KSwgaiA9IGtbYV0gfHwgW10sIG4gPSBqWzBdID09PSB3ICYmIGpbMV0sIHQgPSBuICYmIGpbMl0sIG0gPSBuICYmIHEuY2hpbGROb2Rlc1tuXTt3aGlsZSAobSA9ICsrbiAmJiBtICYmIG1bcF0gfHwgKHQgPSBuID0gMCkgfHwgby5wb3AoKSkge1xcbiAgICAgICAgICAgICAgICAgIGlmICgxID09PSBtLm5vZGVUeXBlICYmICsrdCAmJiBtID09PSBiKSB7XFxuICAgICAgICAgICAgICAgICAgICBrW2FdID0gW3csIG4sIHRdO2JyZWFrO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzICYmIChtID0gYiwgbCA9IG1bdV0gfHwgKG1bdV0gPSB7fSksIGsgPSBsW20udW5pcXVlSURdIHx8IChsW20udW5pcXVlSURdID0ge30pLCBqID0ga1thXSB8fCBbXSwgbiA9IGpbMF0gPT09IHcgJiYgalsxXSwgdCA9IG4pLCB0ID09PSAhMSkgd2hpbGUgKG0gPSArK24gJiYgbSAmJiBtW3BdIHx8ICh0ID0gbiA9IDApIHx8IG8ucG9wKCkpIHtcXG4gICAgICAgICAgICAgICAgaWYgKChoID8gbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSByIDogMSA9PT0gbS5ub2RlVHlwZSkgJiYgKyt0ICYmIChzICYmIChsID0gbVt1XSB8fCAobVt1XSA9IHt9KSwgayA9IGxbbS51bmlxdWVJRF0gfHwgKGxbbS51bmlxdWVJRF0gPSB7fSksIGtbYV0gPSBbdywgdF0pLCBtID09PSBiKSkgYnJlYWs7XFxuICAgICAgICAgICAgICB9cmV0dXJuIHQgLT0gZSwgdCA9PT0gZCB8fCB0ICUgZCA9PT0gMCAmJiB0IC8gZCA+PSAwO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0sIFBTRVVETzogZnVuY3Rpb24gUFNFVURPKGEsIGIpIHtcXG4gICAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgICBlID0gZC5wc2V1ZG9zW2FdIHx8IGQuc2V0RmlsdGVyc1thLnRvTG93ZXJDYXNlKCldIHx8IGZhLmVycm9yKFxcXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFxcXCIgKyBhKTtyZXR1cm4gZVt1XSA/IGUoYikgOiBlLmxlbmd0aCA+IDEgPyAoYyA9IFthLCBhLCBcXFwiXFxcIiwgYl0sIGQuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eShhLnRvTG93ZXJDYXNlKCkpID8gaGEoZnVuY3Rpb24gKGEsIGMpIHtcXG4gICAgICAgICAgICB2YXIgZCxcXG4gICAgICAgICAgICAgICAgZiA9IGUoYSwgYiksXFxuICAgICAgICAgICAgICAgIGcgPSBmLmxlbmd0aDt3aGlsZSAoZy0tKSB7XFxuICAgICAgICAgICAgICBkID0gSihhLCBmW2ddKSwgYVtkXSA9ICEoY1tkXSA9IGZbZ10pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSkgOiBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICAgIHJldHVybiBlKGEsIDAsIGMpO1xcbiAgICAgICAgICB9KSA6IGU7XFxuICAgICAgICB9IH0sIHBzZXVkb3M6IHsgbm90OiBoYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICB2YXIgYiA9IFtdLFxcbiAgICAgICAgICAgICAgYyA9IFtdLFxcbiAgICAgICAgICAgICAgZCA9IGgoYS5yZXBsYWNlKFEsIFxcXCIkMVxcXCIpKTtyZXR1cm4gZFt1XSA/IGhhKGZ1bmN0aW9uIChhLCBiLCBjLCBlKSB7XFxuICAgICAgICAgICAgdmFyIGYsXFxuICAgICAgICAgICAgICAgIGcgPSBkKGEsIG51bGwsIGUsIFtdKSxcXG4gICAgICAgICAgICAgICAgaCA9IGEubGVuZ3RoO3doaWxlIChoLS0pIHtcXG4gICAgICAgICAgICAgIChmID0gZ1toXSkgJiYgKGFbaF0gPSAhKGJbaF0gPSBmKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KSA6IGZ1bmN0aW9uIChhLCBlLCBmKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGJbMF0gPSBhLCBkKGIsIG51bGwsIGYsIGMpLCBiWzBdID0gbnVsbCwgIWMucG9wKCk7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9KSwgaGFzOiBoYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmEoYSwgYikubGVuZ3RoID4gMDtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0pLCBjb250YWluczogaGEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGEgPSBhLnJlcGxhY2UoYmEsIGNhKSwgZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgICAgICByZXR1cm4gKGIudGV4dENvbnRlbnQgfHwgYi5pbm5lclRleHQgfHwgZShiKSkuaW5kZXhPZihhKSA+IC0xO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSksIGxhbmc6IGhhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgIHJldHVybiBWLnRlc3QoYSB8fCBcXFwiXFxcIikgfHwgZmEuZXJyb3IoXFxcInVuc3VwcG9ydGVkIGxhbmc6IFxcXCIgKyBhKSwgYSA9IGEucmVwbGFjZShiYSwgY2EpLnRvTG93ZXJDYXNlKCksIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICAgICAgdmFyIGM7ZG8ge1xcbiAgICAgICAgICAgICAgaWYgKGMgPSBwID8gYi5sYW5nIDogYi5nZXRBdHRyaWJ1dGUoXFxcInhtbDpsYW5nXFxcIikgfHwgYi5nZXRBdHRyaWJ1dGUoXFxcImxhbmdcXFwiKSkgcmV0dXJuIGMgPSBjLnRvTG93ZXJDYXNlKCksIGMgPT09IGEgfHwgMCA9PT0gYy5pbmRleE9mKGEgKyBcXFwiLVxcXCIpO1xcbiAgICAgICAgICAgIH0gd2hpbGUgKChiID0gYi5wYXJlbnROb2RlKSAmJiAxID09PSBiLm5vZGVUeXBlKTtyZXR1cm4gITE7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9KSwgdGFyZ2V0OiBmdW5jdGlvbiB0YXJnZXQoYikge1xcbiAgICAgICAgICB2YXIgYyA9IGEubG9jYXRpb24gJiYgYS5sb2NhdGlvbi5oYXNoO3JldHVybiBjICYmIGMuc2xpY2UoMSkgPT09IGIuaWQ7XFxuICAgICAgICB9LCByb290OiBmdW5jdGlvbiByb290KGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGEgPT09IG87XFxuICAgICAgICB9LCBmb2N1czogZnVuY3Rpb24gZm9jdXMoYSkge1xcbiAgICAgICAgICByZXR1cm4gYSA9PT0gbi5hY3RpdmVFbGVtZW50ICYmICghbi5oYXNGb2N1cyB8fCBuLmhhc0ZvY3VzKCkpICYmICEhKGEudHlwZSB8fCBhLmhyZWYgfHwgfmEudGFiSW5kZXgpO1xcbiAgICAgICAgfSwgZW5hYmxlZDogZnVuY3Rpb24gZW5hYmxlZChhKSB7XFxuICAgICAgICAgIHJldHVybiBhLmRpc2FibGVkID09PSAhMTtcXG4gICAgICAgIH0sIGRpc2FibGVkOiBmdW5jdGlvbiBkaXNhYmxlZChhKSB7XFxuICAgICAgICAgIHJldHVybiBhLmRpc2FibGVkID09PSAhMDtcXG4gICAgICAgIH0sIGNoZWNrZWQ6IGZ1bmN0aW9uIGNoZWNrZWQoYSkge1xcbiAgICAgICAgICB2YXIgYiA9IGEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gXFxcImlucHV0XFxcIiA9PT0gYiAmJiAhIWEuY2hlY2tlZCB8fCBcXFwib3B0aW9uXFxcIiA9PT0gYiAmJiAhIWEuc2VsZWN0ZWQ7XFxuICAgICAgICB9LCBzZWxlY3RlZDogZnVuY3Rpb24gc2VsZWN0ZWQoYSkge1xcbiAgICAgICAgICByZXR1cm4gYS5wYXJlbnROb2RlICYmIGEucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LCBhLnNlbGVjdGVkID09PSAhMDtcXG4gICAgICAgIH0sIGVtcHR5OiBmdW5jdGlvbiBlbXB0eShhKSB7XFxuICAgICAgICAgIGZvciAoYSA9IGEuZmlyc3RDaGlsZDsgYTsgYSA9IGEubmV4dFNpYmxpbmcpIHtcXG4gICAgICAgICAgICBpZiAoYS5ub2RlVHlwZSA8IDYpIHJldHVybiAhMTtcXG4gICAgICAgICAgfXJldHVybiAhMDtcXG4gICAgICAgIH0sIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KGEpIHtcXG4gICAgICAgICAgcmV0dXJuICFkLnBzZXVkb3MuZW1wdHkoYSk7XFxuICAgICAgICB9LCBoZWFkZXI6IGZ1bmN0aW9uIGhlYWRlcihhKSB7XFxuICAgICAgICAgIHJldHVybiBZLnRlc3QoYS5ub2RlTmFtZSk7XFxuICAgICAgICB9LCBpbnB1dDogZnVuY3Rpb24gaW5wdXQoYSkge1xcbiAgICAgICAgICByZXR1cm4gWC50ZXN0KGEubm9kZU5hbWUpO1xcbiAgICAgICAgfSwgYnV0dG9uOiBmdW5jdGlvbiBidXR0b24oYSkge1xcbiAgICAgICAgICB2YXIgYiA9IGEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gXFxcImlucHV0XFxcIiA9PT0gYiAmJiBcXFwiYnV0dG9uXFxcIiA9PT0gYS50eXBlIHx8IFxcXCJidXR0b25cXFwiID09PSBiO1xcbiAgICAgICAgfSwgdGV4dDogZnVuY3Rpb24gdGV4dChhKSB7XFxuICAgICAgICAgIHZhciBiO3JldHVybiBcXFwiaW5wdXRcXFwiID09PSBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgJiYgXFxcInRleHRcXFwiID09PSBhLnR5cGUgJiYgKG51bGwgPT0gKGIgPSBhLmdldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIpKSB8fCBcXFwidGV4dFxcXCIgPT09IGIudG9Mb3dlckNhc2UoKSk7XFxuICAgICAgICB9LCBmaXJzdDogbmEoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4gWzBdO1xcbiAgICAgICAgfSksIGxhc3Q6IG5hKGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICAgIHJldHVybiBbYiAtIDFdO1xcbiAgICAgICAgfSksIGVxOiBuYShmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICAgICAgICByZXR1cm4gWzAgPiBjID8gYyArIGIgOiBjXTtcXG4gICAgICAgIH0pLCBldmVuOiBuYShmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYiA+IGM7IGMgKz0gMikge1xcbiAgICAgICAgICAgIGEucHVzaChjKTtcXG4gICAgICAgICAgfXJldHVybiBhO1xcbiAgICAgICAgfSksIG9kZDogbmEoZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgICAgZm9yICh2YXIgYyA9IDE7IGIgPiBjOyBjICs9IDIpIHtcXG4gICAgICAgICAgICBhLnB1c2goYyk7XFxuICAgICAgICAgIH1yZXR1cm4gYTtcXG4gICAgICAgIH0pLCBsdDogbmEoZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICAgICAgZm9yICh2YXIgZCA9IDAgPiBjID8gYyArIGIgOiBjOyAtLWQgPj0gMDspIHtcXG4gICAgICAgICAgICBhLnB1c2goZCk7XFxuICAgICAgICAgIH1yZXR1cm4gYTtcXG4gICAgICAgIH0pLCBndDogbmEoZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICAgICAgZm9yICh2YXIgZCA9IDAgPiBjID8gYyArIGIgOiBjOyArK2QgPCBiOykge1xcbiAgICAgICAgICAgIGEucHVzaChkKTtcXG4gICAgICAgICAgfXJldHVybiBhO1xcbiAgICAgICAgfSkgfSB9LCBkLnBzZXVkb3MubnRoID0gZC5wc2V1ZG9zLmVxO2ZvciAoYiBpbiB7IHJhZGlvOiAhMCwgY2hlY2tib3g6ICEwLCBmaWxlOiAhMCwgcGFzc3dvcmQ6ICEwLCBpbWFnZTogITAgfSkge1xcbiAgICAgIGQucHNldWRvc1tiXSA9IGxhKGIpO1xcbiAgICB9Zm9yIChiIGluIHsgc3VibWl0OiAhMCwgcmVzZXQ6ICEwIH0pIHtcXG4gICAgICBkLnBzZXVkb3NbYl0gPSBtYShiKTtcXG4gICAgfWZ1bmN0aW9uIHBhKCkge31wYS5wcm90b3R5cGUgPSBkLmZpbHRlcnMgPSBkLnBzZXVkb3MsIGQuc2V0RmlsdGVycyA9IG5ldyBwYSgpLCBnID0gZmEudG9rZW5pemUgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIHZhciBjLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrID0gelthICsgXFxcIiBcXFwiXTtpZiAoaykgcmV0dXJuIGIgPyAwIDogay5zbGljZSgwKTtoID0gYSwgaSA9IFtdLCBqID0gZC5wcmVGaWx0ZXI7d2hpbGUgKGgpIHtcXG4gICAgICAgICghYyB8fCAoZSA9IFIuZXhlYyhoKSkpICYmIChlICYmIChoID0gaC5zbGljZShlWzBdLmxlbmd0aCkgfHwgaCksIGkucHVzaChmID0gW10pKSwgYyA9ICExLCAoZSA9IFMuZXhlYyhoKSkgJiYgKGMgPSBlLnNoaWZ0KCksIGYucHVzaCh7IHZhbHVlOiBjLCB0eXBlOiBlWzBdLnJlcGxhY2UoUSwgXFxcIiBcXFwiKSB9KSwgaCA9IGguc2xpY2UoYy5sZW5ndGgpKTtmb3IgKGcgaW4gZC5maWx0ZXIpIHtcXG4gICAgICAgICAgIShlID0gV1tnXS5leGVjKGgpKSB8fCBqW2ddICYmICEoZSA9IGpbZ10oZSkpIHx8IChjID0gZS5zaGlmdCgpLCBmLnB1c2goeyB2YWx1ZTogYywgdHlwZTogZywgbWF0Y2hlczogZSB9KSwgaCA9IGguc2xpY2UoYy5sZW5ndGgpKTtcXG4gICAgICAgIH1pZiAoIWMpIGJyZWFrO1xcbiAgICAgIH1yZXR1cm4gYiA/IGgubGVuZ3RoIDogaCA/IGZhLmVycm9yKGEpIDogeihhLCBpKS5zbGljZSgwKTtcXG4gICAgfTtmdW5jdGlvbiBxYShhKSB7XFxuICAgICAgZm9yICh2YXIgYiA9IDAsIGMgPSBhLmxlbmd0aCwgZCA9IFxcXCJcXFwiOyBjID4gYjsgYisrKSB7XFxuICAgICAgICBkICs9IGFbYl0udmFsdWU7XFxuICAgICAgfXJldHVybiBkO1xcbiAgICB9ZnVuY3Rpb24gcmEoYSwgYiwgYykge1xcbiAgICAgIHZhciBkID0gYi5kaXIsXFxuICAgICAgICAgIGUgPSBjICYmIFxcXCJwYXJlbnROb2RlXFxcIiA9PT0gZCxcXG4gICAgICAgICAgZiA9IHgrKztyZXR1cm4gYi5maXJzdCA/IGZ1bmN0aW9uIChiLCBjLCBmKSB7XFxuICAgICAgICB3aGlsZSAoYiA9IGJbZF0pIHtcXG4gICAgICAgICAgaWYgKDEgPT09IGIubm9kZVR5cGUgfHwgZSkgcmV0dXJuIGEoYiwgYywgZik7XFxuICAgICAgICB9XFxuICAgICAgfSA6IGZ1bmN0aW9uIChiLCBjLCBnKSB7XFxuICAgICAgICB2YXIgaCxcXG4gICAgICAgICAgICBpLFxcbiAgICAgICAgICAgIGosXFxuICAgICAgICAgICAgayA9IFt3LCBmXTtpZiAoZykge1xcbiAgICAgICAgICB3aGlsZSAoYiA9IGJbZF0pIHtcXG4gICAgICAgICAgICBpZiAoKDEgPT09IGIubm9kZVR5cGUgfHwgZSkgJiYgYShiLCBjLCBnKSkgcmV0dXJuICEwO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Ugd2hpbGUgKGIgPSBiW2RdKSB7XFxuICAgICAgICAgIGlmICgxID09PSBiLm5vZGVUeXBlIHx8IGUpIHtcXG4gICAgICAgICAgICBpZiAoaiA9IGJbdV0gfHwgKGJbdV0gPSB7fSksIGkgPSBqW2IudW5pcXVlSURdIHx8IChqW2IudW5pcXVlSURdID0ge30pLCAoaCA9IGlbZF0pICYmIGhbMF0gPT09IHcgJiYgaFsxXSA9PT0gZikgcmV0dXJuIGtbMl0gPSBoWzJdO2lmIChpW2RdID0gaywga1syXSA9IGEoYiwgYywgZykpIHJldHVybiAhMDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1mdW5jdGlvbiBzYShhKSB7XFxuICAgICAgcmV0dXJuIGEubGVuZ3RoID4gMSA/IGZ1bmN0aW9uIChiLCBjLCBkKSB7XFxuICAgICAgICB2YXIgZSA9IGEubGVuZ3RoO3doaWxlIChlLS0pIHtcXG4gICAgICAgICAgaWYgKCFhW2VdKGIsIGMsIGQpKSByZXR1cm4gITE7XFxuICAgICAgICB9cmV0dXJuICEwO1xcbiAgICAgIH0gOiBhWzBdO1xcbiAgICB9ZnVuY3Rpb24gdGEoYSwgYiwgYykge1xcbiAgICAgIGZvciAodmFyIGQgPSAwLCBlID0gYi5sZW5ndGg7IGUgPiBkOyBkKyspIHtcXG4gICAgICAgIGZhKGEsIGJbZF0sIGMpO1xcbiAgICAgIH1yZXR1cm4gYztcXG4gICAgfWZ1bmN0aW9uIHVhKGEsIGIsIGMsIGQsIGUpIHtcXG4gICAgICBmb3IgKHZhciBmLCBnID0gW10sIGggPSAwLCBpID0gYS5sZW5ndGgsIGogPSBudWxsICE9IGI7IGkgPiBoOyBoKyspIHtcXG4gICAgICAgIChmID0gYVtoXSkgJiYgKCFjIHx8IGMoZiwgZCwgZSkpICYmIChnLnB1c2goZiksIGogJiYgYi5wdXNoKGgpKTtcXG4gICAgICB9cmV0dXJuIGc7XFxuICAgIH1mdW5jdGlvbiB2YShhLCBiLCBjLCBkLCBlLCBmKSB7XFxuICAgICAgcmV0dXJuIGQgJiYgIWRbdV0gJiYgKGQgPSB2YShkKSksIGUgJiYgIWVbdV0gJiYgKGUgPSB2YShlLCBmKSksIGhhKGZ1bmN0aW9uIChmLCBnLCBoLCBpKSB7XFxuICAgICAgICB2YXIgaixcXG4gICAgICAgICAgICBrLFxcbiAgICAgICAgICAgIGwsXFxuICAgICAgICAgICAgbSA9IFtdLFxcbiAgICAgICAgICAgIG4gPSBbXSxcXG4gICAgICAgICAgICBvID0gZy5sZW5ndGgsXFxuICAgICAgICAgICAgcCA9IGYgfHwgdGEoYiB8fCBcXFwiKlxcXCIsIGgubm9kZVR5cGUgPyBbaF0gOiBoLCBbXSksXFxuICAgICAgICAgICAgcSA9ICFhIHx8ICFmICYmIGIgPyBwIDogdWEocCwgbSwgYSwgaCwgaSksXFxuICAgICAgICAgICAgciA9IGMgPyBlIHx8IChmID8gYSA6IG8gfHwgZCkgPyBbXSA6IGcgOiBxO2lmIChjICYmIGMocSwgciwgaCwgaSksIGQpIHtcXG4gICAgICAgICAgaiA9IHVhKHIsIG4pLCBkKGosIFtdLCBoLCBpKSwgayA9IGoubGVuZ3RoO3doaWxlIChrLS0pIHtcXG4gICAgICAgICAgICAobCA9IGpba10pICYmIChyW25ba11dID0gIShxW25ba11dID0gbCkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9aWYgKGYpIHtcXG4gICAgICAgICAgaWYgKGUgfHwgYSkge1xcbiAgICAgICAgICAgIGlmIChlKSB7XFxuICAgICAgICAgICAgICBqID0gW10sIGsgPSByLmxlbmd0aDt3aGlsZSAoay0tKSB7XFxuICAgICAgICAgICAgICAgIChsID0gcltrXSkgJiYgai5wdXNoKHFba10gPSBsKTtcXG4gICAgICAgICAgICAgIH1lKG51bGwsIHIgPSBbXSwgaiwgaSk7XFxuICAgICAgICAgICAgfWsgPSByLmxlbmd0aDt3aGlsZSAoay0tKSB7XFxuICAgICAgICAgICAgICAobCA9IHJba10pICYmIChqID0gZSA/IEooZiwgbCkgOiBtW2tdKSA+IC0xICYmIChmW2pdID0gIShnW2pdID0gbCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHIgPSB1YShyID09PSBnID8gci5zcGxpY2Uobywgci5sZW5ndGgpIDogciksIGUgPyBlKG51bGwsIGcsIHIsIGkpIDogSC5hcHBseShnLCByKTtcXG4gICAgICB9KTtcXG4gICAgfWZ1bmN0aW9uIHdhKGEpIHtcXG4gICAgICBmb3IgKHZhciBiLCBjLCBlLCBmID0gYS5sZW5ndGgsIGcgPSBkLnJlbGF0aXZlW2FbMF0udHlwZV0sIGggPSBnIHx8IGQucmVsYXRpdmVbXFxcIiBcXFwiXSwgaSA9IGcgPyAxIDogMCwgayA9IHJhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICByZXR1cm4gYSA9PT0gYjtcXG4gICAgICB9LCBoLCAhMCksIGwgPSByYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgcmV0dXJuIEooYiwgYSkgPiAtMTtcXG4gICAgICB9LCBoLCAhMCksIG0gPSBbZnVuY3Rpb24gKGEsIGMsIGQpIHtcXG4gICAgICAgIHZhciBlID0gIWcgJiYgKGQgfHwgYyAhPT0gaikgfHwgKChiID0gYykubm9kZVR5cGUgPyBrKGEsIGMsIGQpIDogbChhLCBjLCBkKSk7cmV0dXJuIGIgPSBudWxsLCBlO1xcbiAgICAgIH1dOyBmID4gaTsgaSsrKSB7XFxuICAgICAgICBpZiAoYyA9IGQucmVsYXRpdmVbYVtpXS50eXBlXSkgbSA9IFtyYShzYShtKSwgYyldO2Vsc2Uge1xcbiAgICAgICAgICBpZiAoYyA9IGQuZmlsdGVyW2FbaV0udHlwZV0uYXBwbHkobnVsbCwgYVtpXS5tYXRjaGVzKSwgY1t1XSkge1xcbiAgICAgICAgICAgIGZvciAoZSA9ICsraTsgZiA+IGU7IGUrKykge1xcbiAgICAgICAgICAgICAgaWYgKGQucmVsYXRpdmVbYVtlXS50eXBlXSkgYnJlYWs7XFxuICAgICAgICAgICAgfXJldHVybiB2YShpID4gMSAmJiBzYShtKSwgaSA+IDEgJiYgcWEoYS5zbGljZSgwLCBpIC0gMSkuY29uY2F0KHsgdmFsdWU6IFxcXCIgXFxcIiA9PT0gYVtpIC0gMl0udHlwZSA/IFxcXCIqXFxcIiA6IFxcXCJcXFwiIH0pKS5yZXBsYWNlKFEsIFxcXCIkMVxcXCIpLCBjLCBlID4gaSAmJiB3YShhLnNsaWNlKGksIGUpKSwgZiA+IGUgJiYgd2EoYSA9IGEuc2xpY2UoZSkpLCBmID4gZSAmJiBxYShhKSk7XFxuICAgICAgICAgIH1tLnB1c2goYyk7XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiBzYShtKTtcXG4gICAgfWZ1bmN0aW9uIHhhKGEsIGIpIHtcXG4gICAgICB2YXIgYyA9IGIubGVuZ3RoID4gMCxcXG4gICAgICAgICAgZSA9IGEubGVuZ3RoID4gMCxcXG4gICAgICAgICAgZiA9IGZ1bmN0aW9uIGYoX2YsIGcsIGgsIGksIGspIHtcXG4gICAgICAgIHZhciBsLFxcbiAgICAgICAgICAgIG8sXFxuICAgICAgICAgICAgcSxcXG4gICAgICAgICAgICByID0gMCxcXG4gICAgICAgICAgICBzID0gXFxcIjBcXFwiLFxcbiAgICAgICAgICAgIHQgPSBfZiAmJiBbXSxcXG4gICAgICAgICAgICB1ID0gW10sXFxuICAgICAgICAgICAgdiA9IGosXFxuICAgICAgICAgICAgeCA9IF9mIHx8IGUgJiYgZC5maW5kLlRBRyhcXFwiKlxcXCIsIGspLFxcbiAgICAgICAgICAgIHkgPSB3ICs9IG51bGwgPT0gdiA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IC4xLFxcbiAgICAgICAgICAgIHogPSB4Lmxlbmd0aDtmb3IgKGsgJiYgKGogPSBnID09PSBuIHx8IGcgfHwgayk7IHMgIT09IHogJiYgbnVsbCAhPSAobCA9IHhbc10pOyBzKyspIHtcXG4gICAgICAgICAgaWYgKGUgJiYgbCkge1xcbiAgICAgICAgICAgIG8gPSAwLCBnIHx8IGwub3duZXJEb2N1bWVudCA9PT0gbiB8fCAobShsKSwgaCA9ICFwKTt3aGlsZSAocSA9IGFbbysrXSkge1xcbiAgICAgICAgICAgICAgaWYgKHEobCwgZyB8fCBuLCBoKSkge1xcbiAgICAgICAgICAgICAgICBpLnB1c2gobCk7YnJlYWs7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfWsgJiYgKHcgPSB5KTtcXG4gICAgICAgICAgfWMgJiYgKChsID0gIXEgJiYgbCkgJiYgci0tLCBfZiAmJiB0LnB1c2gobCkpO1xcbiAgICAgICAgfWlmIChyICs9IHMsIGMgJiYgcyAhPT0gcikge1xcbiAgICAgICAgICBvID0gMDt3aGlsZSAocSA9IGJbbysrXSkge1xcbiAgICAgICAgICAgIHEodCwgdSwgZywgaCk7XFxuICAgICAgICAgIH1pZiAoX2YpIHtcXG4gICAgICAgICAgICBpZiAociA+IDApIHdoaWxlIChzLS0pIHtcXG4gICAgICAgICAgICAgIHRbc10gfHwgdVtzXSB8fCAodVtzXSA9IEYuY2FsbChpKSk7XFxuICAgICAgICAgICAgfXUgPSB1YSh1KTtcXG4gICAgICAgICAgfUguYXBwbHkoaSwgdSksIGsgJiYgIV9mICYmIHUubGVuZ3RoID4gMCAmJiByICsgYi5sZW5ndGggPiAxICYmIGZhLnVuaXF1ZVNvcnQoaSk7XFxuICAgICAgICB9cmV0dXJuIGsgJiYgKHcgPSB5LCBqID0gdiksIHQ7XFxuICAgICAgfTtyZXR1cm4gYyA/IGhhKGYpIDogZjtcXG4gICAgfXJldHVybiBoID0gZmEuY29tcGlsZSA9IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgdmFyIGMsXFxuICAgICAgICAgIGQgPSBbXSxcXG4gICAgICAgICAgZSA9IFtdLFxcbiAgICAgICAgICBmID0gQVthICsgXFxcIiBcXFwiXTtpZiAoIWYpIHtcXG4gICAgICAgIGIgfHwgKGIgPSBnKGEpKSwgYyA9IGIubGVuZ3RoO3doaWxlIChjLS0pIHtcXG4gICAgICAgICAgZiA9IHdhKGJbY10pLCBmW3VdID8gZC5wdXNoKGYpIDogZS5wdXNoKGYpO1xcbiAgICAgICAgfWYgPSBBKGEsIHhhKGUsIGQpKSwgZi5zZWxlY3RvciA9IGE7XFxuICAgICAgfXJldHVybiBmO1xcbiAgICB9LCBpID0gZmEuc2VsZWN0ID0gZnVuY3Rpb24gKGEsIGIsIGUsIGYpIHtcXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayxcXG4gICAgICAgICAgbCxcXG4gICAgICAgICAgbSxcXG4gICAgICAgICAgbiA9IFxcXCJmdW5jdGlvblxcXCIgPT0gdHlwZW9mIGEgJiYgYSxcXG4gICAgICAgICAgbyA9ICFmICYmIGcoYSA9IG4uc2VsZWN0b3IgfHwgYSk7aWYgKGUgPSBlIHx8IFtdLCAxID09PSBvLmxlbmd0aCkge1xcbiAgICAgICAgaWYgKGogPSBvWzBdID0gb1swXS5zbGljZSgwKSwgai5sZW5ndGggPiAyICYmIFxcXCJJRFxcXCIgPT09IChrID0galswXSkudHlwZSAmJiBjLmdldEJ5SWQgJiYgOSA9PT0gYi5ub2RlVHlwZSAmJiBwICYmIGQucmVsYXRpdmVbalsxXS50eXBlXSkge1xcbiAgICAgICAgICBpZiAoYiA9IChkLmZpbmQuSUQoay5tYXRjaGVzWzBdLnJlcGxhY2UoYmEsIGNhKSwgYikgfHwgW10pWzBdLCAhYikgcmV0dXJuIGU7biAmJiAoYiA9IGIucGFyZW50Tm9kZSksIGEgPSBhLnNsaWNlKGouc2hpZnQoKS52YWx1ZS5sZW5ndGgpO1xcbiAgICAgICAgfWkgPSBXLm5lZWRzQ29udGV4dC50ZXN0KGEpID8gMCA6IGoubGVuZ3RoO3doaWxlIChpLS0pIHtcXG4gICAgICAgICAgaWYgKGsgPSBqW2ldLCBkLnJlbGF0aXZlW2wgPSBrLnR5cGVdKSBicmVhaztpZiAoKG0gPSBkLmZpbmRbbF0pICYmIChmID0gbShrLm1hdGNoZXNbMF0ucmVwbGFjZShiYSwgY2EpLCBfLnRlc3QoalswXS50eXBlKSAmJiBvYShiLnBhcmVudE5vZGUpIHx8IGIpKSkge1xcbiAgICAgICAgICAgIGlmIChqLnNwbGljZShpLCAxKSwgYSA9IGYubGVuZ3RoICYmIHFhKGopLCAhYSkgcmV0dXJuIEguYXBwbHkoZSwgZiksIGU7YnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9cmV0dXJuIChuIHx8IGgoYSwgbykpKGYsIGIsICFwLCBlLCAhYiB8fCBfLnRlc3QoYSkgJiYgb2EoYi5wYXJlbnROb2RlKSB8fCBiKSwgZTtcXG4gICAgfSwgYy5zb3J0U3RhYmxlID0gdS5zcGxpdChcXFwiXFxcIikuc29ydChCKS5qb2luKFxcXCJcXFwiKSA9PT0gdSwgYy5kZXRlY3REdXBsaWNhdGVzID0gISFsLCBtKCksIGMuc29ydERldGFjaGVkID0gaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICByZXR1cm4gMSAmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24obi5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSk7XFxuICAgIH0pLCBpYShmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiBhLmlubmVySFRNTCA9IFxcXCI8YSBocmVmPScjJz48L2E+XFxcIiwgXFxcIiNcXFwiID09PSBhLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIik7XFxuICAgIH0pIHx8IGphKFxcXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXFxcIiwgZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gYyA/IHZvaWQgMCA6IGEuZ2V0QXR0cmlidXRlKGIsIFxcXCJ0eXBlXFxcIiA9PT0gYi50b0xvd2VyQ2FzZSgpID8gMSA6IDIpO1xcbiAgICB9KSwgYy5hdHRyaWJ1dGVzICYmIGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIGEuaW5uZXJIVE1MID0gXFxcIjxpbnB1dC8+XFxcIiwgYS5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcXFwidmFsdWVcXFwiLCBcXFwiXFxcIiksIFxcXCJcXFwiID09PSBhLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFxcXCJ2YWx1ZVxcXCIpO1xcbiAgICB9KSB8fCBqYShcXFwidmFsdWVcXFwiLCBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiBjIHx8IFxcXCJpbnB1dFxcXCIgIT09IGEubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA/IHZvaWQgMCA6IGEuZGVmYXVsdFZhbHVlO1xcbiAgICB9KSwgaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICByZXR1cm4gbnVsbCA9PSBhLmdldEF0dHJpYnV0ZShcXFwiZGlzYWJsZWRcXFwiKTtcXG4gICAgfSkgfHwgamEoSywgZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZDtyZXR1cm4gYyA/IHZvaWQgMCA6IGFbYl0gPT09ICEwID8gYi50b0xvd2VyQ2FzZSgpIDogKGQgPSBhLmdldEF0dHJpYnV0ZU5vZGUoYikpICYmIGQuc3BlY2lmaWVkID8gZC52YWx1ZSA6IG51bGw7XFxuICAgIH0pLCBmYTtcXG4gIH0oYSk7bi5maW5kID0gdCwgbi5leHByID0gdC5zZWxlY3RvcnMsIG4uZXhwcltcXFwiOlxcXCJdID0gbi5leHByLnBzZXVkb3MsIG4udW5pcXVlU29ydCA9IG4udW5pcXVlID0gdC51bmlxdWVTb3J0LCBuLnRleHQgPSB0LmdldFRleHQsIG4uaXNYTUxEb2MgPSB0LmlzWE1MLCBuLmNvbnRhaW5zID0gdC5jb250YWluczt2YXIgdSA9IGZ1bmN0aW9uIHUoYSwgYiwgYykge1xcbiAgICB2YXIgZCA9IFtdLFxcbiAgICAgICAgZSA9IHZvaWQgMCAhPT0gYzt3aGlsZSAoKGEgPSBhW2JdKSAmJiA5ICE9PSBhLm5vZGVUeXBlKSB7XFxuICAgICAgaWYgKDEgPT09IGEubm9kZVR5cGUpIHtcXG4gICAgICAgIGlmIChlICYmIG4oYSkuaXMoYykpIGJyZWFrO2QucHVzaChhKTtcXG4gICAgICB9XFxuICAgIH1yZXR1cm4gZDtcXG4gIH0sXFxuICAgICAgdiA9IGZ1bmN0aW9uIHYoYSwgYikge1xcbiAgICBmb3IgKHZhciBjID0gW107IGE7IGEgPSBhLm5leHRTaWJsaW5nKSB7XFxuICAgICAgMSA9PT0gYS5ub2RlVHlwZSAmJiBhICE9PSBiICYmIGMucHVzaChhKTtcXG4gICAgfXJldHVybiBjO1xcbiAgfSxcXG4gICAgICB3ID0gbi5leHByLm1hdGNoLm5lZWRzQ29udGV4dCxcXG4gICAgICB4ID0gL148KFtcXFxcdy1dKylcXFxccypcXFxcLz8+KD86PFxcXFwvXFxcXDE+fCkkLyxcXG4gICAgICB5ID0gL14uW146I1xcXFxbXFxcXC4sXSokLztmdW5jdGlvbiB6KGEsIGIsIGMpIHtcXG4gICAgaWYgKG4uaXNGdW5jdGlvbihiKSkgcmV0dXJuIG4uZ3JlcChhLCBmdW5jdGlvbiAoYSwgZCkge1xcbiAgICAgIHJldHVybiAhIWIuY2FsbChhLCBkLCBhKSAhPT0gYztcXG4gICAgfSk7aWYgKGIubm9kZVR5cGUpIHJldHVybiBuLmdyZXAoYSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgICByZXR1cm4gYSA9PT0gYiAhPT0gYztcXG4gICAgfSk7aWYgKFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBiKSB7XFxuICAgICAgaWYgKHkudGVzdChiKSkgcmV0dXJuIG4uZmlsdGVyKGIsIGEsIGMpO2IgPSBuLmZpbHRlcihiLCBhKTtcXG4gICAgfXJldHVybiBuLmdyZXAoYSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgICByZXR1cm4gaC5jYWxsKGIsIGEpID4gLTEgIT09IGM7XFxuICAgIH0pO1xcbiAgfW4uZmlsdGVyID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgdmFyIGQgPSBiWzBdO3JldHVybiBjICYmIChhID0gXFxcIjpub3QoXFxcIiArIGEgKyBcXFwiKVxcXCIpLCAxID09PSBiLmxlbmd0aCAmJiAxID09PSBkLm5vZGVUeXBlID8gbi5maW5kLm1hdGNoZXNTZWxlY3RvcihkLCBhKSA/IFtkXSA6IFtdIDogbi5maW5kLm1hdGNoZXMoYSwgbi5ncmVwKGIsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIDEgPT09IGEubm9kZVR5cGU7XFxuICAgIH0pKTtcXG4gIH0sIG4uZm4uZXh0ZW5kKHsgZmluZDogZnVuY3Rpb24gZmluZChhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGMgPSB0aGlzLmxlbmd0aCxcXG4gICAgICAgICAgZCA9IFtdLFxcbiAgICAgICAgICBlID0gdGhpcztpZiAoXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEpIHJldHVybiB0aGlzLnB1c2hTdGFjayhuKGEpLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuICAgICAgICBmb3IgKGIgPSAwOyBjID4gYjsgYisrKSB7XFxuICAgICAgICAgIGlmIChuLmNvbnRhaW5zKGVbYl0sIHRoaXMpKSByZXR1cm4gITA7XFxuICAgICAgICB9XFxuICAgICAgfSkpO2ZvciAoYiA9IDA7IGMgPiBiOyBiKyspIHtcXG4gICAgICAgIG4uZmluZChhLCBlW2JdLCBkKTtcXG4gICAgICB9cmV0dXJuIGQgPSB0aGlzLnB1c2hTdGFjayhjID4gMSA/IG4udW5pcXVlKGQpIDogZCksIGQuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3RvciArIFxcXCIgXFxcIiArIGEgOiBhLCBkO1xcbiAgICB9LCBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHoodGhpcywgYSB8fCBbXSwgITEpKTtcXG4gICAgfSwgbm90OiBmdW5jdGlvbiBub3QoYSkge1xcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayh6KHRoaXMsIGEgfHwgW10sICEwKSk7XFxuICAgIH0sIGlzOiBmdW5jdGlvbiBpcyhhKSB7XFxuICAgICAgcmV0dXJuICEheih0aGlzLCBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSAmJiB3LnRlc3QoYSkgPyBuKGEpIDogYSB8fCBbXSwgITEpLmxlbmd0aDtcXG4gICAgfSB9KTt2YXIgQSxcXG4gICAgICBCID0gL14oPzpcXFxccyooPFtcXFxcd1xcXFxXXSs+KVtePl0qfCMoW1xcXFx3LV0qKSkkLyxcXG4gICAgICBDID0gbi5mbi5pbml0ID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgdmFyIGUsIGY7aWYgKCFhKSByZXR1cm4gdGhpcztpZiAoYyA9IGMgfHwgQSwgXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGEpIHtcXG4gICAgICBpZiAoZSA9IFxcXCI8XFxcIiA9PT0gYVswXSAmJiBcXFwiPlxcXCIgPT09IGFbYS5sZW5ndGggLSAxXSAmJiBhLmxlbmd0aCA+PSAzID8gW251bGwsIGEsIG51bGxdIDogQi5leGVjKGEpLCAhZSB8fCAhZVsxXSAmJiBiKSByZXR1cm4gIWIgfHwgYi5qcXVlcnkgPyAoYiB8fCBjKS5maW5kKGEpIDogdGhpcy5jb25zdHJ1Y3RvcihiKS5maW5kKGEpO2lmIChlWzFdKSB7XFxuICAgICAgICBpZiAoYiA9IGIgaW5zdGFuY2VvZiBuID8gYlswXSA6IGIsIG4ubWVyZ2UodGhpcywgbi5wYXJzZUhUTUwoZVsxXSwgYiAmJiBiLm5vZGVUeXBlID8gYi5vd25lckRvY3VtZW50IHx8IGIgOiBkLCAhMCkpLCB4LnRlc3QoZVsxXSkgJiYgbi5pc1BsYWluT2JqZWN0KGIpKSBmb3IgKGUgaW4gYikge1xcbiAgICAgICAgICBuLmlzRnVuY3Rpb24odGhpc1tlXSkgPyB0aGlzW2VdKGJbZV0pIDogdGhpcy5hdHRyKGUsIGJbZV0pO1xcbiAgICAgICAgfXJldHVybiB0aGlzO1xcbiAgICAgIH1yZXR1cm4gZiA9IGQuZ2V0RWxlbWVudEJ5SWQoZVsyXSksIGYgJiYgZi5wYXJlbnROb2RlICYmICh0aGlzLmxlbmd0aCA9IDEsIHRoaXNbMF0gPSBmKSwgdGhpcy5jb250ZXh0ID0gZCwgdGhpcy5zZWxlY3RvciA9IGEsIHRoaXM7XFxuICAgIH1yZXR1cm4gYS5ub2RlVHlwZSA/ICh0aGlzLmNvbnRleHQgPSB0aGlzWzBdID0gYSwgdGhpcy5sZW5ndGggPSAxLCB0aGlzKSA6IG4uaXNGdW5jdGlvbihhKSA/IHZvaWQgMCAhPT0gYy5yZWFkeSA/IGMucmVhZHkoYSkgOiBhKG4pIDogKHZvaWQgMCAhPT0gYS5zZWxlY3RvciAmJiAodGhpcy5zZWxlY3RvciA9IGEuc2VsZWN0b3IsIHRoaXMuY29udGV4dCA9IGEuY29udGV4dCksIG4ubWFrZUFycmF5KGEsIHRoaXMpKTtcXG4gIH07Qy5wcm90b3R5cGUgPSBuLmZuLCBBID0gbihkKTt2YXIgRCA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxcbiAgICAgIEUgPSB7IGNoaWxkcmVuOiAhMCwgY29udGVudHM6ICEwLCBuZXh0OiAhMCwgcHJldjogITAgfTtuLmZuLmV4dGVuZCh7IGhhczogZnVuY3Rpb24gaGFzKGEpIHtcXG4gICAgICB2YXIgYiA9IG4oYSwgdGhpcyksXFxuICAgICAgICAgIGMgPSBiLmxlbmd0aDtyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgZm9yICh2YXIgYSA9IDA7IGMgPiBhOyBhKyspIHtcXG4gICAgICAgICAgaWYgKG4uY29udGFpbnModGhpcywgYlthXSkpIHJldHVybiAhMDtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSwgY2xvc2VzdDogZnVuY3Rpb24gY2xvc2VzdChhLCBiKSB7XFxuICAgICAgZm9yICh2YXIgYywgZCA9IDAsIGUgPSB0aGlzLmxlbmd0aCwgZiA9IFtdLCBnID0gdy50ZXN0KGEpIHx8IFxcXCJzdHJpbmdcXFwiICE9IHR5cGVvZiBhID8gbihhLCBiIHx8IHRoaXMuY29udGV4dCkgOiAwOyBlID4gZDsgZCsrKSB7XFxuICAgICAgICBmb3IgKGMgPSB0aGlzW2RdOyBjICYmIGMgIT09IGI7IGMgPSBjLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgaWYgKGMubm9kZVR5cGUgPCAxMSAmJiAoZyA/IGcuaW5kZXgoYykgPiAtMSA6IDEgPT09IGMubm9kZVR5cGUgJiYgbi5maW5kLm1hdGNoZXNTZWxlY3RvcihjLCBhKSkpIHtcXG4gICAgICAgICAgICBmLnB1c2goYyk7YnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9cmV0dXJuIHRoaXMucHVzaFN0YWNrKGYubGVuZ3RoID4gMSA/IG4udW5pcXVlU29ydChmKSA6IGYpO1xcbiAgICB9LCBpbmRleDogZnVuY3Rpb24gaW5kZXgoYSkge1xcbiAgICAgIHJldHVybiBhID8gXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGEgPyBoLmNhbGwobihhKSwgdGhpc1swXSkgOiBoLmNhbGwodGhpcywgYS5qcXVlcnkgPyBhWzBdIDogYSkgOiB0aGlzWzBdICYmIHRoaXNbMF0ucGFyZW50Tm9kZSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XFxuICAgIH0sIGFkZDogZnVuY3Rpb24gYWRkKGEsIGIpIHtcXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sobi51bmlxdWVTb3J0KG4ubWVyZ2UodGhpcy5nZXQoKSwgbihhLCBiKSkpKTtcXG4gICAgfSwgYWRkQmFjazogZnVuY3Rpb24gYWRkQmFjayhhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuYWRkKG51bGwgPT0gYSA/IHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoYSkpO1xcbiAgICB9IH0pO2Z1bmN0aW9uIEYoYSwgYikge1xcbiAgICB3aGlsZSAoKGEgPSBhW2JdKSAmJiAxICE9PSBhLm5vZGVUeXBlKSB7fXJldHVybiBhO1xcbiAgfW4uZWFjaCh7IHBhcmVudDogZnVuY3Rpb24gcGFyZW50KGEpIHtcXG4gICAgICB2YXIgYiA9IGEucGFyZW50Tm9kZTtyZXR1cm4gYiAmJiAxMSAhPT0gYi5ub2RlVHlwZSA/IGIgOiBudWxsO1xcbiAgICB9LCBwYXJlbnRzOiBmdW5jdGlvbiBwYXJlbnRzKGEpIHtcXG4gICAgICByZXR1cm4gdShhLCBcXFwicGFyZW50Tm9kZVxcXCIpO1xcbiAgICB9LCBwYXJlbnRzVW50aWw6IGZ1bmN0aW9uIHBhcmVudHNVbnRpbChhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIHUoYSwgXFxcInBhcmVudE5vZGVcXFwiLCBjKTtcXG4gICAgfSwgbmV4dDogZnVuY3Rpb24gbmV4dChhKSB7XFxuICAgICAgcmV0dXJuIEYoYSwgXFxcIm5leHRTaWJsaW5nXFxcIik7XFxuICAgIH0sIHByZXY6IGZ1bmN0aW9uIHByZXYoYSkge1xcbiAgICAgIHJldHVybiBGKGEsIFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiKTtcXG4gICAgfSwgbmV4dEFsbDogZnVuY3Rpb24gbmV4dEFsbChhKSB7XFxuICAgICAgcmV0dXJuIHUoYSwgXFxcIm5leHRTaWJsaW5nXFxcIik7XFxuICAgIH0sIHByZXZBbGw6IGZ1bmN0aW9uIHByZXZBbGwoYSkge1xcbiAgICAgIHJldHVybiB1KGEsIFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiKTtcXG4gICAgfSwgbmV4dFVudGlsOiBmdW5jdGlvbiBuZXh0VW50aWwoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiB1KGEsIFxcXCJuZXh0U2libGluZ1xcXCIsIGMpO1xcbiAgICB9LCBwcmV2VW50aWw6IGZ1bmN0aW9uIHByZXZVbnRpbChhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIHUoYSwgXFxcInByZXZpb3VzU2libGluZ1xcXCIsIGMpO1xcbiAgICB9LCBzaWJsaW5nczogZnVuY3Rpb24gc2libGluZ3MoYSkge1xcbiAgICAgIHJldHVybiB2KChhLnBhcmVudE5vZGUgfHwge30pLmZpcnN0Q2hpbGQsIGEpO1xcbiAgICB9LCBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4oYSkge1xcbiAgICAgIHJldHVybiB2KGEuZmlyc3RDaGlsZCk7XFxuICAgIH0sIGNvbnRlbnRzOiBmdW5jdGlvbiBjb250ZW50cyhhKSB7XFxuICAgICAgcmV0dXJuIGEuY29udGVudERvY3VtZW50IHx8IG4ubWVyZ2UoW10sIGEuY2hpbGROb2Rlcyk7XFxuICAgIH0gfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5mblthXSA9IGZ1bmN0aW9uIChjLCBkKSB7XFxuICAgICAgdmFyIGUgPSBuLm1hcCh0aGlzLCBiLCBjKTtyZXR1cm4gXFxcIlVudGlsXFxcIiAhPT0gYS5zbGljZSgtNSkgJiYgKGQgPSBjKSwgZCAmJiBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgZCAmJiAoZSA9IG4uZmlsdGVyKGQsIGUpKSwgdGhpcy5sZW5ndGggPiAxICYmIChFW2FdIHx8IG4udW5pcXVlU29ydChlKSwgRC50ZXN0KGEpICYmIGUucmV2ZXJzZSgpKSwgdGhpcy5wdXNoU3RhY2soZSk7XFxuICAgIH07XFxuICB9KTt2YXIgRyA9IC9cXFxcUysvZztmdW5jdGlvbiBIKGEpIHtcXG4gICAgdmFyIGIgPSB7fTtyZXR1cm4gbi5lYWNoKGEubWF0Y2goRykgfHwgW10sIGZ1bmN0aW9uIChhLCBjKSB7XFxuICAgICAgYltjXSA9ICEwO1xcbiAgICB9KSwgYjtcXG4gIH1uLkNhbGxiYWNrcyA9IGZ1bmN0aW9uIChhKSB7XFxuICAgIGEgPSBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSA/IEgoYSkgOiBuLmV4dGVuZCh7fSwgYSk7dmFyIGIsXFxuICAgICAgICBjLFxcbiAgICAgICAgZCxcXG4gICAgICAgIGUsXFxuICAgICAgICBmID0gW10sXFxuICAgICAgICBnID0gW10sXFxuICAgICAgICBoID0gLTEsXFxuICAgICAgICBpID0gZnVuY3Rpb24gaSgpIHtcXG4gICAgICBmb3IgKGUgPSBhLm9uY2UsIGQgPSBiID0gITA7IGcubGVuZ3RoOyBoID0gLTEpIHtcXG4gICAgICAgIGMgPSBnLnNoaWZ0KCk7d2hpbGUgKCsraCA8IGYubGVuZ3RoKSB7XFxuICAgICAgICAgIGZbaF0uYXBwbHkoY1swXSwgY1sxXSkgPT09ICExICYmIGEuc3RvcE9uRmFsc2UgJiYgKGggPSBmLmxlbmd0aCwgYyA9ICExKTtcXG4gICAgICAgIH1cXG4gICAgICB9YS5tZW1vcnkgfHwgKGMgPSAhMSksIGIgPSAhMSwgZSAmJiAoZiA9IGMgPyBbXSA6IFxcXCJcXFwiKTtcXG4gICAgfSxcXG4gICAgICAgIGogPSB7IGFkZDogZnVuY3Rpb24gYWRkKCkge1xcbiAgICAgICAgcmV0dXJuIGYgJiYgKGMgJiYgIWIgJiYgKGggPSBmLmxlbmd0aCAtIDEsIGcucHVzaChjKSksIGZ1bmN0aW9uIGQoYikge1xcbiAgICAgICAgICBuLmVhY2goYiwgZnVuY3Rpb24gKGIsIGMpIHtcXG4gICAgICAgICAgICBuLmlzRnVuY3Rpb24oYykgPyBhLnVuaXF1ZSAmJiBqLmhhcyhjKSB8fCBmLnB1c2goYykgOiBjICYmIGMubGVuZ3RoICYmIFxcXCJzdHJpbmdcXFwiICE9PSBuLnR5cGUoYykgJiYgZChjKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9KGFyZ3VtZW50cyksIGMgJiYgIWIgJiYgaSgpKSwgdGhpcztcXG4gICAgICB9LCByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcXG4gICAgICAgIHJldHVybiBuLmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgICB2YXIgYzt3aGlsZSAoKGMgPSBuLmluQXJyYXkoYiwgZiwgYykpID4gLTEpIHtcXG4gICAgICAgICAgICBmLnNwbGljZShjLCAxKSwgaCA+PSBjICYmIGgtLTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSksIHRoaXM7XFxuICAgICAgfSwgaGFzOiBmdW5jdGlvbiBoYXMoYSkge1xcbiAgICAgICAgcmV0dXJuIGEgPyBuLmluQXJyYXkoYSwgZikgPiAtMSA6IGYubGVuZ3RoID4gMDtcXG4gICAgICB9LCBlbXB0eTogZnVuY3Rpb24gZW1wdHkoKSB7XFxuICAgICAgICByZXR1cm4gZiAmJiAoZiA9IFtdKSwgdGhpcztcXG4gICAgICB9LCBkaXNhYmxlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xcbiAgICAgICAgcmV0dXJuIGUgPSBnID0gW10sIGYgPSBjID0gXFxcIlxcXCIsIHRoaXM7XFxuICAgICAgfSwgZGlzYWJsZWQ6IGZ1bmN0aW9uIGRpc2FibGVkKCkge1xcbiAgICAgICAgcmV0dXJuICFmO1xcbiAgICAgIH0sIGxvY2s6IGZ1bmN0aW9uIGxvY2soKSB7XFxuICAgICAgICByZXR1cm4gZSA9IGcgPSBbXSwgYyB8fCAoZiA9IGMgPSBcXFwiXFxcIiksIHRoaXM7XFxuICAgICAgfSwgbG9ja2VkOiBmdW5jdGlvbiBsb2NrZWQoKSB7XFxuICAgICAgICByZXR1cm4gISFlO1xcbiAgICAgIH0sIGZpcmVXaXRoOiBmdW5jdGlvbiBmaXJlV2l0aChhLCBjKSB7XFxuICAgICAgICByZXR1cm4gZSB8fCAoYyA9IGMgfHwgW10sIGMgPSBbYSwgYy5zbGljZSA/IGMuc2xpY2UoKSA6IGNdLCBnLnB1c2goYyksIGIgfHwgaSgpKSwgdGhpcztcXG4gICAgICB9LCBmaXJlOiBmdW5jdGlvbiBmaXJlKCkge1xcbiAgICAgICAgcmV0dXJuIGouZmlyZVdpdGgodGhpcywgYXJndW1lbnRzKSwgdGhpcztcXG4gICAgICB9LCBmaXJlZDogZnVuY3Rpb24gZmlyZWQoKSB7XFxuICAgICAgICByZXR1cm4gISFkO1xcbiAgICAgIH0gfTtyZXR1cm4gajtcXG4gIH0sIG4uZXh0ZW5kKHsgRGVmZXJyZWQ6IGZ1bmN0aW9uIERlZmVycmVkKGEpIHtcXG4gICAgICB2YXIgYiA9IFtbXFxcInJlc29sdmVcXFwiLCBcXFwiZG9uZVxcXCIsIG4uQ2FsbGJhY2tzKFxcXCJvbmNlIG1lbW9yeVxcXCIpLCBcXFwicmVzb2x2ZWRcXFwiXSwgW1xcXCJyZWplY3RcXFwiLCBcXFwiZmFpbFxcXCIsIG4uQ2FsbGJhY2tzKFxcXCJvbmNlIG1lbW9yeVxcXCIpLCBcXFwicmVqZWN0ZWRcXFwiXSwgW1xcXCJub3RpZnlcXFwiLCBcXFwicHJvZ3Jlc3NcXFwiLCBuLkNhbGxiYWNrcyhcXFwibWVtb3J5XFxcIildXSxcXG4gICAgICAgICAgYyA9IFxcXCJwZW5kaW5nXFxcIixcXG4gICAgICAgICAgZCA9IHsgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKCkge1xcbiAgICAgICAgICByZXR1cm4gYztcXG4gICAgICAgIH0sIGFsd2F5czogZnVuY3Rpb24gYWx3YXlzKCkge1xcbiAgICAgICAgICByZXR1cm4gZS5kb25lKGFyZ3VtZW50cykuZmFpbChhcmd1bWVudHMpLCB0aGlzO1xcbiAgICAgICAgfSwgdGhlbjogZnVuY3Rpb24gdGhlbigpIHtcXG4gICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7cmV0dXJuIG4uRGVmZXJyZWQoZnVuY3Rpb24gKGMpIHtcXG4gICAgICAgICAgICBuLmVhY2goYiwgZnVuY3Rpb24gKGIsIGYpIHtcXG4gICAgICAgICAgICAgIHZhciBnID0gbi5pc0Z1bmN0aW9uKGFbYl0pICYmIGFbYl07ZVtmWzFdXShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIHZhciBhID0gZyAmJiBnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7YSAmJiBuLmlzRnVuY3Rpb24oYS5wcm9taXNlKSA/IGEucHJvbWlzZSgpLnByb2dyZXNzKGMubm90aWZ5KS5kb25lKGMucmVzb2x2ZSkuZmFpbChjLnJlamVjdCkgOiBjW2ZbMF0gKyBcXFwiV2l0aFxcXCJdKHRoaXMgPT09IGQgPyBjLnByb21pc2UoKSA6IHRoaXMsIGcgPyBbYV0gOiBhcmd1bWVudHMpO1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSksIGEgPSBudWxsO1xcbiAgICAgICAgICB9KS5wcm9taXNlKCk7XFxuICAgICAgICB9LCBwcm9taXNlOiBmdW5jdGlvbiBwcm9taXNlKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIG51bGwgIT0gYSA/IG4uZXh0ZW5kKGEsIGQpIDogZDtcXG4gICAgICAgIH0gfSxcXG4gICAgICAgICAgZSA9IHt9O3JldHVybiBkLnBpcGUgPSBkLnRoZW4sIG4uZWFjaChiLCBmdW5jdGlvbiAoYSwgZikge1xcbiAgICAgICAgdmFyIGcgPSBmWzJdLFxcbiAgICAgICAgICAgIGggPSBmWzNdO2RbZlsxXV0gPSBnLmFkZCwgaCAmJiBnLmFkZChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGMgPSBoO1xcbiAgICAgICAgfSwgYlsxIF4gYV1bMl0uZGlzYWJsZSwgYlsyXVsyXS5sb2NrKSwgZVtmWzBdXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIGVbZlswXSArIFxcXCJXaXRoXFxcIl0odGhpcyA9PT0gZSA/IGQgOiB0aGlzLCBhcmd1bWVudHMpLCB0aGlzO1xcbiAgICAgICAgfSwgZVtmWzBdICsgXFxcIldpdGhcXFwiXSA9IGcuZmlyZVdpdGg7XFxuICAgICAgfSksIGQucHJvbWlzZShlKSwgYSAmJiBhLmNhbGwoZSwgZSksIGU7XFxuICAgIH0sIHdoZW46IGZ1bmN0aW9uIHdoZW4oYSkge1xcbiAgICAgIHZhciBiID0gMCxcXG4gICAgICAgICAgYyA9IGUuY2FsbChhcmd1bWVudHMpLFxcbiAgICAgICAgICBkID0gYy5sZW5ndGgsXFxuICAgICAgICAgIGYgPSAxICE9PSBkIHx8IGEgJiYgbi5pc0Z1bmN0aW9uKGEucHJvbWlzZSkgPyBkIDogMCxcXG4gICAgICAgICAgZyA9IDEgPT09IGYgPyBhIDogbi5EZWZlcnJlZCgpLFxcbiAgICAgICAgICBoID0gZnVuY3Rpb24gaChhLCBiLCBjKSB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcXG4gICAgICAgICAgYlthXSA9IHRoaXMsIGNbYV0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGUuY2FsbChhcmd1bWVudHMpIDogZCwgYyA9PT0gaSA/IGcubm90aWZ5V2l0aChiLCBjKSA6IC0tZiB8fCBnLnJlc29sdmVXaXRoKGIsIGMpO1xcbiAgICAgICAgfTtcXG4gICAgICB9LFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrO2lmIChkID4gMSkgZm9yIChpID0gbmV3IEFycmF5KGQpLCBqID0gbmV3IEFycmF5KGQpLCBrID0gbmV3IEFycmF5KGQpOyBkID4gYjsgYisrKSB7XFxuICAgICAgICBjW2JdICYmIG4uaXNGdW5jdGlvbihjW2JdLnByb21pc2UpID8gY1tiXS5wcm9taXNlKCkucHJvZ3Jlc3MoaChiLCBqLCBpKSkuZG9uZShoKGIsIGssIGMpKS5mYWlsKGcucmVqZWN0KSA6IC0tZjtcXG4gICAgICB9cmV0dXJuIGYgfHwgZy5yZXNvbHZlV2l0aChrLCBjKSwgZy5wcm9taXNlKCk7XFxuICAgIH0gfSk7dmFyIEk7bi5mbi5yZWFkeSA9IGZ1bmN0aW9uIChhKSB7XFxuICAgIHJldHVybiBuLnJlYWR5LnByb21pc2UoKS5kb25lKGEpLCB0aGlzO1xcbiAgfSwgbi5leHRlbmQoeyBpc1JlYWR5OiAhMSwgcmVhZHlXYWl0OiAxLCBob2xkUmVhZHk6IGZ1bmN0aW9uIGhvbGRSZWFkeShhKSB7XFxuICAgICAgYSA/IG4ucmVhZHlXYWl0KysgOiBuLnJlYWR5KCEwKTtcXG4gICAgfSwgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KGEpIHtcXG4gICAgICAoYSA9PT0gITAgPyAtLW4ucmVhZHlXYWl0IDogbi5pc1JlYWR5KSB8fCAobi5pc1JlYWR5ID0gITAsIGEgIT09ICEwICYmIC0tbi5yZWFkeVdhaXQgPiAwIHx8IChJLnJlc29sdmVXaXRoKGQsIFtuXSksIG4uZm4udHJpZ2dlckhhbmRsZXIgJiYgKG4oZCkudHJpZ2dlckhhbmRsZXIoXFxcInJlYWR5XFxcIiksIG4oZCkub2ZmKFxcXCJyZWFkeVxcXCIpKSkpO1xcbiAgICB9IH0pO2Z1bmN0aW9uIEooKSB7XFxuICAgIGQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwiRE9NQ29udGVudExvYWRlZFxcXCIsIEopLCBhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImxvYWRcXFwiLCBKKSwgbi5yZWFkeSgpO1xcbiAgfW4ucmVhZHkucHJvbWlzZSA9IGZ1bmN0aW9uIChiKSB7XFxuICAgIHJldHVybiBJIHx8IChJID0gbi5EZWZlcnJlZCgpLCBcXFwiY29tcGxldGVcXFwiID09PSBkLnJlYWR5U3RhdGUgfHwgXFxcImxvYWRpbmdcXFwiICE9PSBkLnJlYWR5U3RhdGUgJiYgIWQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsID8gYS5zZXRUaW1lb3V0KG4ucmVhZHkpIDogKGQuYWRkRXZlbnRMaXN0ZW5lcihcXFwiRE9NQ29udGVudExvYWRlZFxcXCIsIEopLCBhLmFkZEV2ZW50TGlzdGVuZXIoXFxcImxvYWRcXFwiLCBKKSkpLCBJLnByb21pc2UoYik7XFxuICB9LCBuLnJlYWR5LnByb21pc2UoKTt2YXIgSyA9IGZ1bmN0aW9uIEsoYSwgYiwgYywgZCwgZSwgZiwgZykge1xcbiAgICB2YXIgaCA9IDAsXFxuICAgICAgICBpID0gYS5sZW5ndGgsXFxuICAgICAgICBqID0gbnVsbCA9PSBjO2lmIChcXFwib2JqZWN0XFxcIiA9PT0gbi50eXBlKGMpKSB7XFxuICAgICAgZSA9ICEwO2ZvciAoaCBpbiBjKSB7XFxuICAgICAgICBLKGEsIGIsIGgsIGNbaF0sICEwLCBmLCBnKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAodm9pZCAwICE9PSBkICYmIChlID0gITAsIG4uaXNGdW5jdGlvbihkKSB8fCAoZyA9ICEwKSwgaiAmJiAoZyA/IChiLmNhbGwoYSwgZCksIGIgPSBudWxsKSA6IChqID0gYiwgYiA9IGZ1bmN0aW9uIGIoYSwgX2IsIGMpIHtcXG4gICAgICByZXR1cm4gai5jYWxsKG4oYSksIGMpO1xcbiAgICB9KSksIGIpKSBmb3IgKDsgaSA+IGg7IGgrKykge1xcbiAgICAgIGIoYVtoXSwgYywgZyA/IGQgOiBkLmNhbGwoYVtoXSwgaCwgYihhW2hdLCBjKSkpO1xcbiAgICB9cmV0dXJuIGUgPyBhIDogaiA/IGIuY2FsbChhKSA6IGkgPyBiKGFbMF0sIGMpIDogZjtcXG4gIH0sXFxuICAgICAgTCA9IGZ1bmN0aW9uIEwoYSkge1xcbiAgICByZXR1cm4gMSA9PT0gYS5ub2RlVHlwZSB8fCA5ID09PSBhLm5vZGVUeXBlIHx8ICErYS5ub2RlVHlwZTtcXG4gIH07ZnVuY3Rpb24gTSgpIHtcXG4gICAgdGhpcy5leHBhbmRvID0gbi5leHBhbmRvICsgTS51aWQrKztcXG4gIH1NLnVpZCA9IDEsIE0ucHJvdG90eXBlID0geyByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoYSwgYikge1xcbiAgICAgIHZhciBjID0gYiB8fCB7fTtyZXR1cm4gYS5ub2RlVHlwZSA/IGFbdGhpcy5leHBhbmRvXSA9IGMgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgdGhpcy5leHBhbmRvLCB7IHZhbHVlOiBjLCB3cml0YWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAgfSksIGFbdGhpcy5leHBhbmRvXTtcXG4gICAgfSwgY2FjaGU6IGZ1bmN0aW9uIGNhY2hlKGEpIHtcXG4gICAgICBpZiAoIUwoYSkpIHJldHVybiB7fTt2YXIgYiA9IGFbdGhpcy5leHBhbmRvXTtyZXR1cm4gYiB8fCAoYiA9IHt9LCBMKGEpICYmIChhLm5vZGVUeXBlID8gYVt0aGlzLmV4cGFuZG9dID0gYiA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCB0aGlzLmV4cGFuZG8sIHsgdmFsdWU6IGIsIGNvbmZpZ3VyYWJsZTogITAgfSkpKSwgYjtcXG4gICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoYSwgYiwgYykge1xcbiAgICAgIHZhciBkLFxcbiAgICAgICAgICBlID0gdGhpcy5jYWNoZShhKTtpZiAoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGIpIGVbYl0gPSBjO2Vsc2UgZm9yIChkIGluIGIpIHtcXG4gICAgICAgIGVbZF0gPSBiW2RdO1xcbiAgICAgIH1yZXR1cm4gZTtcXG4gICAgfSwgZ2V0OiBmdW5jdGlvbiBnZXQoYSwgYikge1xcbiAgICAgIHJldHVybiB2b2lkIDAgPT09IGIgPyB0aGlzLmNhY2hlKGEpIDogYVt0aGlzLmV4cGFuZG9dICYmIGFbdGhpcy5leHBhbmRvXVtiXTtcXG4gICAgfSwgYWNjZXNzOiBmdW5jdGlvbiBhY2Nlc3MoYSwgYiwgYykge1xcbiAgICAgIHZhciBkO3JldHVybiB2b2lkIDAgPT09IGIgfHwgYiAmJiBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYiAmJiB2b2lkIDAgPT09IGMgPyAoZCA9IHRoaXMuZ2V0KGEsIGIpLCB2b2lkIDAgIT09IGQgPyBkIDogdGhpcy5nZXQoYSwgbi5jYW1lbENhc2UoYikpKSA6ICh0aGlzLnNldChhLCBiLCBjKSwgdm9pZCAwICE9PSBjID8gYyA6IGIpO1xcbiAgICB9LCByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShhLCBiKSB7XFxuICAgICAgdmFyIGMsXFxuICAgICAgICAgIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYgPSBhW3RoaXMuZXhwYW5kb107aWYgKHZvaWQgMCAhPT0gZikge1xcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gYikgdGhpcy5yZWdpc3RlcihhKTtlbHNlIHtcXG4gICAgICAgICAgbi5pc0FycmF5KGIpID8gZCA9IGIuY29uY2F0KGIubWFwKG4uY2FtZWxDYXNlKSkgOiAoZSA9IG4uY2FtZWxDYXNlKGIpLCBiIGluIGYgPyBkID0gW2IsIGVdIDogKGQgPSBlLCBkID0gZCBpbiBmID8gW2RdIDogZC5tYXRjaChHKSB8fCBbXSkpLCBjID0gZC5sZW5ndGg7d2hpbGUgKGMtLSkge1xcbiAgICAgICAgICAgIGRlbGV0ZSBmW2RbY11dO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KHZvaWQgMCA9PT0gYiB8fCBuLmlzRW1wdHlPYmplY3QoZikpICYmIChhLm5vZGVUeXBlID8gYVt0aGlzLmV4cGFuZG9dID0gdm9pZCAwIDogZGVsZXRlIGFbdGhpcy5leHBhbmRvXSk7XFxuICAgICAgfVxcbiAgICB9LCBoYXNEYXRhOiBmdW5jdGlvbiBoYXNEYXRhKGEpIHtcXG4gICAgICB2YXIgYiA9IGFbdGhpcy5leHBhbmRvXTtyZXR1cm4gdm9pZCAwICE9PSBiICYmICFuLmlzRW1wdHlPYmplY3QoYik7XFxuICAgIH0gfTt2YXIgTiA9IG5ldyBNKCksXFxuICAgICAgTyA9IG5ldyBNKCksXFxuICAgICAgUCA9IC9eKD86XFxcXHtbXFxcXHdcXFxcV10qXFxcXH18XFxcXFtbXFxcXHdcXFxcV10qXFxcXF0pJC8sXFxuICAgICAgUSA9IC9bQS1aXS9nO2Z1bmN0aW9uIFIoYSwgYiwgYykge1xcbiAgICB2YXIgZDtpZiAodm9pZCAwID09PSBjICYmIDEgPT09IGEubm9kZVR5cGUpIGlmIChkID0gXFxcImRhdGEtXFxcIiArIGIucmVwbGFjZShRLCBcXFwiLSQmXFxcIikudG9Mb3dlckNhc2UoKSwgYyA9IGEuZ2V0QXR0cmlidXRlKGQpLCBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYykge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICBjID0gXFxcInRydWVcXFwiID09PSBjID8gITAgOiBcXFwiZmFsc2VcXFwiID09PSBjID8gITEgOiBcXFwibnVsbFxcXCIgPT09IGMgPyBudWxsIDogK2MgKyBcXFwiXFxcIiA9PT0gYyA/ICtjIDogUC50ZXN0KGMpID8gbi5wYXJzZUpTT04oYykgOiBjO1xcbiAgICAgIH0gY2F0Y2ggKGUpIHt9Ty5zZXQoYSwgYiwgYyk7XFxuICAgIH0gZWxzZSBjID0gdm9pZCAwO3JldHVybiBjO1xcbiAgfW4uZXh0ZW5kKHsgaGFzRGF0YTogZnVuY3Rpb24gaGFzRGF0YShhKSB7XFxuICAgICAgcmV0dXJuIE8uaGFzRGF0YShhKSB8fCBOLmhhc0RhdGEoYSk7XFxuICAgIH0sIGRhdGE6IGZ1bmN0aW9uIGRhdGEoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiBPLmFjY2VzcyhhLCBiLCBjKTtcXG4gICAgfSwgcmVtb3ZlRGF0YTogZnVuY3Rpb24gcmVtb3ZlRGF0YShhLCBiKSB7XFxuICAgICAgTy5yZW1vdmUoYSwgYik7XFxuICAgIH0sIF9kYXRhOiBmdW5jdGlvbiBfZGF0YShhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIE4uYWNjZXNzKGEsIGIsIGMpO1xcbiAgICB9LCBfcmVtb3ZlRGF0YTogZnVuY3Rpb24gX3JlbW92ZURhdGEoYSwgYikge1xcbiAgICAgIE4ucmVtb3ZlKGEsIGIpO1xcbiAgICB9IH0pLCBuLmZuLmV4dGVuZCh7IGRhdGE6IGZ1bmN0aW9uIGRhdGEoYSwgYikge1xcbiAgICAgIHZhciBjLFxcbiAgICAgICAgICBkLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBmID0gdGhpc1swXSxcXG4gICAgICAgICAgZyA9IGYgJiYgZi5hdHRyaWJ1dGVzO2lmICh2b2lkIDAgPT09IGEpIHtcXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCAmJiAoZSA9IE8uZ2V0KGYpLCAxID09PSBmLm5vZGVUeXBlICYmICFOLmdldChmLCBcXFwiaGFzRGF0YUF0dHJzXFxcIikpKSB7XFxuICAgICAgICAgIGMgPSBnLmxlbmd0aDt3aGlsZSAoYy0tKSB7XFxuICAgICAgICAgICAgZ1tjXSAmJiAoZCA9IGdbY10ubmFtZSwgMCA9PT0gZC5pbmRleE9mKFxcXCJkYXRhLVxcXCIpICYmIChkID0gbi5jYW1lbENhc2UoZC5zbGljZSg1KSksIFIoZiwgZCwgZVtkXSkpKTtcXG4gICAgICAgICAgfU4uc2V0KGYsIFxcXCJoYXNEYXRhQXR0cnNcXFwiLCAhMCk7XFxuICAgICAgICB9cmV0dXJuIGU7XFxuICAgICAgfXJldHVybiBcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGEgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGEpKSA/IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBPLnNldCh0aGlzLCBhKTtcXG4gICAgICB9KSA6IEsodGhpcywgZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgIHZhciBjLCBkO2lmIChmICYmIHZvaWQgMCA9PT0gYikge1xcbiAgICAgICAgICBpZiAoYyA9IE8uZ2V0KGYsIGEpIHx8IE8uZ2V0KGYsIGEucmVwbGFjZShRLCBcXFwiLSQmXFxcIikudG9Mb3dlckNhc2UoKSksIHZvaWQgMCAhPT0gYykgcmV0dXJuIGM7aWYgKGQgPSBuLmNhbWVsQ2FzZShhKSwgYyA9IE8uZ2V0KGYsIGQpLCB2b2lkIDAgIT09IGMpIHJldHVybiBjO2lmIChjID0gUihmLCBkLCB2b2lkIDApLCB2b2lkIDAgIT09IGMpIHJldHVybiBjO1xcbiAgICAgICAgfSBlbHNlIGQgPSBuLmNhbWVsQ2FzZShhKSwgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIGMgPSBPLmdldCh0aGlzLCBkKTtPLnNldCh0aGlzLCBkLCBiKSwgYS5pbmRleE9mKFxcXCItXFxcIikgPiAtMSAmJiB2b2lkIDAgIT09IGMgJiYgTy5zZXQodGhpcywgYSwgYik7XFxuICAgICAgICB9KTtcXG4gICAgICB9LCBudWxsLCBiLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgITApO1xcbiAgICB9LCByZW1vdmVEYXRhOiBmdW5jdGlvbiByZW1vdmVEYXRhKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIE8ucmVtb3ZlKHRoaXMsIGEpO1xcbiAgICAgIH0pO1xcbiAgICB9IH0pLCBuLmV4dGVuZCh7IHF1ZXVlOiBmdW5jdGlvbiBxdWV1ZShhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQ7cmV0dXJuIGEgPyAoYiA9IChiIHx8IFxcXCJmeFxcXCIpICsgXFxcInF1ZXVlXFxcIiwgZCA9IE4uZ2V0KGEsIGIpLCBjICYmICghZCB8fCBuLmlzQXJyYXkoYykgPyBkID0gTi5hY2Nlc3MoYSwgYiwgbi5tYWtlQXJyYXkoYykpIDogZC5wdXNoKGMpKSwgZCB8fCBbXSkgOiB2b2lkIDA7XFxuICAgIH0sIGRlcXVldWU6IGZ1bmN0aW9uIGRlcXVldWUoYSwgYikge1xcbiAgICAgIGIgPSBiIHx8IFxcXCJmeFxcXCI7dmFyIGMgPSBuLnF1ZXVlKGEsIGIpLFxcbiAgICAgICAgICBkID0gYy5sZW5ndGgsXFxuICAgICAgICAgIGUgPSBjLnNoaWZ0KCksXFxuICAgICAgICAgIGYgPSBuLl9xdWV1ZUhvb2tzKGEsIGIpLFxcbiAgICAgICAgICBnID0gZnVuY3Rpb24gZygpIHtcXG4gICAgICAgIG4uZGVxdWV1ZShhLCBiKTtcXG4gICAgICB9O1xcXCJpbnByb2dyZXNzXFxcIiA9PT0gZSAmJiAoZSA9IGMuc2hpZnQoKSwgZC0tKSwgZSAmJiAoXFxcImZ4XFxcIiA9PT0gYiAmJiBjLnVuc2hpZnQoXFxcImlucHJvZ3Jlc3NcXFwiKSwgZGVsZXRlIGYuc3RvcCwgZS5jYWxsKGEsIGcsIGYpKSwgIWQgJiYgZiAmJiBmLmVtcHR5LmZpcmUoKTtcXG4gICAgfSwgX3F1ZXVlSG9va3M6IGZ1bmN0aW9uIF9xdWV1ZUhvb2tzKGEsIGIpIHtcXG4gICAgICB2YXIgYyA9IGIgKyBcXFwicXVldWVIb29rc1xcXCI7cmV0dXJuIE4uZ2V0KGEsIGMpIHx8IE4uYWNjZXNzKGEsIGMsIHsgZW1wdHk6IG4uQ2FsbGJhY2tzKFxcXCJvbmNlIG1lbW9yeVxcXCIpLmFkZChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIE4ucmVtb3ZlKGEsIFtiICsgXFxcInF1ZXVlXFxcIiwgY10pO1xcbiAgICAgICAgfSkgfSk7XFxuICAgIH0gfSksIG4uZm4uZXh0ZW5kKHsgcXVldWU6IGZ1bmN0aW9uIHF1ZXVlKGEsIGIpIHtcXG4gICAgICB2YXIgYyA9IDI7cmV0dXJuIFxcXCJzdHJpbmdcXFwiICE9IHR5cGVvZiBhICYmIChiID0gYSwgYSA9IFxcXCJmeFxcXCIsIGMtLSksIGFyZ3VtZW50cy5sZW5ndGggPCBjID8gbi5xdWV1ZSh0aGlzWzBdLCBhKSA6IHZvaWQgMCA9PT0gYiA/IHRoaXMgOiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGMgPSBuLnF1ZXVlKHRoaXMsIGEsIGIpO24uX3F1ZXVlSG9va3ModGhpcywgYSksIFxcXCJmeFxcXCIgPT09IGEgJiYgXFxcImlucHJvZ3Jlc3NcXFwiICE9PSBjWzBdICYmIG4uZGVxdWV1ZSh0aGlzLCBhKTtcXG4gICAgICB9KTtcXG4gICAgfSwgZGVxdWV1ZTogZnVuY3Rpb24gZGVxdWV1ZShhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBuLmRlcXVldWUodGhpcywgYSk7XFxuICAgICAgfSk7XFxuICAgIH0sIGNsZWFyUXVldWU6IGZ1bmN0aW9uIGNsZWFyUXVldWUoYSkge1xcbiAgICAgIHJldHVybiB0aGlzLnF1ZXVlKGEgfHwgXFxcImZ4XFxcIiwgW10pO1xcbiAgICB9LCBwcm9taXNlOiBmdW5jdGlvbiBwcm9taXNlKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCA9IDEsXFxuICAgICAgICAgIGUgPSBuLkRlZmVycmVkKCksXFxuICAgICAgICAgIGYgPSB0aGlzLFxcbiAgICAgICAgICBnID0gdGhpcy5sZW5ndGgsXFxuICAgICAgICAgIGggPSBmdW5jdGlvbiBoKCkge1xcbiAgICAgICAgLS1kIHx8IGUucmVzb2x2ZVdpdGgoZiwgW2ZdKTtcXG4gICAgICB9O1xcXCJzdHJpbmdcXFwiICE9IHR5cGVvZiBhICYmIChiID0gYSwgYSA9IHZvaWQgMCksIGEgPSBhIHx8IFxcXCJmeFxcXCI7d2hpbGUgKGctLSkge1xcbiAgICAgICAgYyA9IE4uZ2V0KGZbZ10sIGEgKyBcXFwicXVldWVIb29rc1xcXCIpLCBjICYmIGMuZW1wdHkgJiYgKGQrKywgYy5lbXB0eS5hZGQoaCkpO1xcbiAgICAgIH1yZXR1cm4gaCgpLCBlLnByb21pc2UoYik7XFxuICAgIH0gfSk7dmFyIFMgPSAvWystXT8oPzpcXFxcZCpcXFxcLnwpXFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrfCkvLnNvdXJjZSxcXG4gICAgICBUID0gbmV3IFJlZ0V4cChcXFwiXig/OihbKy1dKT18KShcXFwiICsgUyArIFxcXCIpKFthLXolXSopJFxcXCIsIFxcXCJpXFxcIiksXFxuICAgICAgVSA9IFtcXFwiVG9wXFxcIiwgXFxcIlJpZ2h0XFxcIiwgXFxcIkJvdHRvbVxcXCIsIFxcXCJMZWZ0XFxcIl0sXFxuICAgICAgViA9IGZ1bmN0aW9uIFYoYSwgYikge1xcbiAgICByZXR1cm4gYSA9IGIgfHwgYSwgXFxcIm5vbmVcXFwiID09PSBuLmNzcyhhLCBcXFwiZGlzcGxheVxcXCIpIHx8ICFuLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCwgYSk7XFxuICB9O2Z1bmN0aW9uIFcoYSwgYiwgYywgZCkge1xcbiAgICB2YXIgZSxcXG4gICAgICAgIGYgPSAxLFxcbiAgICAgICAgZyA9IDIwLFxcbiAgICAgICAgaCA9IGQgPyBmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuIGQuY3VyKCk7XFxuICAgIH0gOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuIG4uY3NzKGEsIGIsIFxcXCJcXFwiKTtcXG4gICAgfSxcXG4gICAgICAgIGkgPSBoKCksXFxuICAgICAgICBqID0gYyAmJiBjWzNdIHx8IChuLmNzc051bWJlcltiXSA/IFxcXCJcXFwiIDogXFxcInB4XFxcIiksXFxuICAgICAgICBrID0gKG4uY3NzTnVtYmVyW2JdIHx8IFxcXCJweFxcXCIgIT09IGogJiYgK2kpICYmIFQuZXhlYyhuLmNzcyhhLCBiKSk7aWYgKGsgJiYga1szXSAhPT0gaikge1xcbiAgICAgIGogPSBqIHx8IGtbM10sIGMgPSBjIHx8IFtdLCBrID0gK2kgfHwgMTtkbyB7XFxuICAgICAgICBmID0gZiB8fCBcXFwiLjVcXFwiLCBrIC89IGYsIG4uc3R5bGUoYSwgYiwgayArIGopO1xcbiAgICAgIH0gd2hpbGUgKGYgIT09IChmID0gaCgpIC8gaSkgJiYgMSAhPT0gZiAmJiAtLWcpO1xcbiAgICB9cmV0dXJuIGMgJiYgKGsgPSArayB8fCAraSB8fCAwLCBlID0gY1sxXSA/IGsgKyAoY1sxXSArIDEpICogY1syXSA6ICtjWzJdLCBkICYmIChkLnVuaXQgPSBqLCBkLnN0YXJ0ID0gaywgZC5lbmQgPSBlKSksIGU7XFxuICB9dmFyIFggPSAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSxcXG4gICAgICBZID0gLzwoW1xcXFx3Oi1dKykvLFxcbiAgICAgIFogPSAvXiR8XFxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2ksXFxuICAgICAgJCA9IHsgb3B0aW9uOiBbMSwgXFxcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cXFwiLCBcXFwiPC9zZWxlY3Q+XFxcIl0sIHRoZWFkOiBbMSwgXFxcIjx0YWJsZT5cXFwiLCBcXFwiPC90YWJsZT5cXFwiXSwgY29sOiBbMiwgXFxcIjx0YWJsZT48Y29sZ3JvdXA+XFxcIiwgXFxcIjwvY29sZ3JvdXA+PC90YWJsZT5cXFwiXSwgdHI6IFsyLCBcXFwiPHRhYmxlPjx0Ym9keT5cXFwiLCBcXFwiPC90Ym9keT48L3RhYmxlPlxcXCJdLCB0ZDogWzMsIFxcXCI8dGFibGU+PHRib2R5Pjx0cj5cXFwiLCBcXFwiPC90cj48L3Rib2R5PjwvdGFibGU+XFxcIl0sIF9kZWZhdWx0OiBbMCwgXFxcIlxcXCIsIFxcXCJcXFwiXSB9OyQub3B0Z3JvdXAgPSAkLm9wdGlvbiwgJC50Ym9keSA9ICQudGZvb3QgPSAkLmNvbGdyb3VwID0gJC5jYXB0aW9uID0gJC50aGVhZCwgJC50aCA9ICQudGQ7ZnVuY3Rpb24gXyhhLCBiKSB7XFxuICAgIHZhciBjID0gXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPyBhLmdldEVsZW1lbnRzQnlUYWdOYW1lKGIgfHwgXFxcIipcXFwiKSA6IFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiBhLnF1ZXJ5U2VsZWN0b3JBbGwgPyBhLnF1ZXJ5U2VsZWN0b3JBbGwoYiB8fCBcXFwiKlxcXCIpIDogW107cmV0dXJuIHZvaWQgMCA9PT0gYiB8fCBiICYmIG4ubm9kZU5hbWUoYSwgYikgPyBuLm1lcmdlKFthXSwgYykgOiBjO1xcbiAgfWZ1bmN0aW9uIGFhKGEsIGIpIHtcXG4gICAgZm9yICh2YXIgYyA9IDAsIGQgPSBhLmxlbmd0aDsgZCA+IGM7IGMrKykge1xcbiAgICAgIE4uc2V0KGFbY10sIFxcXCJnbG9iYWxFdmFsXFxcIiwgIWIgfHwgTi5nZXQoYltjXSwgXFxcImdsb2JhbEV2YWxcXFwiKSk7XFxuICAgIH1cXG4gIH12YXIgYmEgPSAvPHwmIz9cXFxcdys7LztmdW5jdGlvbiBjYShhLCBiLCBjLCBkLCBlKSB7XFxuICAgIGZvciAodmFyIGYsIGcsIGgsIGksIGosIGssIGwgPSBiLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgbSA9IFtdLCBvID0gMCwgcCA9IGEubGVuZ3RoOyBwID4gbzsgbysrKSB7XFxuICAgICAgaWYgKGYgPSBhW29dLCBmIHx8IDAgPT09IGYpIGlmIChcXFwib2JqZWN0XFxcIiA9PT0gbi50eXBlKGYpKSBuLm1lcmdlKG0sIGYubm9kZVR5cGUgPyBbZl0gOiBmKTtlbHNlIGlmIChiYS50ZXN0KGYpKSB7XFxuICAgICAgICBnID0gZyB8fCBsLmFwcGVuZENoaWxkKGIuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIikpLCBoID0gKFkuZXhlYyhmKSB8fCBbXFxcIlxcXCIsIFxcXCJcXFwiXSlbMV0udG9Mb3dlckNhc2UoKSwgaSA9ICRbaF0gfHwgJC5fZGVmYXVsdCwgZy5pbm5lckhUTUwgPSBpWzFdICsgbi5odG1sUHJlZmlsdGVyKGYpICsgaVsyXSwgayA9IGlbMF07d2hpbGUgKGstLSkge1xcbiAgICAgICAgICBnID0gZy5sYXN0Q2hpbGQ7XFxuICAgICAgICB9bi5tZXJnZShtLCBnLmNoaWxkTm9kZXMpLCBnID0gbC5maXJzdENoaWxkLCBnLnRleHRDb250ZW50ID0gXFxcIlxcXCI7XFxuICAgICAgfSBlbHNlIG0ucHVzaChiLmNyZWF0ZVRleHROb2RlKGYpKTtcXG4gICAgfWwudGV4dENvbnRlbnQgPSBcXFwiXFxcIiwgbyA9IDA7d2hpbGUgKGYgPSBtW28rK10pIHtcXG4gICAgICBpZiAoZCAmJiBuLmluQXJyYXkoZiwgZCkgPiAtMSkgZSAmJiBlLnB1c2goZik7ZWxzZSBpZiAoaiA9IG4uY29udGFpbnMoZi5vd25lckRvY3VtZW50LCBmKSwgZyA9IF8obC5hcHBlbmRDaGlsZChmKSwgXFxcInNjcmlwdFxcXCIpLCBqICYmIGFhKGcpLCBjKSB7XFxuICAgICAgICBrID0gMDt3aGlsZSAoZiA9IGdbaysrXSkge1xcbiAgICAgICAgICBaLnRlc3QoZi50eXBlIHx8IFxcXCJcXFwiKSAmJiBjLnB1c2goZik7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9cmV0dXJuIGw7XFxuICB9IWZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGEgPSBkLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcXG4gICAgICAgIGIgPSBhLmFwcGVuZENoaWxkKGQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIikpLFxcbiAgICAgICAgYyA9IGQuY3JlYXRlRWxlbWVudChcXFwiaW5wdXRcXFwiKTtjLnNldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIsIFxcXCJyYWRpb1xcXCIpLCBjLnNldEF0dHJpYnV0ZShcXFwiY2hlY2tlZFxcXCIsIFxcXCJjaGVja2VkXFxcIiksIGMuc2V0QXR0cmlidXRlKFxcXCJuYW1lXFxcIiwgXFxcInRcXFwiKSwgYi5hcHBlbmRDaGlsZChjKSwgbC5jaGVja0Nsb25lID0gYi5jbG9uZU5vZGUoITApLmNsb25lTm9kZSghMCkubGFzdENoaWxkLmNoZWNrZWQsIGIuaW5uZXJIVE1MID0gXFxcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cXFwiLCBsLm5vQ2xvbmVDaGVja2VkID0gISFiLmNsb25lTm9kZSghMCkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcXG4gIH0oKTt2YXIgZGEgPSAvXmtleS8sXFxuICAgICAgZWEgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXFxuICAgICAgZmEgPSAvXihbXi5dKikoPzpcXFxcLiguKyl8KS87ZnVuY3Rpb24gZ2EoKSB7XFxuICAgIHJldHVybiAhMDtcXG4gIH1mdW5jdGlvbiBoYSgpIHtcXG4gICAgcmV0dXJuICExO1xcbiAgfWZ1bmN0aW9uIGlhKCkge1xcbiAgICB0cnkge1xcbiAgICAgIHJldHVybiBkLmFjdGl2ZUVsZW1lbnQ7XFxuICAgIH0gY2F0Y2ggKGEpIHt9XFxuICB9ZnVuY3Rpb24gamEoYSwgYiwgYywgZCwgZSwgZikge1xcbiAgICB2YXIgZywgaDtpZiAoXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBiID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihiKSkpIHtcXG4gICAgICBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYyAmJiAoZCA9IGQgfHwgYywgYyA9IHZvaWQgMCk7Zm9yIChoIGluIGIpIHtcXG4gICAgICAgIGphKGEsIGgsIGMsIGQsIGJbaF0sIGYpO1xcbiAgICAgIH1yZXR1cm4gYTtcXG4gICAgfWlmIChudWxsID09IGQgJiYgbnVsbCA9PSBlID8gKGUgPSBjLCBkID0gYyA9IHZvaWQgMCkgOiBudWxsID09IGUgJiYgKFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBjID8gKGUgPSBkLCBkID0gdm9pZCAwKSA6IChlID0gZCwgZCA9IGMsIGMgPSB2b2lkIDApKSwgZSA9PT0gITEpIGUgPSBoYTtlbHNlIGlmICghZSkgcmV0dXJuIGE7cmV0dXJuIDEgPT09IGYgJiYgKGcgPSBlLCBlID0gZnVuY3Rpb24gZShhKSB7XFxuICAgICAgcmV0dXJuIG4oKS5vZmYoYSksIGcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgfSwgZS5ndWlkID0gZy5ndWlkIHx8IChnLmd1aWQgPSBuLmd1aWQrKykpLCBhLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgIG4uZXZlbnQuYWRkKHRoaXMsIGIsIGUsIGQsIGMpO1xcbiAgICB9KTtcXG4gIH1uLmV2ZW50ID0geyBnbG9iYWw6IHt9LCBhZGQ6IGZ1bmN0aW9uIGFkZChhLCBiLCBjLCBkLCBlKSB7XFxuICAgICAgdmFyIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGgsXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIGssXFxuICAgICAgICAgIGwsXFxuICAgICAgICAgIG0sXFxuICAgICAgICAgIG8sXFxuICAgICAgICAgIHAsXFxuICAgICAgICAgIHEsXFxuICAgICAgICAgIHIgPSBOLmdldChhKTtpZiAocikge1xcbiAgICAgICAgYy5oYW5kbGVyICYmIChmID0gYywgYyA9IGYuaGFuZGxlciwgZSA9IGYuc2VsZWN0b3IpLCBjLmd1aWQgfHwgKGMuZ3VpZCA9IG4uZ3VpZCsrKSwgKGkgPSByLmV2ZW50cykgfHwgKGkgPSByLmV2ZW50cyA9IHt9KSwgKGcgPSByLmhhbmRsZSkgfHwgKGcgPSByLmhhbmRsZSA9IGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICAgIHJldHVybiBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgbiAmJiBuLmV2ZW50LnRyaWdnZXJlZCAhPT0gYi50eXBlID8gbi5ldmVudC5kaXNwYXRjaC5hcHBseShhLCBhcmd1bWVudHMpIDogdm9pZCAwO1xcbiAgICAgICAgfSksIGIgPSAoYiB8fCBcXFwiXFxcIikubWF0Y2goRykgfHwgW1xcXCJcXFwiXSwgaiA9IGIubGVuZ3RoO3doaWxlIChqLS0pIHtcXG4gICAgICAgICAgaCA9IGZhLmV4ZWMoYltqXSkgfHwgW10sIG8gPSBxID0gaFsxXSwgcCA9IChoWzJdIHx8IFxcXCJcXFwiKS5zcGxpdChcXFwiLlxcXCIpLnNvcnQoKSwgbyAmJiAobCA9IG4uZXZlbnQuc3BlY2lhbFtvXSB8fCB7fSwgbyA9IChlID8gbC5kZWxlZ2F0ZVR5cGUgOiBsLmJpbmRUeXBlKSB8fCBvLCBsID0gbi5ldmVudC5zcGVjaWFsW29dIHx8IHt9LCBrID0gbi5leHRlbmQoeyB0eXBlOiBvLCBvcmlnVHlwZTogcSwgZGF0YTogZCwgaGFuZGxlcjogYywgZ3VpZDogYy5ndWlkLCBzZWxlY3RvcjogZSwgbmVlZHNDb250ZXh0OiBlICYmIG4uZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdChlKSwgbmFtZXNwYWNlOiBwLmpvaW4oXFxcIi5cXFwiKSB9LCBmKSwgKG0gPSBpW29dKSB8fCAobSA9IGlbb10gPSBbXSwgbS5kZWxlZ2F0ZUNvdW50ID0gMCwgbC5zZXR1cCAmJiBsLnNldHVwLmNhbGwoYSwgZCwgcCwgZykgIT09ICExIHx8IGEuYWRkRXZlbnRMaXN0ZW5lciAmJiBhLmFkZEV2ZW50TGlzdGVuZXIobywgZykpLCBsLmFkZCAmJiAobC5hZGQuY2FsbChhLCBrKSwgay5oYW5kbGVyLmd1aWQgfHwgKGsuaGFuZGxlci5ndWlkID0gYy5ndWlkKSksIGUgPyBtLnNwbGljZShtLmRlbGVnYXRlQ291bnQrKywgMCwgaykgOiBtLnB1c2goayksIG4uZXZlbnQuZ2xvYmFsW29dID0gITApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSwgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoYSwgYiwgYywgZCwgZSkge1xcbiAgICAgIHZhciBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrLFxcbiAgICAgICAgICBsLFxcbiAgICAgICAgICBtLFxcbiAgICAgICAgICBvLFxcbiAgICAgICAgICBwLFxcbiAgICAgICAgICBxLFxcbiAgICAgICAgICByID0gTi5oYXNEYXRhKGEpICYmIE4uZ2V0KGEpO2lmIChyICYmIChpID0gci5ldmVudHMpKSB7XFxuICAgICAgICBiID0gKGIgfHwgXFxcIlxcXCIpLm1hdGNoKEcpIHx8IFtcXFwiXFxcIl0sIGogPSBiLmxlbmd0aDt3aGlsZSAoai0tKSB7XFxuICAgICAgICAgIGlmIChoID0gZmEuZXhlYyhiW2pdKSB8fCBbXSwgbyA9IHEgPSBoWzFdLCBwID0gKGhbMl0gfHwgXFxcIlxcXCIpLnNwbGl0KFxcXCIuXFxcIikuc29ydCgpLCBvKSB7XFxuICAgICAgICAgICAgbCA9IG4uZXZlbnQuc3BlY2lhbFtvXSB8fCB7fSwgbyA9IChkID8gbC5kZWxlZ2F0ZVR5cGUgOiBsLmJpbmRUeXBlKSB8fCBvLCBtID0gaVtvXSB8fCBbXSwgaCA9IGhbMl0gJiYgbmV3IFJlZ0V4cChcXFwiKF58XFxcXFxcXFwuKVxcXCIgKyBwLmpvaW4oXFxcIlxcXFxcXFxcLig/Oi4qXFxcXFxcXFwufClcXFwiKSArIFxcXCIoXFxcXFxcXFwufCQpXFxcIiksIGcgPSBmID0gbS5sZW5ndGg7d2hpbGUgKGYtLSkge1xcbiAgICAgICAgICAgICAgayA9IG1bZl0sICFlICYmIHEgIT09IGsub3JpZ1R5cGUgfHwgYyAmJiBjLmd1aWQgIT09IGsuZ3VpZCB8fCBoICYmICFoLnRlc3Qoay5uYW1lc3BhY2UpIHx8IGQgJiYgZCAhPT0gay5zZWxlY3RvciAmJiAoXFxcIioqXFxcIiAhPT0gZCB8fCAhay5zZWxlY3RvcikgfHwgKG0uc3BsaWNlKGYsIDEpLCBrLnNlbGVjdG9yICYmIG0uZGVsZWdhdGVDb3VudC0tLCBsLnJlbW92ZSAmJiBsLnJlbW92ZS5jYWxsKGEsIGspKTtcXG4gICAgICAgICAgICB9ZyAmJiAhbS5sZW5ndGggJiYgKGwudGVhcmRvd24gJiYgbC50ZWFyZG93bi5jYWxsKGEsIHAsIHIuaGFuZGxlKSAhPT0gITEgfHwgbi5yZW1vdmVFdmVudChhLCBvLCByLmhhbmRsZSksIGRlbGV0ZSBpW29dKTtcXG4gICAgICAgICAgfSBlbHNlIGZvciAobyBpbiBpKSB7XFxuICAgICAgICAgICAgbi5ldmVudC5yZW1vdmUoYSwgbyArIGJbal0sIGMsIGQsICEwKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfW4uaXNFbXB0eU9iamVjdChpKSAmJiBOLnJlbW92ZShhLCBcXFwiaGFuZGxlIGV2ZW50c1xcXCIpO1xcbiAgICAgIH1cXG4gICAgfSwgZGlzcGF0Y2g6IGZ1bmN0aW9uIGRpc3BhdGNoKGEpIHtcXG4gICAgICBhID0gbi5ldmVudC5maXgoYSk7dmFyIGIsXFxuICAgICAgICAgIGMsXFxuICAgICAgICAgIGQsXFxuICAgICAgICAgIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGggPSBbXSxcXG4gICAgICAgICAgaSA9IGUuY2FsbChhcmd1bWVudHMpLFxcbiAgICAgICAgICBqID0gKE4uZ2V0KHRoaXMsIFxcXCJldmVudHNcXFwiKSB8fCB7fSlbYS50eXBlXSB8fCBbXSxcXG4gICAgICAgICAgayA9IG4uZXZlbnQuc3BlY2lhbFthLnR5cGVdIHx8IHt9O2lmIChpWzBdID0gYSwgYS5kZWxlZ2F0ZVRhcmdldCA9IHRoaXMsICFrLnByZURpc3BhdGNoIHx8IGsucHJlRGlzcGF0Y2guY2FsbCh0aGlzLCBhKSAhPT0gITEpIHtcXG4gICAgICAgIGggPSBuLmV2ZW50LmhhbmRsZXJzLmNhbGwodGhpcywgYSwgaiksIGIgPSAwO3doaWxlICgoZiA9IGhbYisrXSkgJiYgIWEuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xcbiAgICAgICAgICBhLmN1cnJlbnRUYXJnZXQgPSBmLmVsZW0sIGMgPSAwO3doaWxlICgoZyA9IGYuaGFuZGxlcnNbYysrXSkgJiYgIWEuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xcbiAgICAgICAgICAgICghYS5ybmFtZXNwYWNlIHx8IGEucm5hbWVzcGFjZS50ZXN0KGcubmFtZXNwYWNlKSkgJiYgKGEuaGFuZGxlT2JqID0gZywgYS5kYXRhID0gZy5kYXRhLCBkID0gKChuLmV2ZW50LnNwZWNpYWxbZy5vcmlnVHlwZV0gfHwge30pLmhhbmRsZSB8fCBnLmhhbmRsZXIpLmFwcGx5KGYuZWxlbSwgaSksIHZvaWQgMCAhPT0gZCAmJiAoYS5yZXN1bHQgPSBkKSA9PT0gITEgJiYgKGEucHJldmVudERlZmF1bHQoKSwgYS5zdG9wUHJvcGFnYXRpb24oKSkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9cmV0dXJuIGsucG9zdERpc3BhdGNoICYmIGsucG9zdERpc3BhdGNoLmNhbGwodGhpcywgYSksIGEucmVzdWx0O1xcbiAgICAgIH1cXG4gICAgfSwgaGFuZGxlcnM6IGZ1bmN0aW9uIGhhbmRsZXJzKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyA9IFtdLFxcbiAgICAgICAgICBoID0gYi5kZWxlZ2F0ZUNvdW50LFxcbiAgICAgICAgICBpID0gYS50YXJnZXQ7aWYgKGggJiYgaS5ub2RlVHlwZSAmJiAoXFxcImNsaWNrXFxcIiAhPT0gYS50eXBlIHx8IGlzTmFOKGEuYnV0dG9uKSB8fCBhLmJ1dHRvbiA8IDEpKSBmb3IgKDsgaSAhPT0gdGhpczsgaSA9IGkucGFyZW50Tm9kZSB8fCB0aGlzKSB7XFxuICAgICAgICBpZiAoMSA9PT0gaS5ub2RlVHlwZSAmJiAoaS5kaXNhYmxlZCAhPT0gITAgfHwgXFxcImNsaWNrXFxcIiAhPT0gYS50eXBlKSkge1xcbiAgICAgICAgICBmb3IgKGQgPSBbXSwgYyA9IDA7IGggPiBjOyBjKyspIHtcXG4gICAgICAgICAgICBmID0gYltjXSwgZSA9IGYuc2VsZWN0b3IgKyBcXFwiIFxcXCIsIHZvaWQgMCA9PT0gZFtlXSAmJiAoZFtlXSA9IGYubmVlZHNDb250ZXh0ID8gbihlLCB0aGlzKS5pbmRleChpKSA+IC0xIDogbi5maW5kKGUsIHRoaXMsIG51bGwsIFtpXSkubGVuZ3RoKSwgZFtlXSAmJiBkLnB1c2goZik7XFxuICAgICAgICAgIH1kLmxlbmd0aCAmJiBnLnB1c2goeyBlbGVtOiBpLCBoYW5kbGVyczogZCB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9cmV0dXJuIGggPCBiLmxlbmd0aCAmJiBnLnB1c2goeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogYi5zbGljZShoKSB9KSwgZztcXG4gICAgfSwgcHJvcHM6IFxcXCJhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBkZXRhaWwgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXFxcIi5zcGxpdChcXFwiIFxcXCIpLCBmaXhIb29rczoge30sIGtleUhvb2tzOiB7IHByb3BzOiBcXFwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVxcXCIuc3BsaXQoXFxcIiBcXFwiKSwgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoYSwgYikge1xcbiAgICAgICAgcmV0dXJuIG51bGwgPT0gYS53aGljaCAmJiAoYS53aGljaCA9IG51bGwgIT0gYi5jaGFyQ29kZSA/IGIuY2hhckNvZGUgOiBiLmtleUNvZGUpLCBhO1xcbiAgICAgIH0gfSwgbW91c2VIb29rczogeyBwcm9wczogXFxcImJ1dHRvbiBidXR0b25zIGNsaWVudFggY2xpZW50WSBvZmZzZXRYIG9mZnNldFkgcGFnZVggcGFnZVkgc2NyZWVuWCBzY3JlZW5ZIHRvRWxlbWVudFxcXCIuc3BsaXQoXFxcIiBcXFwiKSwgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoYSwgYikge1xcbiAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgZSxcXG4gICAgICAgICAgICBmLFxcbiAgICAgICAgICAgIGcgPSBiLmJ1dHRvbjtyZXR1cm4gbnVsbCA9PSBhLnBhZ2VYICYmIG51bGwgIT0gYi5jbGllbnRYICYmIChjID0gYS50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkLCBlID0gYy5kb2N1bWVudEVsZW1lbnQsIGYgPSBjLmJvZHksIGEucGFnZVggPSBiLmNsaWVudFggKyAoZSAmJiBlLnNjcm9sbExlZnQgfHwgZiAmJiBmLnNjcm9sbExlZnQgfHwgMCkgLSAoZSAmJiBlLmNsaWVudExlZnQgfHwgZiAmJiBmLmNsaWVudExlZnQgfHwgMCksIGEucGFnZVkgPSBiLmNsaWVudFkgKyAoZSAmJiBlLnNjcm9sbFRvcCB8fCBmICYmIGYuc2Nyb2xsVG9wIHx8IDApIC0gKGUgJiYgZS5jbGllbnRUb3AgfHwgZiAmJiBmLmNsaWVudFRvcCB8fCAwKSksIGEud2hpY2ggfHwgdm9pZCAwID09PSBnIHx8IChhLndoaWNoID0gMSAmIGcgPyAxIDogMiAmIGcgPyAzIDogNCAmIGcgPyAyIDogMCksIGE7XFxuICAgICAgfSB9LCBmaXg6IGZ1bmN0aW9uIGZpeChhKSB7XFxuICAgICAgaWYgKGFbbi5leHBhbmRvXSkgcmV0dXJuIGE7dmFyIGIsXFxuICAgICAgICAgIGMsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYgPSBhLnR5cGUsXFxuICAgICAgICAgIGcgPSBhLFxcbiAgICAgICAgICBoID0gdGhpcy5maXhIb29rc1tmXTtoIHx8ICh0aGlzLmZpeEhvb2tzW2ZdID0gaCA9IGVhLnRlc3QoZikgPyB0aGlzLm1vdXNlSG9va3MgOiBkYS50ZXN0KGYpID8gdGhpcy5rZXlIb29rcyA6IHt9KSwgZSA9IGgucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdChoLnByb3BzKSA6IHRoaXMucHJvcHMsIGEgPSBuZXcgbi5FdmVudChnKSwgYiA9IGUubGVuZ3RoO3doaWxlIChiLS0pIHtcXG4gICAgICAgIGMgPSBlW2JdLCBhW2NdID0gZ1tjXTtcXG4gICAgICB9cmV0dXJuIGEudGFyZ2V0IHx8IChhLnRhcmdldCA9IGQpLCAzID09PSBhLnRhcmdldC5ub2RlVHlwZSAmJiAoYS50YXJnZXQgPSBhLnRhcmdldC5wYXJlbnROb2RlKSwgaC5maWx0ZXIgPyBoLmZpbHRlcihhLCBnKSA6IGE7XFxuICAgIH0sIHNwZWNpYWw6IHsgbG9hZDogeyBub0J1YmJsZTogITAgfSwgZm9jdXM6IHsgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcigpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMgIT09IGlhKCkgJiYgdGhpcy5mb2N1cyA/ICh0aGlzLmZvY3VzKCksICExKSA6IHZvaWQgMDtcXG4gICAgICAgIH0sIGRlbGVnYXRlVHlwZTogXFxcImZvY3VzaW5cXFwiIH0sIGJsdXI6IHsgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcigpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMgPT09IGlhKCkgJiYgdGhpcy5ibHVyID8gKHRoaXMuYmx1cigpLCAhMSkgOiB2b2lkIDA7XFxuICAgICAgICB9LCBkZWxlZ2F0ZVR5cGU6IFxcXCJmb2N1c291dFxcXCIgfSwgY2xpY2s6IHsgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcigpIHtcXG4gICAgICAgICAgcmV0dXJuIFxcXCJjaGVja2JveFxcXCIgPT09IHRoaXMudHlwZSAmJiB0aGlzLmNsaWNrICYmIG4ubm9kZU5hbWUodGhpcywgXFxcImlucHV0XFxcIikgPyAodGhpcy5jbGljaygpLCAhMSkgOiB2b2lkIDA7XFxuICAgICAgICB9LCBfZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoYSkge1xcbiAgICAgICAgICByZXR1cm4gbi5ub2RlTmFtZShhLnRhcmdldCwgXFxcImFcXFwiKTtcXG4gICAgICAgIH0gfSwgYmVmb3JldW5sb2FkOiB7IHBvc3REaXNwYXRjaDogZnVuY3Rpb24gcG9zdERpc3BhdGNoKGEpIHtcXG4gICAgICAgICAgdm9pZCAwICE9PSBhLnJlc3VsdCAmJiBhLm9yaWdpbmFsRXZlbnQgJiYgKGEub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGEucmVzdWx0KTtcXG4gICAgICAgIH0gfSB9IH0sIG4ucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICBhLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiYgYS5yZW1vdmVFdmVudExpc3RlbmVyKGIsIGMpO1xcbiAgfSwgbi5FdmVudCA9IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2Ygbi5FdmVudCA/IChhICYmIGEudHlwZSA/ICh0aGlzLm9yaWdpbmFsRXZlbnQgPSBhLCB0aGlzLnR5cGUgPSBhLnR5cGUsIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gYS5kZWZhdWx0UHJldmVudGVkIHx8IHZvaWQgMCA9PT0gYS5kZWZhdWx0UHJldmVudGVkICYmIGEucmV0dXJuVmFsdWUgPT09ICExID8gZ2EgOiBoYSkgOiB0aGlzLnR5cGUgPSBhLCBiICYmIG4uZXh0ZW5kKHRoaXMsIGIpLCB0aGlzLnRpbWVTdGFtcCA9IGEgJiYgYS50aW1lU3RhbXAgfHwgbi5ub3coKSwgdm9pZCAodGhpc1tuLmV4cGFuZG9dID0gITApKSA6IG5ldyBuLkV2ZW50KGEsIGIpO1xcbiAgfSwgbi5FdmVudC5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBuLkV2ZW50LCBpc0RlZmF1bHRQcmV2ZW50ZWQ6IGhhLCBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogaGEsIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiBoYSwgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xcbiAgICAgIHZhciBhID0gdGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZ2EsIGEgJiYgYS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICB9LCBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbigpIHtcXG4gICAgICB2YXIgYSA9IHRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZ2EsIGEgJiYgYS5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgfSwgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbiBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XFxuICAgICAgdmFyIGEgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IGdhLCBhICYmIGEuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgIH0gfSwgbi5lYWNoKHsgbW91c2VlbnRlcjogXFxcIm1vdXNlb3ZlclxcXCIsIG1vdXNlbGVhdmU6IFxcXCJtb3VzZW91dFxcXCIsIHBvaW50ZXJlbnRlcjogXFxcInBvaW50ZXJvdmVyXFxcIiwgcG9pbnRlcmxlYXZlOiBcXFwicG9pbnRlcm91dFxcXCIgfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5ldmVudC5zcGVjaWFsW2FdID0geyBkZWxlZ2F0ZVR5cGU6IGIsIGJpbmRUeXBlOiBiLCBoYW5kbGU6IGZ1bmN0aW9uIGhhbmRsZShhKSB7XFxuICAgICAgICB2YXIgYyxcXG4gICAgICAgICAgICBkID0gdGhpcyxcXG4gICAgICAgICAgICBlID0gYS5yZWxhdGVkVGFyZ2V0LFxcbiAgICAgICAgICAgIGYgPSBhLmhhbmRsZU9iajtyZXR1cm4gKCFlIHx8IGUgIT09IGQgJiYgIW4uY29udGFpbnMoZCwgZSkpICYmIChhLnR5cGUgPSBmLm9yaWdUeXBlLCBjID0gZi5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGEudHlwZSA9IGIpLCBjO1xcbiAgICAgIH0gfTtcXG4gIH0pLCBuLmZuLmV4dGVuZCh7IG9uOiBmdW5jdGlvbiBvbihhLCBiLCBjLCBkKSB7XFxuICAgICAgcmV0dXJuIGphKHRoaXMsIGEsIGIsIGMsIGQpO1xcbiAgICB9LCBvbmU6IGZ1bmN0aW9uIG9uZShhLCBiLCBjLCBkKSB7XFxuICAgICAgcmV0dXJuIGphKHRoaXMsIGEsIGIsIGMsIGQsIDEpO1xcbiAgICB9LCBvZmY6IGZ1bmN0aW9uIG9mZihhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQsIGU7aWYgKGEgJiYgYS5wcmV2ZW50RGVmYXVsdCAmJiBhLmhhbmRsZU9iaikgcmV0dXJuIGQgPSBhLmhhbmRsZU9iaiwgbihhLmRlbGVnYXRlVGFyZ2V0KS5vZmYoZC5uYW1lc3BhY2UgPyBkLm9yaWdUeXBlICsgXFxcIi5cXFwiICsgZC5uYW1lc3BhY2UgOiBkLm9yaWdUeXBlLCBkLnNlbGVjdG9yLCBkLmhhbmRsZXIpLCB0aGlzO2lmIChcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGEgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGEpKSkge1xcbiAgICAgICAgZm9yIChlIGluIGEpIHtcXG4gICAgICAgICAgdGhpcy5vZmYoZSwgYiwgYVtlXSk7XFxuICAgICAgICB9cmV0dXJuIHRoaXM7XFxuICAgICAgfXJldHVybiAoYiA9PT0gITEgfHwgXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2YgYikgJiYgKGMgPSBiLCBiID0gdm9pZCAwKSwgYyA9PT0gITEgJiYgKGMgPSBoYSksIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBuLmV2ZW50LnJlbW92ZSh0aGlzLCBhLCBjLCBiKTtcXG4gICAgICB9KTtcXG4gICAgfSB9KTt2YXIga2EgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFxcXHc6LV0rKVtePl0qKVxcXFwvPi9naSxcXG4gICAgICBsYSA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxcbiAgICAgIG1hID0gL2NoZWNrZWRcXFxccyooPzpbXj1dfD1cXFxccyouY2hlY2tlZC4pL2ksXFxuICAgICAgbmEgPSAvXnRydWVcXFxcLyguKikvLFxcbiAgICAgIG9hID0gL15cXFxccyo8ISg/OlxcXFxbQ0RBVEFcXFxcW3wtLSl8KD86XFxcXF1cXFxcXXwtLSk+XFxcXHMqJC9nO2Z1bmN0aW9uIHBhKGEsIGIpIHtcXG4gICAgcmV0dXJuIG4ubm9kZU5hbWUoYSwgXFxcInRhYmxlXFxcIikgJiYgbi5ub2RlTmFtZSgxMSAhPT0gYi5ub2RlVHlwZSA/IGIgOiBiLmZpcnN0Q2hpbGQsIFxcXCJ0clxcXCIpID8gYS5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwidGJvZHlcXFwiKVswXSB8fCBhLmFwcGVuZENoaWxkKGEub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJ0Ym9keVxcXCIpKSA6IGE7XFxuICB9ZnVuY3Rpb24gcWEoYSkge1xcbiAgICByZXR1cm4gYS50eXBlID0gKG51bGwgIT09IGEuZ2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIikpICsgXFxcIi9cXFwiICsgYS50eXBlLCBhO1xcbiAgfWZ1bmN0aW9uIHJhKGEpIHtcXG4gICAgdmFyIGIgPSBuYS5leGVjKGEudHlwZSk7cmV0dXJuIGIgPyBhLnR5cGUgPSBiWzFdIDogYS5yZW1vdmVBdHRyaWJ1dGUoXFxcInR5cGVcXFwiKSwgYTtcXG4gIH1mdW5jdGlvbiBzYShhLCBiKSB7XFxuICAgIHZhciBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqO2lmICgxID09PSBiLm5vZGVUeXBlKSB7XFxuICAgICAgaWYgKE4uaGFzRGF0YShhKSAmJiAoZiA9IE4uYWNjZXNzKGEpLCBnID0gTi5zZXQoYiwgZiksIGogPSBmLmV2ZW50cykpIHtcXG4gICAgICAgIGRlbGV0ZSBnLmhhbmRsZSwgZy5ldmVudHMgPSB7fTtmb3IgKGUgaW4gaikge1xcbiAgICAgICAgICBmb3IgKGMgPSAwLCBkID0galtlXS5sZW5ndGg7IGQgPiBjOyBjKyspIHtcXG4gICAgICAgICAgICBuLmV2ZW50LmFkZChiLCBlLCBqW2VdW2NdKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1PLmhhc0RhdGEoYSkgJiYgKGggPSBPLmFjY2VzcyhhKSwgaSA9IG4uZXh0ZW5kKHt9LCBoKSwgTy5zZXQoYiwgaSkpO1xcbiAgICB9XFxuICB9ZnVuY3Rpb24gdGEoYSwgYikge1xcbiAgICB2YXIgYyA9IGIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcXFwiaW5wdXRcXFwiID09PSBjICYmIFgudGVzdChhLnR5cGUpID8gYi5jaGVja2VkID0gYS5jaGVja2VkIDogKFxcXCJpbnB1dFxcXCIgPT09IGMgfHwgXFxcInRleHRhcmVhXFxcIiA9PT0gYykgJiYgKGIuZGVmYXVsdFZhbHVlID0gYS5kZWZhdWx0VmFsdWUpO1xcbiAgfWZ1bmN0aW9uIHVhKGEsIGIsIGMsIGQpIHtcXG4gICAgYiA9IGYuYXBwbHkoW10sIGIpO3ZhciBlLFxcbiAgICAgICAgZyxcXG4gICAgICAgIGgsXFxuICAgICAgICBpLFxcbiAgICAgICAgaixcXG4gICAgICAgIGssXFxuICAgICAgICBtID0gMCxcXG4gICAgICAgIG8gPSBhLmxlbmd0aCxcXG4gICAgICAgIHAgPSBvIC0gMSxcXG4gICAgICAgIHEgPSBiWzBdLFxcbiAgICAgICAgciA9IG4uaXNGdW5jdGlvbihxKTtpZiAociB8fCBvID4gMSAmJiBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgcSAmJiAhbC5jaGVja0Nsb25lICYmIG1hLnRlc3QocSkpIHJldHVybiBhLmVhY2goZnVuY3Rpb24gKGUpIHtcXG4gICAgICB2YXIgZiA9IGEuZXEoZSk7ciAmJiAoYlswXSA9IHEuY2FsbCh0aGlzLCBlLCBmLmh0bWwoKSkpLCB1YShmLCBiLCBjLCBkKTtcXG4gICAgfSk7aWYgKG8gJiYgKGUgPSBjYShiLCBhWzBdLm93bmVyRG9jdW1lbnQsICExLCBhLCBkKSwgZyA9IGUuZmlyc3RDaGlsZCwgMSA9PT0gZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiAoZSA9IGcpLCBnIHx8IGQpKSB7XFxuICAgICAgZm9yIChoID0gbi5tYXAoXyhlLCBcXFwic2NyaXB0XFxcIiksIHFhKSwgaSA9IGgubGVuZ3RoOyBvID4gbTsgbSsrKSB7XFxuICAgICAgICBqID0gZSwgbSAhPT0gcCAmJiAoaiA9IG4uY2xvbmUoaiwgITAsICEwKSwgaSAmJiBuLm1lcmdlKGgsIF8oaiwgXFxcInNjcmlwdFxcXCIpKSksIGMuY2FsbChhW21dLCBqLCBtKTtcXG4gICAgICB9aWYgKGkpIGZvciAoayA9IGhbaC5sZW5ndGggLSAxXS5vd25lckRvY3VtZW50LCBuLm1hcChoLCByYSksIG0gPSAwOyBpID4gbTsgbSsrKSB7XFxuICAgICAgICBqID0gaFttXSwgWi50ZXN0KGoudHlwZSB8fCBcXFwiXFxcIikgJiYgIU4uYWNjZXNzKGosIFxcXCJnbG9iYWxFdmFsXFxcIikgJiYgbi5jb250YWlucyhrLCBqKSAmJiAoai5zcmMgPyBuLl9ldmFsVXJsICYmIG4uX2V2YWxVcmwoai5zcmMpIDogbi5nbG9iYWxFdmFsKGoudGV4dENvbnRlbnQucmVwbGFjZShvYSwgXFxcIlxcXCIpKSk7XFxuICAgICAgfVxcbiAgICB9cmV0dXJuIGE7XFxuICB9ZnVuY3Rpb24gdmEoYSwgYiwgYykge1xcbiAgICBmb3IgKHZhciBkLCBlID0gYiA/IG4uZmlsdGVyKGIsIGEpIDogYSwgZiA9IDA7IG51bGwgIT0gKGQgPSBlW2ZdKTsgZisrKSB7XFxuICAgICAgYyB8fCAxICE9PSBkLm5vZGVUeXBlIHx8IG4uY2xlYW5EYXRhKF8oZCkpLCBkLnBhcmVudE5vZGUgJiYgKGMgJiYgbi5jb250YWlucyhkLm93bmVyRG9jdW1lbnQsIGQpICYmIGFhKF8oZCwgXFxcInNjcmlwdFxcXCIpKSwgZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGQpKTtcXG4gICAgfXJldHVybiBhO1xcbiAgfW4uZXh0ZW5kKHsgaHRtbFByZWZpbHRlcjogZnVuY3Rpb24gaHRtbFByZWZpbHRlcihhKSB7XFxuICAgICAgcmV0dXJuIGEucmVwbGFjZShrYSwgXFxcIjwkMT48LyQyPlxcXCIpO1xcbiAgICB9LCBjbG9uZTogZnVuY3Rpb24gY2xvbmUoYSwgYiwgYykge1xcbiAgICAgIHZhciBkLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoID0gYS5jbG9uZU5vZGUoITApLFxcbiAgICAgICAgICBpID0gbi5jb250YWlucyhhLm93bmVyRG9jdW1lbnQsIGEpO2lmICghKGwubm9DbG9uZUNoZWNrZWQgfHwgMSAhPT0gYS5ub2RlVHlwZSAmJiAxMSAhPT0gYS5ub2RlVHlwZSB8fCBuLmlzWE1MRG9jKGEpKSkgZm9yIChnID0gXyhoKSwgZiA9IF8oYSksIGQgPSAwLCBlID0gZi5sZW5ndGg7IGUgPiBkOyBkKyspIHtcXG4gICAgICAgIHRhKGZbZF0sIGdbZF0pO1xcbiAgICAgIH1pZiAoYikgaWYgKGMpIGZvciAoZiA9IGYgfHwgXyhhKSwgZyA9IGcgfHwgXyhoKSwgZCA9IDAsIGUgPSBmLmxlbmd0aDsgZSA+IGQ7IGQrKykge1xcbiAgICAgICAgc2EoZltkXSwgZ1tkXSk7XFxuICAgICAgfSBlbHNlIHNhKGEsIGgpO3JldHVybiBnID0gXyhoLCBcXFwic2NyaXB0XFxcIiksIGcubGVuZ3RoID4gMCAmJiBhYShnLCAhaSAmJiBfKGEsIFxcXCJzY3JpcHRcXFwiKSksIGg7XFxuICAgIH0sIGNsZWFuRGF0YTogZnVuY3Rpb24gY2xlYW5EYXRhKGEpIHtcXG4gICAgICBmb3IgKHZhciBiLCBjLCBkLCBlID0gbi5ldmVudC5zcGVjaWFsLCBmID0gMDsgdm9pZCAwICE9PSAoYyA9IGFbZl0pOyBmKyspIHtcXG4gICAgICAgIGlmIChMKGMpKSB7XFxuICAgICAgICAgIGlmIChiID0gY1tOLmV4cGFuZG9dKSB7XFxuICAgICAgICAgICAgaWYgKGIuZXZlbnRzKSBmb3IgKGQgaW4gYi5ldmVudHMpIHtcXG4gICAgICAgICAgICAgIGVbZF0gPyBuLmV2ZW50LnJlbW92ZShjLCBkKSA6IG4ucmVtb3ZlRXZlbnQoYywgZCwgYi5oYW5kbGUpO1xcbiAgICAgICAgICAgIH1jW04uZXhwYW5kb10gPSB2b2lkIDA7XFxuICAgICAgICAgIH1jW08uZXhwYW5kb10gJiYgKGNbTy5leHBhbmRvXSA9IHZvaWQgMCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9IH0pLCBuLmZuLmV4dGVuZCh7IGRvbU1hbmlwOiB1YSwgZGV0YWNoOiBmdW5jdGlvbiBkZXRhY2goYSkge1xcbiAgICAgIHJldHVybiB2YSh0aGlzLCBhLCAhMCk7XFxuICAgIH0sIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGEpIHtcXG4gICAgICByZXR1cm4gdmEodGhpcywgYSk7XFxuICAgIH0sIHRleHQ6IGZ1bmN0aW9uIHRleHQoYSkge1xcbiAgICAgIHJldHVybiBLKHRoaXMsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICByZXR1cm4gdm9pZCAwID09PSBhID8gbi50ZXh0KHRoaXMpIDogdGhpcy5lbXB0eSgpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAoMSA9PT0gdGhpcy5ub2RlVHlwZSB8fCAxMSA9PT0gdGhpcy5ub2RlVHlwZSB8fCA5ID09PSB0aGlzLm5vZGVUeXBlKSAmJiAodGhpcy50ZXh0Q29udGVudCA9IGEpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSwgbnVsbCwgYSwgYXJndW1lbnRzLmxlbmd0aCk7XFxuICAgIH0sIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKCkge1xcbiAgICAgIHJldHVybiB1YSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICBpZiAoMSA9PT0gdGhpcy5ub2RlVHlwZSB8fCAxMSA9PT0gdGhpcy5ub2RlVHlwZSB8fCA5ID09PSB0aGlzLm5vZGVUeXBlKSB7XFxuICAgICAgICAgIHZhciBiID0gcGEodGhpcywgYSk7Yi5hcHBlbmRDaGlsZChhKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSwgcHJlcGVuZDogZnVuY3Rpb24gcHJlcGVuZCgpIHtcXG4gICAgICByZXR1cm4gdWEodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgaWYgKDEgPT09IHRoaXMubm9kZVR5cGUgfHwgMTEgPT09IHRoaXMubm9kZVR5cGUgfHwgOSA9PT0gdGhpcy5ub2RlVHlwZSkge1xcbiAgICAgICAgICB2YXIgYiA9IHBhKHRoaXMsIGEpO2IuaW5zZXJ0QmVmb3JlKGEsIGIuZmlyc3RDaGlsZCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sIGJlZm9yZTogZnVuY3Rpb24gYmVmb3JlKCkge1xcbiAgICAgIHJldHVybiB1YSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB0aGlzLnBhcmVudE5vZGUgJiYgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLCB0aGlzKTtcXG4gICAgICB9KTtcXG4gICAgfSwgYWZ0ZXI6IGZ1bmN0aW9uIGFmdGVyKCkge1xcbiAgICAgIHJldHVybiB1YSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB0aGlzLnBhcmVudE5vZGUgJiYgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLCB0aGlzLm5leHRTaWJsaW5nKTtcXG4gICAgICB9KTtcXG4gICAgfSwgZW1wdHk6IGZ1bmN0aW9uIGVtcHR5KCkge1xcbiAgICAgIGZvciAodmFyIGEsIGIgPSAwOyBudWxsICE9IChhID0gdGhpc1tiXSk7IGIrKykge1xcbiAgICAgICAgMSA9PT0gYS5ub2RlVHlwZSAmJiAobi5jbGVhbkRhdGEoXyhhLCAhMSkpLCBhLnRleHRDb250ZW50ID0gXFxcIlxcXCIpO1xcbiAgICAgIH1yZXR1cm4gdGhpcztcXG4gICAgfSwgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKGEsIGIpIHtcXG4gICAgICByZXR1cm4gYSA9IG51bGwgPT0gYSA/ICExIDogYSwgYiA9IG51bGwgPT0gYiA/IGEgOiBiLCB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gbi5jbG9uZSh0aGlzLCBhLCBiKTtcXG4gICAgICB9KTtcXG4gICAgfSwgaHRtbDogZnVuY3Rpb24gaHRtbChhKSB7XFxuICAgICAgcmV0dXJuIEsodGhpcywgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHZhciBiID0gdGhpc1swXSB8fCB7fSxcXG4gICAgICAgICAgICBjID0gMCxcXG4gICAgICAgICAgICBkID0gdGhpcy5sZW5ndGg7aWYgKHZvaWQgMCA9PT0gYSAmJiAxID09PSBiLm5vZGVUeXBlKSByZXR1cm4gYi5pbm5lckhUTUw7aWYgKFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhICYmICFsYS50ZXN0KGEpICYmICEkWyhZLmV4ZWMoYSkgfHwgW1xcXCJcXFwiLCBcXFwiXFxcIl0pWzFdLnRvTG93ZXJDYXNlKCldKSB7XFxuICAgICAgICAgIGEgPSBuLmh0bWxQcmVmaWx0ZXIoYSk7dHJ5IHtcXG4gICAgICAgICAgICBmb3IgKDsgZCA+IGM7IGMrKykge1xcbiAgICAgICAgICAgICAgYiA9IHRoaXNbY10gfHwge30sIDEgPT09IGIubm9kZVR5cGUgJiYgKG4uY2xlYW5EYXRhKF8oYiwgITEpKSwgYi5pbm5lckhUTUwgPSBhKTtcXG4gICAgICAgICAgICB9YiA9IDA7XFxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgICAgICB9YiAmJiB0aGlzLmVtcHR5KCkuYXBwZW5kKGEpO1xcbiAgICAgIH0sIG51bGwsIGEsIGFyZ3VtZW50cy5sZW5ndGgpO1xcbiAgICB9LCByZXBsYWNlV2l0aDogZnVuY3Rpb24gcmVwbGFjZVdpdGgoKSB7XFxuICAgICAgdmFyIGEgPSBbXTtyZXR1cm4gdWEodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgdmFyIGMgPSB0aGlzLnBhcmVudE5vZGU7bi5pbkFycmF5KHRoaXMsIGEpIDwgMCAmJiAobi5jbGVhbkRhdGEoXyh0aGlzKSksIGMgJiYgYy5yZXBsYWNlQ2hpbGQoYiwgdGhpcykpO1xcbiAgICAgIH0sIGEpO1xcbiAgICB9IH0pLCBuLmVhY2goeyBhcHBlbmRUbzogXFxcImFwcGVuZFxcXCIsIHByZXBlbmRUbzogXFxcInByZXBlbmRcXFwiLCBpbnNlcnRCZWZvcmU6IFxcXCJiZWZvcmVcXFwiLCBpbnNlcnRBZnRlcjogXFxcImFmdGVyXFxcIiwgcmVwbGFjZUFsbDogXFxcInJlcGxhY2VXaXRoXFxcIiB9LCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmZuW2FdID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICBmb3IgKHZhciBjLCBkID0gW10sIGUgPSBuKGEpLCBmID0gZS5sZW5ndGggLSAxLCBoID0gMDsgZiA+PSBoOyBoKyspIHtcXG4gICAgICAgIGMgPSBoID09PSBmID8gdGhpcyA6IHRoaXMuY2xvbmUoITApLCBuKGVbaF0pW2JdKGMpLCBnLmFwcGx5KGQsIGMuZ2V0KCkpO1xcbiAgICAgIH1yZXR1cm4gdGhpcy5wdXNoU3RhY2soZCk7XFxuICAgIH07XFxuICB9KTt2YXIgd2EsXFxuICAgICAgeGEgPSB7IEhUTUw6IFxcXCJibG9ja1xcXCIsIEJPRFk6IFxcXCJibG9ja1xcXCIgfTtmdW5jdGlvbiB5YShhLCBiKSB7XFxuICAgIHZhciBjID0gbihiLmNyZWF0ZUVsZW1lbnQoYSkpLmFwcGVuZFRvKGIuYm9keSksXFxuICAgICAgICBkID0gbi5jc3MoY1swXSwgXFxcImRpc3BsYXlcXFwiKTtyZXR1cm4gYy5kZXRhY2goKSwgZDtcXG4gIH1mdW5jdGlvbiB6YShhKSB7XFxuICAgIHZhciBiID0gZCxcXG4gICAgICAgIGMgPSB4YVthXTtyZXR1cm4gYyB8fCAoYyA9IHlhKGEsIGIpLCBcXFwibm9uZVxcXCIgIT09IGMgJiYgYyB8fCAod2EgPSAod2EgfHwgbihcXFwiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPlxcXCIpKS5hcHBlbmRUbyhiLmRvY3VtZW50RWxlbWVudCksIGIgPSB3YVswXS5jb250ZW50RG9jdW1lbnQsIGIud3JpdGUoKSwgYi5jbG9zZSgpLCBjID0geWEoYSwgYiksIHdhLmRldGFjaCgpKSwgeGFbYV0gPSBjKSwgYztcXG4gIH12YXIgQWEgPSAvXm1hcmdpbi8sXFxuICAgICAgQmEgPSBuZXcgUmVnRXhwKFxcXCJeKFxcXCIgKyBTICsgXFxcIikoPyFweClbYS16JV0rJFxcXCIsIFxcXCJpXFxcIiksXFxuICAgICAgQ2EgPSBmdW5jdGlvbiBDYShiKSB7XFxuICAgIHZhciBjID0gYi5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O3JldHVybiBjICYmIGMub3BlbmVyIHx8IChjID0gYSksIGMuZ2V0Q29tcHV0ZWRTdHlsZShiKTtcXG4gIH0sXFxuICAgICAgRGEgPSBmdW5jdGlvbiBEYShhLCBiLCBjLCBkKSB7XFxuICAgIHZhciBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcgPSB7fTtmb3IgKGYgaW4gYikge1xcbiAgICAgIGdbZl0gPSBhLnN0eWxlW2ZdLCBhLnN0eWxlW2ZdID0gYltmXTtcXG4gICAgfWUgPSBjLmFwcGx5KGEsIGQgfHwgW10pO2ZvciAoZiBpbiBiKSB7XFxuICAgICAgYS5zdHlsZVtmXSA9IGdbZl07XFxuICAgIH1yZXR1cm4gZTtcXG4gIH0sXFxuICAgICAgRWEgPSBkLmRvY3VtZW50RWxlbWVudDshZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgYixcXG4gICAgICAgIGMsXFxuICAgICAgICBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcgPSBkLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpLFxcbiAgICAgICAgaCA9IGQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7aWYgKGguc3R5bGUpIHtcXG4gICAgICAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGkgPSBmdW5jdGlvbiBpKCkge1xcbiAgICAgICAgICBoLnN0eWxlLmNzc1RleHQgPSBcXFwiLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7bWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDt0b3A6MSU7d2lkdGg6NTAlXFxcIiwgaC5pbm5lckhUTUwgPSBcXFwiXFxcIiwgRWEuYXBwZW5kQ2hpbGQoZyk7dmFyIGQgPSBhLmdldENvbXB1dGVkU3R5bGUoaCk7YiA9IFxcXCIxJVxcXCIgIT09IGQudG9wLCBmID0gXFxcIjJweFxcXCIgPT09IGQubWFyZ2luTGVmdCwgYyA9IFxcXCI0cHhcXFwiID09PSBkLndpZHRoLCBoLnN0eWxlLm1hcmdpblJpZ2h0ID0gXFxcIjUwJVxcXCIsIGUgPSBcXFwiNHB4XFxcIiA9PT0gZC5tYXJnaW5SaWdodCwgRWEucmVtb3ZlQ2hpbGQoZyk7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgaC5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFxcXCJjb250ZW50LWJveFxcXCIsIGguY2xvbmVOb2RlKCEwKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFxcXCJcXFwiLCBsLmNsZWFyQ2xvbmVTdHlsZSA9IFxcXCJjb250ZW50LWJveFxcXCIgPT09IGguc3R5bGUuYmFja2dyb3VuZENsaXAsIGcuc3R5bGUuY3NzVGV4dCA9IFxcXCJib3JkZXI6MDt3aWR0aDo4cHg7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O3BhZGRpbmc6MDttYXJnaW4tdG9wOjFweDtwb3NpdGlvbjphYnNvbHV0ZVxcXCIsIGcuYXBwZW5kQ2hpbGQoaCk7bi5leHRlbmQobCwgeyBwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbiBwaXhlbFBvc2l0aW9uKCkge1xcbiAgICAgICAgICAgIHJldHVybiBpKCksIGI7XFxuICAgICAgICAgIH0sIGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbiBib3hTaXppbmdSZWxpYWJsZSgpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBjICYmIGkoKSwgYztcXG4gICAgICAgICAgfSwgcGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24gcGl4ZWxNYXJnaW5SaWdodCgpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBjICYmIGkoKSwgZTtcXG4gICAgICAgICAgfSwgcmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbiByZWxpYWJsZU1hcmdpbkxlZnQoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gYyAmJiBpKCksIGY7XFxuICAgICAgICAgIH0sIHJlbGlhYmxlTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uIHJlbGlhYmxlTWFyZ2luUmlnaHQoKSB7XFxuICAgICAgICAgICAgdmFyIGIsXFxuICAgICAgICAgICAgICAgIGMgPSBoLmFwcGVuZENoaWxkKGQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIikpO3JldHVybiBjLnN0eWxlLmNzc1RleHQgPSBoLnN0eWxlLmNzc1RleHQgPSBcXFwiLXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JveC1zaXppbmc6Y29udGVudC1ib3g7ZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjBcXFwiLCBjLnN0eWxlLm1hcmdpblJpZ2h0ID0gYy5zdHlsZS53aWR0aCA9IFxcXCIwXFxcIiwgaC5zdHlsZS53aWR0aCA9IFxcXCIxcHhcXFwiLCBFYS5hcHBlbmRDaGlsZChnKSwgYiA9ICFwYXJzZUZsb2F0KGEuZ2V0Q29tcHV0ZWRTdHlsZShjKS5tYXJnaW5SaWdodCksIEVhLnJlbW92ZUNoaWxkKGcpLCBoLnJlbW92ZUNoaWxkKGMpLCBiO1xcbiAgICAgICAgICB9IH0pO1xcbiAgICAgIH0pKCk7XFxuICAgIH1cXG4gIH0oKTtmdW5jdGlvbiBGYShhLCBiLCBjKSB7XFxuICAgIHZhciBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCA9IGEuc3R5bGU7cmV0dXJuIGMgPSBjIHx8IENhKGEpLCBnID0gYyA/IGMuZ2V0UHJvcGVydHlWYWx1ZShiKSB8fCBjW2JdIDogdm9pZCAwLCBcXFwiXFxcIiAhPT0gZyAmJiB2b2lkIDAgIT09IGcgfHwgbi5jb250YWlucyhhLm93bmVyRG9jdW1lbnQsIGEpIHx8IChnID0gbi5zdHlsZShhLCBiKSksIGMgJiYgIWwucGl4ZWxNYXJnaW5SaWdodCgpICYmIEJhLnRlc3QoZykgJiYgQWEudGVzdChiKSAmJiAoZCA9IGgud2lkdGgsIGUgPSBoLm1pbldpZHRoLCBmID0gaC5tYXhXaWR0aCwgaC5taW5XaWR0aCA9IGgubWF4V2lkdGggPSBoLndpZHRoID0gZywgZyA9IGMud2lkdGgsIGgud2lkdGggPSBkLCBoLm1pbldpZHRoID0gZSwgaC5tYXhXaWR0aCA9IGYpLCB2b2lkIDAgIT09IGcgPyBnICsgXFxcIlxcXCIgOiBnO1xcbiAgfWZ1bmN0aW9uIEdhKGEsIGIpIHtcXG4gICAgcmV0dXJuIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gYSgpID8gdm9pZCBkZWxldGUgdGhpcy5nZXQgOiAodGhpcy5nZXQgPSBiKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH0gfTtcXG4gIH12YXIgSGEgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXFxuICAgICAgSWEgPSB7IHBvc2l0aW9uOiBcXFwiYWJzb2x1dGVcXFwiLCB2aXNpYmlsaXR5OiBcXFwiaGlkZGVuXFxcIiwgZGlzcGxheTogXFxcImJsb2NrXFxcIiB9LFxcbiAgICAgIEphID0geyBsZXR0ZXJTcGFjaW5nOiBcXFwiMFxcXCIsIGZvbnRXZWlnaHQ6IFxcXCI0MDBcXFwiIH0sXFxuICAgICAgS2EgPSBbXFxcIldlYmtpdFxcXCIsIFxcXCJPXFxcIiwgXFxcIk1velxcXCIsIFxcXCJtc1xcXCJdLFxcbiAgICAgIExhID0gZC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKS5zdHlsZTtmdW5jdGlvbiBNYShhKSB7XFxuICAgIGlmIChhIGluIExhKSByZXR1cm4gYTt2YXIgYiA9IGFbMF0udG9VcHBlckNhc2UoKSArIGEuc2xpY2UoMSksXFxuICAgICAgICBjID0gS2EubGVuZ3RoO3doaWxlIChjLS0pIHtcXG4gICAgICBpZiAoYSA9IEthW2NdICsgYiwgYSBpbiBMYSkgcmV0dXJuIGE7XFxuICAgIH1cXG4gIH1mdW5jdGlvbiBOYShhLCBiLCBjKSB7XFxuICAgIHZhciBkID0gVC5leGVjKGIpO3JldHVybiBkID8gTWF0aC5tYXgoMCwgZFsyXSAtIChjIHx8IDApKSArIChkWzNdIHx8IFxcXCJweFxcXCIpIDogYjtcXG4gIH1mdW5jdGlvbiBPYShhLCBiLCBjLCBkLCBlKSB7XFxuICAgIGZvciAodmFyIGYgPSBjID09PSAoZCA/IFxcXCJib3JkZXJcXFwiIDogXFxcImNvbnRlbnRcXFwiKSA/IDQgOiBcXFwid2lkdGhcXFwiID09PSBiID8gMSA6IDAsIGcgPSAwOyA0ID4gZjsgZiArPSAyKSB7XFxuICAgICAgXFxcIm1hcmdpblxcXCIgPT09IGMgJiYgKGcgKz0gbi5jc3MoYSwgYyArIFVbZl0sICEwLCBlKSksIGQgPyAoXFxcImNvbnRlbnRcXFwiID09PSBjICYmIChnIC09IG4uY3NzKGEsIFxcXCJwYWRkaW5nXFxcIiArIFVbZl0sICEwLCBlKSksIFxcXCJtYXJnaW5cXFwiICE9PSBjICYmIChnIC09IG4uY3NzKGEsIFxcXCJib3JkZXJcXFwiICsgVVtmXSArIFxcXCJXaWR0aFxcXCIsICEwLCBlKSkpIDogKGcgKz0gbi5jc3MoYSwgXFxcInBhZGRpbmdcXFwiICsgVVtmXSwgITAsIGUpLCBcXFwicGFkZGluZ1xcXCIgIT09IGMgJiYgKGcgKz0gbi5jc3MoYSwgXFxcImJvcmRlclxcXCIgKyBVW2ZdICsgXFxcIldpZHRoXFxcIiwgITAsIGUpKSk7XFxuICAgIH1yZXR1cm4gZztcXG4gIH1mdW5jdGlvbiBQYShiLCBjLCBlKSB7XFxuICAgIHZhciBmID0gITAsXFxuICAgICAgICBnID0gXFxcIndpZHRoXFxcIiA9PT0gYyA/IGIub2Zmc2V0V2lkdGggOiBiLm9mZnNldEhlaWdodCxcXG4gICAgICAgIGggPSBDYShiKSxcXG4gICAgICAgIGkgPSBcXFwiYm9yZGVyLWJveFxcXCIgPT09IG4uY3NzKGIsIFxcXCJib3hTaXppbmdcXFwiLCAhMSwgaCk7aWYgKGQubXNGdWxsc2NyZWVuRWxlbWVudCAmJiBhLnRvcCAhPT0gYSAmJiBiLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICYmIChnID0gTWF0aC5yb3VuZCgxMDAgKiBiLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2NdKSksIDAgPj0gZyB8fCBudWxsID09IGcpIHtcXG4gICAgICBpZiAoZyA9IEZhKGIsIGMsIGgpLCAoMCA+IGcgfHwgbnVsbCA9PSBnKSAmJiAoZyA9IGIuc3R5bGVbY10pLCBCYS50ZXN0KGcpKSByZXR1cm4gZztmID0gaSAmJiAobC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IGcgPT09IGIuc3R5bGVbY10pLCBnID0gcGFyc2VGbG9hdChnKSB8fCAwO1xcbiAgICB9cmV0dXJuIGcgKyBPYShiLCBjLCBlIHx8IChpID8gXFxcImJvcmRlclxcXCIgOiBcXFwiY29udGVudFxcXCIpLCBmLCBoKSArIFxcXCJweFxcXCI7XFxuICB9ZnVuY3Rpb24gUWEoYSwgYikge1xcbiAgICBmb3IgKHZhciBjLCBkLCBlLCBmID0gW10sIGcgPSAwLCBoID0gYS5sZW5ndGg7IGggPiBnOyBnKyspIHtcXG4gICAgICBkID0gYVtnXSwgZC5zdHlsZSAmJiAoZltnXSA9IE4uZ2V0KGQsIFxcXCJvbGRkaXNwbGF5XFxcIiksIGMgPSBkLnN0eWxlLmRpc3BsYXksIGIgPyAoZltnXSB8fCBcXFwibm9uZVxcXCIgIT09IGMgfHwgKGQuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiKSwgXFxcIlxcXCIgPT09IGQuc3R5bGUuZGlzcGxheSAmJiBWKGQpICYmIChmW2ddID0gTi5hY2Nlc3MoZCwgXFxcIm9sZGRpc3BsYXlcXFwiLCB6YShkLm5vZGVOYW1lKSkpKSA6IChlID0gVihkKSwgXFxcIm5vbmVcXFwiID09PSBjICYmIGUgfHwgTi5zZXQoZCwgXFxcIm9sZGRpc3BsYXlcXFwiLCBlID8gYyA6IG4uY3NzKGQsIFxcXCJkaXNwbGF5XFxcIikpKSk7XFxuICAgIH1mb3IgKGcgPSAwOyBoID4gZzsgZysrKSB7XFxuICAgICAgZCA9IGFbZ10sIGQuc3R5bGUgJiYgKGIgJiYgXFxcIm5vbmVcXFwiICE9PSBkLnN0eWxlLmRpc3BsYXkgJiYgXFxcIlxcXCIgIT09IGQuc3R5bGUuZGlzcGxheSB8fCAoZC5zdHlsZS5kaXNwbGF5ID0gYiA/IGZbZ10gfHwgXFxcIlxcXCIgOiBcXFwibm9uZVxcXCIpKTtcXG4gICAgfXJldHVybiBhO1xcbiAgfW4uZXh0ZW5kKHsgY3NzSG9va3M6IHsgb3BhY2l0eTogeyBnZXQ6IGZ1bmN0aW9uIGdldChhLCBiKSB7XFxuICAgICAgICAgIGlmIChiKSB7XFxuICAgICAgICAgICAgdmFyIGMgPSBGYShhLCBcXFwib3BhY2l0eVxcXCIpO3JldHVybiBcXFwiXFxcIiA9PT0gYyA/IFxcXCIxXFxcIiA6IGM7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gfSB9LCBjc3NOdW1iZXI6IHsgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6ICEwLCBjb2x1bW5Db3VudDogITAsIGZpbGxPcGFjaXR5OiAhMCwgZmxleEdyb3c6ICEwLCBmbGV4U2hyaW5rOiAhMCwgZm9udFdlaWdodDogITAsIGxpbmVIZWlnaHQ6ICEwLCBvcGFjaXR5OiAhMCwgb3JkZXI6ICEwLCBvcnBoYW5zOiAhMCwgd2lkb3dzOiAhMCwgekluZGV4OiAhMCwgem9vbTogITAgfSwgY3NzUHJvcHM6IHsgXFxcImZsb2F0XFxcIjogXFxcImNzc0Zsb2F0XFxcIiB9LCBzdHlsZTogZnVuY3Rpb24gc3R5bGUoYSwgYiwgYywgZCkge1xcbiAgICAgIGlmIChhICYmIDMgIT09IGEubm9kZVR5cGUgJiYgOCAhPT0gYS5ub2RlVHlwZSAmJiBhLnN0eWxlKSB7XFxuICAgICAgICB2YXIgZSxcXG4gICAgICAgICAgICBmLFxcbiAgICAgICAgICAgIGcsXFxuICAgICAgICAgICAgaCA9IG4uY2FtZWxDYXNlKGIpLFxcbiAgICAgICAgICAgIGkgPSBhLnN0eWxlO3JldHVybiBiID0gbi5jc3NQcm9wc1toXSB8fCAobi5jc3NQcm9wc1toXSA9IE1hKGgpIHx8IGgpLCBnID0gbi5jc3NIb29rc1tiXSB8fCBuLmNzc0hvb2tzW2hdLCB2b2lkIDAgPT09IGMgPyBnICYmIFxcXCJnZXRcXFwiIGluIGcgJiYgdm9pZCAwICE9PSAoZSA9IGcuZ2V0KGEsICExLCBkKSkgPyBlIDogaVtiXSA6IChmID0gdHlwZW9mIGMgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGMpLCBcXFwic3RyaW5nXFxcIiA9PT0gZiAmJiAoZSA9IFQuZXhlYyhjKSkgJiYgZVsxXSAmJiAoYyA9IFcoYSwgYiwgZSksIGYgPSBcXFwibnVtYmVyXFxcIiksIG51bGwgIT0gYyAmJiBjID09PSBjICYmIChcXFwibnVtYmVyXFxcIiA9PT0gZiAmJiAoYyArPSBlICYmIGVbM10gfHwgKG4uY3NzTnVtYmVyW2hdID8gXFxcIlxcXCIgOiBcXFwicHhcXFwiKSksIGwuY2xlYXJDbG9uZVN0eWxlIHx8IFxcXCJcXFwiICE9PSBjIHx8IDAgIT09IGIuaW5kZXhPZihcXFwiYmFja2dyb3VuZFxcXCIpIHx8IChpW2JdID0gXFxcImluaGVyaXRcXFwiKSwgZyAmJiBcXFwic2V0XFxcIiBpbiBnICYmIHZvaWQgMCA9PT0gKGMgPSBnLnNldChhLCBjLCBkKSkgfHwgKGlbYl0gPSBjKSksIHZvaWQgMCk7XFxuICAgICAgfVxcbiAgICB9LCBjc3M6IGZ1bmN0aW9uIGNzcyhhLCBiLCBjLCBkKSB7XFxuICAgICAgdmFyIGUsXFxuICAgICAgICAgIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGggPSBuLmNhbWVsQ2FzZShiKTtyZXR1cm4gYiA9IG4uY3NzUHJvcHNbaF0gfHwgKG4uY3NzUHJvcHNbaF0gPSBNYShoKSB8fCBoKSwgZyA9IG4uY3NzSG9va3NbYl0gfHwgbi5jc3NIb29rc1toXSwgZyAmJiBcXFwiZ2V0XFxcIiBpbiBnICYmIChlID0gZy5nZXQoYSwgITAsIGMpKSwgdm9pZCAwID09PSBlICYmIChlID0gRmEoYSwgYiwgZCkpLCBcXFwibm9ybWFsXFxcIiA9PT0gZSAmJiBiIGluIEphICYmIChlID0gSmFbYl0pLCBcXFwiXFxcIiA9PT0gYyB8fCBjID8gKGYgPSBwYXJzZUZsb2F0KGUpLCBjID09PSAhMCB8fCBpc0Zpbml0ZShmKSA/IGYgfHwgMCA6IGUpIDogZTtcXG4gICAgfSB9KSwgbi5lYWNoKFtcXFwiaGVpZ2h0XFxcIiwgXFxcIndpZHRoXFxcIl0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG4uY3NzSG9va3NbYl0gPSB7IGdldDogZnVuY3Rpb24gZ2V0KGEsIGMsIGQpIHtcXG4gICAgICAgIHJldHVybiBjID8gSGEudGVzdChuLmNzcyhhLCBcXFwiZGlzcGxheVxcXCIpKSAmJiAwID09PSBhLm9mZnNldFdpZHRoID8gRGEoYSwgSWEsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIFBhKGEsIGIsIGQpO1xcbiAgICAgICAgfSkgOiBQYShhLCBiLCBkKSA6IHZvaWQgMDtcXG4gICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChhLCBjLCBkKSB7XFxuICAgICAgICB2YXIgZSxcXG4gICAgICAgICAgICBmID0gZCAmJiBDYShhKSxcXG4gICAgICAgICAgICBnID0gZCAmJiBPYShhLCBiLCBkLCBcXFwiYm9yZGVyLWJveFxcXCIgPT09IG4uY3NzKGEsIFxcXCJib3hTaXppbmdcXFwiLCAhMSwgZiksIGYpO3JldHVybiBnICYmIChlID0gVC5leGVjKGMpKSAmJiBcXFwicHhcXFwiICE9PSAoZVszXSB8fCBcXFwicHhcXFwiKSAmJiAoYS5zdHlsZVtiXSA9IGMsIGMgPSBuLmNzcyhhLCBiKSksIE5hKGEsIGMsIGcpO1xcbiAgICAgIH0gfTtcXG4gIH0pLCBuLmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBHYShsLnJlbGlhYmxlTWFyZ2luTGVmdCwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgcmV0dXJuIGIgPyAocGFyc2VGbG9hdChGYShhLCBcXFwibWFyZ2luTGVmdFxcXCIpKSB8fCBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBEYShhLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XFxuICAgIH0pKSArIFxcXCJweFxcXCIgOiB2b2lkIDA7XFxuICB9KSwgbi5jc3NIb29rcy5tYXJnaW5SaWdodCA9IEdhKGwucmVsaWFibGVNYXJnaW5SaWdodCwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgcmV0dXJuIGIgPyBEYShhLCB7IGRpc3BsYXk6IFxcXCJpbmxpbmUtYmxvY2tcXFwiIH0sIEZhLCBbYSwgXFxcIm1hcmdpblJpZ2h0XFxcIl0pIDogdm9pZCAwO1xcbiAgfSksIG4uZWFjaCh7IG1hcmdpbjogXFxcIlxcXCIsIHBhZGRpbmc6IFxcXCJcXFwiLCBib3JkZXI6IFxcXCJXaWR0aFxcXCIgfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5jc3NIb29rc1thICsgYl0gPSB7IGV4cGFuZDogZnVuY3Rpb24gZXhwYW5kKGMpIHtcXG4gICAgICAgIGZvciAodmFyIGQgPSAwLCBlID0ge30sIGYgPSBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYyA/IGMuc3BsaXQoXFxcIiBcXFwiKSA6IFtjXTsgNCA+IGQ7IGQrKykge1xcbiAgICAgICAgICBlW2EgKyBVW2RdICsgYl0gPSBmW2RdIHx8IGZbZCAtIDJdIHx8IGZbMF07XFxuICAgICAgICB9cmV0dXJuIGU7XFxuICAgICAgfSB9LCBBYS50ZXN0KGEpIHx8IChuLmNzc0hvb2tzW2EgKyBiXS5zZXQgPSBOYSk7XFxuICB9KSwgbi5mbi5leHRlbmQoeyBjc3M6IGZ1bmN0aW9uIGNzcyhhLCBiKSB7XFxuICAgICAgcmV0dXJuIEsodGhpcywgZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICAgIHZhciBkLFxcbiAgICAgICAgICAgIGUsXFxuICAgICAgICAgICAgZiA9IHt9LFxcbiAgICAgICAgICAgIGcgPSAwO2lmIChuLmlzQXJyYXkoYikpIHtcXG4gICAgICAgICAgZm9yIChkID0gQ2EoYSksIGUgPSBiLmxlbmd0aDsgZSA+IGc7IGcrKykge1xcbiAgICAgICAgICAgIGZbYltnXV0gPSBuLmNzcyhhLCBiW2ddLCAhMSwgZCk7XFxuICAgICAgICAgIH1yZXR1cm4gZjtcXG4gICAgICAgIH1yZXR1cm4gdm9pZCAwICE9PSBjID8gbi5zdHlsZShhLCBiLCBjKSA6IG4uY3NzKGEsIGIpO1xcbiAgICAgIH0sIGEsIGIsIGFyZ3VtZW50cy5sZW5ndGggPiAxKTtcXG4gICAgfSwgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcXG4gICAgICByZXR1cm4gUWEodGhpcywgITApO1xcbiAgICB9LCBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xcbiAgICAgIHJldHVybiBRYSh0aGlzKTtcXG4gICAgfSwgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUoYSkge1xcbiAgICAgIHJldHVybiBcXFwiYm9vbGVhblxcXCIgPT0gdHlwZW9mIGEgPyBhID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKSA6IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBWKHRoaXMpID8gbih0aGlzKS5zaG93KCkgOiBuKHRoaXMpLmhpZGUoKTtcXG4gICAgICB9KTtcXG4gICAgfSB9KTtmdW5jdGlvbiBSYShhLCBiLCBjLCBkLCBlKSB7XFxuICAgIHJldHVybiBuZXcgUmEucHJvdG90eXBlLmluaXQoYSwgYiwgYywgZCwgZSk7XFxuICB9bi5Ud2VlbiA9IFJhLCBSYS5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBSYSwgaW5pdDogZnVuY3Rpb24gaW5pdChhLCBiLCBjLCBkLCBlLCBmKSB7XFxuICAgICAgdGhpcy5lbGVtID0gYSwgdGhpcy5wcm9wID0gYywgdGhpcy5lYXNpbmcgPSBlIHx8IG4uZWFzaW5nLl9kZWZhdWx0LCB0aGlzLm9wdGlvbnMgPSBiLCB0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpLCB0aGlzLmVuZCA9IGQsIHRoaXMudW5pdCA9IGYgfHwgKG4uY3NzTnVtYmVyW2NdID8gXFxcIlxcXCIgOiBcXFwicHhcXFwiKTtcXG4gICAgfSwgY3VyOiBmdW5jdGlvbiBjdXIoKSB7XFxuICAgICAgdmFyIGEgPSBSYS5wcm9wSG9va3NbdGhpcy5wcm9wXTtyZXR1cm4gYSAmJiBhLmdldCA/IGEuZ2V0KHRoaXMpIDogUmEucHJvcEhvb2tzLl9kZWZhdWx0LmdldCh0aGlzKTtcXG4gICAgfSwgcnVuOiBmdW5jdGlvbiBydW4oYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjID0gUmEucHJvcEhvb2tzW3RoaXMucHJvcF07cmV0dXJuIHRoaXMub3B0aW9ucy5kdXJhdGlvbiA/IHRoaXMucG9zID0gYiA9IG4uZWFzaW5nW3RoaXMuZWFzaW5nXShhLCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBhLCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb24pIDogdGhpcy5wb3MgPSBiID0gYSwgdGhpcy5ub3cgPSAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIGIgKyB0aGlzLnN0YXJ0LCB0aGlzLm9wdGlvbnMuc3RlcCAmJiB0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMpLCBjICYmIGMuc2V0ID8gYy5zZXQodGhpcykgOiBSYS5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KHRoaXMpLCB0aGlzO1xcbiAgICB9IH0sIFJhLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFJhLnByb3RvdHlwZSwgUmEucHJvcEhvb2tzID0geyBfZGVmYXVsdDogeyBnZXQ6IGZ1bmN0aW9uIGdldChhKSB7XFxuICAgICAgICB2YXIgYjtyZXR1cm4gMSAhPT0gYS5lbGVtLm5vZGVUeXBlIHx8IG51bGwgIT0gYS5lbGVtW2EucHJvcF0gJiYgbnVsbCA9PSBhLmVsZW0uc3R5bGVbYS5wcm9wXSA/IGEuZWxlbVthLnByb3BdIDogKGIgPSBuLmNzcyhhLmVsZW0sIGEucHJvcCwgXFxcIlxcXCIpLCBiICYmIFxcXCJhdXRvXFxcIiAhPT0gYiA/IGIgOiAwKTtcXG4gICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChhKSB7XFxuICAgICAgICBuLmZ4LnN0ZXBbYS5wcm9wXSA/IG4uZnguc3RlcFthLnByb3BdKGEpIDogMSAhPT0gYS5lbGVtLm5vZGVUeXBlIHx8IG51bGwgPT0gYS5lbGVtLnN0eWxlW24uY3NzUHJvcHNbYS5wcm9wXV0gJiYgIW4uY3NzSG9va3NbYS5wcm9wXSA/IGEuZWxlbVthLnByb3BdID0gYS5ub3cgOiBuLnN0eWxlKGEuZWxlbSwgYS5wcm9wLCBhLm5vdyArIGEudW5pdCk7XFxuICAgICAgfSB9IH0sIFJhLnByb3BIb29rcy5zY3JvbGxUb3AgPSBSYS5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHsgc2V0OiBmdW5jdGlvbiBzZXQoYSkge1xcbiAgICAgIGEuZWxlbS5ub2RlVHlwZSAmJiBhLmVsZW0ucGFyZW50Tm9kZSAmJiAoYS5lbGVtW2EucHJvcF0gPSBhLm5vdyk7XFxuICAgIH0gfSwgbi5lYXNpbmcgPSB7IGxpbmVhcjogZnVuY3Rpb24gbGluZWFyKGEpIHtcXG4gICAgICByZXR1cm4gYTtcXG4gICAgfSwgc3dpbmc6IGZ1bmN0aW9uIHN3aW5nKGEpIHtcXG4gICAgICByZXR1cm4gLjUgLSBNYXRoLmNvcyhhICogTWF0aC5QSSkgLyAyO1xcbiAgICB9LCBfZGVmYXVsdDogXFxcInN3aW5nXFxcIiB9LCBuLmZ4ID0gUmEucHJvdG90eXBlLmluaXQsIG4uZnguc3RlcCA9IHt9O3ZhciBTYSxcXG4gICAgICBUYSxcXG4gICAgICBVYSA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcXG4gICAgICBWYSA9IC9xdWV1ZUhvb2tzJC87ZnVuY3Rpb24gV2EoKSB7XFxuICAgIHJldHVybiBhLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgIFNhID0gdm9pZCAwO1xcbiAgICB9KSwgU2EgPSBuLm5vdygpO1xcbiAgfWZ1bmN0aW9uIFhhKGEsIGIpIHtcXG4gICAgdmFyIGMsXFxuICAgICAgICBkID0gMCxcXG4gICAgICAgIGUgPSB7IGhlaWdodDogYSB9O2ZvciAoYiA9IGIgPyAxIDogMDsgNCA+IGQ7IGQgKz0gMiAtIGIpIHtcXG4gICAgICBjID0gVVtkXSwgZVtcXFwibWFyZ2luXFxcIiArIGNdID0gZVtcXFwicGFkZGluZ1xcXCIgKyBjXSA9IGE7XFxuICAgIH1yZXR1cm4gYiAmJiAoZS5vcGFjaXR5ID0gZS53aWR0aCA9IGEpLCBlO1xcbiAgfWZ1bmN0aW9uIFlhKGEsIGIsIGMpIHtcXG4gICAgZm9yICh2YXIgZCwgZSA9IChfYS50d2VlbmVyc1tiXSB8fCBbXSkuY29uY2F0KF9hLnR3ZWVuZXJzW1xcXCIqXFxcIl0pLCBmID0gMCwgZyA9IGUubGVuZ3RoOyBnID4gZjsgZisrKSB7XFxuICAgICAgaWYgKGQgPSBlW2ZdLmNhbGwoYywgYiwgYSkpIHJldHVybiBkO1xcbiAgICB9XFxuICB9ZnVuY3Rpb24gWmEoYSwgYiwgYykge1xcbiAgICB2YXIgZCxcXG4gICAgICAgIGUsXFxuICAgICAgICBmLFxcbiAgICAgICAgZyxcXG4gICAgICAgIGgsXFxuICAgICAgICBpLFxcbiAgICAgICAgaixcXG4gICAgICAgIGssXFxuICAgICAgICBsID0gdGhpcyxcXG4gICAgICAgIG0gPSB7fSxcXG4gICAgICAgIG8gPSBhLnN0eWxlLFxcbiAgICAgICAgcCA9IGEubm9kZVR5cGUgJiYgVihhKSxcXG4gICAgICAgIHEgPSBOLmdldChhLCBcXFwiZnhzaG93XFxcIik7Yy5xdWV1ZSB8fCAoaCA9IG4uX3F1ZXVlSG9va3MoYSwgXFxcImZ4XFxcIiksIG51bGwgPT0gaC51bnF1ZXVlZCAmJiAoaC51bnF1ZXVlZCA9IDAsIGkgPSBoLmVtcHR5LmZpcmUsIGguZW1wdHkuZmlyZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBoLnVucXVldWVkIHx8IGkoKTtcXG4gICAgfSksIGgudW5xdWV1ZWQrKywgbC5hbHdheXMoZnVuY3Rpb24gKCkge1xcbiAgICAgIGwuYWx3YXlzKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGgudW5xdWV1ZWQtLSwgbi5xdWV1ZShhLCBcXFwiZnhcXFwiKS5sZW5ndGggfHwgaC5lbXB0eS5maXJlKCk7XFxuICAgICAgfSk7XFxuICAgIH0pKSwgMSA9PT0gYS5ub2RlVHlwZSAmJiAoXFxcImhlaWdodFxcXCIgaW4gYiB8fCBcXFwid2lkdGhcXFwiIGluIGIpICYmIChjLm92ZXJmbG93ID0gW28ub3ZlcmZsb3csIG8ub3ZlcmZsb3dYLCBvLm92ZXJmbG93WV0sIGogPSBuLmNzcyhhLCBcXFwiZGlzcGxheVxcXCIpLCBrID0gXFxcIm5vbmVcXFwiID09PSBqID8gTi5nZXQoYSwgXFxcIm9sZGRpc3BsYXlcXFwiKSB8fCB6YShhLm5vZGVOYW1lKSA6IGosIFxcXCJpbmxpbmVcXFwiID09PSBrICYmIFxcXCJub25lXFxcIiA9PT0gbi5jc3MoYSwgXFxcImZsb2F0XFxcIikgJiYgKG8uZGlzcGxheSA9IFxcXCJpbmxpbmUtYmxvY2tcXFwiKSksIGMub3ZlcmZsb3cgJiYgKG8ub3ZlcmZsb3cgPSBcXFwiaGlkZGVuXFxcIiwgbC5hbHdheXMoZnVuY3Rpb24gKCkge1xcbiAgICAgIG8ub3ZlcmZsb3cgPSBjLm92ZXJmbG93WzBdLCBvLm92ZXJmbG93WCA9IGMub3ZlcmZsb3dbMV0sIG8ub3ZlcmZsb3dZID0gYy5vdmVyZmxvd1syXTtcXG4gICAgfSkpO2ZvciAoZCBpbiBiKSB7XFxuICAgICAgaWYgKGUgPSBiW2RdLCBVYS5leGVjKGUpKSB7XFxuICAgICAgICBpZiAoZGVsZXRlIGJbZF0sIGYgPSBmIHx8IFxcXCJ0b2dnbGVcXFwiID09PSBlLCBlID09PSAocCA/IFxcXCJoaWRlXFxcIiA6IFxcXCJzaG93XFxcIikpIHtcXG4gICAgICAgICAgaWYgKFxcXCJzaG93XFxcIiAhPT0gZSB8fCAhcSB8fCB2b2lkIDAgPT09IHFbZF0pIGNvbnRpbnVlO3AgPSAhMDtcXG4gICAgICAgIH1tW2RdID0gcSAmJiBxW2RdIHx8IG4uc3R5bGUoYSwgZCk7XFxuICAgICAgfSBlbHNlIGogPSB2b2lkIDA7XFxuICAgIH1pZiAobi5pc0VtcHR5T2JqZWN0KG0pKSBcXFwiaW5saW5lXFxcIiA9PT0gKFxcXCJub25lXFxcIiA9PT0gaiA/IHphKGEubm9kZU5hbWUpIDogaikgJiYgKG8uZGlzcGxheSA9IGopO2Vsc2Uge1xcbiAgICAgIHEgPyBcXFwiaGlkZGVuXFxcIiBpbiBxICYmIChwID0gcS5oaWRkZW4pIDogcSA9IE4uYWNjZXNzKGEsIFxcXCJmeHNob3dcXFwiLCB7fSksIGYgJiYgKHEuaGlkZGVuID0gIXApLCBwID8gbihhKS5zaG93KCkgOiBsLmRvbmUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgbihhKS5oaWRlKCk7XFxuICAgICAgfSksIGwuZG9uZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYjtOLnJlbW92ZShhLCBcXFwiZnhzaG93XFxcIik7Zm9yIChiIGluIG0pIHtcXG4gICAgICAgICAgbi5zdHlsZShhLCBiLCBtW2JdKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtmb3IgKGQgaW4gbSkge1xcbiAgICAgICAgZyA9IFlhKHAgPyBxW2RdIDogMCwgZCwgbCksIGQgaW4gcSB8fCAocVtkXSA9IGcuc3RhcnQsIHAgJiYgKGcuZW5kID0gZy5zdGFydCwgZy5zdGFydCA9IFxcXCJ3aWR0aFxcXCIgPT09IGQgfHwgXFxcImhlaWdodFxcXCIgPT09IGQgPyAxIDogMCkpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfWZ1bmN0aW9uICRhKGEsIGIpIHtcXG4gICAgdmFyIGMsIGQsIGUsIGYsIGc7Zm9yIChjIGluIGEpIHtcXG4gICAgICBpZiAoZCA9IG4uY2FtZWxDYXNlKGMpLCBlID0gYltkXSwgZiA9IGFbY10sIG4uaXNBcnJheShmKSAmJiAoZSA9IGZbMV0sIGYgPSBhW2NdID0gZlswXSksIGMgIT09IGQgJiYgKGFbZF0gPSBmLCBkZWxldGUgYVtjXSksIGcgPSBuLmNzc0hvb2tzW2RdLCBnICYmIFxcXCJleHBhbmRcXFwiIGluIGcpIHtcXG4gICAgICAgIGYgPSBnLmV4cGFuZChmKSwgZGVsZXRlIGFbZF07Zm9yIChjIGluIGYpIHtcXG4gICAgICAgICAgYyBpbiBhIHx8IChhW2NdID0gZltjXSwgYltjXSA9IGUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBiW2RdID0gZTtcXG4gICAgfVxcbiAgfWZ1bmN0aW9uIF9hKGEsIGIsIGMpIHtcXG4gICAgdmFyIGQsXFxuICAgICAgICBlLFxcbiAgICAgICAgZiA9IDAsXFxuICAgICAgICBnID0gX2EucHJlZmlsdGVycy5sZW5ndGgsXFxuICAgICAgICBoID0gbi5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbiAoKSB7XFxuICAgICAgZGVsZXRlIGkuZWxlbTtcXG4gICAgfSksXFxuICAgICAgICBpID0gZnVuY3Rpb24gaSgpIHtcXG4gICAgICBpZiAoZSkgcmV0dXJuICExO2ZvciAodmFyIGIgPSBTYSB8fCBXYSgpLCBjID0gTWF0aC5tYXgoMCwgai5zdGFydFRpbWUgKyBqLmR1cmF0aW9uIC0gYiksIGQgPSBjIC8gai5kdXJhdGlvbiB8fCAwLCBmID0gMSAtIGQsIGcgPSAwLCBpID0gai50d2VlbnMubGVuZ3RoOyBpID4gZzsgZysrKSB7XFxuICAgICAgICBqLnR3ZWVuc1tnXS5ydW4oZik7XFxuICAgICAgfXJldHVybiBoLm5vdGlmeVdpdGgoYSwgW2osIGYsIGNdKSwgMSA+IGYgJiYgaSA/IGMgOiAoaC5yZXNvbHZlV2l0aChhLCBbal0pLCAhMSk7XFxuICAgIH0sXFxuICAgICAgICBqID0gaC5wcm9taXNlKHsgZWxlbTogYSwgcHJvcHM6IG4uZXh0ZW5kKHt9LCBiKSwgb3B0czogbi5leHRlbmQoITAsIHsgc3BlY2lhbEVhc2luZzoge30sIGVhc2luZzogbi5lYXNpbmcuX2RlZmF1bHQgfSwgYyksIG9yaWdpbmFsUHJvcGVydGllczogYiwgb3JpZ2luYWxPcHRpb25zOiBjLCBzdGFydFRpbWU6IFNhIHx8IFdhKCksIGR1cmF0aW9uOiBjLmR1cmF0aW9uLCB0d2VlbnM6IFtdLCBjcmVhdGVUd2VlbjogZnVuY3Rpb24gY3JlYXRlVHdlZW4oYiwgYykge1xcbiAgICAgICAgdmFyIGQgPSBuLlR3ZWVuKGEsIGoub3B0cywgYiwgYywgai5vcHRzLnNwZWNpYWxFYXNpbmdbYl0gfHwgai5vcHRzLmVhc2luZyk7cmV0dXJuIGoudHdlZW5zLnB1c2goZCksIGQ7XFxuICAgICAgfSwgc3RvcDogZnVuY3Rpb24gc3RvcChiKSB7XFxuICAgICAgICB2YXIgYyA9IDAsXFxuICAgICAgICAgICAgZCA9IGIgPyBqLnR3ZWVucy5sZW5ndGggOiAwO2lmIChlKSByZXR1cm4gdGhpcztmb3IgKGUgPSAhMDsgZCA+IGM7IGMrKykge1xcbiAgICAgICAgICBqLnR3ZWVuc1tjXS5ydW4oMSk7XFxuICAgICAgICB9cmV0dXJuIGIgPyAoaC5ub3RpZnlXaXRoKGEsIFtqLCAxLCAwXSksIGgucmVzb2x2ZVdpdGgoYSwgW2osIGJdKSkgOiBoLnJlamVjdFdpdGgoYSwgW2osIGJdKSwgdGhpcztcXG4gICAgICB9IH0pLFxcbiAgICAgICAgayA9IGoucHJvcHM7Zm9yICgkYShrLCBqLm9wdHMuc3BlY2lhbEVhc2luZyk7IGcgPiBmOyBmKyspIHtcXG4gICAgICBpZiAoZCA9IF9hLnByZWZpbHRlcnNbZl0uY2FsbChqLCBhLCBrLCBqLm9wdHMpKSByZXR1cm4gbi5pc0Z1bmN0aW9uKGQuc3RvcCkgJiYgKG4uX3F1ZXVlSG9va3Moai5lbGVtLCBqLm9wdHMucXVldWUpLnN0b3AgPSBuLnByb3h5KGQuc3RvcCwgZCkpLCBkO1xcbiAgICB9cmV0dXJuIG4ubWFwKGssIFlhLCBqKSwgbi5pc0Z1bmN0aW9uKGoub3B0cy5zdGFydCkgJiYgai5vcHRzLnN0YXJ0LmNhbGwoYSwgaiksIG4uZngudGltZXIobi5leHRlbmQoaSwgeyBlbGVtOiBhLCBhbmltOiBqLCBxdWV1ZTogai5vcHRzLnF1ZXVlIH0pKSwgai5wcm9ncmVzcyhqLm9wdHMucHJvZ3Jlc3MpLmRvbmUoai5vcHRzLmRvbmUsIGoub3B0cy5jb21wbGV0ZSkuZmFpbChqLm9wdHMuZmFpbCkuYWx3YXlzKGoub3B0cy5hbHdheXMpO1xcbiAgfW4uQW5pbWF0aW9uID0gbi5leHRlbmQoX2EsIHsgdHdlZW5lcnM6IHsgXFxcIipcXFwiOiBbZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVUd2VlbihhLCBiKTtyZXR1cm4gVyhjLmVsZW0sIGEsIFQuZXhlYyhiKSwgYyksIGM7XFxuICAgICAgfV0gfSwgdHdlZW5lcjogZnVuY3Rpb24gdHdlZW5lcihhLCBiKSB7XFxuICAgICAgbi5pc0Z1bmN0aW9uKGEpID8gKGIgPSBhLCBhID0gW1xcXCIqXFxcIl0pIDogYSA9IGEubWF0Y2goRyk7Zm9yICh2YXIgYywgZCA9IDAsIGUgPSBhLmxlbmd0aDsgZSA+IGQ7IGQrKykge1xcbiAgICAgICAgYyA9IGFbZF0sIF9hLnR3ZWVuZXJzW2NdID0gX2EudHdlZW5lcnNbY10gfHwgW10sIF9hLnR3ZWVuZXJzW2NdLnVuc2hpZnQoYik7XFxuICAgICAgfVxcbiAgICB9LCBwcmVmaWx0ZXJzOiBbWmFdLCBwcmVmaWx0ZXI6IGZ1bmN0aW9uIHByZWZpbHRlcihhLCBiKSB7XFxuICAgICAgYiA/IF9hLnByZWZpbHRlcnMudW5zaGlmdChhKSA6IF9hLnByZWZpbHRlcnMucHVzaChhKTtcXG4gICAgfSB9KSwgbi5zcGVlZCA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgIHZhciBkID0gYSAmJiBcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGEgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGEpKSA/IG4uZXh0ZW5kKHt9LCBhKSA6IHsgY29tcGxldGU6IGMgfHwgIWMgJiYgYiB8fCBuLmlzRnVuY3Rpb24oYSkgJiYgYSwgZHVyYXRpb246IGEsIGVhc2luZzogYyAmJiBiIHx8IGIgJiYgIW4uaXNGdW5jdGlvbihiKSAmJiBiIH07cmV0dXJuIGQuZHVyYXRpb24gPSBuLmZ4Lm9mZiA/IDAgOiBcXFwibnVtYmVyXFxcIiA9PSB0eXBlb2YgZC5kdXJhdGlvbiA/IGQuZHVyYXRpb24gOiBkLmR1cmF0aW9uIGluIG4uZnguc3BlZWRzID8gbi5meC5zcGVlZHNbZC5kdXJhdGlvbl0gOiBuLmZ4LnNwZWVkcy5fZGVmYXVsdCwgKG51bGwgPT0gZC5xdWV1ZSB8fCBkLnF1ZXVlID09PSAhMCkgJiYgKGQucXVldWUgPSBcXFwiZnhcXFwiKSwgZC5vbGQgPSBkLmNvbXBsZXRlLCBkLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIG4uaXNGdW5jdGlvbihkLm9sZCkgJiYgZC5vbGQuY2FsbCh0aGlzKSwgZC5xdWV1ZSAmJiBuLmRlcXVldWUodGhpcywgZC5xdWV1ZSk7XFxuICAgIH0sIGQ7XFxuICB9LCBuLmZuLmV4dGVuZCh7IGZhZGVUbzogZnVuY3Rpb24gZmFkZVRvKGEsIGIsIGMsIGQpIHtcXG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoVikuY3NzKFxcXCJvcGFjaXR5XFxcIiwgMCkuc2hvdygpLmVuZCgpLmFuaW1hdGUoeyBvcGFjaXR5OiBiIH0sIGEsIGMsIGQpO1xcbiAgICB9LCBhbmltYXRlOiBmdW5jdGlvbiBhbmltYXRlKGEsIGIsIGMsIGQpIHtcXG4gICAgICB2YXIgZSA9IG4uaXNFbXB0eU9iamVjdChhKSxcXG4gICAgICAgICAgZiA9IG4uc3BlZWQoYiwgYywgZCksXFxuICAgICAgICAgIGcgPSBmdW5jdGlvbiBnKCkge1xcbiAgICAgICAgdmFyIGIgPSBfYSh0aGlzLCBuLmV4dGVuZCh7fSwgYSksIGYpOyhlIHx8IE4uZ2V0KHRoaXMsIFxcXCJmaW5pc2hcXFwiKSkgJiYgYi5zdG9wKCEwKTtcXG4gICAgICB9O3JldHVybiBnLmZpbmlzaCA9IGcsIGUgfHwgZi5xdWV1ZSA9PT0gITEgPyB0aGlzLmVhY2goZykgOiB0aGlzLnF1ZXVlKGYucXVldWUsIGcpO1xcbiAgICB9LCBzdG9wOiBmdW5jdGlvbiBzdG9wKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCA9IGZ1bmN0aW9uIGQoYSkge1xcbiAgICAgICAgdmFyIGIgPSBhLnN0b3A7ZGVsZXRlIGEuc3RvcCwgYihjKTtcXG4gICAgICB9O3JldHVybiBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYSAmJiAoYyA9IGIsIGIgPSBhLCBhID0gdm9pZCAwKSwgYiAmJiBhICE9PSAhMSAmJiB0aGlzLnF1ZXVlKGEgfHwgXFxcImZ4XFxcIiwgW10pLCB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGIgPSAhMCxcXG4gICAgICAgICAgICBlID0gbnVsbCAhPSBhICYmIGEgKyBcXFwicXVldWVIb29rc1xcXCIsXFxuICAgICAgICAgICAgZiA9IG4udGltZXJzLFxcbiAgICAgICAgICAgIGcgPSBOLmdldCh0aGlzKTtpZiAoZSkgZ1tlXSAmJiBnW2VdLnN0b3AgJiYgZChnW2VdKTtlbHNlIGZvciAoZSBpbiBnKSB7XFxuICAgICAgICAgIGdbZV0gJiYgZ1tlXS5zdG9wICYmIFZhLnRlc3QoZSkgJiYgZChnW2VdKTtcXG4gICAgICAgIH1mb3IgKGUgPSBmLmxlbmd0aDsgZS0tOykge1xcbiAgICAgICAgICBmW2VdLmVsZW0gIT09IHRoaXMgfHwgbnVsbCAhPSBhICYmIGZbZV0ucXVldWUgIT09IGEgfHwgKGZbZV0uYW5pbS5zdG9wKGMpLCBiID0gITEsIGYuc3BsaWNlKGUsIDEpKTtcXG4gICAgICAgIH0oYiB8fCAhYykgJiYgbi5kZXF1ZXVlKHRoaXMsIGEpO1xcbiAgICAgIH0pO1xcbiAgICB9LCBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChhKSB7XFxuICAgICAgcmV0dXJuIGEgIT09ICExICYmIChhID0gYSB8fCBcXFwiZnhcXFwiKSwgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBiLFxcbiAgICAgICAgICAgIGMgPSBOLmdldCh0aGlzKSxcXG4gICAgICAgICAgICBkID0gY1thICsgXFxcInF1ZXVlXFxcIl0sXFxuICAgICAgICAgICAgZSA9IGNbYSArIFxcXCJxdWV1ZUhvb2tzXFxcIl0sXFxuICAgICAgICAgICAgZiA9IG4udGltZXJzLFxcbiAgICAgICAgICAgIGcgPSBkID8gZC5sZW5ndGggOiAwO2ZvciAoYy5maW5pc2ggPSAhMCwgbi5xdWV1ZSh0aGlzLCBhLCBbXSksIGUgJiYgZS5zdG9wICYmIGUuc3RvcC5jYWxsKHRoaXMsICEwKSwgYiA9IGYubGVuZ3RoOyBiLS07KSB7XFxuICAgICAgICAgIGZbYl0uZWxlbSA9PT0gdGhpcyAmJiBmW2JdLnF1ZXVlID09PSBhICYmIChmW2JdLmFuaW0uc3RvcCghMCksIGYuc3BsaWNlKGIsIDEpKTtcXG4gICAgICAgIH1mb3IgKGIgPSAwOyBnID4gYjsgYisrKSB7XFxuICAgICAgICAgIGRbYl0gJiYgZFtiXS5maW5pc2ggJiYgZFtiXS5maW5pc2guY2FsbCh0aGlzKTtcXG4gICAgICAgIH1kZWxldGUgYy5maW5pc2g7XFxuICAgICAgfSk7XFxuICAgIH0gfSksIG4uZWFjaChbXFxcInRvZ2dsZVxcXCIsIFxcXCJzaG93XFxcIiwgXFxcImhpZGVcXFwiXSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBuLmZuW2JdO24uZm5bYl0gPSBmdW5jdGlvbiAoYSwgZCwgZSkge1xcbiAgICAgIHJldHVybiBudWxsID09IGEgfHwgXFxcImJvb2xlYW5cXFwiID09IHR5cGVvZiBhID8gYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdGhpcy5hbmltYXRlKFhhKGIsICEwKSwgYSwgZCwgZSk7XFxuICAgIH07XFxuICB9KSwgbi5lYWNoKHsgc2xpZGVEb3duOiBYYShcXFwic2hvd1xcXCIpLCBzbGlkZVVwOiBYYShcXFwiaGlkZVxcXCIpLCBzbGlkZVRvZ2dsZTogWGEoXFxcInRvZ2dsZVxcXCIpLCBmYWRlSW46IHsgb3BhY2l0eTogXFxcInNob3dcXFwiIH0sIGZhZGVPdXQ6IHsgb3BhY2l0eTogXFxcImhpZGVcXFwiIH0sIGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXFxcInRvZ2dsZVxcXCIgfSB9LCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmZuW2FdID0gZnVuY3Rpb24gKGEsIGMsIGQpIHtcXG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRlKGIsIGEsIGMsIGQpO1xcbiAgICB9O1xcbiAgfSksIG4udGltZXJzID0gW10sIG4uZngudGljayA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGEsXFxuICAgICAgICBiID0gMCxcXG4gICAgICAgIGMgPSBuLnRpbWVycztmb3IgKFNhID0gbi5ub3coKTsgYiA8IGMubGVuZ3RoOyBiKyspIHtcXG4gICAgICBhID0gY1tiXSwgYSgpIHx8IGNbYl0gIT09IGEgfHwgYy5zcGxpY2UoYi0tLCAxKTtcXG4gICAgfWMubGVuZ3RoIHx8IG4uZnguc3RvcCgpLCBTYSA9IHZvaWQgMDtcXG4gIH0sIG4uZngudGltZXIgPSBmdW5jdGlvbiAoYSkge1xcbiAgICBuLnRpbWVycy5wdXNoKGEpLCBhKCkgPyBuLmZ4LnN0YXJ0KCkgOiBuLnRpbWVycy5wb3AoKTtcXG4gIH0sIG4uZnguaW50ZXJ2YWwgPSAxMywgbi5meC5zdGFydCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgVGEgfHwgKFRhID0gYS5zZXRJbnRlcnZhbChuLmZ4LnRpY2ssIG4uZnguaW50ZXJ2YWwpKTtcXG4gIH0sIG4uZnguc3RvcCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYS5jbGVhckludGVydmFsKFRhKSwgVGEgPSBudWxsO1xcbiAgfSwgbi5meC5zcGVlZHMgPSB7IHNsb3c6IDYwMCwgZmFzdDogMjAwLCBfZGVmYXVsdDogNDAwIH0sIG4uZm4uZGVsYXkgPSBmdW5jdGlvbiAoYiwgYykge1xcbiAgICByZXR1cm4gYiA9IG4uZnggPyBuLmZ4LnNwZWVkc1tiXSB8fCBiIDogYiwgYyA9IGMgfHwgXFxcImZ4XFxcIiwgdGhpcy5xdWV1ZShjLCBmdW5jdGlvbiAoYywgZCkge1xcbiAgICAgIHZhciBlID0gYS5zZXRUaW1lb3V0KGMsIGIpO2Quc3RvcCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGEuY2xlYXJUaW1lb3V0KGUpO1xcbiAgICAgIH07XFxuICAgIH0pO1xcbiAgfSwgZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgYSA9IGQuY3JlYXRlRWxlbWVudChcXFwiaW5wdXRcXFwiKSxcXG4gICAgICAgIGIgPSBkLmNyZWF0ZUVsZW1lbnQoXFxcInNlbGVjdFxcXCIpLFxcbiAgICAgICAgYyA9IGIuYXBwZW5kQ2hpbGQoZC5jcmVhdGVFbGVtZW50KFxcXCJvcHRpb25cXFwiKSk7YS50eXBlID0gXFxcImNoZWNrYm94XFxcIiwgbC5jaGVja09uID0gXFxcIlxcXCIgIT09IGEudmFsdWUsIGwub3B0U2VsZWN0ZWQgPSBjLnNlbGVjdGVkLCBiLmRpc2FibGVkID0gITAsIGwub3B0RGlzYWJsZWQgPSAhYy5kaXNhYmxlZCwgYSA9IGQuY3JlYXRlRWxlbWVudChcXFwiaW5wdXRcXFwiKSwgYS52YWx1ZSA9IFxcXCJ0XFxcIiwgYS50eXBlID0gXFxcInJhZGlvXFxcIiwgbC5yYWRpb1ZhbHVlID0gXFxcInRcXFwiID09PSBhLnZhbHVlO1xcbiAgfSgpO3ZhciBhYixcXG4gICAgICBiYiA9IG4uZXhwci5hdHRySGFuZGxlO24uZm4uZXh0ZW5kKHsgYXR0cjogZnVuY3Rpb24gYXR0cihhLCBiKSB7XFxuICAgICAgcmV0dXJuIEsodGhpcywgbi5hdHRyLCBhLCBiLCBhcmd1bWVudHMubGVuZ3RoID4gMSk7XFxuICAgIH0sIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIHJlbW92ZUF0dHIoYSkge1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgbi5yZW1vdmVBdHRyKHRoaXMsIGEpO1xcbiAgICAgIH0pO1xcbiAgICB9IH0pLCBuLmV4dGVuZCh7IGF0dHI6IGZ1bmN0aW9uIGF0dHIoYSwgYiwgYykge1xcbiAgICAgIHZhciBkLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBmID0gYS5ub2RlVHlwZTtpZiAoMyAhPT0gZiAmJiA4ICE9PSBmICYmIDIgIT09IGYpIHJldHVybiBcXFwidW5kZWZpbmVkXFxcIiA9PSB0eXBlb2YgYS5nZXRBdHRyaWJ1dGUgPyBuLnByb3AoYSwgYiwgYykgOiAoMSA9PT0gZiAmJiBuLmlzWE1MRG9jKGEpIHx8IChiID0gYi50b0xvd2VyQ2FzZSgpLCBlID0gbi5hdHRySG9va3NbYl0gfHwgKG4uZXhwci5tYXRjaC5ib29sLnRlc3QoYikgPyBhYiA6IHZvaWQgMCkpLCB2b2lkIDAgIT09IGMgPyBudWxsID09PSBjID8gdm9pZCBuLnJlbW92ZUF0dHIoYSwgYikgOiBlICYmIFxcXCJzZXRcXFwiIGluIGUgJiYgdm9pZCAwICE9PSAoZCA9IGUuc2V0KGEsIGMsIGIpKSA/IGQgOiAoYS5zZXRBdHRyaWJ1dGUoYiwgYyArIFxcXCJcXFwiKSwgYykgOiBlICYmIFxcXCJnZXRcXFwiIGluIGUgJiYgbnVsbCAhPT0gKGQgPSBlLmdldChhLCBiKSkgPyBkIDogKGQgPSBuLmZpbmQuYXR0cihhLCBiKSwgbnVsbCA9PSBkID8gdm9pZCAwIDogZCkpO1xcbiAgICB9LCBhdHRySG9va3M6IHsgdHlwZTogeyBzZXQ6IGZ1bmN0aW9uIHNldChhLCBiKSB7XFxuICAgICAgICAgIGlmICghbC5yYWRpb1ZhbHVlICYmIFxcXCJyYWRpb1xcXCIgPT09IGIgJiYgbi5ub2RlTmFtZShhLCBcXFwiaW5wdXRcXFwiKSkge1xcbiAgICAgICAgICAgIHZhciBjID0gYS52YWx1ZTtyZXR1cm4gYS5zZXRBdHRyaWJ1dGUoXFxcInR5cGVcXFwiLCBiKSwgYyAmJiAoYS52YWx1ZSA9IGMpLCBiO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IH0gfSwgcmVtb3ZlQXR0cjogZnVuY3Rpb24gcmVtb3ZlQXR0cihhLCBiKSB7XFxuICAgICAgdmFyIGMsXFxuICAgICAgICAgIGQsXFxuICAgICAgICAgIGUgPSAwLFxcbiAgICAgICAgICBmID0gYiAmJiBiLm1hdGNoKEcpO2lmIChmICYmIDEgPT09IGEubm9kZVR5cGUpIHdoaWxlIChjID0gZltlKytdKSB7XFxuICAgICAgICBkID0gbi5wcm9wRml4W2NdIHx8IGMsIG4uZXhwci5tYXRjaC5ib29sLnRlc3QoYykgJiYgKGFbZF0gPSAhMSksIGEucmVtb3ZlQXR0cmlidXRlKGMpO1xcbiAgICAgIH1cXG4gICAgfSB9KSwgYWIgPSB7IHNldDogZnVuY3Rpb24gc2V0KGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gYiA9PT0gITEgPyBuLnJlbW92ZUF0dHIoYSwgYykgOiBhLnNldEF0dHJpYnV0ZShjLCBjKSwgYztcXG4gICAgfSB9LCBuLmVhY2gobi5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKC9cXFxcdysvZyksIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIHZhciBjID0gYmJbYl0gfHwgbi5maW5kLmF0dHI7YmJbYl0gPSBmdW5jdGlvbiAoYSwgYiwgZCkge1xcbiAgICAgIHZhciBlLCBmO3JldHVybiBkIHx8IChmID0gYmJbYl0sIGJiW2JdID0gZSwgZSA9IG51bGwgIT0gYyhhLCBiLCBkKSA/IGIudG9Mb3dlckNhc2UoKSA6IG51bGwsIGJiW2JdID0gZiksIGU7XFxuICAgIH07XFxuICB9KTt2YXIgY2IgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxcbiAgICAgIGRiID0gL14oPzphfGFyZWEpJC9pO24uZm4uZXh0ZW5kKHsgcHJvcDogZnVuY3Rpb24gcHJvcChhLCBiKSB7XFxuICAgICAgcmV0dXJuIEsodGhpcywgbi5wcm9wLCBhLCBiLCBhcmd1bWVudHMubGVuZ3RoID4gMSk7XFxuICAgIH0sIHJlbW92ZVByb3A6IGZ1bmN0aW9uIHJlbW92ZVByb3AoYSkge1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgZGVsZXRlIHRoaXNbbi5wcm9wRml4W2FdIHx8IGFdO1xcbiAgICAgIH0pO1xcbiAgICB9IH0pLCBuLmV4dGVuZCh7IHByb3A6IGZ1bmN0aW9uIHByb3AoYSwgYiwgYykge1xcbiAgICAgIHZhciBkLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBmID0gYS5ub2RlVHlwZTtpZiAoMyAhPT0gZiAmJiA4ICE9PSBmICYmIDIgIT09IGYpIHJldHVybiAxID09PSBmICYmIG4uaXNYTUxEb2MoYSkgfHwgKGIgPSBuLnByb3BGaXhbYl0gfHwgYiwgZSA9IG4ucHJvcEhvb2tzW2JdKSwgdm9pZCAwICE9PSBjID8gZSAmJiBcXFwic2V0XFxcIiBpbiBlICYmIHZvaWQgMCAhPT0gKGQgPSBlLnNldChhLCBjLCBiKSkgPyBkIDogYVtiXSA9IGMgOiBlICYmIFxcXCJnZXRcXFwiIGluIGUgJiYgbnVsbCAhPT0gKGQgPSBlLmdldChhLCBiKSkgPyBkIDogYVtiXTtcXG4gICAgfSwgcHJvcEhvb2tzOiB7IHRhYkluZGV4OiB7IGdldDogZnVuY3Rpb24gZ2V0KGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBuLmZpbmQuYXR0cihhLCBcXFwidGFiaW5kZXhcXFwiKTtyZXR1cm4gYiA/IHBhcnNlSW50KGIsIDEwKSA6IGNiLnRlc3QoYS5ub2RlTmFtZSkgfHwgZGIudGVzdChhLm5vZGVOYW1lKSAmJiBhLmhyZWYgPyAwIDogLTE7XFxuICAgICAgICB9IH0gfSwgcHJvcEZpeDogeyBcXFwiZm9yXFxcIjogXFxcImh0bWxGb3JcXFwiLCBcXFwiY2xhc3NcXFwiOiBcXFwiY2xhc3NOYW1lXFxcIiB9IH0pLCBsLm9wdFNlbGVjdGVkIHx8IChuLnByb3BIb29rcy5zZWxlY3RlZCA9IHsgZ2V0OiBmdW5jdGlvbiBnZXQoYSkge1xcbiAgICAgIHZhciBiID0gYS5wYXJlbnROb2RlO3JldHVybiBiICYmIGIucGFyZW50Tm9kZSAmJiBiLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCwgbnVsbDtcXG4gICAgfSB9KSwgbi5lYWNoKFtcXFwidGFiSW5kZXhcXFwiLCBcXFwicmVhZE9ubHlcXFwiLCBcXFwibWF4TGVuZ3RoXFxcIiwgXFxcImNlbGxTcGFjaW5nXFxcIiwgXFxcImNlbGxQYWRkaW5nXFxcIiwgXFxcInJvd1NwYW5cXFwiLCBcXFwiY29sU3BhblxcXCIsIFxcXCJ1c2VNYXBcXFwiLCBcXFwiZnJhbWVCb3JkZXJcXFwiLCBcXFwiY29udGVudEVkaXRhYmxlXFxcIl0sIGZ1bmN0aW9uICgpIHtcXG4gICAgbi5wcm9wRml4W3RoaXMudG9Mb3dlckNhc2UoKV0gPSB0aGlzO1xcbiAgfSk7dmFyIGViID0gL1tcXFxcdFxcXFxyXFxcXG5cXFxcZl0vZztmdW5jdGlvbiBmYihhKSB7XFxuICAgIHJldHVybiBhLmdldEF0dHJpYnV0ZSAmJiBhLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKSB8fCBcXFwiXFxcIjtcXG4gIH1uLmZuLmV4dGVuZCh7IGFkZENsYXNzOiBmdW5jdGlvbiBhZGRDbGFzcyhhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGMsXFxuICAgICAgICAgIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGgsXFxuICAgICAgICAgIGkgPSAwO2lmIChuLmlzRnVuY3Rpb24oYSkpIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgIG4odGhpcykuYWRkQ2xhc3MoYS5jYWxsKHRoaXMsIGIsIGZiKHRoaXMpKSk7XFxuICAgICAgfSk7aWYgKFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhICYmIGEpIHtcXG4gICAgICAgIGIgPSBhLm1hdGNoKEcpIHx8IFtdO3doaWxlIChjID0gdGhpc1tpKytdKSB7XFxuICAgICAgICAgIGlmIChlID0gZmIoYyksIGQgPSAxID09PSBjLm5vZGVUeXBlICYmIChcXFwiIFxcXCIgKyBlICsgXFxcIiBcXFwiKS5yZXBsYWNlKGViLCBcXFwiIFxcXCIpKSB7XFxuICAgICAgICAgICAgZyA9IDA7d2hpbGUgKGYgPSBiW2crK10pIHtcXG4gICAgICAgICAgICAgIGQuaW5kZXhPZihcXFwiIFxcXCIgKyBmICsgXFxcIiBcXFwiKSA8IDAgJiYgKGQgKz0gZiArIFxcXCIgXFxcIik7XFxuICAgICAgICAgICAgfWggPSBuLnRyaW0oZCksIGUgIT09IGggJiYgYy5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIiwgaCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9cmV0dXJuIHRoaXM7XFxuICAgIH0sIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiByZW1vdmVDbGFzcyhhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGMsXFxuICAgICAgICAgIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGgsXFxuICAgICAgICAgIGkgPSAwO2lmIChuLmlzRnVuY3Rpb24oYSkpIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgIG4odGhpcykucmVtb3ZlQ2xhc3MoYS5jYWxsKHRoaXMsIGIsIGZiKHRoaXMpKSk7XFxuICAgICAgfSk7aWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5hdHRyKFxcXCJjbGFzc1xcXCIsIFxcXCJcXFwiKTtpZiAoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGEgJiYgYSkge1xcbiAgICAgICAgYiA9IGEubWF0Y2goRykgfHwgW107d2hpbGUgKGMgPSB0aGlzW2krK10pIHtcXG4gICAgICAgICAgaWYgKGUgPSBmYihjKSwgZCA9IDEgPT09IGMubm9kZVR5cGUgJiYgKFxcXCIgXFxcIiArIGUgKyBcXFwiIFxcXCIpLnJlcGxhY2UoZWIsIFxcXCIgXFxcIikpIHtcXG4gICAgICAgICAgICBnID0gMDt3aGlsZSAoZiA9IGJbZysrXSkge1xcbiAgICAgICAgICAgICAgd2hpbGUgKGQuaW5kZXhPZihcXFwiIFxcXCIgKyBmICsgXFxcIiBcXFwiKSA+IC0xKSB7XFxuICAgICAgICAgICAgICAgIGQgPSBkLnJlcGxhY2UoXFxcIiBcXFwiICsgZiArIFxcXCIgXFxcIiwgXFxcIiBcXFwiKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9aCA9IG4udHJpbShkKSwgZSAhPT0gaCAmJiBjLnNldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiLCBoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1yZXR1cm4gdGhpcztcXG4gICAgfSwgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGEsIGIpIHtcXG4gICAgICB2YXIgYyA9IHR5cGVvZiBhID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihhKTtyZXR1cm4gXFxcImJvb2xlYW5cXFwiID09IHR5cGVvZiBiICYmIFxcXCJzdHJpbmdcXFwiID09PSBjID8gYiA/IHRoaXMuYWRkQ2xhc3MoYSkgOiB0aGlzLnJlbW92ZUNsYXNzKGEpIDogbi5pc0Z1bmN0aW9uKGEpID8gdGhpcy5lYWNoKGZ1bmN0aW9uIChjKSB7XFxuICAgICAgICBuKHRoaXMpLnRvZ2dsZUNsYXNzKGEuY2FsbCh0aGlzLCBjLCBmYih0aGlzKSwgYiksIGIpO1xcbiAgICAgIH0pIDogdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBiLCBkLCBlLCBmO2lmIChcXFwic3RyaW5nXFxcIiA9PT0gYykge1xcbiAgICAgICAgICBkID0gMCwgZSA9IG4odGhpcyksIGYgPSBhLm1hdGNoKEcpIHx8IFtdO3doaWxlIChiID0gZltkKytdKSB7XFxuICAgICAgICAgICAgZS5oYXNDbGFzcyhiKSA/IGUucmVtb3ZlQ2xhc3MoYikgOiBlLmFkZENsYXNzKGIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgKHZvaWQgMCA9PT0gYSB8fCBcXFwiYm9vbGVhblxcXCIgPT09IGMpICYmIChiID0gZmIodGhpcyksIGIgJiYgTi5zZXQodGhpcywgXFxcIl9fY2xhc3NOYW1lX19cXFwiLCBiKSwgdGhpcy5zZXRBdHRyaWJ1dGUgJiYgdGhpcy5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIiwgYiB8fCBhID09PSAhMSA/IFxcXCJcXFwiIDogTi5nZXQodGhpcywgXFxcIl9fY2xhc3NOYW1lX19cXFwiKSB8fCBcXFwiXFxcIikpO1xcbiAgICAgIH0pO1xcbiAgICB9LCBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjLFxcbiAgICAgICAgICBkID0gMDtiID0gXFxcIiBcXFwiICsgYSArIFxcXCIgXFxcIjt3aGlsZSAoYyA9IHRoaXNbZCsrXSkge1xcbiAgICAgICAgaWYgKDEgPT09IGMubm9kZVR5cGUgJiYgKFxcXCIgXFxcIiArIGZiKGMpICsgXFxcIiBcXFwiKS5yZXBsYWNlKGViLCBcXFwiIFxcXCIpLmluZGV4T2YoYikgPiAtMSkgcmV0dXJuICEwO1xcbiAgICAgIH1yZXR1cm4gITE7XFxuICAgIH0gfSk7dmFyIGdiID0gL1xcXFxyL2c7bi5mbi5leHRlbmQoeyB2YWw6IGZ1bmN0aW9uIHZhbChhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGMsXFxuICAgICAgICAgIGQsXFxuICAgICAgICAgIGUgPSB0aGlzWzBdO3tcXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZCA9IG4uaXNGdW5jdGlvbihhKSwgdGhpcy5lYWNoKGZ1bmN0aW9uIChjKSB7XFxuICAgICAgICAgIHZhciBlOzEgPT09IHRoaXMubm9kZVR5cGUgJiYgKGUgPSBkID8gYS5jYWxsKHRoaXMsIGMsIG4odGhpcykudmFsKCkpIDogYSwgbnVsbCA9PSBlID8gZSA9IFxcXCJcXFwiIDogXFxcIm51bWJlclxcXCIgPT0gdHlwZW9mIGUgPyBlICs9IFxcXCJcXFwiIDogbi5pc0FycmF5KGUpICYmIChlID0gbi5tYXAoZSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBhID8gXFxcIlxcXCIgOiBhICsgXFxcIlxcXCI7XFxuICAgICAgICAgIH0pKSwgYiA9IG4udmFsSG9va3NbdGhpcy50eXBlXSB8fCBuLnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0sIGIgJiYgXFxcInNldFxcXCIgaW4gYiAmJiB2b2lkIDAgIT09IGIuc2V0KHRoaXMsIGUsIFxcXCJ2YWx1ZVxcXCIpIHx8ICh0aGlzLnZhbHVlID0gZSkpO1xcbiAgICAgICAgfSk7aWYgKGUpIHJldHVybiBiID0gbi52YWxIb29rc1tlLnR5cGVdIHx8IG4udmFsSG9va3NbZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSwgYiAmJiBcXFwiZ2V0XFxcIiBpbiBiICYmIHZvaWQgMCAhPT0gKGMgPSBiLmdldChlLCBcXFwidmFsdWVcXFwiKSkgPyBjIDogKGMgPSBlLnZhbHVlLCBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYyA/IGMucmVwbGFjZShnYiwgXFxcIlxcXCIpIDogbnVsbCA9PSBjID8gXFxcIlxcXCIgOiBjKTtcXG4gICAgICB9XFxuICAgIH0gfSksIG4uZXh0ZW5kKHsgdmFsSG9va3M6IHsgb3B0aW9uOiB7IGdldDogZnVuY3Rpb24gZ2V0KGEpIHtcXG4gICAgICAgICAgcmV0dXJuIG4udHJpbShhLnZhbHVlKTtcXG4gICAgICAgIH0gfSwgc2VsZWN0OiB7IGdldDogZnVuY3Rpb24gZ2V0KGEpIHtcXG4gICAgICAgICAgZm9yICh2YXIgYiwgYywgZCA9IGEub3B0aW9ucywgZSA9IGEuc2VsZWN0ZWRJbmRleCwgZiA9IFxcXCJzZWxlY3Qtb25lXFxcIiA9PT0gYS50eXBlIHx8IDAgPiBlLCBnID0gZiA/IG51bGwgOiBbXSwgaCA9IGYgPyBlICsgMSA6IGQubGVuZ3RoLCBpID0gMCA+IGUgPyBoIDogZiA/IGUgOiAwOyBoID4gaTsgaSsrKSB7XFxuICAgICAgICAgICAgaWYgKGMgPSBkW2ldLCAoYy5zZWxlY3RlZCB8fCBpID09PSBlKSAmJiAobC5vcHREaXNhYmxlZCA/ICFjLmRpc2FibGVkIDogbnVsbCA9PT0gYy5nZXRBdHRyaWJ1dGUoXFxcImRpc2FibGVkXFxcIikpICYmICghYy5wYXJlbnROb2RlLmRpc2FibGVkIHx8ICFuLm5vZGVOYW1lKGMucGFyZW50Tm9kZSwgXFxcIm9wdGdyb3VwXFxcIikpKSB7XFxuICAgICAgICAgICAgICBpZiAoYiA9IG4oYykudmFsKCksIGYpIHJldHVybiBiO2cucHVzaChiKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1yZXR1cm4gZztcXG4gICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KGEsIGIpIHtcXG4gICAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgICBkLFxcbiAgICAgICAgICAgICAgZSA9IGEub3B0aW9ucyxcXG4gICAgICAgICAgICAgIGYgPSBuLm1ha2VBcnJheShiKSxcXG4gICAgICAgICAgICAgIGcgPSBlLmxlbmd0aDt3aGlsZSAoZy0tKSB7XFxuICAgICAgICAgICAgZCA9IGVbZ10sIChkLnNlbGVjdGVkID0gbi5pbkFycmF5KG4udmFsSG9va3Mub3B0aW9uLmdldChkKSwgZikgPiAtMSkgJiYgKGMgPSAhMCk7XFxuICAgICAgICAgIH1yZXR1cm4gYyB8fCAoYS5zZWxlY3RlZEluZGV4ID0gLTEpLCBmO1xcbiAgICAgICAgfSB9IH0gfSksIG4uZWFjaChbXFxcInJhZGlvXFxcIiwgXFxcImNoZWNrYm94XFxcIl0sIGZ1bmN0aW9uICgpIHtcXG4gICAgbi52YWxIb29rc1t0aGlzXSA9IHsgc2V0OiBmdW5jdGlvbiBzZXQoYSwgYikge1xcbiAgICAgICAgcmV0dXJuIG4uaXNBcnJheShiKSA/IGEuY2hlY2tlZCA9IG4uaW5BcnJheShuKGEpLnZhbCgpLCBiKSA+IC0xIDogdm9pZCAwO1xcbiAgICAgIH0gfSwgbC5jaGVja09uIHx8IChuLnZhbEhvb2tzW3RoaXNdLmdldCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIG51bGwgPT09IGEuZ2V0QXR0cmlidXRlKFxcXCJ2YWx1ZVxcXCIpID8gXFxcIm9uXFxcIiA6IGEudmFsdWU7XFxuICAgIH0pO1xcbiAgfSk7dmFyIGhiID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvO24uZXh0ZW5kKG4uZXZlbnQsIHsgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcihiLCBjLCBlLCBmKSB7XFxuICAgICAgdmFyIGcsXFxuICAgICAgICAgIGgsXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIGwsXFxuICAgICAgICAgIG0sXFxuICAgICAgICAgIG8sXFxuICAgICAgICAgIHAgPSBbZSB8fCBkXSxcXG4gICAgICAgICAgcSA9IGsuY2FsbChiLCBcXFwidHlwZVxcXCIpID8gYi50eXBlIDogYixcXG4gICAgICAgICAgciA9IGsuY2FsbChiLCBcXFwibmFtZXNwYWNlXFxcIikgPyBiLm5hbWVzcGFjZS5zcGxpdChcXFwiLlxcXCIpIDogW107aWYgKGggPSBpID0gZSA9IGUgfHwgZCwgMyAhPT0gZS5ub2RlVHlwZSAmJiA4ICE9PSBlLm5vZGVUeXBlICYmICFoYi50ZXN0KHEgKyBuLmV2ZW50LnRyaWdnZXJlZCkgJiYgKHEuaW5kZXhPZihcXFwiLlxcXCIpID4gLTEgJiYgKHIgPSBxLnNwbGl0KFxcXCIuXFxcIiksIHEgPSByLnNoaWZ0KCksIHIuc29ydCgpKSwgbCA9IHEuaW5kZXhPZihcXFwiOlxcXCIpIDwgMCAmJiBcXFwib25cXFwiICsgcSwgYiA9IGJbbi5leHBhbmRvXSA/IGIgOiBuZXcgbi5FdmVudChxLCBcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGIgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGIpKSAmJiBiKSwgYi5pc1RyaWdnZXIgPSBmID8gMiA6IDMsIGIubmFtZXNwYWNlID0gci5qb2luKFxcXCIuXFxcIiksIGIucm5hbWVzcGFjZSA9IGIubmFtZXNwYWNlID8gbmV3IFJlZ0V4cChcXFwiKF58XFxcXFxcXFwuKVxcXCIgKyByLmpvaW4oXFxcIlxcXFxcXFxcLig/Oi4qXFxcXFxcXFwufClcXFwiKSArIFxcXCIoXFxcXFxcXFwufCQpXFxcIikgOiBudWxsLCBiLnJlc3VsdCA9IHZvaWQgMCwgYi50YXJnZXQgfHwgKGIudGFyZ2V0ID0gZSksIGMgPSBudWxsID09IGMgPyBbYl0gOiBuLm1ha2VBcnJheShjLCBbYl0pLCBvID0gbi5ldmVudC5zcGVjaWFsW3FdIHx8IHt9LCBmIHx8ICFvLnRyaWdnZXIgfHwgby50cmlnZ2VyLmFwcGx5KGUsIGMpICE9PSAhMSkpIHtcXG4gICAgICAgIGlmICghZiAmJiAhby5ub0J1YmJsZSAmJiAhbi5pc1dpbmRvdyhlKSkge1xcbiAgICAgICAgICBmb3IgKGogPSBvLmRlbGVnYXRlVHlwZSB8fCBxLCBoYi50ZXN0KGogKyBxKSB8fCAoaCA9IGgucGFyZW50Tm9kZSk7IGg7IGggPSBoLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgICBwLnB1c2goaCksIGkgPSBoO1xcbiAgICAgICAgICB9aSA9PT0gKGUub3duZXJEb2N1bWVudCB8fCBkKSAmJiBwLnB1c2goaS5kZWZhdWx0VmlldyB8fCBpLnBhcmVudFdpbmRvdyB8fCBhKTtcXG4gICAgICAgIH1nID0gMDt3aGlsZSAoKGggPSBwW2crK10pICYmICFiLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcXG4gICAgICAgICAgYi50eXBlID0gZyA+IDEgPyBqIDogby5iaW5kVHlwZSB8fCBxLCBtID0gKE4uZ2V0KGgsIFxcXCJldmVudHNcXFwiKSB8fCB7fSlbYi50eXBlXSAmJiBOLmdldChoLCBcXFwiaGFuZGxlXFxcIiksIG0gJiYgbS5hcHBseShoLCBjKSwgbSA9IGwgJiYgaFtsXSwgbSAmJiBtLmFwcGx5ICYmIEwoaCkgJiYgKGIucmVzdWx0ID0gbS5hcHBseShoLCBjKSwgYi5yZXN1bHQgPT09ICExICYmIGIucHJldmVudERlZmF1bHQoKSk7XFxuICAgICAgICB9cmV0dXJuIGIudHlwZSA9IHEsIGYgfHwgYi5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBvLl9kZWZhdWx0ICYmIG8uX2RlZmF1bHQuYXBwbHkocC5wb3AoKSwgYykgIT09ICExIHx8ICFMKGUpIHx8IGwgJiYgbi5pc0Z1bmN0aW9uKGVbcV0pICYmICFuLmlzV2luZG93KGUpICYmIChpID0gZVtsXSwgaSAmJiAoZVtsXSA9IG51bGwpLCBuLmV2ZW50LnRyaWdnZXJlZCA9IHEsIGVbcV0oKSwgbi5ldmVudC50cmlnZ2VyZWQgPSB2b2lkIDAsIGkgJiYgKGVbbF0gPSBpKSksIGIucmVzdWx0O1xcbiAgICAgIH1cXG4gICAgfSwgc2ltdWxhdGU6IGZ1bmN0aW9uIHNpbXVsYXRlKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCA9IG4uZXh0ZW5kKG5ldyBuLkV2ZW50KCksIGMsIHsgdHlwZTogYSwgaXNTaW11bGF0ZWQ6ICEwIH0pO24uZXZlbnQudHJpZ2dlcihkLCBudWxsLCBiKSwgZC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSAmJiBjLnByZXZlbnREZWZhdWx0KCk7XFxuICAgIH0gfSksIG4uZm4uZXh0ZW5kKHsgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcihhLCBiKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBuLmV2ZW50LnRyaWdnZXIoYSwgYiwgdGhpcyk7XFxuICAgICAgfSk7XFxuICAgIH0sIHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiB0cmlnZ2VySGFuZGxlcihhLCBiKSB7XFxuICAgICAgdmFyIGMgPSB0aGlzWzBdO3JldHVybiBjID8gbi5ldmVudC50cmlnZ2VyKGEsIGIsIGMsICEwKSA6IHZvaWQgMDtcXG4gICAgfSB9KSwgbi5lYWNoKFxcXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yIGNvbnRleHRtZW51XFxcIi5zcGxpdChcXFwiIFxcXCIpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmZuW2JdID0gZnVuY3Rpb24gKGEsIGMpIHtcXG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgPyB0aGlzLm9uKGIsIG51bGwsIGEsIGMpIDogdGhpcy50cmlnZ2VyKGIpO1xcbiAgICB9O1xcbiAgfSksIG4uZm4uZXh0ZW5kKHsgaG92ZXI6IGZ1bmN0aW9uIGhvdmVyKGEsIGIpIHtcXG4gICAgICByZXR1cm4gdGhpcy5tb3VzZWVudGVyKGEpLm1vdXNlbGVhdmUoYiB8fCBhKTtcXG4gICAgfSB9KSwgbC5mb2N1c2luID0gXFxcIm9uZm9jdXNpblxcXCIgaW4gYSwgbC5mb2N1c2luIHx8IG4uZWFjaCh7IGZvY3VzOiBcXFwiZm9jdXNpblxcXCIsIGJsdXI6IFxcXCJmb2N1c291dFxcXCIgfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBmdW5jdGlvbiBjKGEpIHtcXG4gICAgICBuLmV2ZW50LnNpbXVsYXRlKGIsIGEudGFyZ2V0LCBuLmV2ZW50LmZpeChhKSk7XFxuICAgIH07bi5ldmVudC5zcGVjaWFsW2JdID0geyBzZXR1cDogZnVuY3Rpb24gc2V0dXAoKSB7XFxuICAgICAgICB2YXIgZCA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxcbiAgICAgICAgICAgIGUgPSBOLmFjY2VzcyhkLCBiKTtlIHx8IGQuYWRkRXZlbnRMaXN0ZW5lcihhLCBjLCAhMCksIE4uYWNjZXNzKGQsIGIsIChlIHx8IDApICsgMSk7XFxuICAgICAgfSwgdGVhcmRvd246IGZ1bmN0aW9uIHRlYXJkb3duKCkge1xcbiAgICAgICAgdmFyIGQgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcXG4gICAgICAgICAgICBlID0gTi5hY2Nlc3MoZCwgYikgLSAxO2UgPyBOLmFjY2VzcyhkLCBiLCBlKSA6IChkLnJlbW92ZUV2ZW50TGlzdGVuZXIoYSwgYywgITApLCBOLnJlbW92ZShkLCBiKSk7XFxuICAgICAgfSB9O1xcbiAgfSk7dmFyIGliID0gYS5sb2NhdGlvbixcXG4gICAgICBqYiA9IG4ubm93KCksXFxuICAgICAga2IgPSAvXFxcXD8vO24ucGFyc2VKU09OID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoYSArIFxcXCJcXFwiKTtcXG4gIH0sIG4ucGFyc2VYTUwgPSBmdW5jdGlvbiAoYikge1xcbiAgICB2YXIgYztpZiAoIWIgfHwgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGIpIHJldHVybiBudWxsO3RyeSB7XFxuICAgICAgYyA9IG5ldyBhLkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhiLCBcXFwidGV4dC94bWxcXFwiKTtcXG4gICAgfSBjYXRjaCAoZCkge1xcbiAgICAgIGMgPSB2b2lkIDA7XFxuICAgIH1yZXR1cm4gKCFjIHx8IGMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcInBhcnNlcmVycm9yXFxcIikubGVuZ3RoKSAmJiBuLmVycm9yKFxcXCJJbnZhbGlkIFhNTDogXFxcIiArIGIpLCBjO1xcbiAgfTt2YXIgbGIgPSAvIy4qJC8sXFxuICAgICAgbWIgPSAvKFs/Jl0pXz1bXiZdKi8sXFxuICAgICAgbmIgPSAvXiguKj8pOlsgXFxcXHRdKihbXlxcXFxyXFxcXG5dKikkL2dtLFxcbiAgICAgIG9iID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXFxuICAgICAgcGIgPSAvXig/OkdFVHxIRUFEKSQvLFxcbiAgICAgIHFiID0gL15cXFxcL1xcXFwvLyxcXG4gICAgICByYiA9IHt9LFxcbiAgICAgIHNiID0ge30sXFxuICAgICAgdGIgPSBcXFwiKi9cXFwiLmNvbmNhdChcXFwiKlxcXCIpLFxcbiAgICAgIHViID0gZC5jcmVhdGVFbGVtZW50KFxcXCJhXFxcIik7dWIuaHJlZiA9IGliLmhyZWY7ZnVuY3Rpb24gdmIoYSkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24gKGIsIGMpIHtcXG4gICAgICBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYiAmJiAoYyA9IGIsIGIgPSBcXFwiKlxcXCIpO3ZhciBkLFxcbiAgICAgICAgICBlID0gMCxcXG4gICAgICAgICAgZiA9IGIudG9Mb3dlckNhc2UoKS5tYXRjaChHKSB8fCBbXTtpZiAobi5pc0Z1bmN0aW9uKGMpKSB3aGlsZSAoZCA9IGZbZSsrXSkge1xcbiAgICAgICAgXFxcIitcXFwiID09PSBkWzBdID8gKGQgPSBkLnNsaWNlKDEpIHx8IFxcXCIqXFxcIiwgKGFbZF0gPSBhW2RdIHx8IFtdKS51bnNoaWZ0KGMpKSA6IChhW2RdID0gYVtkXSB8fCBbXSkucHVzaChjKTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9ZnVuY3Rpb24gd2IoYSwgYiwgYywgZCkge1xcbiAgICB2YXIgZSA9IHt9LFxcbiAgICAgICAgZiA9IGEgPT09IHNiO2Z1bmN0aW9uIGcoaCkge1xcbiAgICAgIHZhciBpO3JldHVybiBlW2hdID0gITAsIG4uZWFjaChhW2hdIHx8IFtdLCBmdW5jdGlvbiAoYSwgaCkge1xcbiAgICAgICAgdmFyIGogPSBoKGIsIGMsIGQpO3JldHVybiBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgaiB8fCBmIHx8IGVbal0gPyBmID8gIShpID0gaikgOiB2b2lkIDAgOiAoYi5kYXRhVHlwZXMudW5zaGlmdChqKSwgZyhqKSwgITEpO1xcbiAgICAgIH0pLCBpO1xcbiAgICB9cmV0dXJuIGcoYi5kYXRhVHlwZXNbMF0pIHx8ICFlW1xcXCIqXFxcIl0gJiYgZyhcXFwiKlxcXCIpO1xcbiAgfWZ1bmN0aW9uIHhiKGEsIGIpIHtcXG4gICAgdmFyIGMsXFxuICAgICAgICBkLFxcbiAgICAgICAgZSA9IG4uYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O2ZvciAoYyBpbiBiKSB7XFxuICAgICAgdm9pZCAwICE9PSBiW2NdICYmICgoZVtjXSA/IGEgOiBkIHx8IChkID0ge30pKVtjXSA9IGJbY10pO1xcbiAgICB9cmV0dXJuIGQgJiYgbi5leHRlbmQoITAsIGEsIGQpLCBhO1xcbiAgfWZ1bmN0aW9uIHliKGEsIGIsIGMpIHtcXG4gICAgdmFyIGQsXFxuICAgICAgICBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcsXFxuICAgICAgICBoID0gYS5jb250ZW50cyxcXG4gICAgICAgIGkgPSBhLmRhdGFUeXBlczt3aGlsZSAoXFxcIipcXFwiID09PSBpWzBdKSB7XFxuICAgICAgaS5zaGlmdCgpLCB2b2lkIDAgPT09IGQgJiYgKGQgPSBhLm1pbWVUeXBlIHx8IGIuZ2V0UmVzcG9uc2VIZWFkZXIoXFxcIkNvbnRlbnQtVHlwZVxcXCIpKTtcXG4gICAgfWlmIChkKSBmb3IgKGUgaW4gaCkge1xcbiAgICAgIGlmIChoW2VdICYmIGhbZV0udGVzdChkKSkge1xcbiAgICAgICAgaS51bnNoaWZ0KGUpO2JyZWFrO1xcbiAgICAgIH1cXG4gICAgfWlmIChpWzBdIGluIGMpIGYgPSBpWzBdO2Vsc2Uge1xcbiAgICAgIGZvciAoZSBpbiBjKSB7XFxuICAgICAgICBpZiAoIWlbMF0gfHwgYS5jb252ZXJ0ZXJzW2UgKyBcXFwiIFxcXCIgKyBpWzBdXSkge1xcbiAgICAgICAgICBmID0gZTticmVhaztcXG4gICAgICAgIH1nIHx8IChnID0gZSk7XFxuICAgICAgfWYgPSBmIHx8IGc7XFxuICAgIH1yZXR1cm4gZiA/IChmICE9PSBpWzBdICYmIGkudW5zaGlmdChmKSwgY1tmXSkgOiB2b2lkIDA7XFxuICB9ZnVuY3Rpb24gemIoYSwgYiwgYywgZCkge1xcbiAgICB2YXIgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCxcXG4gICAgICAgIGksXFxuICAgICAgICBqID0ge30sXFxuICAgICAgICBrID0gYS5kYXRhVHlwZXMuc2xpY2UoKTtpZiAoa1sxXSkgZm9yIChnIGluIGEuY29udmVydGVycykge1xcbiAgICAgIGpbZy50b0xvd2VyQ2FzZSgpXSA9IGEuY29udmVydGVyc1tnXTtcXG4gICAgfWYgPSBrLnNoaWZ0KCk7d2hpbGUgKGYpIHtcXG4gICAgICBpZiAoYS5yZXNwb25zZUZpZWxkc1tmXSAmJiAoY1thLnJlc3BvbnNlRmllbGRzW2ZdXSA9IGIpLCAhaSAmJiBkICYmIGEuZGF0YUZpbHRlciAmJiAoYiA9IGEuZGF0YUZpbHRlcihiLCBhLmRhdGFUeXBlKSksIGkgPSBmLCBmID0gay5zaGlmdCgpKSBpZiAoXFxcIipcXFwiID09PSBmKSBmID0gaTtlbHNlIGlmIChcXFwiKlxcXCIgIT09IGkgJiYgaSAhPT0gZikge1xcbiAgICAgICAgaWYgKGcgPSBqW2kgKyBcXFwiIFxcXCIgKyBmXSB8fCBqW1xcXCIqIFxcXCIgKyBmXSwgIWcpIGZvciAoZSBpbiBqKSB7XFxuICAgICAgICAgIGlmIChoID0gZS5zcGxpdChcXFwiIFxcXCIpLCBoWzFdID09PSBmICYmIChnID0galtpICsgXFxcIiBcXFwiICsgaFswXV0gfHwgaltcXFwiKiBcXFwiICsgaFswXV0pKSB7XFxuICAgICAgICAgICAgZyA9PT0gITAgPyBnID0galtlXSA6IGpbZV0gIT09ICEwICYmIChmID0gaFswXSwgay51bnNoaWZ0KGhbMV0pKTticmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfWlmIChnICE9PSAhMCkgaWYgKGcgJiYgYVtcXFwidGhyb3dzXFxcIl0pIGIgPSBnKGIpO2Vsc2UgdHJ5IHtcXG4gICAgICAgICAgYiA9IGcoYik7XFxuICAgICAgICB9IGNhdGNoIChsKSB7XFxuICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBcXFwicGFyc2VyZXJyb3JcXFwiLCBlcnJvcjogZyA/IGwgOiBcXFwiTm8gY29udmVyc2lvbiBmcm9tIFxcXCIgKyBpICsgXFxcIiB0byBcXFwiICsgZiB9O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfXJldHVybiB7IHN0YXRlOiBcXFwic3VjY2Vzc1xcXCIsIGRhdGE6IGIgfTtcXG4gIH1uLmV4dGVuZCh7IGFjdGl2ZTogMCwgbGFzdE1vZGlmaWVkOiB7fSwgZXRhZzoge30sIGFqYXhTZXR0aW5nczogeyB1cmw6IGliLmhyZWYsIHR5cGU6IFxcXCJHRVRcXFwiLCBpc0xvY2FsOiBvYi50ZXN0KGliLnByb3RvY29sKSwgZ2xvYmFsOiAhMCwgcHJvY2Vzc0RhdGE6ICEwLCBhc3luYzogITAsIGNvbnRlbnRUeXBlOiBcXFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XFxcIiwgYWNjZXB0czogeyBcXFwiKlxcXCI6IHRiLCB0ZXh0OiBcXFwidGV4dC9wbGFpblxcXCIsIGh0bWw6IFxcXCJ0ZXh0L2h0bWxcXFwiLCB4bWw6IFxcXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXFxcIiwganNvbjogXFxcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFxcXCIgfSwgY29udGVudHM6IHsgeG1sOiAvXFxcXGJ4bWxcXFxcYi8sIGh0bWw6IC9cXFxcYmh0bWwvLCBqc29uOiAvXFxcXGJqc29uXFxcXGIvIH0sIHJlc3BvbnNlRmllbGRzOiB7IHhtbDogXFxcInJlc3BvbnNlWE1MXFxcIiwgdGV4dDogXFxcInJlc3BvbnNlVGV4dFxcXCIsIGpzb246IFxcXCJyZXNwb25zZUpTT05cXFwiIH0sIGNvbnZlcnRlcnM6IHsgXFxcIiogdGV4dFxcXCI6IFN0cmluZywgXFxcInRleHQgaHRtbFxcXCI6ICEwLCBcXFwidGV4dCBqc29uXFxcIjogbi5wYXJzZUpTT04sIFxcXCJ0ZXh0IHhtbFxcXCI6IG4ucGFyc2VYTUwgfSwgZmxhdE9wdGlvbnM6IHsgdXJsOiAhMCwgY29udGV4dDogITAgfSB9LCBhamF4U2V0dXA6IGZ1bmN0aW9uIGFqYXhTZXR1cChhLCBiKSB7XFxuICAgICAgcmV0dXJuIGIgPyB4Yih4YihhLCBuLmFqYXhTZXR0aW5ncyksIGIpIDogeGIobi5hamF4U2V0dGluZ3MsIGEpO1xcbiAgICB9LCBhamF4UHJlZmlsdGVyOiB2YihyYiksIGFqYXhUcmFuc3BvcnQ6IHZiKHNiKSwgYWpheDogZnVuY3Rpb24gYWpheChiLCBjKSB7XFxuICAgICAgXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBiID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihiKSkgJiYgKGMgPSBiLCBiID0gdm9pZCAwKSwgYyA9IGMgfHwge307dmFyIGUsXFxuICAgICAgICAgIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGgsXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIGssXFxuICAgICAgICAgIGwsXFxuICAgICAgICAgIG0gPSBuLmFqYXhTZXR1cCh7fSwgYyksXFxuICAgICAgICAgIG8gPSBtLmNvbnRleHQgfHwgbSxcXG4gICAgICAgICAgcCA9IG0uY29udGV4dCAmJiAoby5ub2RlVHlwZSB8fCBvLmpxdWVyeSkgPyBuKG8pIDogbi5ldmVudCxcXG4gICAgICAgICAgcSA9IG4uRGVmZXJyZWQoKSxcXG4gICAgICAgICAgciA9IG4uQ2FsbGJhY2tzKFxcXCJvbmNlIG1lbW9yeVxcXCIpLFxcbiAgICAgICAgICBzID0gbS5zdGF0dXNDb2RlIHx8IHt9LFxcbiAgICAgICAgICB0ID0ge30sXFxuICAgICAgICAgIHUgPSB7fSxcXG4gICAgICAgICAgdiA9IDAsXFxuICAgICAgICAgIHcgPSBcXFwiY2FuY2VsZWRcXFwiLFxcbiAgICAgICAgICB4ID0geyByZWFkeVN0YXRlOiAwLCBnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24gZ2V0UmVzcG9uc2VIZWFkZXIoYSkge1xcbiAgICAgICAgICB2YXIgYjtpZiAoMiA9PT0gdikge1xcbiAgICAgICAgICAgIGlmICghaCkge1xcbiAgICAgICAgICAgICAgaCA9IHt9O3doaWxlIChiID0gbmIuZXhlYyhnKSkge1xcbiAgICAgICAgICAgICAgICBoW2JbMV0udG9Mb3dlckNhc2UoKV0gPSBiWzJdO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1iID0gaFthLnRvTG93ZXJDYXNlKCldO1xcbiAgICAgICAgICB9cmV0dXJuIG51bGwgPT0gYiA/IG51bGwgOiBiO1xcbiAgICAgICAgfSwgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbiBnZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB7XFxuICAgICAgICAgIHJldHVybiAyID09PSB2ID8gZyA6IG51bGw7XFxuICAgICAgICB9LCBzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKGEsIGIpIHtcXG4gICAgICAgICAgdmFyIGMgPSBhLnRvTG93ZXJDYXNlKCk7cmV0dXJuIHYgfHwgKGEgPSB1W2NdID0gdVtjXSB8fCBhLCB0W2FdID0gYiksIHRoaXM7XFxuICAgICAgICB9LCBvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiBvdmVycmlkZU1pbWVUeXBlKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIHYgfHwgKG0ubWltZVR5cGUgPSBhKSwgdGhpcztcXG4gICAgICAgIH0sIHN0YXR1c0NvZGU6IGZ1bmN0aW9uIHN0YXR1c0NvZGUoYSkge1xcbiAgICAgICAgICB2YXIgYjtpZiAoYSkgaWYgKDIgPiB2KSBmb3IgKGIgaW4gYSkge1xcbiAgICAgICAgICAgIHNbYl0gPSBbc1tiXSwgYVtiXV07XFxuICAgICAgICAgIH0gZWxzZSB4LmFsd2F5cyhhW3guc3RhdHVzXSk7cmV0dXJuIHRoaXM7XFxuICAgICAgICB9LCBhYm9ydDogZnVuY3Rpb24gYWJvcnQoYSkge1xcbiAgICAgICAgICB2YXIgYiA9IGEgfHwgdztyZXR1cm4gZSAmJiBlLmFib3J0KGIpLCB6KDAsIGIpLCB0aGlzO1xcbiAgICAgICAgfSB9O2lmIChxLnByb21pc2UoeCkuY29tcGxldGUgPSByLmFkZCwgeC5zdWNjZXNzID0geC5kb25lLCB4LmVycm9yID0geC5mYWlsLCBtLnVybCA9ICgoYiB8fCBtLnVybCB8fCBpYi5ocmVmKSArIFxcXCJcXFwiKS5yZXBsYWNlKGxiLCBcXFwiXFxcIikucmVwbGFjZShxYiwgaWIucHJvdG9jb2wgKyBcXFwiLy9cXFwiKSwgbS50eXBlID0gYy5tZXRob2QgfHwgYy50eXBlIHx8IG0ubWV0aG9kIHx8IG0udHlwZSwgbS5kYXRhVHlwZXMgPSBuLnRyaW0obS5kYXRhVHlwZSB8fCBcXFwiKlxcXCIpLnRvTG93ZXJDYXNlKCkubWF0Y2goRykgfHwgW1xcXCJcXFwiXSwgbnVsbCA9PSBtLmNyb3NzRG9tYWluKSB7XFxuICAgICAgICBqID0gZC5jcmVhdGVFbGVtZW50KFxcXCJhXFxcIik7dHJ5IHtcXG4gICAgICAgICAgai5ocmVmID0gbS51cmwsIGouaHJlZiA9IGouaHJlZiwgbS5jcm9zc0RvbWFpbiA9IHViLnByb3RvY29sICsgXFxcIi8vXFxcIiArIHViLmhvc3QgIT0gai5wcm90b2NvbCArIFxcXCIvL1xcXCIgKyBqLmhvc3Q7XFxuICAgICAgICB9IGNhdGNoICh5KSB7XFxuICAgICAgICAgIG0uY3Jvc3NEb21haW4gPSAhMDtcXG4gICAgICAgIH1cXG4gICAgICB9aWYgKG0uZGF0YSAmJiBtLnByb2Nlc3NEYXRhICYmIFxcXCJzdHJpbmdcXFwiICE9IHR5cGVvZiBtLmRhdGEgJiYgKG0uZGF0YSA9IG4ucGFyYW0obS5kYXRhLCBtLnRyYWRpdGlvbmFsKSksIHdiKHJiLCBtLCBjLCB4KSwgMiA9PT0gdikgcmV0dXJuIHg7ayA9IG4uZXZlbnQgJiYgbS5nbG9iYWwsIGsgJiYgMCA9PT0gbi5hY3RpdmUrKyAmJiBuLmV2ZW50LnRyaWdnZXIoXFxcImFqYXhTdGFydFxcXCIpLCBtLnR5cGUgPSBtLnR5cGUudG9VcHBlckNhc2UoKSwgbS5oYXNDb250ZW50ID0gIXBiLnRlc3QobS50eXBlKSwgZiA9IG0udXJsLCBtLmhhc0NvbnRlbnQgfHwgKG0uZGF0YSAmJiAoZiA9IG0udXJsICs9IChrYi50ZXN0KGYpID8gXFxcIiZcXFwiIDogXFxcIj9cXFwiKSArIG0uZGF0YSwgZGVsZXRlIG0uZGF0YSksIG0uY2FjaGUgPT09ICExICYmIChtLnVybCA9IG1iLnRlc3QoZikgPyBmLnJlcGxhY2UobWIsIFxcXCIkMV89XFxcIiArIGpiKyspIDogZiArIChrYi50ZXN0KGYpID8gXFxcIiZcXFwiIDogXFxcIj9cXFwiKSArIFxcXCJfPVxcXCIgKyBqYisrKSksIG0uaWZNb2RpZmllZCAmJiAobi5sYXN0TW9kaWZpZWRbZl0gJiYgeC5zZXRSZXF1ZXN0SGVhZGVyKFxcXCJJZi1Nb2RpZmllZC1TaW5jZVxcXCIsIG4ubGFzdE1vZGlmaWVkW2ZdKSwgbi5ldGFnW2ZdICYmIHguc2V0UmVxdWVzdEhlYWRlcihcXFwiSWYtTm9uZS1NYXRjaFxcXCIsIG4uZXRhZ1tmXSkpLCAobS5kYXRhICYmIG0uaGFzQ29udGVudCAmJiBtLmNvbnRlbnRUeXBlICE9PSAhMSB8fCBjLmNvbnRlbnRUeXBlKSAmJiB4LnNldFJlcXVlc3RIZWFkZXIoXFxcIkNvbnRlbnQtVHlwZVxcXCIsIG0uY29udGVudFR5cGUpLCB4LnNldFJlcXVlc3RIZWFkZXIoXFxcIkFjY2VwdFxcXCIsIG0uZGF0YVR5cGVzWzBdICYmIG0uYWNjZXB0c1ttLmRhdGFUeXBlc1swXV0gPyBtLmFjY2VwdHNbbS5kYXRhVHlwZXNbMF1dICsgKFxcXCIqXFxcIiAhPT0gbS5kYXRhVHlwZXNbMF0gPyBcXFwiLCBcXFwiICsgdGIgKyBcXFwiOyBxPTAuMDFcXFwiIDogXFxcIlxcXCIpIDogbS5hY2NlcHRzW1xcXCIqXFxcIl0pO2ZvciAobCBpbiBtLmhlYWRlcnMpIHtcXG4gICAgICAgIHguc2V0UmVxdWVzdEhlYWRlcihsLCBtLmhlYWRlcnNbbF0pO1xcbiAgICAgIH1pZiAobS5iZWZvcmVTZW5kICYmIChtLmJlZm9yZVNlbmQuY2FsbChvLCB4LCBtKSA9PT0gITEgfHwgMiA9PT0gdikpIHJldHVybiB4LmFib3J0KCk7dyA9IFxcXCJhYm9ydFxcXCI7Zm9yIChsIGluIHsgc3VjY2VzczogMSwgZXJyb3I6IDEsIGNvbXBsZXRlOiAxIH0pIHtcXG4gICAgICAgIHhbbF0obVtsXSk7XFxuICAgICAgfWlmIChlID0gd2Ioc2IsIG0sIGMsIHgpKSB7XFxuICAgICAgICBpZiAoeC5yZWFkeVN0YXRlID0gMSwgayAmJiBwLnRyaWdnZXIoXFxcImFqYXhTZW5kXFxcIiwgW3gsIG1dKSwgMiA9PT0gdikgcmV0dXJuIHg7bS5hc3luYyAmJiBtLnRpbWVvdXQgPiAwICYmIChpID0gYS5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgeC5hYm9ydChcXFwidGltZW91dFxcXCIpO1xcbiAgICAgICAgfSwgbS50aW1lb3V0KSk7dHJ5IHtcXG4gICAgICAgICAgdiA9IDEsIGUuc2VuZCh0LCB6KTtcXG4gICAgICAgIH0gY2F0Y2ggKHkpIHtcXG4gICAgICAgICAgaWYgKCEoMiA+IHYpKSB0aHJvdyB5O3ooLTEsIHkpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB6KC0xLCBcXFwiTm8gVHJhbnNwb3J0XFxcIik7ZnVuY3Rpb24geihiLCBjLCBkLCBoKSB7XFxuICAgICAgICB2YXIgaixcXG4gICAgICAgICAgICBsLFxcbiAgICAgICAgICAgIHQsXFxuICAgICAgICAgICAgdSxcXG4gICAgICAgICAgICB3LFxcbiAgICAgICAgICAgIHkgPSBjOzIgIT09IHYgJiYgKHYgPSAyLCBpICYmIGEuY2xlYXJUaW1lb3V0KGkpLCBlID0gdm9pZCAwLCBnID0gaCB8fCBcXFwiXFxcIiwgeC5yZWFkeVN0YXRlID0gYiA+IDAgPyA0IDogMCwgaiA9IGIgPj0gMjAwICYmIDMwMCA+IGIgfHwgMzA0ID09PSBiLCBkICYmICh1ID0geWIobSwgeCwgZCkpLCB1ID0gemIobSwgdSwgeCwgaiksIGogPyAobS5pZk1vZGlmaWVkICYmICh3ID0geC5nZXRSZXNwb25zZUhlYWRlcihcXFwiTGFzdC1Nb2RpZmllZFxcXCIpLCB3ICYmIChuLmxhc3RNb2RpZmllZFtmXSA9IHcpLCB3ID0geC5nZXRSZXNwb25zZUhlYWRlcihcXFwiZXRhZ1xcXCIpLCB3ICYmIChuLmV0YWdbZl0gPSB3KSksIDIwNCA9PT0gYiB8fCBcXFwiSEVBRFxcXCIgPT09IG0udHlwZSA/IHkgPSBcXFwibm9jb250ZW50XFxcIiA6IDMwNCA9PT0gYiA/IHkgPSBcXFwibm90bW9kaWZpZWRcXFwiIDogKHkgPSB1LnN0YXRlLCBsID0gdS5kYXRhLCB0ID0gdS5lcnJvciwgaiA9ICF0KSkgOiAodCA9IHksIChiIHx8ICF5KSAmJiAoeSA9IFxcXCJlcnJvclxcXCIsIDAgPiBiICYmIChiID0gMCkpKSwgeC5zdGF0dXMgPSBiLCB4LnN0YXR1c1RleHQgPSAoYyB8fCB5KSArIFxcXCJcXFwiLCBqID8gcS5yZXNvbHZlV2l0aChvLCBbbCwgeSwgeF0pIDogcS5yZWplY3RXaXRoKG8sIFt4LCB5LCB0XSksIHguc3RhdHVzQ29kZShzKSwgcyA9IHZvaWQgMCwgayAmJiBwLnRyaWdnZXIoaiA/IFxcXCJhamF4U3VjY2Vzc1xcXCIgOiBcXFwiYWpheEVycm9yXFxcIiwgW3gsIG0sIGogPyBsIDogdF0pLCByLmZpcmVXaXRoKG8sIFt4LCB5XSksIGsgJiYgKHAudHJpZ2dlcihcXFwiYWpheENvbXBsZXRlXFxcIiwgW3gsIG1dKSwgLS1uLmFjdGl2ZSB8fCBuLmV2ZW50LnRyaWdnZXIoXFxcImFqYXhTdG9wXFxcIikpKTtcXG4gICAgICB9cmV0dXJuIHg7XFxuICAgIH0sIGdldEpTT046IGZ1bmN0aW9uIGdldEpTT04oYSwgYiwgYykge1xcbiAgICAgIHJldHVybiBuLmdldChhLCBiLCBjLCBcXFwianNvblxcXCIpO1xcbiAgICB9LCBnZXRTY3JpcHQ6IGZ1bmN0aW9uIGdldFNjcmlwdChhLCBiKSB7XFxuICAgICAgcmV0dXJuIG4uZ2V0KGEsIHZvaWQgMCwgYiwgXFxcInNjcmlwdFxcXCIpO1xcbiAgICB9IH0pLCBuLmVhY2goW1xcXCJnZXRcXFwiLCBcXFwicG9zdFxcXCJdLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuW2JdID0gZnVuY3Rpb24gKGEsIGMsIGQsIGUpIHtcXG4gICAgICByZXR1cm4gbi5pc0Z1bmN0aW9uKGMpICYmIChlID0gZSB8fCBkLCBkID0gYywgYyA9IHZvaWQgMCksIG4uYWpheChuLmV4dGVuZCh7IHVybDogYSwgdHlwZTogYiwgZGF0YVR5cGU6IGUsIGRhdGE6IGMsIHN1Y2Nlc3M6IGQgfSwgbi5pc1BsYWluT2JqZWN0KGEpICYmIGEpKTtcXG4gICAgfTtcXG4gIH0pLCBuLl9ldmFsVXJsID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgcmV0dXJuIG4uYWpheCh7IHVybDogYSwgdHlwZTogXFxcIkdFVFxcXCIsIGRhdGFUeXBlOiBcXFwic2NyaXB0XFxcIiwgYXN5bmM6ICExLCBnbG9iYWw6ICExLCBcXFwidGhyb3dzXFxcIjogITAgfSk7XFxuICB9LCBuLmZuLmV4dGVuZCh7IHdyYXBBbGw6IGZ1bmN0aW9uIHdyYXBBbGwoYSkge1xcbiAgICAgIHZhciBiO3JldHVybiBuLmlzRnVuY3Rpb24oYSkgPyB0aGlzLmVhY2goZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgIG4odGhpcykud3JhcEFsbChhLmNhbGwodGhpcywgYikpO1xcbiAgICAgIH0pIDogKHRoaXNbMF0gJiYgKGIgPSBuKGEsIHRoaXNbMF0ub3duZXJEb2N1bWVudCkuZXEoMCkuY2xvbmUoITApLCB0aGlzWzBdLnBhcmVudE5vZGUgJiYgYi5pbnNlcnRCZWZvcmUodGhpc1swXSksIGIubWFwKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBhID0gdGhpczt3aGlsZSAoYS5maXJzdEVsZW1lbnRDaGlsZCkge1xcbiAgICAgICAgICBhID0gYS5maXJzdEVsZW1lbnRDaGlsZDtcXG4gICAgICAgIH1yZXR1cm4gYTtcXG4gICAgICB9KS5hcHBlbmQodGhpcykpLCB0aGlzKTtcXG4gICAgfSwgd3JhcElubmVyOiBmdW5jdGlvbiB3cmFwSW5uZXIoYSkge1xcbiAgICAgIHJldHVybiBuLmlzRnVuY3Rpb24oYSkgPyB0aGlzLmVhY2goZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgIG4odGhpcykud3JhcElubmVyKGEuY2FsbCh0aGlzLCBiKSk7XFxuICAgICAgfSkgOiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGIgPSBuKHRoaXMpLFxcbiAgICAgICAgICAgIGMgPSBiLmNvbnRlbnRzKCk7Yy5sZW5ndGggPyBjLndyYXBBbGwoYSkgOiBiLmFwcGVuZChhKTtcXG4gICAgICB9KTtcXG4gICAgfSwgd3JhcDogZnVuY3Rpb24gd3JhcChhKSB7XFxuICAgICAgdmFyIGIgPSBuLmlzRnVuY3Rpb24oYSk7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoYykge1xcbiAgICAgICAgbih0aGlzKS53cmFwQWxsKGIgPyBhLmNhbGwodGhpcywgYykgOiBhKTtcXG4gICAgICB9KTtcXG4gICAgfSwgdW53cmFwOiBmdW5jdGlvbiB1bndyYXAoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBuLm5vZGVOYW1lKHRoaXMsIFxcXCJib2R5XFxcIikgfHwgbih0aGlzKS5yZXBsYWNlV2l0aCh0aGlzLmNoaWxkTm9kZXMpO1xcbiAgICAgIH0pLmVuZCgpO1xcbiAgICB9IH0pLCBuLmV4cHIuZmlsdGVycy5oaWRkZW4gPSBmdW5jdGlvbiAoYSkge1xcbiAgICByZXR1cm4gIW4uZXhwci5maWx0ZXJzLnZpc2libGUoYSk7XFxuICB9LCBuLmV4cHIuZmlsdGVycy52aXNpYmxlID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgcmV0dXJuIGEub2Zmc2V0V2lkdGggPiAwIHx8IGEub2Zmc2V0SGVpZ2h0ID4gMCB8fCBhLmdldENsaWVudFJlY3RzKCkubGVuZ3RoID4gMDtcXG4gIH07dmFyIEFiID0gLyUyMC9nLFxcbiAgICAgIEJiID0gL1xcXFxbXFxcXF0kLyxcXG4gICAgICBDYiA9IC9cXFxccj9cXFxcbi9nLFxcbiAgICAgIERiID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxcbiAgICAgIEViID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO2Z1bmN0aW9uIEZiKGEsIGIsIGMsIGQpIHtcXG4gICAgdmFyIGU7aWYgKG4uaXNBcnJheShiKSkgbi5lYWNoKGIsIGZ1bmN0aW9uIChiLCBlKSB7XFxuICAgICAgYyB8fCBCYi50ZXN0KGEpID8gZChhLCBlKSA6IEZiKGEgKyBcXFwiW1xcXCIgKyAoXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBlID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihlKSkgJiYgbnVsbCAhPSBlID8gYiA6IFxcXCJcXFwiKSArIFxcXCJdXFxcIiwgZSwgYywgZCk7XFxuICAgIH0pO2Vsc2UgaWYgKGMgfHwgXFxcIm9iamVjdFxcXCIgIT09IG4udHlwZShiKSkgZChhLCBiKTtlbHNlIGZvciAoZSBpbiBiKSB7XFxuICAgICAgRmIoYSArIFxcXCJbXFxcIiArIGUgKyBcXFwiXVxcXCIsIGJbZV0sIGMsIGQpO1xcbiAgICB9XFxuICB9bi5wYXJhbSA9IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIHZhciBjLFxcbiAgICAgICAgZCA9IFtdLFxcbiAgICAgICAgZSA9IGZ1bmN0aW9uIGUoYSwgYikge1xcbiAgICAgIGIgPSBuLmlzRnVuY3Rpb24oYikgPyBiKCkgOiBudWxsID09IGIgPyBcXFwiXFxcIiA6IGIsIGRbZC5sZW5ndGhdID0gZW5jb2RlVVJJQ29tcG9uZW50KGEpICsgXFxcIj1cXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGIpO1xcbiAgICB9O2lmICh2b2lkIDAgPT09IGIgJiYgKGIgPSBuLmFqYXhTZXR0aW5ncyAmJiBuLmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbCksIG4uaXNBcnJheShhKSB8fCBhLmpxdWVyeSAmJiAhbi5pc1BsYWluT2JqZWN0KGEpKSBuLmVhY2goYSwgZnVuY3Rpb24gKCkge1xcbiAgICAgIGUodGhpcy5uYW1lLCB0aGlzLnZhbHVlKTtcXG4gICAgfSk7ZWxzZSBmb3IgKGMgaW4gYSkge1xcbiAgICAgIEZiKGMsIGFbY10sIGIsIGUpO1xcbiAgICB9cmV0dXJuIGQuam9pbihcXFwiJlxcXCIpLnJlcGxhY2UoQWIsIFxcXCIrXFxcIik7XFxuICB9LCBuLmZuLmV4dGVuZCh7IHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xcbiAgICAgIHJldHVybiBuLnBhcmFtKHRoaXMuc2VyaWFsaXplQXJyYXkoKSk7XFxuICAgIH0sIHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbiBzZXJpYWxpemVBcnJheSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGEgPSBuLnByb3AodGhpcywgXFxcImVsZW1lbnRzXFxcIik7cmV0dXJuIGEgPyBuLm1ha2VBcnJheShhKSA6IHRoaXM7XFxuICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBhID0gdGhpcy50eXBlO3JldHVybiB0aGlzLm5hbWUgJiYgIW4odGhpcykuaXMoXFxcIjpkaXNhYmxlZFxcXCIpICYmIEViLnRlc3QodGhpcy5ub2RlTmFtZSkgJiYgIURiLnRlc3QoYSkgJiYgKHRoaXMuY2hlY2tlZCB8fCAhWC50ZXN0KGEpKTtcXG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIHZhciBjID0gbih0aGlzKS52YWwoKTtyZXR1cm4gbnVsbCA9PSBjID8gbnVsbCA6IG4uaXNBcnJheShjKSA/IG4ubWFwKGMsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgIHJldHVybiB7IG5hbWU6IGIubmFtZSwgdmFsdWU6IGEucmVwbGFjZShDYiwgXFxcIlxcXFxyXFxcXG5cXFwiKSB9O1xcbiAgICAgICAgfSkgOiB7IG5hbWU6IGIubmFtZSwgdmFsdWU6IGMucmVwbGFjZShDYiwgXFxcIlxcXFxyXFxcXG5cXFwiKSB9O1xcbiAgICAgIH0pLmdldCgpO1xcbiAgICB9IH0pLCBuLmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHRyeSB7XFxuICAgICAgcmV0dXJuIG5ldyBhLlhNTEh0dHBSZXF1ZXN0KCk7XFxuICAgIH0gY2F0Y2ggKGIpIHt9XFxuICB9O3ZhciBHYiA9IHsgMDogMjAwLCAxMjIzOiAyMDQgfSxcXG4gICAgICBIYiA9IG4uYWpheFNldHRpbmdzLnhocigpO2wuY29ycyA9ICEhSGIgJiYgXFxcIndpdGhDcmVkZW50aWFsc1xcXCIgaW4gSGIsIGwuYWpheCA9IEhiID0gISFIYiwgbi5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uIChiKSB7XFxuICAgIHZhciBfYywgZDtyZXR1cm4gbC5jb3JzIHx8IEhiICYmICFiLmNyb3NzRG9tYWluID8geyBzZW5kOiBmdW5jdGlvbiBzZW5kKGUsIGYpIHtcXG4gICAgICAgIHZhciBnLFxcbiAgICAgICAgICAgIGggPSBiLnhocigpO2lmIChoLm9wZW4oYi50eXBlLCBiLnVybCwgYi5hc3luYywgYi51c2VybmFtZSwgYi5wYXNzd29yZCksIGIueGhyRmllbGRzKSBmb3IgKGcgaW4gYi54aHJGaWVsZHMpIHtcXG4gICAgICAgICAgaFtnXSA9IGIueGhyRmllbGRzW2ddO1xcbiAgICAgICAgfWIubWltZVR5cGUgJiYgaC5vdmVycmlkZU1pbWVUeXBlICYmIGgub3ZlcnJpZGVNaW1lVHlwZShiLm1pbWVUeXBlKSwgYi5jcm9zc0RvbWFpbiB8fCBlW1xcXCJYLVJlcXVlc3RlZC1XaXRoXFxcIl0gfHwgKGVbXFxcIlgtUmVxdWVzdGVkLVdpdGhcXFwiXSA9IFxcXCJYTUxIdHRwUmVxdWVzdFxcXCIpO2ZvciAoZyBpbiBlKSB7XFxuICAgICAgICAgIGguc2V0UmVxdWVzdEhlYWRlcihnLCBlW2ddKTtcXG4gICAgICAgIH1fYyA9IGZ1bmN0aW9uIGMoYSkge1xcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIF9jICYmIChfYyA9IGQgPSBoLm9ubG9hZCA9IGgub25lcnJvciA9IGgub25hYm9ydCA9IGgub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbCwgXFxcImFib3J0XFxcIiA9PT0gYSA/IGguYWJvcnQoKSA6IFxcXCJlcnJvclxcXCIgPT09IGEgPyBcXFwibnVtYmVyXFxcIiAhPSB0eXBlb2YgaC5zdGF0dXMgPyBmKDAsIFxcXCJlcnJvclxcXCIpIDogZihoLnN0YXR1cywgaC5zdGF0dXNUZXh0KSA6IGYoR2JbaC5zdGF0dXNdIHx8IGguc3RhdHVzLCBoLnN0YXR1c1RleHQsIFxcXCJ0ZXh0XFxcIiAhPT0gKGgucmVzcG9uc2VUeXBlIHx8IFxcXCJ0ZXh0XFxcIikgfHwgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGgucmVzcG9uc2VUZXh0ID8geyBiaW5hcnk6IGgucmVzcG9uc2UgfSA6IHsgdGV4dDogaC5yZXNwb25zZVRleHQgfSwgaC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSwgaC5vbmxvYWQgPSBfYygpLCBkID0gaC5vbmVycm9yID0gX2MoXFxcImVycm9yXFxcIiksIHZvaWQgMCAhPT0gaC5vbmFib3J0ID8gaC5vbmFib3J0ID0gZCA6IGgub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICA0ID09PSBoLnJlYWR5U3RhdGUgJiYgYS5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBfYyAmJiBkKCk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSwgX2MgPSBfYyhcXFwiYWJvcnRcXFwiKTt0cnkge1xcbiAgICAgICAgICBoLnNlbmQoYi5oYXNDb250ZW50ICYmIGIuZGF0YSB8fCBudWxsKTtcXG4gICAgICAgIH0gY2F0Y2ggKGkpIHtcXG4gICAgICAgICAgaWYgKF9jKSB0aHJvdyBpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIGFib3J0OiBmdW5jdGlvbiBhYm9ydCgpIHtcXG4gICAgICAgIF9jICYmIF9jKCk7XFxuICAgICAgfSB9IDogdm9pZCAwO1xcbiAgfSksIG4uYWpheFNldHVwKHsgYWNjZXB0czogeyBzY3JpcHQ6IFxcXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFxcXCIgfSwgY29udGVudHM6IHsgc2NyaXB0OiAvXFxcXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxcXGIvIH0sIGNvbnZlcnRlcnM6IHsgXFxcInRleHQgc2NyaXB0XFxcIjogZnVuY3Rpb24gdGV4dFNjcmlwdChhKSB7XFxuICAgICAgICByZXR1cm4gbi5nbG9iYWxFdmFsKGEpLCBhO1xcbiAgICAgIH0gfSB9KSwgbi5hamF4UHJlZmlsdGVyKFxcXCJzY3JpcHRcXFwiLCBmdW5jdGlvbiAoYSkge1xcbiAgICB2b2lkIDAgPT09IGEuY2FjaGUgJiYgKGEuY2FjaGUgPSAhMSksIGEuY3Jvc3NEb21haW4gJiYgKGEudHlwZSA9IFxcXCJHRVRcXFwiKTtcXG4gIH0pLCBuLmFqYXhUcmFuc3BvcnQoXFxcInNjcmlwdFxcXCIsIGZ1bmN0aW9uIChhKSB7XFxuICAgIGlmIChhLmNyb3NzRG9tYWluKSB7XFxuICAgICAgdmFyIGIsIF9jMjtyZXR1cm4geyBzZW5kOiBmdW5jdGlvbiBzZW5kKGUsIGYpIHtcXG4gICAgICAgICAgYiA9IG4oXFxcIjxzY3JpcHQ+XFxcIikucHJvcCh7IGNoYXJzZXQ6IGEuc2NyaXB0Q2hhcnNldCwgc3JjOiBhLnVybCB9KS5vbihcXFwibG9hZCBlcnJvclxcXCIsIF9jMiA9IGZ1bmN0aW9uIGMoYSkge1xcbiAgICAgICAgICAgIGIucmVtb3ZlKCksIF9jMiA9IG51bGwsIGEgJiYgZihcXFwiZXJyb3JcXFwiID09PSBhLnR5cGUgPyA0MDQgOiAyMDAsIGEudHlwZSk7XFxuICAgICAgICAgIH0pLCBkLmhlYWQuYXBwZW5kQ2hpbGQoYlswXSk7XFxuICAgICAgICB9LCBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XFxuICAgICAgICAgIF9jMiAmJiBfYzIoKTtcXG4gICAgICAgIH0gfTtcXG4gICAgfVxcbiAgfSk7dmFyIEliID0gW10sXFxuICAgICAgSmIgPSAvKD0pXFxcXD8oPz0mfCQpfFxcXFw/XFxcXD8vO24uYWpheFNldHVwKHsganNvbnA6IFxcXCJjYWxsYmFja1xcXCIsIGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uIGpzb25wQ2FsbGJhY2soKSB7XFxuICAgICAgdmFyIGEgPSBJYi5wb3AoKSB8fCBuLmV4cGFuZG8gKyBcXFwiX1xcXCIgKyBqYisrO3JldHVybiB0aGlzW2FdID0gITAsIGE7XFxuICAgIH0gfSksIG4uYWpheFByZWZpbHRlcihcXFwianNvbiBqc29ucFxcXCIsIGZ1bmN0aW9uIChiLCBjLCBkKSB7XFxuICAgIHZhciBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcsXFxuICAgICAgICBoID0gYi5qc29ucCAhPT0gITEgJiYgKEpiLnRlc3QoYi51cmwpID8gXFxcInVybFxcXCIgOiBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYi5kYXRhICYmIDAgPT09IChiLmNvbnRlbnRUeXBlIHx8IFxcXCJcXFwiKS5pbmRleE9mKFxcXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcXFwiKSAmJiBKYi50ZXN0KGIuZGF0YSkgJiYgXFxcImRhdGFcXFwiKTtyZXR1cm4gaCB8fCBcXFwianNvbnBcXFwiID09PSBiLmRhdGFUeXBlc1swXSA/IChlID0gYi5qc29ucENhbGxiYWNrID0gbi5pc0Z1bmN0aW9uKGIuanNvbnBDYWxsYmFjaykgPyBiLmpzb25wQ2FsbGJhY2soKSA6IGIuanNvbnBDYWxsYmFjaywgaCA/IGJbaF0gPSBiW2hdLnJlcGxhY2UoSmIsIFxcXCIkMVxcXCIgKyBlKSA6IGIuanNvbnAgIT09ICExICYmIChiLnVybCArPSAoa2IudGVzdChiLnVybCkgPyBcXFwiJlxcXCIgOiBcXFwiP1xcXCIpICsgYi5qc29ucCArIFxcXCI9XFxcIiArIGUpLCBiLmNvbnZlcnRlcnNbXFxcInNjcmlwdCBqc29uXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuIGcgfHwgbi5lcnJvcihlICsgXFxcIiB3YXMgbm90IGNhbGxlZFxcXCIpLCBnWzBdO1xcbiAgICB9LCBiLmRhdGFUeXBlc1swXSA9IFxcXCJqc29uXFxcIiwgZiA9IGFbZV0sIGFbZV0gPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgZyA9IGFyZ3VtZW50cztcXG4gICAgfSwgZC5hbHdheXMoZnVuY3Rpb24gKCkge1xcbiAgICAgIHZvaWQgMCA9PT0gZiA/IG4oYSkucmVtb3ZlUHJvcChlKSA6IGFbZV0gPSBmLCBiW2VdICYmIChiLmpzb25wQ2FsbGJhY2sgPSBjLmpzb25wQ2FsbGJhY2ssIEliLnB1c2goZSkpLCBnICYmIG4uaXNGdW5jdGlvbihmKSAmJiBmKGdbMF0pLCBnID0gZiA9IHZvaWQgMDtcXG4gICAgfSksIFxcXCJzY3JpcHRcXFwiKSA6IHZvaWQgMDtcXG4gIH0pLCBsLmNyZWF0ZUhUTUxEb2N1bWVudCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGEgPSBkLmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcXFwiXFxcIikuYm9keTtyZXR1cm4gYS5pbm5lckhUTUwgPSBcXFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cXFwiLCAyID09PSBhLmNoaWxkTm9kZXMubGVuZ3RoO1xcbiAgfSgpLCBuLnBhcnNlSFRNTCA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgIGlmICghYSB8fCBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYSkgcmV0dXJuIG51bGw7XFxcImJvb2xlYW5cXFwiID09IHR5cGVvZiBiICYmIChjID0gYiwgYiA9ICExKSwgYiA9IGIgfHwgKGwuY3JlYXRlSFRNTERvY3VtZW50ID8gZC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXFxcIlxcXCIpIDogZCk7dmFyIGUgPSB4LmV4ZWMoYSksXFxuICAgICAgICBmID0gIWMgJiYgW107cmV0dXJuIGUgPyBbYi5jcmVhdGVFbGVtZW50KGVbMV0pXSA6IChlID0gY2EoW2FdLCBiLCBmKSwgZiAmJiBmLmxlbmd0aCAmJiBuKGYpLnJlbW92ZSgpLCBuLm1lcmdlKFtdLCBlLmNoaWxkTm9kZXMpKTtcXG4gIH07dmFyIEtiID0gbi5mbi5sb2FkO24uZm4ubG9hZCA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgIGlmIChcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYSAmJiBLYikgcmV0dXJuIEtiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7dmFyIGQsXFxuICAgICAgICBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcgPSB0aGlzLFxcbiAgICAgICAgaCA9IGEuaW5kZXhPZihcXFwiIFxcXCIpO3JldHVybiBoID4gLTEgJiYgKGQgPSBuLnRyaW0oYS5zbGljZShoKSksIGEgPSBhLnNsaWNlKDAsIGgpKSwgbi5pc0Z1bmN0aW9uKGIpID8gKGMgPSBiLCBiID0gdm9pZCAwKSA6IGIgJiYgXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBiID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihiKSkgJiYgKGUgPSBcXFwiUE9TVFxcXCIpLCBnLmxlbmd0aCA+IDAgJiYgbi5hamF4KHsgdXJsOiBhLCB0eXBlOiBlIHx8IFxcXCJHRVRcXFwiLCBkYXRhVHlwZTogXFxcImh0bWxcXFwiLCBkYXRhOiBiIH0pLmRvbmUoZnVuY3Rpb24gKGEpIHtcXG4gICAgICBmID0gYXJndW1lbnRzLCBnLmh0bWwoZCA/IG4oXFxcIjxkaXY+XFxcIikuYXBwZW5kKG4ucGFyc2VIVE1MKGEpKS5maW5kKGQpIDogYSk7XFxuICAgIH0pLmFsd2F5cyhjICYmIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgZy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGMuYXBwbHkoZywgZiB8fCBbYS5yZXNwb25zZVRleHQsIGIsIGFdKTtcXG4gICAgICB9KTtcXG4gICAgfSksIHRoaXM7XFxuICB9LCBuLmVhY2goW1xcXCJhamF4U3RhcnRcXFwiLCBcXFwiYWpheFN0b3BcXFwiLCBcXFwiYWpheENvbXBsZXRlXFxcIiwgXFxcImFqYXhFcnJvclxcXCIsIFxcXCJhamF4U3VjY2Vzc1xcXCIsIFxcXCJhamF4U2VuZFxcXCJdLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmZuW2JdID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5vbihiLCBhKTtcXG4gICAgfTtcXG4gIH0pLCBuLmV4cHIuZmlsdGVycy5hbmltYXRlZCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgIHJldHVybiBuLmdyZXAobi50aW1lcnMsIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgcmV0dXJuIGEgPT09IGIuZWxlbTtcXG4gICAgfSkubGVuZ3RoO1xcbiAgfTtmdW5jdGlvbiBMYihhKSB7XFxuICAgIHJldHVybiBuLmlzV2luZG93KGEpID8gYSA6IDkgPT09IGEubm9kZVR5cGUgJiYgYS5kZWZhdWx0VmlldztcXG4gIH1uLm9mZnNldCA9IHsgc2V0T2Zmc2V0OiBmdW5jdGlvbiBzZXRPZmZzZXQoYSwgYiwgYykge1xcbiAgICAgIHZhciBkLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrID0gbi5jc3MoYSwgXFxcInBvc2l0aW9uXFxcIiksXFxuICAgICAgICAgIGwgPSBuKGEpLFxcbiAgICAgICAgICBtID0ge307XFxcInN0YXRpY1xcXCIgPT09IGsgJiYgKGEuc3R5bGUucG9zaXRpb24gPSBcXFwicmVsYXRpdmVcXFwiKSwgaCA9IGwub2Zmc2V0KCksIGYgPSBuLmNzcyhhLCBcXFwidG9wXFxcIiksIGkgPSBuLmNzcyhhLCBcXFwibGVmdFxcXCIpLCBqID0gKFxcXCJhYnNvbHV0ZVxcXCIgPT09IGsgfHwgXFxcImZpeGVkXFxcIiA9PT0gaykgJiYgKGYgKyBpKS5pbmRleE9mKFxcXCJhdXRvXFxcIikgPiAtMSwgaiA/IChkID0gbC5wb3NpdGlvbigpLCBnID0gZC50b3AsIGUgPSBkLmxlZnQpIDogKGcgPSBwYXJzZUZsb2F0KGYpIHx8IDAsIGUgPSBwYXJzZUZsb2F0KGkpIHx8IDApLCBuLmlzRnVuY3Rpb24oYikgJiYgKGIgPSBiLmNhbGwoYSwgYywgbi5leHRlbmQoe30sIGgpKSksIG51bGwgIT0gYi50b3AgJiYgKG0udG9wID0gYi50b3AgLSBoLnRvcCArIGcpLCBudWxsICE9IGIubGVmdCAmJiAobS5sZWZ0ID0gYi5sZWZ0IC0gaC5sZWZ0ICsgZSksIFxcXCJ1c2luZ1xcXCIgaW4gYiA/IGIudXNpbmcuY2FsbChhLCBtKSA6IGwuY3NzKG0pO1xcbiAgICB9IH0sIG4uZm4uZXh0ZW5kKHsgb2Zmc2V0OiBmdW5jdGlvbiBvZmZzZXQoYSkge1xcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdm9pZCAwID09PSBhID8gdGhpcyA6IHRoaXMuZWFjaChmdW5jdGlvbiAoYikge1xcbiAgICAgICAgbi5vZmZzZXQuc2V0T2Zmc2V0KHRoaXMsIGEsIGIpO1xcbiAgICAgIH0pO3ZhciBiLFxcbiAgICAgICAgICBjLFxcbiAgICAgICAgICBkID0gdGhpc1swXSxcXG4gICAgICAgICAgZSA9IHsgdG9wOiAwLCBsZWZ0OiAwIH0sXFxuICAgICAgICAgIGYgPSBkICYmIGQub3duZXJEb2N1bWVudDtpZiAoZikgcmV0dXJuIGIgPSBmLmRvY3VtZW50RWxlbWVudCwgbi5jb250YWlucyhiLCBkKSA/IChlID0gZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYyA9IExiKGYpLCB7IHRvcDogZS50b3AgKyBjLnBhZ2VZT2Zmc2V0IC0gYi5jbGllbnRUb3AsIGxlZnQ6IGUubGVmdCArIGMucGFnZVhPZmZzZXQgLSBiLmNsaWVudExlZnQgfSkgOiBlO1xcbiAgICB9LCBwb3NpdGlvbjogZnVuY3Rpb24gcG9zaXRpb24oKSB7XFxuICAgICAgaWYgKHRoaXNbMF0pIHtcXG4gICAgICAgIHZhciBhLFxcbiAgICAgICAgICAgIGIsXFxuICAgICAgICAgICAgYyA9IHRoaXNbMF0sXFxuICAgICAgICAgICAgZCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07cmV0dXJuIFxcXCJmaXhlZFxcXCIgPT09IG4uY3NzKGMsIFxcXCJwb3NpdGlvblxcXCIpID8gYiA9IGMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiAoYSA9IHRoaXMub2Zmc2V0UGFyZW50KCksIGIgPSB0aGlzLm9mZnNldCgpLCBuLm5vZGVOYW1lKGFbMF0sIFxcXCJodG1sXFxcIikgfHwgKGQgPSBhLm9mZnNldCgpKSwgZC50b3AgKz0gbi5jc3MoYVswXSwgXFxcImJvcmRlclRvcFdpZHRoXFxcIiwgITApLCBkLmxlZnQgKz0gbi5jc3MoYVswXSwgXFxcImJvcmRlckxlZnRXaWR0aFxcXCIsICEwKSksIHsgdG9wOiBiLnRvcCAtIGQudG9wIC0gbi5jc3MoYywgXFxcIm1hcmdpblRvcFxcXCIsICEwKSwgbGVmdDogYi5sZWZ0IC0gZC5sZWZ0IC0gbi5jc3MoYywgXFxcIm1hcmdpbkxlZnRcXFwiLCAhMCkgfTtcXG4gICAgICB9XFxuICAgIH0sIG9mZnNldFBhcmVudDogZnVuY3Rpb24gb2Zmc2V0UGFyZW50KCkge1xcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYSA9IHRoaXMub2Zmc2V0UGFyZW50O3doaWxlIChhICYmIFxcXCJzdGF0aWNcXFwiID09PSBuLmNzcyhhLCBcXFwicG9zaXRpb25cXFwiKSkge1xcbiAgICAgICAgICBhID0gYS5vZmZzZXRQYXJlbnQ7XFxuICAgICAgICB9cmV0dXJuIGEgfHwgRWE7XFxuICAgICAgfSk7XFxuICAgIH0gfSksIG4uZWFjaCh7IHNjcm9sbExlZnQ6IFxcXCJwYWdlWE9mZnNldFxcXCIsIHNjcm9sbFRvcDogXFxcInBhZ2VZT2Zmc2V0XFxcIiB9LCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICB2YXIgYyA9IFxcXCJwYWdlWU9mZnNldFxcXCIgPT09IGI7bi5mblthXSA9IGZ1bmN0aW9uIChkKSB7XFxuICAgICAgcmV0dXJuIEsodGhpcywgZnVuY3Rpb24gKGEsIGQsIGUpIHtcXG4gICAgICAgIHZhciBmID0gTGIoYSk7cmV0dXJuIHZvaWQgMCA9PT0gZSA/IGYgPyBmW2JdIDogYVtkXSA6IHZvaWQgKGYgPyBmLnNjcm9sbFRvKGMgPyBmLnBhZ2VYT2Zmc2V0IDogZSwgYyA/IGUgOiBmLnBhZ2VZT2Zmc2V0KSA6IGFbZF0gPSBlKTtcXG4gICAgICB9LCBhLCBkLCBhcmd1bWVudHMubGVuZ3RoKTtcXG4gICAgfTtcXG4gIH0pLCBuLmVhY2goW1xcXCJ0b3BcXFwiLCBcXFwibGVmdFxcXCJdLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmNzc0hvb2tzW2JdID0gR2EobC5waXhlbFBvc2l0aW9uLCBmdW5jdGlvbiAoYSwgYykge1xcbiAgICAgIHJldHVybiBjID8gKGMgPSBGYShhLCBiKSwgQmEudGVzdChjKSA/IG4oYSkucG9zaXRpb24oKVtiXSArIFxcXCJweFxcXCIgOiBjKSA6IHZvaWQgMDtcXG4gICAgfSk7XFxuICB9KSwgbi5lYWNoKHsgSGVpZ2h0OiBcXFwiaGVpZ2h0XFxcIiwgV2lkdGg6IFxcXCJ3aWR0aFxcXCIgfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5lYWNoKHsgcGFkZGluZzogXFxcImlubmVyXFxcIiArIGEsIGNvbnRlbnQ6IGIsIFxcXCJcXFwiOiBcXFwib3V0ZXJcXFwiICsgYSB9LCBmdW5jdGlvbiAoYywgZCkge1xcbiAgICAgIG4uZm5bZF0gPSBmdW5jdGlvbiAoZCwgZSkge1xcbiAgICAgICAgdmFyIGYgPSBhcmd1bWVudHMubGVuZ3RoICYmIChjIHx8IFxcXCJib29sZWFuXFxcIiAhPSB0eXBlb2YgZCksXFxuICAgICAgICAgICAgZyA9IGMgfHwgKGQgPT09ICEwIHx8IGUgPT09ICEwID8gXFxcIm1hcmdpblxcXCIgOiBcXFwiYm9yZGVyXFxcIik7cmV0dXJuIEsodGhpcywgZnVuY3Rpb24gKGIsIGMsIGQpIHtcXG4gICAgICAgICAgdmFyIGU7cmV0dXJuIG4uaXNXaW5kb3coYikgPyBiLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcXFwiY2xpZW50XFxcIiArIGFdIDogOSA9PT0gYi5ub2RlVHlwZSA/IChlID0gYi5kb2N1bWVudEVsZW1lbnQsIE1hdGgubWF4KGIuYm9keVtcXFwic2Nyb2xsXFxcIiArIGFdLCBlW1xcXCJzY3JvbGxcXFwiICsgYV0sIGIuYm9keVtcXFwib2Zmc2V0XFxcIiArIGFdLCBlW1xcXCJvZmZzZXRcXFwiICsgYV0sIGVbXFxcImNsaWVudFxcXCIgKyBhXSkpIDogdm9pZCAwID09PSBkID8gbi5jc3MoYiwgYywgZykgOiBuLnN0eWxlKGIsIGMsIGQsIGcpO1xcbiAgICAgICAgfSwgYiwgZiA/IGQgOiB2b2lkIDAsIGYsIG51bGwpO1xcbiAgICAgIH07XFxuICAgIH0pO1xcbiAgfSksIG4uZm4uZXh0ZW5kKHsgYmluZDogZnVuY3Rpb24gYmluZChhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIHRoaXMub24oYSwgbnVsbCwgYiwgYyk7XFxuICAgIH0sIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKGEsIGIpIHtcXG4gICAgICByZXR1cm4gdGhpcy5vZmYoYSwgbnVsbCwgYik7XFxuICAgIH0sIGRlbGVnYXRlOiBmdW5jdGlvbiBkZWxlZ2F0ZShhLCBiLCBjLCBkKSB7XFxuICAgICAgcmV0dXJuIHRoaXMub24oYiwgYSwgYywgZCk7XFxuICAgIH0sIHVuZGVsZWdhdGU6IGZ1bmN0aW9uIHVuZGVsZWdhdGUoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiAxID09PSBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5vZmYoYSwgXFxcIioqXFxcIikgOiB0aGlzLm9mZihiLCBhIHx8IFxcXCIqKlxcXCIsIGMpO1xcbiAgICB9LCBzaXplOiBmdW5jdGlvbiBzaXplKCkge1xcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcXG4gICAgfSB9KSwgbi5mbi5hbmRTZWxmID0gbi5mbi5hZGRCYWNrLCBcXFwiZnVuY3Rpb25cXFwiID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCAmJiBkZWZpbmUoXFxcImpxdWVyeVxcXCIsIFtdLCBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiBuO1xcbiAgfSk7dmFyIE1iID0gYS5qUXVlcnksXFxuICAgICAgTmIgPSBhLiQ7cmV0dXJuIG4ubm9Db25mbGljdCA9IGZ1bmN0aW9uIChiKSB7XFxuICAgIHJldHVybiBhLiQgPT09IG4gJiYgKGEuJCA9IE5iKSwgYiAmJiBhLmpRdWVyeSA9PT0gbiAmJiAoYS5qUXVlcnkgPSBNYiksIG47XFxuICB9LCBiIHx8IChhLmpRdWVyeSA9IGEuJCA9IG4pLCBuO1xcbn0pO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2JhYmVsLWxvYWRlcj97XCJwcmVzZXRzXCI6W1wicmVhY3RcIixcImVzMjAxNVwiXX0hLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZShcIiEhQzpcXFxcVXNlcnNcXFxcUGFyYWdvblxcXFxEZXNrdG9wXFxcXHByb2plY3RzXFxcXHJlYWN0XFxcXHJlYWN0d2VhdGhlclxcXFxub2RlX21vZHVsZXNcXFxcc2NyaXB0LWxvYWRlclxcXFxhZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhQzpcXFxcVXNlcnNcXFxcUGFyYWdvblxcXFxEZXNrdG9wXFxcXHByb2plY3RzXFxcXHJlYWN0XFxcXHJlYWN0d2VhdGhlclxcXFxub2RlX21vZHVsZXNcXFxccmF3LWxvYWRlclxcXFxpbmRleC5qcyFDOlxcXFxVc2Vyc1xcXFxQYXJhZ29uXFxcXERlc2t0b3BcXFxccHJvamVjdHNcXFxccmVhY3RcXFxccmVhY3R3ZWF0aGVyXFxcXG5vZGVfbW9kdWxlc1xcXFxiYWJlbC1sb2FkZXJcXFxcaW5kZXguanM/e1xcXCJwcmVzZXRzXFxcIjpbXFxcInJlYWN0XFxcIixcXFwiZXMyMDE1XFxcIl19IUM6XFxcXFVzZXJzXFxcXFBhcmFnb25cXFxcRGVza3RvcFxcXFxwcm9qZWN0c1xcXFxyZWFjdFxcXFxyZWFjdHdlYXRoZXJcXFxcbm9kZV9tb2R1bGVzXFxcXGZvdW5kYXRpb24tc2l0ZXNcXFxcZGlzdFxcXFxmb3VuZGF0aW9uLm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2ZvdW5kYXRpb24ubWluLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJcXFwidXNlIHN0cmljdFxcXCI7dmFyIF90eXBlb2Y9dHlwZW9mIFN5bWJvbD09PVxcXCJmdW5jdGlvblxcXCImJnR5cGVvZiBTeW1ib2wuaXRlcmF0b3I9PT1cXFwic3ltYm9sXFxcIj9mdW5jdGlvbihvYmope3JldHVybiB0eXBlb2Ygb2JqO306ZnVuY3Rpb24ob2JqKXtyZXR1cm4gb2JqJiZ0eXBlb2YgU3ltYm9sPT09XFxcImZ1bmN0aW9uXFxcIiYmb2JqLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZvYmohPT1TeW1ib2wucHJvdG90eXBlP1xcXCJzeW1ib2xcXFwiOnR5cGVvZiBvYmo7fTtmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9IWZ1bmN0aW9uKHQpe1xcXCJ1c2Ugc3RyaWN0XFxcIjtmdW5jdGlvbiBlKHQpe2lmKHZvaWQgMD09PUZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lKXt2YXIgZT0vZnVuY3Rpb25cXFxccyhbXihdezEsfSlcXFxcKC8saT1lLmV4ZWModC50b1N0cmluZygpKTtyZXR1cm4gaSYmaS5sZW5ndGg+MT9pWzFdLnRyaW0oKTpcXFwiXFxcIjt9cmV0dXJuIHZvaWQgMD09PXQucHJvdG90eXBlP3QuY29uc3RydWN0b3IubmFtZTp0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lO31mdW5jdGlvbiBpKHQpe3JldHVybiAvdHJ1ZS8udGVzdCh0KT8hMDovZmFsc2UvLnRlc3QodCk/ITE6aXNOYU4oMSp0KT90OnBhcnNlRmxvYXQodCk7fWZ1bmN0aW9uIG4odCl7cmV0dXJuIHQucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZyxcXFwiJDEtJDJcXFwiKS50b0xvd2VyQ2FzZSgpO312YXIgcz1cXFwiNi4yLjBcXFwiLG89e3ZlcnNpb246cyxfcGx1Z2luczp7fSxfdXVpZHM6W10scnRsOmZ1bmN0aW9uIHJ0bCgpe3JldHVyblxcXCJydGxcXFwiPT09dChcXFwiaHRtbFxcXCIpLmF0dHIoXFxcImRpclxcXCIpO30scGx1Z2luOmZ1bmN0aW9uIHBsdWdpbih0LGkpe3ZhciBzPWl8fGUodCksbz1uKHMpO3RoaXMuX3BsdWdpbnNbb109dGhpc1tzXT10O30scmVnaXN0ZXJQbHVnaW46ZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW4odCxpKXt2YXIgcz1pP24oaSk6ZSh0LmNvbnN0cnVjdG9yKS50b0xvd2VyQ2FzZSgpO3QudXVpZD10aGlzLkdldFlvRGlnaXRzKDYscyksdC4kZWxlbWVudC5hdHRyKFxcXCJkYXRhLVxcXCIrcyl8fHQuJGVsZW1lbnQuYXR0cihcXFwiZGF0YS1cXFwiK3MsdC51dWlkKSx0LiRlbGVtZW50LmRhdGEoXFxcInpmUGx1Z2luXFxcIil8fHQuJGVsZW1lbnQuZGF0YShcXFwiemZQbHVnaW5cXFwiLHQpLHQuJGVsZW1lbnQudHJpZ2dlcihcXFwiaW5pdC56Zi5cXFwiK3MpLHRoaXMuX3V1aWRzLnB1c2godC51dWlkKTt9LHVucmVnaXN0ZXJQbHVnaW46ZnVuY3Rpb24gdW5yZWdpc3RlclBsdWdpbih0KXt2YXIgaT1uKGUodC4kZWxlbWVudC5kYXRhKFxcXCJ6ZlBsdWdpblxcXCIpLmNvbnN0cnVjdG9yKSk7dGhpcy5fdXVpZHMuc3BsaWNlKHRoaXMuX3V1aWRzLmluZGV4T2YodC51dWlkKSwxKSx0LiRlbGVtZW50LnJlbW92ZUF0dHIoXFxcImRhdGEtXFxcIitpKS5yZW1vdmVEYXRhKFxcXCJ6ZlBsdWdpblxcXCIpLnRyaWdnZXIoXFxcImRlc3Ryb3llZC56Zi5cXFwiK2kpO2Zvcih2YXIgcyBpbiB0KXt0W3NdPW51bGw7fX0scmVJbml0OmZ1bmN0aW9uIHJlSW5pdChlKXt2YXIgaT1lIGluc3RhbmNlb2YgdDt0cnl7aWYoaSllLmVhY2goZnVuY3Rpb24oKXt0KHRoaXMpLmRhdGEoXFxcInpmUGx1Z2luXFxcIikuX2luaXQoKTt9KTtlbHNle3ZhciBzPXR5cGVvZiBlPT09XFxcInVuZGVmaW5lZFxcXCI/XFxcInVuZGVmaW5lZFxcXCI6X3R5cGVvZihlKSxvPXRoaXMsYT17b2JqZWN0OmZ1bmN0aW9uIG9iamVjdChlKXtlLmZvckVhY2goZnVuY3Rpb24oZSl7ZT1uKGUpLHQoXFxcIltkYXRhLVxcXCIrZStcXFwiXVxcXCIpLmZvdW5kYXRpb24oXFxcIl9pbml0XFxcIik7fSk7fSxzdHJpbmc6ZnVuY3Rpb24gc3RyaW5nKCl7ZT1uKGUpLHQoXFxcIltkYXRhLVxcXCIrZStcXFwiXVxcXCIpLmZvdW5kYXRpb24oXFxcIl9pbml0XFxcIik7fSx1bmRlZmluZWQ6ZnVuY3Rpb24gdW5kZWZpbmVkKCl7dGhpcy5vYmplY3QoT2JqZWN0LmtleXMoby5fcGx1Z2lucykpO319O2Fbc10oZSk7fX1jYXRjaChyKXtjb25zb2xlLmVycm9yKHIpO31maW5hbGx5e3JldHVybiBlO319LEdldFlvRGlnaXRzOmZ1bmN0aW9uIEdldFlvRGlnaXRzKHQsZSl7cmV0dXJuIHQ9dHx8NixNYXRoLnJvdW5kKE1hdGgucG93KDM2LHQrMSktTWF0aC5yYW5kb20oKSpNYXRoLnBvdygzNix0KSkudG9TdHJpbmcoMzYpLnNsaWNlKDEpKyhlP1xcXCItXFxcIitlOlxcXCJcXFwiKTt9LHJlZmxvdzpmdW5jdGlvbiByZWZsb3coZSxuKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIG4/bj1PYmplY3Qua2V5cyh0aGlzLl9wbHVnaW5zKTpcXFwic3RyaW5nXFxcIj09dHlwZW9mIG4mJihuPVtuXSk7dmFyIHM9dGhpczt0LmVhY2gobixmdW5jdGlvbihuLG8pe3ZhciBhPXMuX3BsdWdpbnNbb10scj10KGUpLmZpbmQoXFxcIltkYXRhLVxcXCIrbytcXFwiXVxcXCIpLmFkZEJhY2soXFxcIltkYXRhLVxcXCIrbytcXFwiXVxcXCIpO3IuZWFjaChmdW5jdGlvbigpe3ZhciBlPXQodGhpcyksbj17fTtpZihlLmRhdGEoXFxcInpmUGx1Z2luXFxcIikpcmV0dXJuIHZvaWQgY29uc29sZS53YXJuKFxcXCJUcmllZCB0byBpbml0aWFsaXplIFxcXCIrbytcXFwiIG9uIGFuIGVsZW1lbnQgdGhhdCBhbHJlYWR5IGhhcyBhIEZvdW5kYXRpb24gcGx1Z2luLlxcXCIpO2lmKGUuYXR0cihcXFwiZGF0YS1vcHRpb25zXFxcIikpe2UuYXR0cihcXFwiZGF0YS1vcHRpb25zXFxcIikuc3BsaXQoXFxcIjtcXFwiKS5mb3JFYWNoKGZ1bmN0aW9uKHQsZSl7dmFyIHM9dC5zcGxpdChcXFwiOlxcXCIpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC50cmltKCk7fSk7c1swXSYmKG5bc1swXV09aShzWzFdKSk7fSk7fXRyeXtlLmRhdGEoXFxcInpmUGx1Z2luXFxcIixuZXcgYSh0KHRoaXMpLG4pKTt9Y2F0Y2gocyl7Y29uc29sZS5lcnJvcihzKTt9ZmluYWxseXtyZXR1cm47fX0pO30pO30sZ2V0Rm5OYW1lOmUsdHJhbnNpdGlvbmVuZDpmdW5jdGlvbiB0cmFuc2l0aW9uZW5kKHQpe3ZhciBlLGk9e3RyYW5zaXRpb246XFxcInRyYW5zaXRpb25lbmRcXFwiLFdlYmtpdFRyYW5zaXRpb246XFxcIndlYmtpdFRyYW5zaXRpb25FbmRcXFwiLE1velRyYW5zaXRpb246XFxcInRyYW5zaXRpb25lbmRcXFwiLE9UcmFuc2l0aW9uOlxcXCJvdHJhbnNpdGlvbmVuZFxcXCJ9LG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7Zm9yKHZhciBzIGluIGkpe1xcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygbi5zdHlsZVtzXSYmKGU9aVtzXSk7fXJldHVybiBlP2U6KGU9c2V0VGltZW91dChmdW5jdGlvbigpe3QudHJpZ2dlckhhbmRsZXIoXFxcInRyYW5zaXRpb25lbmRcXFwiLFt0XSk7fSwxKSxcXFwidHJhbnNpdGlvbmVuZFxcXCIpO319O28udXRpbD17dGhyb3R0bGU6ZnVuY3Rpb24gdGhyb3R0bGUodCxlKXt2YXIgaT1udWxsO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXMscz1hcmd1bWVudHM7bnVsbD09PWkmJihpPXNldFRpbWVvdXQoZnVuY3Rpb24oKXt0LmFwcGx5KG4scyksaT1udWxsO30sZSkpO307fX07dmFyIGE9ZnVuY3Rpb24gYShpKXt2YXIgbj10eXBlb2YgaT09PVxcXCJ1bmRlZmluZWRcXFwiP1xcXCJ1bmRlZmluZWRcXFwiOl90eXBlb2YoaSkscz10KFxcXCJtZXRhLmZvdW5kYXRpb24tbXFcXFwiKSxhPXQoXFxcIi5uby1qc1xcXCIpO2lmKHMubGVuZ3RofHx0KCc8bWV0YSBjbGFzcz1cXFwiZm91bmRhdGlvbi1tcVxcXCI+JykuYXBwZW5kVG8oZG9jdW1lbnQuaGVhZCksYS5sZW5ndGgmJmEucmVtb3ZlQ2xhc3MoXFxcIm5vLWpzXFxcIiksXFxcInVuZGVmaW5lZFxcXCI9PT1uKW8uTWVkaWFRdWVyeS5faW5pdCgpLG8ucmVmbG93KHRoaXMpO2Vsc2V7aWYoXFxcInN0cmluZ1xcXCIhPT1uKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIldlJ3JlIHNvcnJ5LCBcXFwiK24rXFxcIiBpcyBub3QgYSB2YWxpZCBwYXJhbWV0ZXIuIFlvdSBtdXN0IHVzZSBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG1ldGhvZCB5b3Ugd2lzaCB0byBpbnZva2UuXFxcIik7dmFyIHI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLGw9dGhpcy5kYXRhKFxcXCJ6ZlBsdWdpblxcXCIpO2lmKHZvaWQgMD09PWx8fHZvaWQgMD09PWxbaV0pdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJXZSdyZSBzb3JyeSwgJ1xcXCIraStcXFwiJyBpcyBub3QgYW4gYXZhaWxhYmxlIG1ldGhvZCBmb3IgXFxcIisobD9lKGwpOlxcXCJ0aGlzIGVsZW1lbnRcXFwiKStcXFwiLlxcXCIpOzE9PT10aGlzLmxlbmd0aD9sW2ldLmFwcGx5KGwscik6dGhpcy5lYWNoKGZ1bmN0aW9uKGUsbil7bFtpXS5hcHBseSh0KG4pLmRhdGEoXFxcInpmUGx1Z2luXFxcIikscik7fSk7fXJldHVybiB0aGlzO307d2luZG93LkZvdW5kYXRpb249byx0LmZuLmZvdW5kYXRpb249YSxmdW5jdGlvbigpe0RhdGUubm93JiZ3aW5kb3cuRGF0ZS5ub3d8fCh3aW5kb3cuRGF0ZS5ub3c9RGF0ZS5ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7fSk7Zm9yKHZhciB0PVtcXFwid2Via2l0XFxcIixcXFwibW96XFxcIl0sZT0wO2U8dC5sZW5ndGgmJiF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOysrZSl7dmFyIGk9dFtlXTt3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lPXdpbmRvd1tpK1xcXCJSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcXFwiXSx3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWU9d2luZG93W2krXFxcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXFxcIl18fHdpbmRvd1tpK1xcXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcXFwiXTt9aWYoL2lQKGFkfGhvbmV8b2QpLipPUyA2Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KXx8IXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpe3ZhciBuPTA7d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZT1mdW5jdGlvbih0KXt2YXIgZT1EYXRlLm5vdygpLGk9TWF0aC5tYXgobisxNixlKTtyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe3Qobj1pKTt9LGktZSk7fSx3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWU9Y2xlYXJUaW1lb3V0O313aW5kb3cucGVyZm9ybWFuY2UmJndpbmRvdy5wZXJmb3JtYW5jZS5ub3d8fCh3aW5kb3cucGVyZm9ybWFuY2U9e3N0YXJ0OkRhdGUubm93KCksbm93OmZ1bmN0aW9uIG5vdygpe3JldHVybiBEYXRlLm5vdygpLXRoaXMuc3RhcnQ7fX0pO30oKSxGdW5jdGlvbi5wcm90b3R5cGUuYmluZHx8KEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kPWZ1bmN0aW9uKHQpe2lmKFxcXCJmdW5jdGlvblxcXCIhPXR5cGVvZiB0aGlzKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlXFxcIik7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLGk9dGhpcyxuPWZ1bmN0aW9uIG4oKXt9LHM9ZnVuY3Rpb24gcygpe3JldHVybiBpLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBuP3RoaXM6dCxlLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7fTtyZXR1cm4gdGhpcy5wcm90b3R5cGUmJihuLnByb3RvdHlwZT10aGlzLnByb3RvdHlwZSkscy5wcm90b3R5cGU9bmV3IG4oKSxzO30pO30oalF1ZXJ5KSwhZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0LGUsbixzKXt2YXIgbyxhLHIsbCx1PWkodCk7aWYoZSl7dmFyIGQ9aShlKTthPXUub2Zmc2V0LnRvcCt1LmhlaWdodDw9ZC5oZWlnaHQrZC5vZmZzZXQudG9wLG89dS5vZmZzZXQudG9wPj1kLm9mZnNldC50b3Ascj11Lm9mZnNldC5sZWZ0Pj1kLm9mZnNldC5sZWZ0LGw9dS5vZmZzZXQubGVmdCt1LndpZHRoPD1kLndpZHRoO31lbHNlIGE9dS5vZmZzZXQudG9wK3UuaGVpZ2h0PD11LndpbmRvd0RpbXMuaGVpZ2h0K3Uud2luZG93RGltcy5vZmZzZXQudG9wLG89dS5vZmZzZXQudG9wPj11LndpbmRvd0RpbXMub2Zmc2V0LnRvcCxyPXUub2Zmc2V0LmxlZnQ+PXUud2luZG93RGltcy5vZmZzZXQubGVmdCxsPXUub2Zmc2V0LmxlZnQrdS53aWR0aDw9dS53aW5kb3dEaW1zLndpZHRoO3ZhciBoPVthLG8scixsXTtyZXR1cm4gbj9yPT09bD09ITA6cz9vPT09YT09ITA6LTE9PT1oLmluZGV4T2YoITEpO31mdW5jdGlvbiBpKHQsZSl7aWYodD10Lmxlbmd0aD90WzBdOnQsdD09PXdpbmRvd3x8dD09PWRvY3VtZW50KXRocm93IG5ldyBFcnJvcihcXFwiSSdtIHNvcnJ5LCBEYXZlLiBJJ20gYWZyYWlkIEkgY2FuJ3QgZG8gdGhhdC5cXFwiKTt2YXIgaT10LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG49dC5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLHM9ZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxvPXdpbmRvdy5wYWdlWU9mZnNldCxhPXdpbmRvdy5wYWdlWE9mZnNldDtyZXR1cm57d2lkdGg6aS53aWR0aCxoZWlnaHQ6aS5oZWlnaHQsb2Zmc2V0Ont0b3A6aS50b3ArbyxsZWZ0OmkubGVmdCthfSxwYXJlbnREaW1zOnt3aWR0aDpuLndpZHRoLGhlaWdodDpuLmhlaWdodCxvZmZzZXQ6e3RvcDpuLnRvcCtvLGxlZnQ6bi5sZWZ0K2F9fSx3aW5kb3dEaW1zOnt3aWR0aDpzLndpZHRoLGhlaWdodDpzLmhlaWdodCxvZmZzZXQ6e3RvcDpvLGxlZnQ6YX19fTt9ZnVuY3Rpb24gbih0LGUsbixzLG8sYSl7dmFyIHI9aSh0KSxsPWU/aShlKTpudWxsO3N3aXRjaChuKXtjYXNlXFxcInRvcFxcXCI6cmV0dXJue2xlZnQ6Rm91bmRhdGlvbi5ydGwoKT9sLm9mZnNldC5sZWZ0LXIud2lkdGgrbC53aWR0aDpsLm9mZnNldC5sZWZ0LHRvcDpsLm9mZnNldC50b3AtKHIuaGVpZ2h0K3MpfTtjYXNlXFxcImxlZnRcXFwiOnJldHVybntsZWZ0Omwub2Zmc2V0LmxlZnQtKHIud2lkdGgrbyksdG9wOmwub2Zmc2V0LnRvcH07Y2FzZVxcXCJyaWdodFxcXCI6cmV0dXJue2xlZnQ6bC5vZmZzZXQubGVmdCtsLndpZHRoK28sdG9wOmwub2Zmc2V0LnRvcH07Y2FzZVxcXCJjZW50ZXIgdG9wXFxcIjpyZXR1cm57bGVmdDpsLm9mZnNldC5sZWZ0K2wud2lkdGgvMi1yLndpZHRoLzIsdG9wOmwub2Zmc2V0LnRvcC0oci5oZWlnaHQrcyl9O2Nhc2VcXFwiY2VudGVyIGJvdHRvbVxcXCI6cmV0dXJue2xlZnQ6YT9vOmwub2Zmc2V0LmxlZnQrbC53aWR0aC8yLXIud2lkdGgvMix0b3A6bC5vZmZzZXQudG9wK2wuaGVpZ2h0K3N9O2Nhc2VcXFwiY2VudGVyIGxlZnRcXFwiOnJldHVybntsZWZ0Omwub2Zmc2V0LmxlZnQtKHIud2lkdGgrbyksdG9wOmwub2Zmc2V0LnRvcCtsLmhlaWdodC8yLXIuaGVpZ2h0LzJ9O2Nhc2VcXFwiY2VudGVyIHJpZ2h0XFxcIjpyZXR1cm57bGVmdDpsLm9mZnNldC5sZWZ0K2wud2lkdGgrbysxLHRvcDpsLm9mZnNldC50b3ArbC5oZWlnaHQvMi1yLmhlaWdodC8yfTtjYXNlXFxcImNlbnRlclxcXCI6cmV0dXJue2xlZnQ6ci53aW5kb3dEaW1zLm9mZnNldC5sZWZ0K3Iud2luZG93RGltcy53aWR0aC8yLXIud2lkdGgvMix0b3A6ci53aW5kb3dEaW1zLm9mZnNldC50b3Arci53aW5kb3dEaW1zLmhlaWdodC8yLXIuaGVpZ2h0LzJ9O2Nhc2VcXFwicmV2ZWFsXFxcIjpyZXR1cm57bGVmdDooci53aW5kb3dEaW1zLndpZHRoLXIud2lkdGgpLzIsdG9wOnIud2luZG93RGltcy5vZmZzZXQudG9wK3N9O2Nhc2VcXFwicmV2ZWFsIGZ1bGxcXFwiOnJldHVybntsZWZ0OnIud2luZG93RGltcy5vZmZzZXQubGVmdCx0b3A6ci53aW5kb3dEaW1zLm9mZnNldC50b3B9O2RlZmF1bHQ6cmV0dXJue2xlZnQ6Rm91bmRhdGlvbi5ydGwoKT9sLm9mZnNldC5sZWZ0LXIud2lkdGgrbC53aWR0aDpsLm9mZnNldC5sZWZ0LHRvcDpsLm9mZnNldC50b3ArbC5oZWlnaHQrc307fX1Gb3VuZGF0aW9uLkJveD17SW1Ob3RUb3VjaGluZ1lvdTplLEdldERpbWVuc2lvbnM6aSxHZXRPZmZzZXRzOm59O30oalF1ZXJ5KSwhZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXt2YXIgZT17fTtmb3IodmFyIGkgaW4gdCl7ZVt0W2ldXT10W2ldO31yZXR1cm4gZTt9dmFyIGk9ezk6XFxcIlRBQlxcXCIsMTM6XFxcIkVOVEVSXFxcIiwyNzpcXFwiRVNDQVBFXFxcIiwzMjpcXFwiU1BBQ0VcXFwiLDM3OlxcXCJBUlJPV19MRUZUXFxcIiwzODpcXFwiQVJST1dfVVBcXFwiLDM5OlxcXCJBUlJPV19SSUdIVFxcXCIsNDA6XFxcIkFSUk9XX0RPV05cXFwifSxuPXt9LHM9e2tleXM6ZShpKSxwYXJzZUtleTpmdW5jdGlvbiBwYXJzZUtleSh0KXt2YXIgZT1pW3Qud2hpY2h8fHQua2V5Q29kZV18fFN0cmluZy5mcm9tQ2hhckNvZGUodC53aGljaCkudG9VcHBlckNhc2UoKTtyZXR1cm4gdC5zaGlmdEtleSYmKGU9XFxcIlNISUZUX1xcXCIrZSksdC5jdHJsS2V5JiYoZT1cXFwiQ1RSTF9cXFwiK2UpLHQuYWx0S2V5JiYoZT1cXFwiQUxUX1xcXCIrZSksZTt9LGhhbmRsZUtleTpmdW5jdGlvbiBoYW5kbGVLZXkoZSxpLHMpe3ZhciBvLGEscixsPW5baV0sdT10aGlzLnBhcnNlS2V5KGUpO3JldHVybiBsPyhvPVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgbC5sdHI/bDpGb3VuZGF0aW9uLnJ0bCgpP3QuZXh0ZW5kKHt9LGwubHRyLGwucnRsKTp0LmV4dGVuZCh7fSxsLnJ0bCxsLmx0ciksYT1vW3VdLHI9c1thXSx2b2lkKHImJlxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiByPyhyLmFwcGx5KCksKHMuaGFuZGxlZHx8XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHMuaGFuZGxlZCkmJnMuaGFuZGxlZC5hcHBseSgpKToocy51bmhhbmRsZWR8fFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBzLnVuaGFuZGxlZCkmJnMudW5oYW5kbGVkLmFwcGx5KCkpKTpjb25zb2xlLndhcm4oXFxcIkNvbXBvbmVudCBub3QgZGVmaW5lZCFcXFwiKTt9LGZpbmRGb2N1c2FibGU6ZnVuY3Rpb24gZmluZEZvY3VzYWJsZShlKXtyZXR1cm4gZS5maW5kKFxcXCJhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSksIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSwgYnV0dG9uOm5vdChbZGlzYWJsZWRdKSwgaWZyYW1lLCBvYmplY3QsIGVtYmVkLCAqW3RhYmluZGV4XSwgKltjb250ZW50ZWRpdGFibGVdXFxcIikuZmlsdGVyKGZ1bmN0aW9uKCl7cmV0dXJuIHQodGhpcykuaXMoXFxcIjp2aXNpYmxlXFxcIikmJiEodCh0aGlzKS5hdHRyKFxcXCJ0YWJpbmRleFxcXCIpPDApO30pO30scmVnaXN0ZXI6ZnVuY3Rpb24gcmVnaXN0ZXIodCxlKXtuW3RdPWU7fX07Rm91bmRhdGlvbi5LZXlib2FyZD1zO30oalF1ZXJ5KSwhZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXt2YXIgZT17fTtyZXR1cm5cXFwic3RyaW5nXFxcIiE9dHlwZW9mIHQ/ZToodD10LnRyaW0oKS5zbGljZSgxLC0xKSk/ZT10LnNwbGl0KFxcXCImXFxcIikucmVkdWNlKGZ1bmN0aW9uKHQsZSl7dmFyIGk9ZS5yZXBsYWNlKC9cXFxcKy9nLFxcXCIgXFxcIikuc3BsaXQoXFxcIj1cXFwiKSxuPWlbMF0scz1pWzFdO3JldHVybiBuPWRlY29kZVVSSUNvbXBvbmVudChuKSxzPXZvaWQgMD09PXM/bnVsbDpkZWNvZGVVUklDb21wb25lbnQocyksdC5oYXNPd25Qcm9wZXJ0eShuKT9BcnJheS5pc0FycmF5KHRbbl0pP3Rbbl0ucHVzaChzKTp0W25dPVt0W25dLHNdOnRbbl09cyx0O30se30pOmU7fXZhciBpPXtxdWVyaWVzOltdLGN1cnJlbnQ6XFxcIlxcXCIsX2luaXQ6ZnVuY3Rpb24gX2luaXQoKXt2YXIgaSxuPXRoaXMscz10KFxcXCIuZm91bmRhdGlvbi1tcVxcXCIpLmNzcyhcXFwiZm9udC1mYW1pbHlcXFwiKTtpPWUocyk7Zm9yKHZhciBvIGluIGkpe24ucXVlcmllcy5wdXNoKHtuYW1lOm8sdmFsdWU6XFxcIm9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiBcXFwiK2lbb10rXFxcIilcXFwifSk7fXRoaXMuY3VycmVudD10aGlzLl9nZXRDdXJyZW50U2l6ZSgpLHRoaXMuX3dhdGNoZXIoKTt9LGF0TGVhc3Q6ZnVuY3Rpb24gYXRMZWFzdCh0KXt2YXIgZT10aGlzLmdldCh0KTtyZXR1cm4gZT93aW5kb3cubWF0Y2hNZWRpYShlKS5tYXRjaGVzOiExO30sZ2V0OmZ1bmN0aW9uIGdldCh0KXtmb3IodmFyIGUgaW4gdGhpcy5xdWVyaWVzKXt2YXIgaT10aGlzLnF1ZXJpZXNbZV07aWYodD09PWkubmFtZSlyZXR1cm4gaS52YWx1ZTt9cmV0dXJuIG51bGw7fSxfZ2V0Q3VycmVudFNpemU6ZnVuY3Rpb24gX2dldEN1cnJlbnRTaXplKCl7dmFyIHQ7Zm9yKHZhciBlIGluIHRoaXMucXVlcmllcyl7dmFyIGk9dGhpcy5xdWVyaWVzW2VdO3dpbmRvdy5tYXRjaE1lZGlhKGkudmFsdWUpLm1hdGNoZXMmJih0PWkpO31yZXR1cm5cXFwib2JqZWN0XFxcIj09KHR5cGVvZiB0PT09XFxcInVuZGVmaW5lZFxcXCI/XFxcInVuZGVmaW5lZFxcXCI6X3R5cGVvZih0KSk/dC5uYW1lOnQ7fSxfd2F0Y2hlcjpmdW5jdGlvbiBfd2F0Y2hlcigpe3ZhciBlPXRoaXM7dCh3aW5kb3cpLm9uKFxcXCJyZXNpemUuemYubWVkaWFxdWVyeVxcXCIsZnVuY3Rpb24oKXt2YXIgaT1lLl9nZXRDdXJyZW50U2l6ZSgpO2khPT1lLmN1cnJlbnQmJih0KHdpbmRvdykudHJpZ2dlcihcXFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFxcIixbaSxlLmN1cnJlbnRdKSxlLmN1cnJlbnQ9aSk7fSk7fX07Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5PWksd2luZG93Lm1hdGNoTWVkaWF8fCh3aW5kb3cubWF0Y2hNZWRpYT1mdW5jdGlvbigpe1xcXCJ1c2Ugc3RyaWN0XFxcIjt2YXIgdD13aW5kb3cuc3R5bGVNZWRpYXx8d2luZG93Lm1lZGlhO2lmKCF0KXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJzdHlsZVxcXCIpLGk9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcInNjcmlwdFxcXCIpWzBdLG49bnVsbDtlLnR5cGU9XFxcInRleHQvY3NzXFxcIixlLmlkPVxcXCJtYXRjaG1lZGlhanMtdGVzdFxcXCIsaS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLGkpLG49XFxcImdldENvbXB1dGVkU3R5bGVcXFwiaW4gd2luZG93JiZ3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlLG51bGwpfHxlLmN1cnJlbnRTdHlsZSx0PXttYXRjaE1lZGl1bTpmdW5jdGlvbiBtYXRjaE1lZGl1bSh0KXt2YXIgaT1cXFwiQG1lZGlhIFxcXCIrdCtcXFwieyAjbWF0Y2htZWRpYWpzLXRlc3QgeyB3aWR0aDogMXB4OyB9IH1cXFwiO3JldHVybiBlLnN0eWxlU2hlZXQ/ZS5zdHlsZVNoZWV0LmNzc1RleHQ9aTplLnRleHRDb250ZW50PWksXFxcIjFweFxcXCI9PT1uLndpZHRoO319O31yZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJue21hdGNoZXM6dC5tYXRjaE1lZGl1bShlfHxcXFwiYWxsXFxcIiksbWVkaWE6ZXx8XFxcImFsbFxcXCJ9O307fSgpKSxGb3VuZGF0aW9uLk1lZGlhUXVlcnk9aTt9KGpRdWVyeSksIWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCxlLGkpe2Z1bmN0aW9uIG4ocil7YXx8KGE9d2luZG93LnBlcmZvcm1hbmNlLm5vdygpKSxvPXItYSxpLmFwcGx5KGUpLHQ+bz9zPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobixlKTood2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHMpLGUudHJpZ2dlcihcXFwiZmluaXNoZWQuemYuYW5pbWF0ZVxcXCIsW2VdKS50cmlnZ2VySGFuZGxlcihcXFwiZmluaXNoZWQuemYuYW5pbWF0ZVxcXCIsW2VdKSk7fXZhciBzLG8sYT1udWxsO3M9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShuKTt9ZnVuY3Rpb24gaShlLGksbyxhKXtmdW5jdGlvbiByKCl7ZXx8aS5oaWRlKCksbCgpLGEmJmEuYXBwbHkoaSk7fWZ1bmN0aW9uIGwoKXtpWzBdLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbj0wLGkucmVtb3ZlQ2xhc3ModStcXFwiIFxcXCIrZCtcXFwiIFxcXCIrbyk7fWlmKGk9dChpKS5lcSgwKSxpLmxlbmd0aCl7dmFyIHU9ZT9uWzBdOm5bMV0sZD1lP3NbMF06c1sxXTtsKCksaS5hZGRDbGFzcyhvKS5jc3MoXFxcInRyYW5zaXRpb25cXFwiLFxcXCJub25lXFxcIikscmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7aS5hZGRDbGFzcyh1KSxlJiZpLnNob3coKTt9KSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtpWzBdLm9mZnNldFdpZHRoLGkuY3NzKFxcXCJ0cmFuc2l0aW9uXFxcIixcXFwiXFxcIikuYWRkQ2xhc3MoZCk7fSksaS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKGkpLHIpO319dmFyIG49W1xcXCJtdWktZW50ZXJcXFwiLFxcXCJtdWktbGVhdmVcXFwiXSxzPVtcXFwibXVpLWVudGVyLWFjdGl2ZVxcXCIsXFxcIm11aS1sZWF2ZS1hY3RpdmVcXFwiXSxvPXthbmltYXRlSW46ZnVuY3Rpb24gYW5pbWF0ZUluKHQsZSxuKXtpKCEwLHQsZSxuKTt9LGFuaW1hdGVPdXQ6ZnVuY3Rpb24gYW5pbWF0ZU91dCh0LGUsbil7aSghMSx0LGUsbik7fX07Rm91bmRhdGlvbi5Nb3ZlPWUsRm91bmRhdGlvbi5Nb3Rpb249bzt9KGpRdWVyeSksIWZ1bmN0aW9uKHQpe3ZhciBlPXtGZWF0aGVyOmZ1bmN0aW9uIEZlYXRoZXIoZSl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aDw9MXx8dm9pZCAwPT09YXJndW1lbnRzWzFdP1xcXCJ6ZlxcXCI6YXJndW1lbnRzWzFdO2UuYXR0cihcXFwicm9sZVxcXCIsXFxcIm1lbnViYXJcXFwiKTt2YXIgbj1lLmZpbmQoXFxcImxpXFxcIikuYXR0cih7cm9sZTpcXFwibWVudWl0ZW1cXFwifSkscz1cXFwiaXMtXFxcIitpK1xcXCItc3VibWVudVxcXCIsbz1zK1xcXCItaXRlbVxcXCIsYT1cXFwiaXMtXFxcIitpK1xcXCItc3VibWVudS1wYXJlbnRcXFwiO2UuZmluZChcXFwiYTpmaXJzdFxcXCIpLmF0dHIoXFxcInRhYmluZGV4XFxcIiwwKSxuLmVhY2goZnVuY3Rpb24oKXt2YXIgZT10KHRoaXMpLGk9ZS5jaGlsZHJlbihcXFwidWxcXFwiKTtpLmxlbmd0aCYmKGUuYWRkQ2xhc3MoYSkuYXR0cih7XFxcImFyaWEtaGFzcG9wdXBcXFwiOiEwLFxcXCJhcmlhLWV4cGFuZGVkXFxcIjohMSxcXFwiYXJpYS1sYWJlbFxcXCI6ZS5jaGlsZHJlbihcXFwiYTpmaXJzdFxcXCIpLnRleHQoKX0pLGkuYWRkQ2xhc3MoXFxcInN1Ym1lbnUgXFxcIitzKS5hdHRyKHtcXFwiZGF0YS1zdWJtZW51XFxcIjpcXFwiXFxcIixcXFwiYXJpYS1oaWRkZW5cXFwiOiEwLHJvbGU6XFxcIm1lbnVcXFwifSkpLGUucGFyZW50KFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLmxlbmd0aCYmZS5hZGRDbGFzcyhcXFwiaXMtc3VibWVudS1pdGVtIFxcXCIrbyk7fSk7fSxCdXJuOmZ1bmN0aW9uIEJ1cm4odCxlKXt2YXIgaT0odC5maW5kKFxcXCJsaVxcXCIpLnJlbW92ZUF0dHIoXFxcInRhYmluZGV4XFxcIiksXFxcImlzLVxcXCIrZStcXFwiLXN1Ym1lbnVcXFwiKSxuPWkrXFxcIi1pdGVtXFxcIixzPVxcXCJpcy1cXFwiK2UrXFxcIi1zdWJtZW51LXBhcmVudFxcXCI7dC5maW5kKFxcXCIqXFxcIikucmVtb3ZlQ2xhc3MoaStcXFwiIFxcXCIrbitcXFwiIFxcXCIrcytcXFwiIGlzLXN1Ym1lbnUtaXRlbSBzdWJtZW51IGlzLWFjdGl2ZVxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEtc3VibWVudVxcXCIpLmNzcyhcXFwiZGlzcGxheVxcXCIsXFxcIlxcXCIpO319O0ZvdW5kYXRpb24uTmVzdD1lO30oalF1ZXJ5KSwhZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0LGUsaSl7dmFyIG4scyxvPXRoaXMsYT1lLmR1cmF0aW9uLHI9T2JqZWN0LmtleXModC5kYXRhKCkpWzBdfHxcXFwidGltZXJcXFwiLGw9LTE7dGhpcy5pc1BhdXNlZD0hMSx0aGlzLnJlc3RhcnQ9ZnVuY3Rpb24oKXtsPS0xLGNsZWFyVGltZW91dChzKSx0aGlzLnN0YXJ0KCk7fSx0aGlzLnN0YXJ0PWZ1bmN0aW9uKCl7dGhpcy5pc1BhdXNlZD0hMSxjbGVhclRpbWVvdXQocyksbD0wPj1sP2E6bCx0LmRhdGEoXFxcInBhdXNlZFxcXCIsITEpLG49RGF0ZS5ub3coKSxzPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLmluZmluaXRlJiZvLnJlc3RhcnQoKSxpKCk7fSxsKSx0LnRyaWdnZXIoXFxcInRpbWVyc3RhcnQuemYuXFxcIityKTt9LHRoaXMucGF1c2U9ZnVuY3Rpb24oKXt0aGlzLmlzUGF1c2VkPSEwLGNsZWFyVGltZW91dChzKSx0LmRhdGEoXFxcInBhdXNlZFxcXCIsITApO3ZhciBlPURhdGUubm93KCk7bC09ZS1uLHQudHJpZ2dlcihcXFwidGltZXJwYXVzZWQuemYuXFxcIityKTt9O31mdW5jdGlvbiBpKGUsaSl7ZnVuY3Rpb24gbigpe3MtLSwwPT09cyYmaSgpO312YXIgcz1lLmxlbmd0aDswPT09cyYmaSgpLGUuZWFjaChmdW5jdGlvbigpe3RoaXMuY29tcGxldGU/bigpOlxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgdGhpcy5uYXR1cmFsV2lkdGgmJnRoaXMubmF0dXJhbFdpZHRoPjA/bigpOnQodGhpcykub25lKFxcXCJsb2FkXFxcIixmdW5jdGlvbigpe24oKTt9KTt9KTt9Rm91bmRhdGlvbi5UaW1lcj1lLEZvdW5kYXRpb24ub25JbWFnZXNMb2FkZWQ9aTt9KGpRdWVyeSksZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3RoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwidG91Y2htb3ZlXFxcIixpKSx0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcInRvdWNoZW5kXFxcIixlKSx1PSExO31mdW5jdGlvbiBpKGkpe2lmKHQuc3BvdFN3aXBlLnByZXZlbnREZWZhdWx0JiZpLnByZXZlbnREZWZhdWx0KCksdSl7dmFyIG4scz1pLnRvdWNoZXNbMF0ucGFnZVgsYT0oaS50b3VjaGVzWzBdLnBhZ2VZLG8tcyk7bD1uZXcgRGF0ZSgpLmdldFRpbWUoKS1yLE1hdGguYWJzKGEpPj10LnNwb3RTd2lwZS5tb3ZlVGhyZXNob2xkJiZsPD10LnNwb3RTd2lwZS50aW1lVGhyZXNob2xkJiYobj1hPjA/XFxcImxlZnRcXFwiOlxcXCJyaWdodFxcXCIpLG4mJihpLnByZXZlbnREZWZhdWx0KCksZS5jYWxsKHRoaXMpLHQodGhpcykudHJpZ2dlcihcXFwic3dpcGVcXFwiLG4pLnRyaWdnZXIoXFxcInN3aXBlXFxcIituKSk7fX1mdW5jdGlvbiBuKHQpezE9PXQudG91Y2hlcy5sZW5ndGgmJihvPXQudG91Y2hlc1swXS5wYWdlWCxhPXQudG91Y2hlc1swXS5wYWdlWSx1PSEwLHI9bmV3IERhdGUoKS5nZXRUaW1lKCksdGhpcy5hZGRFdmVudExpc3RlbmVyKFxcXCJ0b3VjaG1vdmVcXFwiLGksITEpLHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcXFwidG91Y2hlbmRcXFwiLGUsITEpKTt9ZnVuY3Rpb24gcygpe3RoaXMuYWRkRXZlbnRMaXN0ZW5lciYmdGhpcy5hZGRFdmVudExpc3RlbmVyKFxcXCJ0b3VjaHN0YXJ0XFxcIixuLCExKTt9dC5zcG90U3dpcGU9e3ZlcnNpb246XFxcIjEuMC4wXFxcIixlbmFibGVkOlxcXCJvbnRvdWNoc3RhcnRcXFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LHByZXZlbnREZWZhdWx0OiExLG1vdmVUaHJlc2hvbGQ6NzUsdGltZVRocmVzaG9sZDoyMDB9O3ZhciBvLGEscixsLHU9ITE7dC5ldmVudC5zcGVjaWFsLnN3aXBlPXtzZXR1cDpzfSx0LmVhY2goW1xcXCJsZWZ0XFxcIixcXFwidXBcXFwiLFxcXCJkb3duXFxcIixcXFwicmlnaHRcXFwiXSxmdW5jdGlvbigpe3QuZXZlbnQuc3BlY2lhbFtcXFwic3dpcGVcXFwiK3RoaXNdPXtzZXR1cDpmdW5jdGlvbiBzZXR1cCgpe3QodGhpcykub24oXFxcInN3aXBlXFxcIix0Lm5vb3ApO319O30pO30oalF1ZXJ5KSwhZnVuY3Rpb24odCl7dC5mbi5hZGRUb3VjaD1mdW5jdGlvbigpe3RoaXMuZWFjaChmdW5jdGlvbihpLG4pe3QobikuYmluZChcXFwidG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWxcXFwiLGZ1bmN0aW9uKCl7ZShldmVudCk7fSk7fSk7dmFyIGU9ZnVuY3Rpb24gZSh0KXt2YXIgZSxpPXQuY2hhbmdlZFRvdWNoZXMsbj1pWzBdLHM9e3RvdWNoc3RhcnQ6XFxcIm1vdXNlZG93blxcXCIsdG91Y2htb3ZlOlxcXCJtb3VzZW1vdmVcXFwiLHRvdWNoZW5kOlxcXCJtb3VzZXVwXFxcIn0sbz1zW3QudHlwZV07XFxcIk1vdXNlRXZlbnRcXFwiaW4gd2luZG93JiZcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2Ygd2luZG93Lk1vdXNlRXZlbnQ/ZT13aW5kb3cuTW91c2VFdmVudChvLHtidWJibGVzOiEwLGNhbmNlbGFibGU6ITAsc2NyZWVuWDpuLnNjcmVlblgsc2NyZWVuWTpuLnNjcmVlblksY2xpZW50WDpuLmNsaWVudFgsY2xpZW50WTpuLmNsaWVudFl9KTooZT1kb2N1bWVudC5jcmVhdGVFdmVudChcXFwiTW91c2VFdmVudFxcXCIpLGUuaW5pdE1vdXNlRXZlbnQobywhMCwhMCx3aW5kb3csMSxuLnNjcmVlblgsbi5zY3JlZW5ZLG4uY2xpZW50WCxuLmNsaWVudFksITEsITEsITEsITEsMCxudWxsKSksbi50YXJnZXQuZGlzcGF0Y2hFdmVudChlKTt9O307fShqUXVlcnkpLCFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7bygpLG4oKSxzKCksaSgpO31mdW5jdGlvbiBpKGUpe3ZhciBpPXQoXFxcIltkYXRhLXlldGktYm94XVxcXCIpLG49W1xcXCJkcm9wZG93blxcXCIsXFxcInRvb2x0aXBcXFwiLFxcXCJyZXZlYWxcXFwiXTtpZihlJiYoXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBlP24ucHVzaChlKTpcXFwib2JqZWN0XFxcIj09KHR5cGVvZiBlPT09XFxcInVuZGVmaW5lZFxcXCI/XFxcInVuZGVmaW5lZFxcXCI6X3R5cGVvZihlKSkmJlxcXCJzdHJpbmdcXFwiPT10eXBlb2YgZVswXT9uLmNvbmNhdChlKTpjb25zb2xlLmVycm9yKFxcXCJQbHVnaW4gbmFtZXMgbXVzdCBiZSBzdHJpbmdzXFxcIikpLGkubGVuZ3RoKXt2YXIgcz1uLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cXFwiY2xvc2VtZS56Zi5cXFwiK3Q7fSkuam9pbihcXFwiIFxcXCIpO3Qod2luZG93KS5vZmYocykub24ocyxmdW5jdGlvbihlLGkpe3ZhciBuPWUubmFtZXNwYWNlLnNwbGl0KFxcXCIuXFxcIilbMF0scz10KFxcXCJbZGF0YS1cXFwiK24rXFxcIl1cXFwiKS5ub3QoJ1tkYXRhLXlldGktYm94PVxcXCInK2krJ1xcXCJdJyk7cy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGU9dCh0aGlzKTtlLnRyaWdnZXJIYW5kbGVyKFxcXCJjbG9zZS56Zi50cmlnZ2VyXFxcIixbZV0pO30pO30pO319ZnVuY3Rpb24gbihlKXt2YXIgaT12b2lkIDAsbj10KFxcXCJbZGF0YS1yZXNpemVdXFxcIik7bi5sZW5ndGgmJnQod2luZG93KS5vZmYoXFxcInJlc2l6ZS56Zi50cmlnZ2VyXFxcIikub24oXFxcInJlc2l6ZS56Zi50cmlnZ2VyXFxcIixmdW5jdGlvbihzKXtpJiZjbGVhclRpbWVvdXQoaSksaT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YXx8bi5lYWNoKGZ1bmN0aW9uKCl7dCh0aGlzKS50cmlnZ2VySGFuZGxlcihcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCIpO30pLG4uYXR0cihcXFwiZGF0YS1ldmVudHNcXFwiLFxcXCJyZXNpemVcXFwiKTt9LGV8fDEwKTt9KTt9ZnVuY3Rpb24gcyhlKXt2YXIgaT12b2lkIDAsbj10KFxcXCJbZGF0YS1zY3JvbGxdXFxcIik7bi5sZW5ndGgmJnQod2luZG93KS5vZmYoXFxcInNjcm9sbC56Zi50cmlnZ2VyXFxcIikub24oXFxcInNjcm9sbC56Zi50cmlnZ2VyXFxcIixmdW5jdGlvbihzKXtpJiZjbGVhclRpbWVvdXQoaSksaT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YXx8bi5lYWNoKGZ1bmN0aW9uKCl7dCh0aGlzKS50cmlnZ2VySGFuZGxlcihcXFwic2Nyb2xsbWUuemYudHJpZ2dlclxcXCIpO30pLG4uYXR0cihcXFwiZGF0YS1ldmVudHNcXFwiLFxcXCJzY3JvbGxcXFwiKTt9LGV8fDEwKTt9KTt9ZnVuY3Rpb24gbygpe2lmKCFhKXJldHVybiExO3ZhciBlPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltkYXRhLXJlc2l6ZV0sIFtkYXRhLXNjcm9sbF0sIFtkYXRhLW11dGF0ZV1cXFwiKSxpPWZ1bmN0aW9uIGkoZSl7dmFyIGk9dChlWzBdLnRhcmdldCk7c3dpdGNoKGkuYXR0cihcXFwiZGF0YS1ldmVudHNcXFwiKSl7Y2FzZVxcXCJyZXNpemVcXFwiOmkudHJpZ2dlckhhbmRsZXIoXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiLFtpXSk7YnJlYWs7Y2FzZVxcXCJzY3JvbGxcXFwiOmkudHJpZ2dlckhhbmRsZXIoXFxcInNjcm9sbG1lLnpmLnRyaWdnZXJcXFwiLFtpLHdpbmRvdy5wYWdlWU9mZnNldF0pO2JyZWFrO2RlZmF1bHQ6cmV0dXJuITE7fX07aWYoZS5sZW5ndGgpZm9yKHZhciBuPTA7bjw9ZS5sZW5ndGgtMTtuKyspe3ZhciBzPW5ldyBhKGkpO3Mub2JzZXJ2ZShlW25dLHthdHRyaWJ1dGVzOiEwLGNoaWxkTGlzdDohMSxjaGFyYWN0ZXJEYXRhOiExLHN1YnRyZWU6ITEsYXR0cmlidXRlRmlsdGVyOltcXFwiZGF0YS1ldmVudHNcXFwiXX0pO319dmFyIGE9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W1xcXCJXZWJLaXRcXFwiLFxcXCJNb3pcXFwiLFxcXCJPXFxcIixcXFwiTXNcXFwiLFxcXCJcXFwiXSxlPTA7ZTx0Lmxlbmd0aDtlKyspe2lmKHRbZV0rXFxcIk11dGF0aW9uT2JzZXJ2ZXJcXFwiaW4gd2luZG93KXJldHVybiB3aW5kb3dbdFtlXStcXFwiTXV0YXRpb25PYnNlcnZlclxcXCJdO31yZXR1cm4hMTt9KCkscj1mdW5jdGlvbiByKGUsaSl7ZS5kYXRhKGkpLnNwbGl0KFxcXCIgXFxcIikuZm9yRWFjaChmdW5jdGlvbihuKXt0KFxcXCIjXFxcIituKVtcXFwiY2xvc2VcXFwiPT09aT9cXFwidHJpZ2dlclxcXCI6XFxcInRyaWdnZXJIYW5kbGVyXFxcIl0oaStcXFwiLnpmLnRyaWdnZXJcXFwiLFtlXSk7fSk7fTt0KGRvY3VtZW50KS5vbihcXFwiY2xpY2suemYudHJpZ2dlclxcXCIsXFxcIltkYXRhLW9wZW5dXFxcIixmdW5jdGlvbigpe3IodCh0aGlzKSxcXFwib3BlblxcXCIpO30pLHQoZG9jdW1lbnQpLm9uKFxcXCJjbGljay56Zi50cmlnZ2VyXFxcIixcXFwiW2RhdGEtY2xvc2VdXFxcIixmdW5jdGlvbigpe3ZhciBlPXQodGhpcykuZGF0YShcXFwiY2xvc2VcXFwiKTtlP3IodCh0aGlzKSxcXFwiY2xvc2VcXFwiKTp0KHRoaXMpLnRyaWdnZXIoXFxcImNsb3NlLnpmLnRyaWdnZXJcXFwiKTt9KSx0KGRvY3VtZW50KS5vbihcXFwiY2xpY2suemYudHJpZ2dlclxcXCIsXFxcIltkYXRhLXRvZ2dsZV1cXFwiLGZ1bmN0aW9uKCl7cih0KHRoaXMpLFxcXCJ0b2dnbGVcXFwiKTt9KSx0KGRvY3VtZW50KS5vbihcXFwiY2xvc2UuemYudHJpZ2dlclxcXCIsXFxcIltkYXRhLWNsb3NhYmxlXVxcXCIsZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKTt2YXIgaT10KHRoaXMpLmRhdGEoXFxcImNsb3NhYmxlXFxcIik7XFxcIlxcXCIhPT1pP0ZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQodCh0aGlzKSxpLGZ1bmN0aW9uKCl7dCh0aGlzKS50cmlnZ2VyKFxcXCJjbG9zZWQuemZcXFwiKTt9KTp0KHRoaXMpLmZhZGVPdXQoKS50cmlnZ2VyKFxcXCJjbG9zZWQuemZcXFwiKTt9KSx0KGRvY3VtZW50KS5vbihcXFwiZm9jdXMuemYudHJpZ2dlciBibHVyLnpmLnRyaWdnZXJcXFwiLFxcXCJbZGF0YS10b2dnbGUtZm9jdXNdXFxcIixmdW5jdGlvbigpe3ZhciBlPXQodGhpcykuZGF0YShcXFwidG9nZ2xlLWZvY3VzXFxcIik7dChcXFwiI1xcXCIrZSkudHJpZ2dlckhhbmRsZXIoXFxcInRvZ2dsZS56Zi50cmlnZ2VyXFxcIixbdCh0aGlzKV0pO30pLHQod2luZG93KS5sb2FkKGZ1bmN0aW9uKCl7ZSgpO30pLEZvdW5kYXRpb24uSUhlYXJZb3U9ZTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGkpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg8PTF8fHZvaWQgMD09PWFyZ3VtZW50c1sxXT97fTphcmd1bWVudHNbMV07X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIkFiaWRlXFxcIik7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kaW5wdXRzPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiaW5wdXQsIHRleHRhcmVhLCBzZWxlY3RcXFwiKS5ub3QoXFxcIltkYXRhLWFiaWRlLWlnbm9yZV1cXFwiKSx0aGlzLl9ldmVudHMoKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dGhpcy4kZWxlbWVudC5vZmYoXFxcIi5hYmlkZVxcXCIpLm9uKFxcXCJyZXNldC56Zi5hYmlkZVxcXCIsZnVuY3Rpb24oKXtlLnJlc2V0Rm9ybSgpO30pLm9uKFxcXCJzdWJtaXQuemYuYWJpZGVcXFwiLGZ1bmN0aW9uKCl7cmV0dXJuIGUudmFsaWRhdGVGb3JtKCk7fSksXFxcImZpZWxkQ2hhbmdlXFxcIj09PXRoaXMub3B0aW9ucy52YWxpZGF0ZU9uJiZ0aGlzLiRpbnB1dHMub2ZmKFxcXCJjaGFuZ2UuemYuYWJpZGVcXFwiKS5vbihcXFwiY2hhbmdlLnpmLmFiaWRlXFxcIixmdW5jdGlvbihpKXtlLnZhbGlkYXRlSW5wdXQodChpLnRhcmdldCkpO30pLHRoaXMub3B0aW9ucy5saXZlVmFsaWRhdGUmJnRoaXMuJGlucHV0cy5vZmYoXFxcImlucHV0LnpmLmFiaWRlXFxcIikub24oXFxcImlucHV0LnpmLmFiaWRlXFxcIixmdW5jdGlvbihpKXtlLnZhbGlkYXRlSW5wdXQodChpLnRhcmdldCkpO30pO319LHtrZXk6XFxcIl9yZWZsb3dcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5faW5pdCgpO319LHtrZXk6XFxcInJlcXVpcmVkQ2hlY2tcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe2lmKCF0LmF0dHIoXFxcInJlcXVpcmVkXFxcIikpcmV0dXJuITA7dmFyIGU9ITA7c3dpdGNoKHRbMF0udHlwZSl7Y2FzZVxcXCJjaGVja2JveFxcXCI6Y2FzZVxcXCJyYWRpb1xcXCI6ZT10WzBdLmNoZWNrZWQ7YnJlYWs7Y2FzZVxcXCJzZWxlY3RcXFwiOmNhc2VcXFwic2VsZWN0LW9uZVxcXCI6Y2FzZVxcXCJzZWxlY3QtbXVsdGlwbGVcXFwiOnZhciBpPXQuZmluZChcXFwib3B0aW9uOnNlbGVjdGVkXFxcIik7aS5sZW5ndGgmJmkudmFsKCl8fChlPSExKTticmVhaztkZWZhdWx0OnQudmFsKCkmJnQudmFsKCkubGVuZ3RofHwoZT0hMSk7fXJldHVybiBlO319LHtrZXk6XFxcImZpbmRGb3JtRXJyb3JcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXQuc2libGluZ3ModGhpcy5vcHRpb25zLmZvcm1FcnJvclNlbGVjdG9yKTtyZXR1cm4gZS5sZW5ndGh8fChlPXQucGFyZW50KCkuZmluZCh0aGlzLm9wdGlvbnMuZm9ybUVycm9yU2VsZWN0b3IpKSxlO319LHtrZXk6XFxcImZpbmRMYWJlbFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dFswXS5pZCxpPXRoaXMuJGVsZW1lbnQuZmluZCgnbGFiZWxbZm9yPVxcXCInK2UrJ1xcXCJdJyk7cmV0dXJuIGkubGVuZ3RoP2k6dC5jbG9zZXN0KFxcXCJsYWJlbFxcXCIpO319LHtrZXk6XFxcImFkZEVycm9yQ2xhc3Nlc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpcy5maW5kTGFiZWwodCksaT10aGlzLmZpbmRGb3JtRXJyb3IodCk7ZS5sZW5ndGgmJmUuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyksaS5sZW5ndGgmJmkuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmZvcm1FcnJvckNsYXNzKSx0LmFkZENsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLmF0dHIoXFxcImRhdGEtaW52YWxpZFxcXCIsXFxcIlxcXCIpO319LHtrZXk6XFxcInJlbW92ZUVycm9yQ2xhc3Nlc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpcy5maW5kTGFiZWwodCksaT10aGlzLmZpbmRGb3JtRXJyb3IodCk7ZS5sZW5ndGgmJmUucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyksaS5sZW5ndGgmJmkucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmZvcm1FcnJvckNsYXNzKSx0LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLnJlbW92ZUF0dHIoXFxcImRhdGEtaW52YWxpZFxcXCIpO319LHtrZXk6XFxcInZhbGlkYXRlSW5wdXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXRoaXMucmVxdWlyZWRDaGVjayh0KSxpPSExLG49ITAscz10LmF0dHIoXFxcImRhdGEtdmFsaWRhdG9yXFxcIiksbz0hMDtzd2l0Y2godFswXS50eXBlKXtjYXNlXFxcInJhZGlvXFxcIjppPXRoaXMudmFsaWRhdGVSYWRpbyh0LmF0dHIoXFxcIm5hbWVcXFwiKSk7YnJlYWs7Y2FzZVxcXCJjaGVja2JveFxcXCI6aT1lO2JyZWFrO2Nhc2VcXFwic2VsZWN0XFxcIjpjYXNlXFxcInNlbGVjdC1vbmVcXFwiOmNhc2VcXFwic2VsZWN0LW11bHRpcGxlXFxcIjppPWU7YnJlYWs7ZGVmYXVsdDppPXRoaXMudmFsaWRhdGVUZXh0KHQpO31zJiYobj10aGlzLm1hdGNoVmFsaWRhdGlvbih0LHMsdC5hdHRyKFxcXCJyZXF1aXJlZFxcXCIpKSksdC5hdHRyKFxcXCJkYXRhLWVxdWFsdG9cXFwiKSYmKG89dGhpcy5vcHRpb25zLnZhbGlkYXRvcnMuZXF1YWxUbyh0KSk7dmFyIGE9LTE9PT1bZSxpLG4sb10uaW5kZXhPZighMSkscj0oYT9cXFwidmFsaWRcXFwiOlxcXCJpbnZhbGlkXFxcIikrXFxcIi56Zi5hYmlkZVxcXCI7cmV0dXJuIHRoaXNbYT9cXFwicmVtb3ZlRXJyb3JDbGFzc2VzXFxcIjpcXFwiYWRkRXJyb3JDbGFzc2VzXFxcIl0odCksdC50cmlnZ2VyKHIsW3RdKSxhO319LHtrZXk6XFxcInZhbGlkYXRlRm9ybVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT1bXSxpPXRoaXM7dGhpcy4kaW5wdXRzLmVhY2goZnVuY3Rpb24oKXtlLnB1c2goaS52YWxpZGF0ZUlucHV0KHQodGhpcykpKTt9KTt2YXIgbj0tMT09PWUuaW5kZXhPZighMSk7cmV0dXJuIHRoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtYWJpZGUtZXJyb3JdXFxcIikuY3NzKFxcXCJkaXNwbGF5XFxcIixuP1xcXCJub25lXFxcIjpcXFwiYmxvY2tcXFwiKSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoKG4/XFxcImZvcm12YWxpZFxcXCI6XFxcImZvcm1pbnZhbGlkXFxcIikrXFxcIi56Zi5hYmlkZVxcXCIsW3RoaXMuJGVsZW1lbnRdKSxuO319LHtrZXk6XFxcInZhbGlkYXRlVGV4dFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlKXtlPWV8fHQuYXR0cihcXFwicGF0dGVyblxcXCIpfHx0LmF0dHIoXFxcInR5cGVcXFwiKTt2YXIgaT10LnZhbCgpO3JldHVybiBpLmxlbmd0aD90aGlzLm9wdGlvbnMucGF0dGVybnMuaGFzT3duUHJvcGVydHkoZSk/dGhpcy5vcHRpb25zLnBhdHRlcm5zW2VdLnRlc3QoaSk6ZSYmZSE9PXQuYXR0cihcXFwidHlwZVxcXCIpP25ldyBSZWdFeHAoZSkudGVzdChpKTohMDohMDt9fSx7a2V5OlxcXCJ2YWxpZGF0ZVJhZGlvXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT10aGlzLiRlbGVtZW50LmZpbmQoJzpyYWRpb1tuYW1lPVxcXCInK2UrJ1xcXCJdJyksbj1bXSxzPXRoaXM7cmV0dXJuIGkuZWFjaChmdW5jdGlvbigpe3ZhciBlPXQodGhpcyksaT1zLnJlcXVpcmVkQ2hlY2soZSk7bi5wdXNoKGkpLGkmJnMucmVtb3ZlRXJyb3JDbGFzc2VzKGUpO30pLC0xPT09bi5pbmRleE9mKCExKTt9fSx7a2V5OlxcXCJtYXRjaFZhbGlkYXRpb25cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQsZSxpKXt2YXIgbj10aGlzO2k9ISFpO3ZhciBzPWUuc3BsaXQoXFxcIiBcXFwiKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG4ub3B0aW9ucy52YWxpZGF0b3JzW2VdKHQsaSx0LnBhcmVudCgpKTt9KTtyZXR1cm4tMT09PXMuaW5kZXhPZighMSk7fX0se2tleTpcXFwicmVzZXRGb3JtXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXMuJGVsZW1lbnQsaT10aGlzLm9wdGlvbnM7dChcXFwiLlxcXCIraS5sYWJlbEVycm9yQ2xhc3MsZSkubm90KFxcXCJzbWFsbFxcXCIpLnJlbW92ZUNsYXNzKGkubGFiZWxFcnJvckNsYXNzKSx0KFxcXCIuXFxcIitpLmlucHV0RXJyb3JDbGFzcyxlKS5ub3QoXFxcInNtYWxsXFxcIikucmVtb3ZlQ2xhc3MoaS5pbnB1dEVycm9yQ2xhc3MpLHQoaS5mb3JtRXJyb3JTZWxlY3RvcitcXFwiLlxcXCIraS5mb3JtRXJyb3JDbGFzcykucmVtb3ZlQ2xhc3MoaS5mb3JtRXJyb3JDbGFzcyksZS5maW5kKFxcXCJbZGF0YS1hYmlkZS1lcnJvcl1cXFwiKS5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJub25lXFxcIiksdChcXFwiOmlucHV0XFxcIixlKS5ub3QoXFxcIjpidXR0b24sIDpzdWJtaXQsIDpyZXNldCwgOmhpZGRlbiwgW2RhdGEtYWJpZGUtaWdub3JlXVxcXCIpLnZhbChcXFwiXFxcIikucmVtb3ZlQXR0cihcXFwiZGF0YS1pbnZhbGlkXFxcIiksZS50cmlnZ2VyKFxcXCJmb3JtcmVzZXQuemYuYWJpZGVcXFwiLFtlXSk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3RoaXMuJGVsZW1lbnQub2ZmKFxcXCIuYWJpZGVcXFwiKS5maW5kKFxcXCJbZGF0YS1hYmlkZS1lcnJvcl1cXFwiKS5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJub25lXFxcIiksdGhpcy4kaW5wdXRzLm9mZihcXFwiLmFiaWRlXFxcIikuZWFjaChmdW5jdGlvbigpe2UucmVtb3ZlRXJyb3JDbGFzc2VzKHQodGhpcykpO30pLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e3ZhbGlkYXRlT246XFxcImZpZWxkQ2hhbmdlXFxcIixsYWJlbEVycm9yQ2xhc3M6XFxcImlzLWludmFsaWQtbGFiZWxcXFwiLGlucHV0RXJyb3JDbGFzczpcXFwiaXMtaW52YWxpZC1pbnB1dFxcXCIsZm9ybUVycm9yU2VsZWN0b3I6XFxcIi5mb3JtLWVycm9yXFxcIixmb3JtRXJyb3JDbGFzczpcXFwiaXMtdmlzaWJsZVxcXCIsbGl2ZVZhbGlkYXRlOiExLHBhdHRlcm5zOnthbHBoYTovXlthLXpBLVpdKyQvLGFscGhhX251bWVyaWM6L15bYS16QS1aMC05XSskLyxpbnRlZ2VyOi9eWy0rXT9cXFxcZCskLyxudW1iZXI6L15bLStdP1xcXFxkKig/OltcXFxcLlxcXFwsXVxcXFxkKyk/JC8sY2FyZDovXig/OjRbMC05XXsxMn0oPzpbMC05XXszfSk/fDVbMS01XVswLTldezE0fXw2KD86MDExfDVbMC05XVswLTldKVswLTldezEyfXwzWzQ3XVswLTldezEzfXwzKD86MFswLTVdfFs2OF1bMC05XSlbMC05XXsxMX18KD86MjEzMXwxODAwfDM1XFxcXGR7M30pXFxcXGR7MTF9KSQvLGN2djovXihbMC05XSl7Myw0fSQvLGVtYWlsOi9eW2EtekEtWjAtOS4hIyQlJicqK1xcXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcXFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSskLyx1cmw6L14oaHR0cHM/fGZ0cHxmaWxlfHNzaCk6XFxcXC9cXFxcLygoKChbYS16QS1aXXxcXFxcZHwtfFxcXFwufF98fnxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KCVbXFxcXGRhLWZdezJ9KXxbIVxcXFwkJidcXFxcKFxcXFwpXFxcXCpcXFxcKyw7PV18OikqQCk/KCgoXFxcXGR8WzEtOV1cXFxcZHwxXFxcXGRcXFxcZHwyWzAtNF1cXFxcZHwyNVswLTVdKVxcXFwuKFxcXFxkfFsxLTldXFxcXGR8MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC01XSlcXFxcLihcXFxcZHxbMS05XVxcXFxkfDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNV0pXFxcXC4oXFxcXGR8WzEtOV1cXFxcZHwxXFxcXGRcXFxcZHwyWzAtNF1cXFxcZHwyNVswLTVdKSl8KCgoW2EtekEtWl18XFxcXGR8W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCgoW2EtekEtWl18XFxcXGR8W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKSooW2EtekEtWl18XFxcXGR8W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKSlcXFxcLikrKChbYS16QS1aXXxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KChbYS16QS1aXXxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSkoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKihbYS16QS1aXXxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSkpKVxcXFwuPykoOlxcXFxkKik/KShcXFxcLygoKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoJVtcXFxcZGEtZl17Mn0pfFshXFxcXCQmJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9XXw6fEApKyhcXFxcLygoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCglW1xcXFxkYS1mXXsyfSl8WyFcXFxcJCYnXFxcXChcXFxcKVxcXFwqXFxcXCssOz1dfDp8QCkqKSopPyk/KFxcXFw/KCgoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCglW1xcXFxkYS1mXXsyfSl8WyFcXFxcJCYnXFxcXChcXFxcKVxcXFwqXFxcXCssOz1dfDp8QCl8W1xcXFx1RTAwMC1cXFxcdUY4RkZdfFxcXFwvfFxcXFw/KSopPyhcXFxcIygoKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoJVtcXFxcZGEtZl17Mn0pfFshXFxcXCQmJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9XXw6fEApfFxcXFwvfFxcXFw/KSopPyQvLGRvbWFpbjovXihbYS16QS1aMC05XShbYS16QS1aMC05XFxcXC1dezAsNjF9W2EtekEtWjAtOV0pP1xcXFwuKStbYS16QS1aXXsyLDh9JC8sZGF0ZXRpbWU6L14oWzAtMl1bMC05XXszfSlcXFxcLShbMC0xXVswLTldKVxcXFwtKFswLTNdWzAtOV0pVChbMC01XVswLTldKVxcXFw6KFswLTVdWzAtOV0pXFxcXDooWzAtNV1bMC05XSkoWnwoW1xcXFwtXFxcXCtdKFswLTFdWzAtOV0pXFxcXDowMCkpJC8sZGF0ZTovKD86MTl8MjApWzAtOV17Mn0tKD86KD86MFsxLTldfDFbMC0yXSktKD86MFsxLTldfDFbMC05XXwyWzAtOV0pfCg/Oig/ITAyKSg/OjBbMS05XXwxWzAtMl0pLSg/OjMwKSl8KD86KD86MFsxMzU3OF18MVswMl0pLTMxKSkkLyx0aW1lOi9eKDBbMC05XXwxWzAtOV18MlswLTNdKSg6WzAtNV1bMC05XSl7Mn0kLyxkYXRlSVNPOi9eXFxcXGR7NH1bXFxcXC9cXFxcLV1cXFxcZHsxLDJ9W1xcXFwvXFxcXC1dXFxcXGR7MSwyfSQvLG1vbnRoX2RheV95ZWFyOi9eKDBbMS05XXwxWzAxMl0pWy0gXFxcXC8uXSgwWzEtOV18WzEyXVswLTldfDNbMDFdKVstIFxcXFwvLl1cXFxcZHs0fSQvLGRheV9tb250aF95ZWFyOi9eKDBbMS05XXxbMTJdWzAtOV18M1swMV0pWy0gXFxcXC8uXSgwWzEtOV18MVswMTJdKVstIFxcXFwvLl1cXFxcZHs0fSQvLGNvbG9yOi9eIz8oW2EtZkEtRjAtOV17Nn18W2EtZkEtRjAtOV17M30pJC99LHZhbGlkYXRvcnM6e2VxdWFsVG86ZnVuY3Rpb24gZXF1YWxUbyhlLGksbil7cmV0dXJuIHQoXFxcIiNcXFwiK2UuYXR0cihcXFwiZGF0YS1lcXVhbHRvXFxcIikpLnZhbCgpPT09ZS52YWwoKTt9fX0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiQWJpZGVcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIkFjY29yZGlvblxcXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIkFjY29yZGlvblxcXCIse0VOVEVSOlxcXCJ0b2dnbGVcXFwiLFNQQUNFOlxcXCJ0b2dnbGVcXFwiLEFSUk9XX0RPV046XFxcIm5leHRcXFwiLEFSUk9XX1VQOlxcXCJwcmV2aW91c1xcXCJ9KTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50LmF0dHIoXFxcInJvbGVcXFwiLFxcXCJ0YWJsaXN0XFxcIiksdGhpcy4kdGFicz10aGlzLiRlbGVtZW50LmNoaWxkcmVuKFxcXCJsaVxcXCIpLDA9PT10aGlzLiR0YWJzLmxlbmd0aCYmKHRoaXMuJHRhYnM9dGhpcy4kZWxlbWVudC5jaGlsZHJlbihcXFwiW2RhdGEtYWNjb3JkaW9uLWl0ZW1dXFxcIikpLHRoaXMuJHRhYnMuZWFjaChmdW5jdGlvbihlLGkpe3ZhciBuPXQoaSkscz1uLmZpbmQoXFxcIltkYXRhLXRhYi1jb250ZW50XVxcXCIpLG89c1swXS5pZHx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJhY2NvcmRpb25cXFwiKSxhPWkuaWR8fG8rXFxcIi1sYWJlbFxcXCI7bi5maW5kKFxcXCJhOmZpcnN0XFxcIikuYXR0cih7XFxcImFyaWEtY29udHJvbHNcXFwiOm8scm9sZTpcXFwidGFiXFxcIixpZDphLFxcXCJhcmlhLWV4cGFuZGVkXFxcIjohMSxcXFwiYXJpYS1zZWxlY3RlZFxcXCI6ITF9KSxzLmF0dHIoe3JvbGU6XFxcInRhYnBhbmVsXFxcIixcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIjphLFxcXCJhcmlhLWhpZGRlblxcXCI6ITAsaWQ6b30pO30pO3ZhciBlPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLmlzLWFjdGl2ZVxcXCIpLmNoaWxkcmVuKFxcXCJbZGF0YS10YWItY29udGVudF1cXFwiKTtlLmxlbmd0aCYmdGhpcy5kb3duKGUsITApLHRoaXMuX2V2ZW50cygpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpczt0aGlzLiR0YWJzLmVhY2goZnVuY3Rpb24oKXt2YXIgaT10KHRoaXMpLG49aS5jaGlsZHJlbihcXFwiW2RhdGEtdGFiLWNvbnRlbnRdXFxcIik7bi5sZW5ndGgmJmkuY2hpbGRyZW4oXFxcImFcXFwiKS5vZmYoXFxcImNsaWNrLnpmLmFjY29yZGlvbiBrZXlkb3duLnpmLmFjY29yZGlvblxcXCIpLm9uKFxcXCJjbGljay56Zi5hY2NvcmRpb25cXFwiLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKSxpLmhhc0NsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKT8oZS5vcHRpb25zLmFsbG93QWxsQ2xvc2VkfHxpLnNpYmxpbmdzKCkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpKSYmZS51cChuKTplLmRvd24obik7fSkub24oXFxcImtleWRvd24uemYuYWNjb3JkaW9uXFxcIixmdW5jdGlvbih0KXtGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleSh0LFxcXCJBY2NvcmRpb25cXFwiLHt0b2dnbGU6ZnVuY3Rpb24gdG9nZ2xlKCl7ZS50b2dnbGUobik7fSxuZXh0OmZ1bmN0aW9uIG5leHQoKXtpLm5leHQoKS5maW5kKFxcXCJhXFxcIikuZm9jdXMoKS50cmlnZ2VyKFxcXCJjbGljay56Zi5hY2NvcmRpb25cXFwiKTt9LHByZXZpb3VzOmZ1bmN0aW9uIHByZXZpb3VzKCl7aS5wcmV2KCkuZmluZChcXFwiYVxcXCIpLmZvY3VzKCkudHJpZ2dlcihcXFwiY2xpY2suemYuYWNjb3JkaW9uXFxcIik7fSxoYW5kbGVkOmZ1bmN0aW9uIGhhbmRsZWQoKXt0LnByZXZlbnREZWZhdWx0KCksdC5zdG9wUHJvcGFnYXRpb24oKTt9fSk7fSk7fSk7fX0se2tleTpcXFwidG9nZ2xlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXtpZih0LnBhcmVudCgpLmhhc0NsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKSl7aWYoIXRoaXMub3B0aW9ucy5hbGxvd0FsbENsb3NlZCYmIXQucGFyZW50KCkuc2libGluZ3MoKS5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikpcmV0dXJuO3RoaXMudXAodCk7fWVsc2UgdGhpcy5kb3duKHQpO319LHtrZXk6XFxcImRvd25cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUsaSl7dmFyIG49dGhpcztpZighdGhpcy5vcHRpb25zLm11bHRpRXhwYW5kJiYhaSl7dmFyIHM9dGhpcy4kZWxlbWVudC5maW5kKFxcXCIuaXMtYWN0aXZlXFxcIikuY2hpbGRyZW4oXFxcIltkYXRhLXRhYi1jb250ZW50XVxcXCIpO3MubGVuZ3RoJiZ0aGlzLnVwKHMpO31lLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMSkucGFyZW50KFxcXCJbZGF0YS10YWItY29udGVudF1cXFwiKS5hZGRCYWNrKCkucGFyZW50KCkuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLGUuc2xpZGVEb3duKG4ub3B0aW9ucy5zbGlkZVNwZWVkLGZ1bmN0aW9uKCl7bi4kZWxlbWVudC50cmlnZ2VyKFxcXCJkb3duLnpmLmFjY29yZGlvblxcXCIsW2VdKTt9KSx0KFxcXCIjXFxcIitlLmF0dHIoXFxcImFyaWEtbGFiZWxsZWRieVxcXCIpKS5hdHRyKHtcXFwiYXJpYS1leHBhbmRlZFxcXCI6ITAsXFxcImFyaWEtc2VsZWN0ZWRcXFwiOiEwfSk7fX0se2tleTpcXFwidXBcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3ZhciBpPWUucGFyZW50KCkuc2libGluZ3MoKSxuPXRoaXMscz10aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQ/aS5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIik6ZS5wYXJlbnQoKS5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIik7KHRoaXMub3B0aW9ucy5hbGxvd0FsbENsb3NlZHx8cykmJihlLnNsaWRlVXAobi5vcHRpb25zLnNsaWRlU3BlZWQsZnVuY3Rpb24oKXtuLiRlbGVtZW50LnRyaWdnZXIoXFxcInVwLnpmLmFjY29yZGlvblxcXCIsW2VdKTt9KSxlLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMCkucGFyZW50KCkucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLHQoXFxcIiNcXFwiK2UuYXR0cihcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIikpLmF0dHIoe1xcXCJhcmlhLWV4cGFuZGVkXFxcIjohMSxcXFwiYXJpYS1zZWxlY3RlZFxcXCI6ITF9KSk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLXRhYi1jb250ZW50XVxcXCIpLnNsaWRlVXAoMCkuY3NzKFxcXCJkaXNwbGF5XFxcIixcXFwiXFxcIiksdGhpcy4kZWxlbWVudC5maW5kKFxcXCJhXFxcIikub2ZmKFxcXCIuemYuYWNjb3JkaW9uXFxcIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17c2xpZGVTcGVlZDoyNTAsbXVsdGlFeHBhbmQ6ITEsYWxsb3dBbGxDbG9zZWQ6ITF9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIkFjY29yZGlvblxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksRm91bmRhdGlvbi5OZXN0LkZlYXRoZXIodGhpcy4kZWxlbWVudCxcXFwiYWNjb3JkaW9uXFxcIiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiQWNjb3JkaW9uTWVudVxcXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIkFjY29yZGlvbk1lbnVcXFwiLHtFTlRFUjpcXFwidG9nZ2xlXFxcIixTUEFDRTpcXFwidG9nZ2xlXFxcIixBUlJPV19SSUdIVDpcXFwib3BlblxcXCIsQVJST1dfVVA6XFxcInVwXFxcIixBUlJPV19ET1dOOlxcXCJkb3duXFxcIixBUlJPV19MRUZUOlxcXCJjbG9zZVxcXCIsRVNDQVBFOlxcXCJjbG9zZUFsbFxcXCIsVEFCOlxcXCJkb3duXFxcIixTSElGVF9UQUI6XFxcInVwXFxcIn0pO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5ub3QoXFxcIi5pcy1hY3RpdmVcXFwiKS5zbGlkZVVwKDApLHRoaXMuJGVsZW1lbnQuYXR0cih7cm9sZTpcXFwidGFibGlzdFxcXCIsXFxcImFyaWEtbXVsdGlzZWxlY3RhYmxlXFxcIjp0aGlzLm9wdGlvbnMubXVsdGlPcGVufSksdGhpcy4kbWVudUxpbmtzPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLmlzLWFjY29yZGlvbi1zdWJtZW51LXBhcmVudFxcXCIpLHRoaXMuJG1lbnVMaW5rcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5pZHx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJhY2MtbWVudS1saW5rXFxcIiksaT10KHRoaXMpLG49aS5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKSxzPW5bMF0uaWR8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNixcXFwiYWNjLW1lbnVcXFwiKSxvPW4uaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpO2kuYXR0cih7XFxcImFyaWEtY29udHJvbHNcXFwiOnMsXFxcImFyaWEtZXhwYW5kZWRcXFwiOm8scm9sZTpcXFwidGFiXFxcIixpZDplfSksbi5hdHRyKHtcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIjplLFxcXCJhcmlhLWhpZGRlblxcXCI6IW8scm9sZTpcXFwidGFicGFuZWxcXFwiLGlkOnN9KTt9KTt2YXIgZT10aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5pcy1hY3RpdmVcXFwiKTtpZihlLmxlbmd0aCl7dmFyIGk9dGhpcztlLmVhY2goZnVuY3Rpb24oKXtpLmRvd24odCh0aGlzKSk7fSk7fXRoaXMuX2V2ZW50cygpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpczt0aGlzLiRlbGVtZW50LmZpbmQoXFxcImxpXFxcIikuZWFjaChmdW5jdGlvbigpe3ZhciBpPXQodGhpcykuY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdXFxcIik7aS5sZW5ndGgmJnQodGhpcykuY2hpbGRyZW4oXFxcImFcXFwiKS5vZmYoXFxcImNsaWNrLnpmLmFjY29yZGlvbk1lbnVcXFwiKS5vbihcXFwiY2xpY2suemYuYWNjb3JkaW9uTWVudVxcXCIsZnVuY3Rpb24odCl7dC5wcmV2ZW50RGVmYXVsdCgpLGUudG9nZ2xlKGkpO30pO30pLm9uKFxcXCJrZXlkb3duLnpmLmFjY29yZGlvbm1lbnVcXFwiLGZ1bmN0aW9uKGkpe3ZhciBuLHMsbz10KHRoaXMpLGE9by5wYXJlbnQoXFxcInVsXFxcIikuY2hpbGRyZW4oXFxcImxpXFxcIikscj1vLmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpO2EuZWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdCh0aGlzKS5pcyhvKT8obj1hLmVxKE1hdGgubWF4KDAsZS0xKSkscz1hLmVxKE1hdGgubWluKGUrMSxhLmxlbmd0aC0xKSksdCh0aGlzKS5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV06dmlzaWJsZVxcXCIpLmxlbmd0aCYmKHM9by5maW5kKFxcXCJsaTpmaXJzdC1jaGlsZFxcXCIpKSx0KHRoaXMpLmlzKFxcXCI6Zmlyc3QtY2hpbGRcXFwiKT9uPW8ucGFyZW50cyhcXFwibGlcXFwiKS5maXJzdCgpOm4uY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdOnZpc2libGVcXFwiKS5sZW5ndGgmJihuPW4uZmluZChcXFwibGk6bGFzdC1jaGlsZFxcXCIpKSx2b2lkKHQodGhpcykuaXMoXFxcIjpsYXN0LWNoaWxkXFxcIikmJihzPW8ucGFyZW50cyhcXFwibGlcXFwiKS5maXJzdCgpLm5leHQoXFxcImxpXFxcIikpKSk6dm9pZCAwO30pLEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGksXFxcIkFjY29yZGlvbk1lbnVcXFwiLHtvcGVuOmZ1bmN0aW9uIG9wZW4oKXtyLmlzKFxcXCI6aGlkZGVuXFxcIikmJihlLmRvd24ociksci5maW5kKFxcXCJsaVxcXCIpLmZpcnN0KCkuZm9jdXMoKSk7fSxjbG9zZTpmdW5jdGlvbiBjbG9zZSgpe3IubGVuZ3RoJiYhci5pcyhcXFwiOmhpZGRlblxcXCIpP2UudXAocik6by5wYXJlbnQoXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikubGVuZ3RoJiYoZS51cChvLnBhcmVudChcXFwiW2RhdGEtc3VibWVudV1cXFwiKSksby5wYXJlbnRzKFxcXCJsaVxcXCIpLmZpcnN0KCkuZm9jdXMoKSk7fSx1cDpmdW5jdGlvbiB1cCgpe24uZm9jdXMoKTt9LGRvd246ZnVuY3Rpb24gZG93bigpe3MuZm9jdXMoKTt9LHRvZ2dsZTpmdW5jdGlvbiB0b2dnbGUoKXtvLmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLmxlbmd0aCYmZS50b2dnbGUoby5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKSk7fSxjbG9zZUFsbDpmdW5jdGlvbiBjbG9zZUFsbCgpe2UuaGlkZUFsbCgpO30saGFuZGxlZDpmdW5jdGlvbiBoYW5kbGVkKCl7aS5wcmV2ZW50RGVmYXVsdCgpLGkuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7fX0pO30pO319LHtrZXk6XFxcImhpZGVBbGxcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLnNsaWRlVXAodGhpcy5vcHRpb25zLnNsaWRlU3BlZWQpO319LHtrZXk6XFxcInRvZ2dsZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dC5pcyhcXFwiOmFuaW1hdGVkXFxcIil8fCh0LmlzKFxcXCI6aGlkZGVuXFxcIik/dGhpcy5kb3duKHQpOnRoaXMudXAodCkpO319LHtrZXk6XFxcImRvd25cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXRoaXM7dGhpcy5vcHRpb25zLm11bHRpT3Blbnx8dGhpcy51cCh0aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5pcy1hY3RpdmVcXFwiKS5ub3QodC5wYXJlbnRzVW50aWwodGhpcy4kZWxlbWVudCkuYWRkKHQpKSksdC5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikuYXR0cih7XFxcImFyaWEtaGlkZGVuXFxcIjohMX0pLnBhcmVudChcXFwiLmlzLWFjY29yZGlvbi1zdWJtZW51LXBhcmVudFxcXCIpLmF0dHIoe1xcXCJhcmlhLWV4cGFuZGVkXFxcIjohMH0pLEZvdW5kYXRpb24uTW92ZSh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCx0LGZ1bmN0aW9uKCl7dC5zbGlkZURvd24oZS5vcHRpb25zLnNsaWRlU3BlZWQsZnVuY3Rpb24oKXtlLiRlbGVtZW50LnRyaWdnZXIoXFxcImRvd24uemYuYWNjb3JkaW9uTWVudVxcXCIsW3RdKTt9KTt9KTt9fSx7a2V5OlxcXCJ1cFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpcztGb3VuZGF0aW9uLk1vdmUodGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsdCxmdW5jdGlvbigpe3Quc2xpZGVVcChlLm9wdGlvbnMuc2xpZGVTcGVlZCxmdW5jdGlvbigpe2UuJGVsZW1lbnQudHJpZ2dlcihcXFwidXAuemYuYWNjb3JkaW9uTWVudVxcXCIsW3RdKTt9KTt9KTt2YXIgaT10LmZpbmQoXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikuc2xpZGVVcCgwKS5hZGRCYWNrKCkuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCEwKTtpLnBhcmVudChcXFwiLmlzLWFjY29yZGlvbi1zdWJtZW51LXBhcmVudFxcXCIpLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCExKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5zbGlkZURvd24oMCkuY3NzKFxcXCJkaXNwbGF5XFxcIixcXFwiXFxcIiksdGhpcy4kZWxlbWVudC5maW5kKFxcXCJhXFxcIikub2ZmKFxcXCJjbGljay56Zi5hY2NvcmRpb25NZW51XFxcIiksRm91bmRhdGlvbi5OZXN0LkJ1cm4odGhpcy4kZWxlbWVudCxcXFwiYWNjb3JkaW9uXFxcIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17c2xpZGVTcGVlZDoyNTAsbXVsdGlPcGVuOiEwfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJBY2NvcmRpb25NZW51XFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSxGb3VuZGF0aW9uLk5lc3QuRmVhdGhlcih0aGlzLiRlbGVtZW50LFxcXCJkcmlsbGRvd25cXFwiKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJEcmlsbGRvd25cXFwiKSxGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKFxcXCJEcmlsbGRvd25cXFwiLHtFTlRFUjpcXFwib3BlblxcXCIsU1BBQ0U6XFxcIm9wZW5cXFwiLEFSUk9XX1JJR0hUOlxcXCJuZXh0XFxcIixBUlJPV19VUDpcXFwidXBcXFwiLEFSUk9XX0RPV046XFxcImRvd25cXFwiLEFSUk9XX0xFRlQ6XFxcInByZXZpb3VzXFxcIixFU0NBUEU6XFxcImNsb3NlXFxcIixUQUI6XFxcImRvd25cXFwiLFNISUZUX1RBQjpcXFwidXBcXFwifSk7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kc3VibWVudUFuY2hvcnM9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJsaS5pcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnRcXFwiKSx0aGlzLiRzdWJtZW51cz10aGlzLiRzdWJtZW51QW5jaG9ycy5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKSx0aGlzLiRtZW51SXRlbXM9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJsaVxcXCIpLm5vdChcXFwiLmpzLWRyaWxsZG93bi1iYWNrXFxcIikuYXR0cihcXFwicm9sZVxcXCIsXFxcIm1lbnVpdGVtXFxcIiksdGhpcy5fcHJlcGFyZU1lbnUoKSx0aGlzLl9rZXlib2FyZEV2ZW50cygpO319LHtrZXk6XFxcIl9wcmVwYXJlTWVudVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3RoaXMuJHN1Ym1lbnVBbmNob3JzLmVhY2goZnVuY3Rpb24oKXt2YXIgaT10KHRoaXMpLG49aS5maW5kKFxcXCJhOmZpcnN0XFxcIik7ZS5vcHRpb25zLnBhcmVudExpbmsmJm4uY2xvbmUoKS5wcmVwZW5kVG8oaS5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKSkud3JhcCgnPGxpIGNsYXNzPVxcXCJpcy1zdWJtZW51LXBhcmVudC1pdGVtIGlzLXN1Ym1lbnUtaXRlbSBpcy1kcmlsbGRvd24tc3VibWVudS1pdGVtXFxcIiByb2xlPVxcXCJtZW51LWl0ZW1cXFwiPjwvbGk+Jyksbi5kYXRhKFxcXCJzYXZlZEhyZWZcXFwiLG4uYXR0cihcXFwiaHJlZlxcXCIpKS5yZW1vdmVBdHRyKFxcXCJocmVmXFxcIiksaS5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOiEwLHRhYmluZGV4OjAscm9sZTpcXFwibWVudVxcXCJ9KSxlLl9ldmVudHMoaSk7fSksdGhpcy4kc3VibWVudXMuZWFjaChmdW5jdGlvbigpe3ZhciBpPXQodGhpcyksbj1pLmZpbmQoXFxcIi5qcy1kcmlsbGRvd24tYmFja1xcXCIpO24ubGVuZ3RofHxpLnByZXBlbmQoZS5vcHRpb25zLmJhY2tCdXR0b24pLGUuX2JhY2soaSk7fSksdGhpcy4kZWxlbWVudC5wYXJlbnQoKS5oYXNDbGFzcyhcXFwiaXMtZHJpbGxkb3duXFxcIil8fCh0aGlzLiR3cmFwcGVyPXQodGhpcy5vcHRpb25zLndyYXBwZXIpLmFkZENsYXNzKFxcXCJpcy1kcmlsbGRvd25cXFwiKS5jc3ModGhpcy5fZ2V0TWF4RGltcygpKSx0aGlzLiRlbGVtZW50LndyYXAodGhpcy4kd3JhcHBlcikpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3ZhciBpPXRoaXM7ZS5vZmYoXFxcImNsaWNrLnpmLmRyaWxsZG93blxcXCIpLm9uKFxcXCJjbGljay56Zi5kcmlsbGRvd25cXFwiLGZ1bmN0aW9uKG4pe2lmKHQobi50YXJnZXQpLnBhcmVudHNVbnRpbChcXFwidWxcXFwiLFxcXCJsaVxcXCIpLmhhc0NsYXNzKFxcXCJpcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnRcXFwiKSYmKG4uc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksbi5wcmV2ZW50RGVmYXVsdCgpKSxpLl9zaG93KGUpLGkub3B0aW9ucy5jbG9zZU9uQ2xpY2spe3ZhciBzPXQoXFxcImJvZHlcXFwiKS5ub3QoaS4kd3JhcHBlcik7cy5vZmYoXFxcIi56Zi5kcmlsbGRvd25cXFwiKS5vbihcXFwiY2xpY2suemYuZHJpbGxkb3duXFxcIixmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCksaS5faGlkZUFsbCgpLHMub2ZmKFxcXCIuemYuZHJpbGxkb3duXFxcIik7fSk7fX0pO319LHtrZXk6XFxcIl9rZXlib2FyZEV2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3RoaXMuJG1lbnVJdGVtcy5hZGQodGhpcy4kZWxlbWVudC5maW5kKFxcXCIuanMtZHJpbGxkb3duLWJhY2tcXFwiKSkub24oXFxcImtleWRvd24uemYuZHJpbGxkb3duXFxcIixmdW5jdGlvbihpKXt2YXIgbixzLG89dCh0aGlzKSxhPW8ucGFyZW50KFxcXCJ1bFxcXCIpLmNoaWxkcmVuKFxcXCJsaVxcXCIpO2EuZWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdCh0aGlzKS5pcyhvKT8obj1hLmVxKE1hdGgubWF4KDAsZS0xKSksdm9pZChzPWEuZXEoTWF0aC5taW4oZSsxLGEubGVuZ3RoLTEpKSkpOnZvaWQgMDt9KSxGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShpLFxcXCJEcmlsbGRvd25cXFwiLHtuZXh0OmZ1bmN0aW9uIG5leHQoKXtvLmlzKGUuJHN1Ym1lbnVBbmNob3JzKSYmKGUuX3Nob3cobyksby5vbihGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQobyksZnVuY3Rpb24oKXtvLmZpbmQoXFxcInVsIGxpXFxcIikuZmlsdGVyKGUuJG1lbnVJdGVtcykuZmlyc3QoKS5mb2N1cygpO30pKTt9LHByZXZpb3VzOmZ1bmN0aW9uIHByZXZpb3VzKCl7ZS5faGlkZShvLnBhcmVudChcXFwidWxcXFwiKSksby5wYXJlbnQoXFxcInVsXFxcIikub24oRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKG8pLGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe28ucGFyZW50KFxcXCJ1bFxcXCIpLnBhcmVudChcXFwibGlcXFwiKS5mb2N1cygpO30sMSk7fSk7fSx1cDpmdW5jdGlvbiB1cCgpe24uZm9jdXMoKTt9LGRvd246ZnVuY3Rpb24gZG93bigpe3MuZm9jdXMoKTt9LGNsb3NlOmZ1bmN0aW9uIGNsb3NlKCl7ZS5fYmFjaygpO30sb3BlbjpmdW5jdGlvbiBvcGVuKCl7by5pcyhlLiRtZW51SXRlbXMpP28uaXMoZS4kc3VibWVudUFuY2hvcnMpJiYoZS5fc2hvdyhvKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7by5maW5kKFxcXCJ1bCBsaVxcXCIpLmZpbHRlcihlLiRtZW51SXRlbXMpLmZpcnN0KCkuZm9jdXMoKTt9LDEpKTooZS5faGlkZShvLnBhcmVudChcXFwidWxcXFwiKSksc2V0VGltZW91dChmdW5jdGlvbigpe28ucGFyZW50KFxcXCJ1bFxcXCIpLnBhcmVudChcXFwibGlcXFwiKS5mb2N1cygpO30sMSkpO30saGFuZGxlZDpmdW5jdGlvbiBoYW5kbGVkKCl7aS5wcmV2ZW50RGVmYXVsdCgpLGkuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7fX0pO30pO319LHtrZXk6XFxcIl9oaWRlQWxsXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLmlzLWRyaWxsZG93bi1zdWJtZW51LmlzLWFjdGl2ZVxcXCIpLmFkZENsYXNzKFxcXCJpcy1jbG9zaW5nXFxcIik7dC5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKHQpLGZ1bmN0aW9uKGUpe3QucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZSBpcy1jbG9zaW5nXFxcIik7fSksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJjbG9zZWQuemYuZHJpbGxkb3duXFxcIik7fX0se2tleTpcXFwiX2JhY2tcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXRoaXM7dC5vZmYoXFxcImNsaWNrLnpmLmRyaWxsZG93blxcXCIpLHQuY2hpbGRyZW4oXFxcIi5qcy1kcmlsbGRvd24tYmFja1xcXCIpLm9uKFxcXCJjbGljay56Zi5kcmlsbGRvd25cXFwiLGZ1bmN0aW9uKGkpe2kuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksZS5faGlkZSh0KTt9KTt9fSx7a2V5OlxcXCJfbWVudUxpbmtFdmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpczt0aGlzLiRtZW51SXRlbXMubm90KFxcXCIuaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50XFxcIikub2ZmKFxcXCJjbGljay56Zi5kcmlsbGRvd25cXFwiKS5vbihcXFwiY2xpY2suemYuZHJpbGxkb3duXFxcIixmdW5jdGlvbihlKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dC5faGlkZUFsbCgpO30sMCk7fSk7fX0se2tleTpcXFwiX3Nob3dcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3QuY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwib3Blbi56Zi5kcmlsbGRvd25cXFwiLFt0XSk7fX0se2tleTpcXFwiX2hpZGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3QuYWRkQ2xhc3MoXFxcImlzLWNsb3NpbmdcXFwiKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKHQpLGZ1bmN0aW9uKCl7dC5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlIGlzLWNsb3NpbmdcXFwiKSx0LmJsdXIoKTt9KSx0LnRyaWdnZXIoXFxcImhpZGUuemYuZHJpbGxkb3duXFxcIixbdF0pO319LHtrZXk6XFxcIl9nZXRNYXhEaW1zXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPTAsaT17fTtyZXR1cm4gdGhpcy4kc3VibWVudXMuYWRkKHRoaXMuJGVsZW1lbnQpLmVhY2goZnVuY3Rpb24oKXt2YXIgaT10KHRoaXMpLmNoaWxkcmVuKFxcXCJsaVxcXCIpLmxlbmd0aDtlPWk+ZT9pOmU7fSksaVtcXFwibWluLWhlaWdodFxcXCJdPWUqdGhpcy4kbWVudUl0ZW1zWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCtcXFwicHhcXFwiLGlbXFxcIm1heC13aWR0aFxcXCJdPXRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgrXFxcInB4XFxcIixpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5faGlkZUFsbCgpLEZvdW5kYXRpb24uTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsXFxcImRyaWxsZG93blxcXCIpLHRoaXMuJGVsZW1lbnQudW53cmFwKCkuZmluZChcXFwiLmpzLWRyaWxsZG93bi1iYWNrLCAuaXMtc3VibWVudS1wYXJlbnQtaXRlbVxcXCIpLnJlbW92ZSgpLmVuZCgpLmZpbmQoXFxcIi5pcy1hY3RpdmUsIC5pcy1jbG9zaW5nLCAuaXMtZHJpbGxkb3duLXN1Ym1lbnVcXFwiKS5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlIGlzLWNsb3NpbmcgaXMtZHJpbGxkb3duLXN1Ym1lbnVcXFwiKS5lbmQoKS5maW5kKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtaGlkZGVuIHRhYmluZGV4IHJvbGVcXFwiKS5vZmYoXFxcIi56Zi5kcmlsbGRvd25cXFwiKS5lbmQoKS5vZmYoXFxcInpmLmRyaWxsZG93blxcXCIpLHRoaXMuJGVsZW1lbnQuZmluZChcXFwiYVxcXCIpLmVhY2goZnVuY3Rpb24oKXt2YXIgZT10KHRoaXMpO2UuZGF0YShcXFwic2F2ZWRIcmVmXFxcIikmJmUuYXR0cihcXFwiaHJlZlxcXCIsZS5kYXRhKFxcXCJzYXZlZEhyZWZcXFwiKSkucmVtb3ZlRGF0YShcXFwic2F2ZWRIcmVmXFxcIik7fSksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17YmFja0J1dHRvbjonPGxpIGNsYXNzPVxcXCJqcy1kcmlsbGRvd24tYmFja1xcXCI+PGE+QmFjazwvYT48L2xpPicsd3JhcHBlcjpcXFwiPGRpdj48L2Rpdj5cXFwiLHBhcmVudExpbms6ITEsY2xvc2VPbkNsaWNrOiExfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJEcmlsbGRvd25cXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIkRyb3Bkb3duXFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiRHJvcGRvd25cXFwiLHtFTlRFUjpcXFwib3BlblxcXCIsU1BBQ0U6XFxcIm9wZW5cXFwiLEVTQ0FQRTpcXFwiY2xvc2VcXFwiLFRBQjpcXFwidGFiX2ZvcndhcmRcXFwiLFNISUZUX1RBQjpcXFwidGFiX2JhY2t3YXJkXFxcIn0pO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXMuJGVsZW1lbnQuYXR0cihcXFwiaWRcXFwiKTt0aGlzLiRhbmNob3I9dCgnW2RhdGEtdG9nZ2xlPVxcXCInK2UrJ1xcXCJdJyl8fHQoJ1tkYXRhLW9wZW49XFxcIicrZSsnXFxcIl0nKSx0aGlzLiRhbmNob3IuYXR0cih7XFxcImFyaWEtY29udHJvbHNcXFwiOmUsXFxcImRhdGEtaXMtZm9jdXNcXFwiOiExLFxcXCJkYXRhLXlldGktYm94XFxcIjplLFxcXCJhcmlhLWhhc3BvcHVwXFxcIjohMCxcXFwiYXJpYS1leHBhbmRlZFxcXCI6ITF9KSx0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcz10aGlzLmdldFBvc2l0aW9uQ2xhc3MoKSx0aGlzLmNvdW50ZXI9NCx0aGlzLnVzZWRQb3NpdGlvbnM9W10sdGhpcy4kZWxlbWVudC5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOlxcXCJ0cnVlXFxcIixcXFwiZGF0YS15ZXRpLWJveFxcXCI6ZSxcXFwiZGF0YS1yZXNpemVcXFwiOmUsXFxcImFyaWEtbGFiZWxsZWRieVxcXCI6dGhpcy4kYW5jaG9yWzBdLmlkfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXFxcImRkLWFuY2hvclxcXCIpfSksdGhpcy5fZXZlbnRzKCk7fX0se2tleTpcXFwiZ2V0UG9zaXRpb25DbGFzc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZS5tYXRjaCgvXFxcXGIodG9wfGxlZnR8cmlnaHQpXFxcXGIvZyk7cmV0dXJuIHQ9dD90WzBdOlxcXCJcXFwiO319LHtrZXk6XFxcIl9yZXBvc2l0aW9uXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt0aGlzLnVzZWRQb3NpdGlvbnMucHVzaCh0P3Q6XFxcImJvdHRvbVxcXCIpLCF0JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwidG9wXFxcIik8MD90aGlzLiRlbGVtZW50LmFkZENsYXNzKFxcXCJ0b3BcXFwiKTpcXFwidG9wXFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJib3R0b21cXFwiKTwwP3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCk6XFxcImxlZnRcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcInJpZ2h0XFxcIik8MD90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHQpLmFkZENsYXNzKFxcXCJyaWdodFxcXCIpOlxcXCJyaWdodFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwibGVmdFxcXCIpPDA/dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0KS5hZGRDbGFzcyhcXFwibGVmdFxcXCIpOiF0JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwidG9wXFxcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIik8MD90aGlzLiRlbGVtZW50LmFkZENsYXNzKFxcXCJsZWZ0XFxcIik6XFxcInRvcFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwiYm90dG9tXFxcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIik8MD90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHQpLmFkZENsYXNzKFxcXCJsZWZ0XFxcIik6XFxcImxlZnRcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcInJpZ2h0XFxcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJib3R0b21cXFwiKTwwP3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCk6XFxcInJpZ2h0XFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJib3R0b21cXFwiKTwwP3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCk6dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0KSx0aGlzLmNsYXNzQ2hhbmdlZD0hMCx0aGlzLmNvdW50ZXItLTt9fSx7a2V5OlxcXCJfc2V0UG9zaXRpb25cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7aWYoXFxcImZhbHNlXFxcIj09PXRoaXMuJGFuY2hvci5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIikpcmV0dXJuITE7dmFyIHQ9dGhpcy5nZXRQb3NpdGlvbkNsYXNzKCksZT1Gb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMuJGVsZW1lbnQpLGk9KEZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy4kYW5jaG9yKSxcXFwibGVmdFxcXCI9PT10P1xcXCJsZWZ0XFxcIjpcXFwicmlnaHRcXFwiPT09dD9cXFwibGVmdFxcXCI6XFxcInRvcFxcXCIpLG49XFxcInRvcFxcXCI9PT1pP1xcXCJoZWlnaHRcXFwiOlxcXCJ3aWR0aFxcXCI7XFxcImhlaWdodFxcXCI9PT1uP3RoaXMub3B0aW9ucy52T2Zmc2V0OnRoaXMub3B0aW9ucy5oT2Zmc2V0O2lmKGUud2lkdGg+PWUud2luZG93RGltcy53aWR0aHx8IXRoaXMuY291bnRlciYmIUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy4kZWxlbWVudCkpcmV0dXJuIHRoaXMuJGVsZW1lbnQub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy4kZWxlbWVudCx0aGlzLiRhbmNob3IsXFxcImNlbnRlciBib3R0b21cXFwiLHRoaXMub3B0aW9ucy52T2Zmc2V0LHRoaXMub3B0aW9ucy5oT2Zmc2V0LCEwKSkuY3NzKHt3aWR0aDplLndpbmRvd0RpbXMud2lkdGgtMip0aGlzLm9wdGlvbnMuaE9mZnNldCxoZWlnaHQ6XFxcImF1dG9cXFwifSksdGhpcy5jbGFzc0NoYW5nZWQ9ITAsITE7Zm9yKHRoaXMuJGVsZW1lbnQub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy4kZWxlbWVudCx0aGlzLiRhbmNob3IsdCx0aGlzLm9wdGlvbnMudk9mZnNldCx0aGlzLm9wdGlvbnMuaE9mZnNldCkpOyFGb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KHRoaXMuJGVsZW1lbnQpJiZ0aGlzLmNvdW50ZXI7KXt0aGlzLl9yZXBvc2l0aW9uKHQpLHRoaXMuX3NldFBvc2l0aW9uKCk7fX19LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpczt0aGlzLiRlbGVtZW50Lm9uKHtcXFwib3Blbi56Zi50cmlnZ2VyXFxcIjp0aGlzLm9wZW4uYmluZCh0aGlzKSxcXFwiY2xvc2UuemYudHJpZ2dlclxcXCI6dGhpcy5jbG9zZS5iaW5kKHRoaXMpLFxcXCJ0b2dnbGUuemYudHJpZ2dlclxcXCI6dGhpcy50b2dnbGUuYmluZCh0aGlzKSxcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCI6dGhpcy5fc2V0UG9zaXRpb24uYmluZCh0aGlzKX0pLHRoaXMub3B0aW9ucy5ob3ZlciYmKHRoaXMuJGFuY2hvci5vZmYoXFxcIm1vdXNlZW50ZXIuemYuZHJvcGRvd24gbW91c2VsZWF2ZS56Zi5kcm9wZG93blxcXCIpLm9uKFxcXCJtb3VzZWVudGVyLnpmLmRyb3Bkb3duXFxcIixmdW5jdGlvbigpe2NsZWFyVGltZW91dChlLnRpbWVvdXQpLGUudGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5vcGVuKCksZS4kYW5jaG9yLmRhdGEoXFxcImhvdmVyXFxcIiwhMCk7fSxlLm9wdGlvbnMuaG92ZXJEZWxheSk7fSkub24oXFxcIm1vdXNlbGVhdmUuemYuZHJvcGRvd25cXFwiLGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGUudGltZW91dCksZS50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLmNsb3NlKCksZS4kYW5jaG9yLmRhdGEoXFxcImhvdmVyXFxcIiwhMSk7fSxlLm9wdGlvbnMuaG92ZXJEZWxheSk7fSksdGhpcy5vcHRpb25zLmhvdmVyUGFuZSYmdGhpcy4kZWxlbWVudC5vZmYoXFxcIm1vdXNlZW50ZXIuemYuZHJvcGRvd24gbW91c2VsZWF2ZS56Zi5kcm9wZG93blxcXCIpLm9uKFxcXCJtb3VzZWVudGVyLnpmLmRyb3Bkb3duXFxcIixmdW5jdGlvbigpe2NsZWFyVGltZW91dChlLnRpbWVvdXQpO30pLm9uKFxcXCJtb3VzZWxlYXZlLnpmLmRyb3Bkb3duXFxcIixmdW5jdGlvbigpe2NsZWFyVGltZW91dChlLnRpbWVvdXQpLGUudGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5jbG9zZSgpLGUuJGFuY2hvci5kYXRhKFxcXCJob3ZlclxcXCIsITEpO30sZS5vcHRpb25zLmhvdmVyRGVsYXkpO30pKSx0aGlzLiRhbmNob3IuYWRkKHRoaXMuJGVsZW1lbnQpLm9uKFxcXCJrZXlkb3duLnpmLmRyb3Bkb3duXFxcIixmdW5jdGlvbihpKXt2YXIgbj10KHRoaXMpLHM9Rm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKGUuJGVsZW1lbnQpO0ZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGksXFxcIkRyb3Bkb3duXFxcIix7dGFiX2ZvcndhcmQ6ZnVuY3Rpb24gdGFiX2ZvcndhcmQoKXtlLiRlbGVtZW50LmZpbmQoXFxcIjpmb2N1c1xcXCIpLmlzKHMuZXEoLTEpKSYmKGUub3B0aW9ucy50cmFwRm9jdXM/KHMuZXEoMCkuZm9jdXMoKSxpLnByZXZlbnREZWZhdWx0KCkpOmUuY2xvc2UoKSk7fSx0YWJfYmFja3dhcmQ6ZnVuY3Rpb24gdGFiX2JhY2t3YXJkKCl7KGUuJGVsZW1lbnQuZmluZChcXFwiOmZvY3VzXFxcIikuaXMocy5lcSgwKSl8fGUuJGVsZW1lbnQuaXMoXFxcIjpmb2N1c1xcXCIpKSYmKGUub3B0aW9ucy50cmFwRm9jdXM/KHMuZXEoLTEpLmZvY3VzKCksaS5wcmV2ZW50RGVmYXVsdCgpKTplLmNsb3NlKCkpO30sb3BlbjpmdW5jdGlvbiBvcGVuKCl7bi5pcyhlLiRhbmNob3IpJiYoZS5vcGVuKCksZS4kZWxlbWVudC5hdHRyKFxcXCJ0YWJpbmRleFxcXCIsLTEpLmZvY3VzKCksaS5wcmV2ZW50RGVmYXVsdCgpKTt9LGNsb3NlOmZ1bmN0aW9uIGNsb3NlKCl7ZS5jbG9zZSgpLGUuJGFuY2hvci5mb2N1cygpO319KTt9KTt9fSx7a2V5OlxcXCJfYWRkQm9keUhhbmRsZXJcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dChkb2N1bWVudC5ib2R5KS5ub3QodGhpcy4kZWxlbWVudCksaT10aGlzO2Uub2ZmKFxcXCJjbGljay56Zi5kcm9wZG93blxcXCIpLm9uKFxcXCJjbGljay56Zi5kcm9wZG93blxcXCIsZnVuY3Rpb24odCl7aS4kYW5jaG9yLmlzKHQudGFyZ2V0KXx8aS4kYW5jaG9yLmZpbmQodC50YXJnZXQpLmxlbmd0aHx8aS4kZWxlbWVudC5maW5kKHQudGFyZ2V0KS5sZW5ndGh8fChpLmNsb3NlKCksZS5vZmYoXFxcImNsaWNrLnpmLmRyb3Bkb3duXFxcIikpO30pO319LHtrZXk6XFxcIm9wZW5cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7aWYodGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJjbG9zZW1lLnpmLmRyb3Bkb3duXFxcIix0aGlzLiRlbGVtZW50LmF0dHIoXFxcImlkXFxcIikpLHRoaXMuJGFuY2hvci5hZGRDbGFzcyhcXFwiaG92ZXJcXFwiKS5hdHRyKHtcXFwiYXJpYS1leHBhbmRlZFxcXCI6ITB9KSx0aGlzLl9zZXRQb3NpdGlvbigpLHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoXFxcImlzLW9wZW5cXFwiKS5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOiExfSksdGhpcy5vcHRpb25zLmF1dG9Gb2N1cyl7dmFyIHQ9Rm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKHRoaXMuJGVsZW1lbnQpO3QubGVuZ3RoJiZ0LmVxKDApLmZvY3VzKCk7fXRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2smJnRoaXMuX2FkZEJvZHlIYW5kbGVyKCksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJzaG93LnpmLmRyb3Bkb3duXFxcIixbdGhpcy4kZWxlbWVudF0pO319LHtrZXk6XFxcImNsb3NlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe2lmKCF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJpcy1vcGVuXFxcIikpcmV0dXJuITE7aWYodGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwiaXMtb3BlblxcXCIpLmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6ITB9KSx0aGlzLiRhbmNob3IucmVtb3ZlQ2xhc3MoXFxcImhvdmVyXFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsITEpLHRoaXMuY2xhc3NDaGFuZ2VkKXt2YXIgdD10aGlzLmdldFBvc2l0aW9uQ2xhc3MoKTt0JiZ0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHQpLHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MpLmNzcyh7aGVpZ2h0OlxcXCJcXFwiLHdpZHRoOlxcXCJcXFwifSksdGhpcy5jbGFzc0NoYW5nZWQ9ITEsdGhpcy5jb3VudGVyPTQsdGhpcy51c2VkUG9zaXRpb25zLmxlbmd0aD0wO310aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcImhpZGUuemYuZHJvcGRvd25cXFwiLFt0aGlzLiRlbGVtZW50XSk7fX0se2tleTpcXFwidG9nZ2xlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe2lmKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXFxcImlzLW9wZW5cXFwiKSl7aWYodGhpcy4kYW5jaG9yLmRhdGEoXFxcImhvdmVyXFxcIikpcmV0dXJuO3RoaXMuY2xvc2UoKTt9ZWxzZSB0aGlzLm9wZW4oKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQub2ZmKFxcXCIuemYudHJpZ2dlclxcXCIpLmhpZGUoKSx0aGlzLiRhbmNob3Iub2ZmKFxcXCIuemYuZHJvcGRvd25cXFwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtob3ZlckRlbGF5OjI1MCxob3ZlcjohMSxob3ZlclBhbmU6ITEsdk9mZnNldDoxLGhPZmZzZXQ6MSxwb3NpdGlvbkNsYXNzOlxcXCJcXFwiLHRyYXBGb2N1czohMSxhdXRvRm9jdXM6ITEsY2xvc2VPbkNsaWNrOiExfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJEcm9wZG93blxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksRm91bmRhdGlvbi5OZXN0LkZlYXRoZXIodGhpcy4kZWxlbWVudCxcXFwiZHJvcGRvd25cXFwiKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJEcm9wZG93bk1lbnVcXFwiKSxGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKFxcXCJEcm9wZG93bk1lbnVcXFwiLHtFTlRFUjpcXFwib3BlblxcXCIsU1BBQ0U6XFxcIm9wZW5cXFwiLEFSUk9XX1JJR0hUOlxcXCJuZXh0XFxcIixBUlJPV19VUDpcXFwidXBcXFwiLEFSUk9XX0RPV046XFxcImRvd25cXFwiLEFSUk9XX0xFRlQ6XFxcInByZXZpb3VzXFxcIixFU0NBUEU6XFxcImNsb3NlXFxcIn0pO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXMuJGVsZW1lbnQuZmluZChcXFwibGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcXFwiKTt0aGlzLiRlbGVtZW50LmNoaWxkcmVuKFxcXCIuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcXFwiKS5jaGlsZHJlbihcXFwiLmlzLWRyb3Bkb3duLXN1Ym1lbnVcXFwiKS5hZGRDbGFzcyhcXFwiZmlyc3Qtc3ViXFxcIiksdGhpcy4kbWVudUl0ZW1zPXRoaXMuJGVsZW1lbnQuZmluZCgnW3JvbGU9XFxcIm1lbnVpdGVtXFxcIl0nKSx0aGlzLiR0YWJzPXRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJ1tyb2xlPVxcXCJtZW51aXRlbVxcXCJdJyksdGhpcy4kdGFicy5maW5kKFxcXCJ1bC5pcy1kcm9wZG93bi1zdWJtZW51XFxcIikuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnZlcnRpY2FsQ2xhc3MpLHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLnJpZ2h0Q2xhc3MpfHxcXFwicmlnaHRcXFwiPT09dGhpcy5vcHRpb25zLmFsaWdubWVudHx8Rm91bmRhdGlvbi5ydGwoKT8odGhpcy5vcHRpb25zLmFsaWdubWVudD1cXFwicmlnaHRcXFwiLHQuYWRkQ2xhc3MoXFxcIm9wZW5zLWxlZnRcXFwiKSk6dC5hZGRDbGFzcyhcXFwib3BlbnMtcmlnaHRcXFwiKSx0aGlzLmNoYW5nZWQ9ITEsdGhpcy5fZXZlbnRzKCk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzLGk9XFxcIm9udG91Y2hzdGFydFxcXCJpbiB3aW5kb3d8fFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93Lm9udG91Y2hzdGFydCxuPVxcXCJpcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFxcXCI7KHRoaXMub3B0aW9ucy5jbGlja09wZW58fGkpJiZ0aGlzLiRtZW51SXRlbXMub24oXFxcImNsaWNrLnpmLmRyb3Bkb3dubWVudSB0b3VjaHN0YXJ0LnpmLmRyb3Bkb3dubWVudVxcXCIsZnVuY3Rpb24ocyl7dmFyIG89dChzLnRhcmdldCkucGFyZW50c1VudGlsKFxcXCJ1bFxcXCIsXFxcIi5cXFwiK24pLGE9by5oYXNDbGFzcyhuKSxyPVxcXCJ0cnVlXFxcIj09PW8uYXR0cihcXFwiZGF0YS1pcy1jbGlja1xcXCIpO28uY2hpbGRyZW4oXFxcIi5pcy1kcm9wZG93bi1zdWJtZW51XFxcIik7aWYoYSlpZihyKXtpZighZS5vcHRpb25zLmNsb3NlT25DbGlja3x8IWUub3B0aW9ucy5jbGlja09wZW4mJiFpfHxlLm9wdGlvbnMuZm9yY2VGb2xsb3cmJmkpcmV0dXJuO3Muc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkscy5wcmV2ZW50RGVmYXVsdCgpLGUuX2hpZGUobyk7fWVsc2Ugcy5wcmV2ZW50RGVmYXVsdCgpLHMuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksZS5fc2hvdyhvLmNoaWxkcmVuKFxcXCIuaXMtZHJvcGRvd24tc3VibWVudVxcXCIpKSxvLmFkZChvLnBhcmVudHNVbnRpbChlLiRlbGVtZW50LFxcXCIuXFxcIituKSkuYXR0cihcXFwiZGF0YS1pcy1jbGlja1xcXCIsITApO30pLHRoaXMub3B0aW9ucy5kaXNhYmxlSG92ZXJ8fHRoaXMuJG1lbnVJdGVtcy5vbihcXFwibW91c2VlbnRlci56Zi5kcm9wZG93bm1lbnVcXFwiLGZ1bmN0aW9uKGkpe2kuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7dmFyIHM9dCh0aGlzKSxvPXMuaGFzQ2xhc3Mobik7byYmKGNsZWFyVGltZW91dChlLmRlbGF5KSxlLmRlbGF5PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLl9zaG93KHMuY2hpbGRyZW4oXFxcIi5pcy1kcm9wZG93bi1zdWJtZW51XFxcIikpO30sZS5vcHRpb25zLmhvdmVyRGVsYXkpKTt9KS5vbihcXFwibW91c2VsZWF2ZS56Zi5kcm9wZG93bm1lbnVcXFwiLGZ1bmN0aW9uKGkpe3ZhciBzPXQodGhpcyksbz1zLmhhc0NsYXNzKG4pO2lmKG8mJmUub3B0aW9ucy5hdXRvY2xvc2Upe2lmKFxcXCJ0cnVlXFxcIj09PXMuYXR0cihcXFwiZGF0YS1pcy1jbGlja1xcXCIpJiZlLm9wdGlvbnMuY2xpY2tPcGVuKXJldHVybiExO2NsZWFyVGltZW91dChlLmRlbGF5KSxlLmRlbGF5PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLl9oaWRlKHMpO30sZS5vcHRpb25zLmNsb3NpbmdUaW1lKTt9fSksdGhpcy4kbWVudUl0ZW1zLm9uKFxcXCJrZXlkb3duLnpmLmRyb3Bkb3dubWVudVxcXCIsZnVuY3Rpb24oaSl7dmFyIG4scyxvPXQoaS50YXJnZXQpLnBhcmVudHNVbnRpbChcXFwidWxcXFwiLCdbcm9sZT1cXFwibWVudWl0ZW1cXFwiXScpLGE9ZS4kdGFicy5pbmRleChvKT4tMSxyPWE/ZS4kdGFiczpvLnNpYmxpbmdzKFxcXCJsaVxcXCIpLmFkZChvKTtyLmVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQodGhpcykuaXMobyk/KG49ci5lcShlLTEpLHZvaWQocz1yLmVxKGUrMSkpKTp2b2lkIDA7fSk7dmFyIGw9ZnVuY3Rpb24gbCgpe28uaXMoXFxcIjpsYXN0LWNoaWxkXFxcIil8fHMuY2hpbGRyZW4oXFxcImE6Zmlyc3RcXFwiKS5mb2N1cygpO30sdT1mdW5jdGlvbiB1KCl7bi5jaGlsZHJlbihcXFwiYTpmaXJzdFxcXCIpLmZvY3VzKCk7fSxkPWZ1bmN0aW9uIGQoKXt2YXIgdD1vLmNoaWxkcmVuKFxcXCJ1bC5pcy1kcm9wZG93bi1zdWJtZW51XFxcIik7dC5sZW5ndGgmJihlLl9zaG93KHQpLG8uZmluZChcXFwibGkgPiBhOmZpcnN0XFxcIikuZm9jdXMoKSk7fSxoPWZ1bmN0aW9uIGgoKXt2YXIgdD1vLnBhcmVudChcXFwidWxcXFwiKS5wYXJlbnQoXFxcImxpXFxcIik7dC5jaGlsZHJlbihcXFwiYTpmaXJzdFxcXCIpLmZvY3VzKCksZS5faGlkZSh0KTt9LGM9e29wZW46ZCxjbG9zZTpmdW5jdGlvbiBjbG9zZSgpe2UuX2hpZGUoZS4kZWxlbWVudCksZS4kbWVudUl0ZW1zLmZpbmQoXFxcImE6Zmlyc3RcXFwiKS5mb2N1cygpO30saGFuZGxlZDpmdW5jdGlvbiBoYW5kbGVkKCl7aS5wcmV2ZW50RGVmYXVsdCgpLGkuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7fX07YT9lLnZlcnRpY2FsP1xcXCJsZWZ0XFxcIj09PWUub3B0aW9ucy5hbGlnbm1lbnQ/dC5leHRlbmQoYyx7ZG93bjpsLHVwOnUsbmV4dDpkLHByZXZpb3VzOmh9KTp0LmV4dGVuZChjLHtkb3duOmwsdXA6dSxuZXh0OmgscHJldmlvdXM6ZH0pOnQuZXh0ZW5kKGMse25leHQ6bCxwcmV2aW91czp1LGRvd246ZCx1cDpofSk6XFxcImxlZnRcXFwiPT09ZS5vcHRpb25zLmFsaWdubWVudD90LmV4dGVuZChjLHtuZXh0OmQscHJldmlvdXM6aCxkb3duOmwsdXA6dX0pOnQuZXh0ZW5kKGMse25leHQ6aCxwcmV2aW91czpkLGRvd246bCx1cDp1fSksRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoaSxcXFwiRHJvcGRvd25NZW51XFxcIixjKTt9KTt9fSx7a2V5OlxcXCJfYWRkQm9keUhhbmRsZXJcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dChkb2N1bWVudC5ib2R5KSxpPXRoaXM7ZS5vZmYoXFxcIm1vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudVxcXCIpLm9uKFxcXCJtb3VzZXVwLnpmLmRyb3Bkb3dubWVudSB0b3VjaGVuZC56Zi5kcm9wZG93bm1lbnVcXFwiLGZ1bmN0aW9uKHQpe3ZhciBuPWkuJGVsZW1lbnQuZmluZCh0LnRhcmdldCk7bi5sZW5ndGh8fChpLl9oaWRlKCksZS5vZmYoXFxcIm1vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudVxcXCIpKTt9KTt9fSx7a2V5OlxcXCJfc2hvd1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGk9dGhpcy4kdGFicy5pbmRleCh0aGlzLiR0YWJzLmZpbHRlcihmdW5jdGlvbihpLG4pe3JldHVybiB0KG4pLmZpbmQoZSkubGVuZ3RoPjA7fSkpLG49ZS5wYXJlbnQoXFxcImxpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50XFxcIikuc2libGluZ3MoXFxcImxpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50XFxcIik7dGhpcy5faGlkZShuLGkpLGUuY3NzKFxcXCJ2aXNpYmlsaXR5XFxcIixcXFwiaGlkZGVuXFxcIikuYWRkQ2xhc3MoXFxcImpzLWRyb3Bkb3duLWFjdGl2ZVxcXCIpLmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6ITF9KS5wYXJlbnQoXFxcImxpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50XFxcIikuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLmF0dHIoe1xcXCJhcmlhLWV4cGFuZGVkXFxcIjohMH0pO3ZhciBzPUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UoZSxudWxsLCEwKTtpZighcyl7dmFyIG89XFxcImxlZnRcXFwiPT09dGhpcy5vcHRpb25zLmFsaWdubWVudD9cXFwiLXJpZ2h0XFxcIjpcXFwiLWxlZnRcXFwiLGE9ZS5wYXJlbnQoXFxcIi5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFxcXCIpO2EucmVtb3ZlQ2xhc3MoXFxcIm9wZW5zXFxcIitvKS5hZGRDbGFzcyhcXFwib3BlbnMtXFxcIit0aGlzLm9wdGlvbnMuYWxpZ25tZW50KSxzPUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UoZSxudWxsLCEwKSxzfHxhLnJlbW92ZUNsYXNzKFxcXCJvcGVucy1cXFwiK3RoaXMub3B0aW9ucy5hbGlnbm1lbnQpLmFkZENsYXNzKFxcXCJvcGVucy1pbm5lclxcXCIpLHRoaXMuY2hhbmdlZD0hMDt9ZS5jc3MoXFxcInZpc2liaWxpdHlcXFwiLFxcXCJcXFwiKSx0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrJiZ0aGlzLl9hZGRCb2R5SGFuZGxlcigpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwic2hvdy56Zi5kcm9wZG93bm1lbnVcXFwiLFtlXSk7fX0se2tleTpcXFwiX2hpZGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQsZSl7dmFyIGk7aT10JiZ0Lmxlbmd0aD90OnZvaWQgMCE9PWU/dGhpcy4kdGFicy5ub3QoZnVuY3Rpb24odCxpKXtyZXR1cm4gdD09PWU7fSk6dGhpcy4kZWxlbWVudDt2YXIgbj1pLmhhc0NsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKXx8aS5maW5kKFxcXCIuaXMtYWN0aXZlXFxcIikubGVuZ3RoPjA7aWYobil7aWYoaS5maW5kKFxcXCJsaS5pcy1hY3RpdmVcXFwiKS5hZGQoaSkuYXR0cih7XFxcImFyaWEtZXhwYW5kZWRcXFwiOiExLFxcXCJkYXRhLWlzLWNsaWNrXFxcIjohMX0pLnJlbW92ZUNsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKSxpLmZpbmQoXFxcInVsLmpzLWRyb3Bkb3duLWFjdGl2ZVxcXCIpLmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6ITB9KS5yZW1vdmVDbGFzcyhcXFwianMtZHJvcGRvd24tYWN0aXZlXFxcIiksdGhpcy5jaGFuZ2VkfHxpLmZpbmQoXFxcIm9wZW5zLWlubmVyXFxcIikubGVuZ3RoKXt2YXIgcz1cXFwibGVmdFxcXCI9PT10aGlzLm9wdGlvbnMuYWxpZ25tZW50P1xcXCJyaWdodFxcXCI6XFxcImxlZnRcXFwiO2kuZmluZChcXFwibGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcXFwiKS5hZGQoaSkucmVtb3ZlQ2xhc3MoXFxcIm9wZW5zLWlubmVyIG9wZW5zLVxcXCIrdGhpcy5vcHRpb25zLmFsaWdubWVudCkuYWRkQ2xhc3MoXFxcIm9wZW5zLVxcXCIrcyksdGhpcy5jaGFuZ2VkPSExO310aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcImhpZGUuemYuZHJvcGRvd25tZW51XFxcIixbaV0pO319fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJG1lbnVJdGVtcy5vZmYoXFxcIi56Zi5kcm9wZG93bm1lbnVcXFwiKS5yZW1vdmVBdHRyKFxcXCJkYXRhLWlzLWNsaWNrXFxcIikucmVtb3ZlQ2xhc3MoXFxcImlzLXJpZ2h0LWFycm93IGlzLWxlZnQtYXJyb3cgaXMtZG93bi1hcnJvdyBvcGVucy1yaWdodCBvcGVucy1sZWZ0IG9wZW5zLWlubmVyXFxcIiksdChkb2N1bWVudC5ib2R5KS5vZmYoXFxcIi56Zi5kcm9wZG93bm1lbnVcXFwiKSxGb3VuZGF0aW9uLk5lc3QuQnVybih0aGlzLiRlbGVtZW50LFxcXCJkcm9wZG93blxcXCIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e2Rpc2FibGVIb3ZlcjohMSxhdXRvY2xvc2U6ITAsaG92ZXJEZWxheTo1MCxjbGlja09wZW46ITEsY2xvc2luZ1RpbWU6NTAwLGFsaWdubWVudDpcXFwibGVmdFxcXCIsY2xvc2VPbkNsaWNrOiEwLHZlcnRpY2FsQ2xhc3M6XFxcInZlcnRpY2FsXFxcIixyaWdodENsYXNzOlxcXCJhbGlnbi1yaWdodFxcXCIsZm9yY2VGb2xsb3c6ITB9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIkRyb3Bkb3duTWVudVxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiRXF1YWxpemVyXFxcIik7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcy4kZWxlbWVudC5hdHRyKFxcXCJkYXRhLWVxdWFsaXplclxcXCIpfHxcXFwiXFxcIixpPXRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtZXF1YWxpemVyLXdhdGNoPVxcXCInK2UrJ1xcXCJdJyk7dGhpcy4kd2F0Y2hlZD1pLmxlbmd0aD9pOnRoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtZXF1YWxpemVyLXdhdGNoXVxcXCIpLHRoaXMuJGVsZW1lbnQuYXR0cihcXFwiZGF0YS1yZXNpemVcXFwiLGV8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNixcXFwiZXFcXFwiKSksdGhpcy5oYXNOZXN0ZWQ9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1lcXVhbGl6ZXJdXFxcIikubGVuZ3RoPjAsdGhpcy5pc05lc3RlZD10aGlzLiRlbGVtZW50LnBhcmVudHNVbnRpbChkb2N1bWVudC5ib2R5LFxcXCJbZGF0YS1lcXVhbGl6ZXJdXFxcIikubGVuZ3RoPjAsdGhpcy5pc09uPSExO3ZhciBuLHM9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJpbWdcXFwiKTt0aGlzLm9wdGlvbnMuZXF1YWxpemVPbj8obj10aGlzLl9jaGVja01RKCksdCh3aW5kb3cpLm9uKFxcXCJjaGFuZ2VkLnpmLm1lZGlhcXVlcnlcXFwiLHRoaXMuX2NoZWNrTVEuYmluZCh0aGlzKSkpOnRoaXMuX2V2ZW50cygpLCh2b2lkIDAhPT1uJiZuPT09ITF8fHZvaWQgMD09PW4pJiYocy5sZW5ndGg/Rm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZChzLHRoaXMuX3JlZmxvdy5iaW5kKHRoaXMpKTp0aGlzLl9yZWZsb3coKSk7fX0se2tleTpcXFwiX3BhdXNlRXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuaXNPbj0hMSx0aGlzLiRlbGVtZW50Lm9mZihcXFwiLnpmLmVxdWFsaXplciByZXNpemVtZS56Zi50cmlnZ2VyXFxcIik7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzO3RoaXMuX3BhdXNlRXZlbnRzKCksdGhpcy5oYXNOZXN0ZWQ/dGhpcy4kZWxlbWVudC5vbihcXFwicG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXJcXFwiLGZ1bmN0aW9uKGUpe2UudGFyZ2V0IT09dC4kZWxlbWVudFswXSYmdC5fcmVmbG93KCk7fSk6dGhpcy4kZWxlbWVudC5vbihcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCIsdGhpcy5fcmVmbG93LmJpbmQodGhpcykpLHRoaXMuaXNPbj0hMDt9fSx7a2V5OlxcXCJfY2hlY2tNUVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD0hRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLmVxdWFsaXplT24pO3JldHVybiB0P3RoaXMuaXNPbiYmKHRoaXMuX3BhdXNlRXZlbnRzKCksdGhpcy4kd2F0Y2hlZC5jc3MoXFxcImhlaWdodFxcXCIsXFxcImF1dG9cXFwiKSk6dGhpcy5pc09ufHx0aGlzLl9ldmVudHMoKSx0O319LHtrZXk6XFxcIl9raWxsc3dpdGNoXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe319LHtrZXk6XFxcIl9yZWZsb3dcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7cmV0dXJuIXRoaXMub3B0aW9ucy5lcXVhbGl6ZU9uU3RhY2smJnRoaXMuX2lzU3RhY2tlZCgpPyh0aGlzLiR3YXRjaGVkLmNzcyhcXFwiaGVpZ2h0XFxcIixcXFwiYXV0b1xcXCIpLCExKTp2b2lkKHRoaXMub3B0aW9ucy5lcXVhbGl6ZUJ5Um93P3RoaXMuZ2V0SGVpZ2h0c0J5Um93KHRoaXMuYXBwbHlIZWlnaHRCeVJvdy5iaW5kKHRoaXMpKTp0aGlzLmdldEhlaWdodHModGhpcy5hcHBseUhlaWdodC5iaW5kKHRoaXMpKSk7fX0se2tleTpcXFwiX2lzU3RhY2tlZFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtyZXR1cm4gdGhpcy4kd2F0Y2hlZFswXS5vZmZzZXRUb3AhPT10aGlzLiR3YXRjaGVkWzFdLm9mZnNldFRvcDt9fSx7a2V5OlxcXCJnZXRIZWlnaHRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXtmb3IodmFyIGU9W10saT0wLG49dGhpcy4kd2F0Y2hlZC5sZW5ndGg7bj5pO2krKyl7dGhpcy4kd2F0Y2hlZFtpXS5zdHlsZS5oZWlnaHQ9XFxcImF1dG9cXFwiLGUucHVzaCh0aGlzLiR3YXRjaGVkW2ldLm9mZnNldEhlaWdodCk7fXQoZSk7fX0se2tleTpcXFwiZ2V0SGVpZ2h0c0J5Um93XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT10aGlzLiR3YXRjaGVkLmZpcnN0KCkub2Zmc2V0KCkudG9wLG49W10scz0wO25bc109W107Zm9yKHZhciBvPTAsYT10aGlzLiR3YXRjaGVkLmxlbmd0aDthPm87bysrKXt0aGlzLiR3YXRjaGVkW29dLnN0eWxlLmhlaWdodD1cXFwiYXV0b1xcXCI7dmFyIHI9dCh0aGlzLiR3YXRjaGVkW29dKS5vZmZzZXQoKS50b3A7ciE9aSYmKHMrKyxuW3NdPVtdLGk9ciksbltzXS5wdXNoKFt0aGlzLiR3YXRjaGVkW29dLHRoaXMuJHdhdGNoZWRbb10ub2Zmc2V0SGVpZ2h0XSk7fWZvcih2YXIgbD0wLHU9bi5sZW5ndGg7dT5sO2wrKyl7dmFyIGQ9dChuW2xdKS5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1sxXTt9KS5nZXQoKSxoPU1hdGgubWF4LmFwcGx5KG51bGwsZCk7bltsXS5wdXNoKGgpO31lKG4pO319LHtrZXk6XFxcImFwcGx5SGVpZ2h0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT1NYXRoLm1heC5hcHBseShudWxsLHQpO3RoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwicHJlZXF1YWxpemVkLnpmLmVxdWFsaXplclxcXCIpLHRoaXMuJHdhdGNoZWQuY3NzKFxcXCJoZWlnaHRcXFwiLGUpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwicG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXJcXFwiKTt9fSx7a2V5OlxcXCJhcHBseUhlaWdodEJ5Um93XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInByZWVxdWFsaXplZC56Zi5lcXVhbGl6ZXJcXFwiKTtmb3IodmFyIGk9MCxuPWUubGVuZ3RoO24+aTtpKyspe3ZhciBzPWVbaV0ubGVuZ3RoLG89ZVtpXVtzLTFdO2lmKDI+PXMpdChlW2ldWzBdWzBdKS5jc3Moe2hlaWdodDpcXFwiYXV0b1xcXCJ9KTtlbHNle3RoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwicHJlZXF1YWxpemVkcm93LnpmLmVxdWFsaXplclxcXCIpO2Zvcih2YXIgYT0wLHI9cy0xO3I+YTthKyspe3QoZVtpXVthXVswXSkuY3NzKHtoZWlnaHQ6b30pO310aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInBvc3RlcXVhbGl6ZWRyb3cuemYuZXF1YWxpemVyXFxcIik7fX10aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInBvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyXFxcIik7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLl9wYXVzZUV2ZW50cygpLHRoaXMuJHdhdGNoZWQuY3NzKFxcXCJoZWlnaHRcXFwiLFxcXCJhdXRvXFxcIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17ZXF1YWxpemVPblN0YWNrOiEwLGVxdWFsaXplQnlSb3c6ITEsZXF1YWxpemVPbjpcXFwiXFxcIn0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiRXF1YWxpemVyXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyxuKSx0aGlzLnJ1bGVzPVtdLHRoaXMuY3VycmVudFBhdGg9XFxcIlxcXCIsdGhpcy5faW5pdCgpLHRoaXMuX2V2ZW50cygpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiSW50ZXJjaGFuZ2VcXFwiKTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLl9hZGRCcmVha3BvaW50cygpLHRoaXMuX2dlbmVyYXRlUnVsZXMoKSx0aGlzLl9yZWZsb3coKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3Qod2luZG93KS5vbihcXFwicmVzaXplLnpmLmludGVyY2hhbmdlXFxcIixGb3VuZGF0aW9uLnV0aWwudGhyb3R0bGUodGhpcy5fcmVmbG93LmJpbmQodGhpcyksNTApKTt9fSx7a2V5OlxcXCJfcmVmbG93XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0O2Zvcih2YXIgZSBpbiB0aGlzLnJ1bGVzKXt2YXIgaT10aGlzLnJ1bGVzW2VdO3dpbmRvdy5tYXRjaE1lZGlhKGkucXVlcnkpLm1hdGNoZXMmJih0PWkpO310JiZ0aGlzLnJlcGxhY2UodC5wYXRoKTt9fSx7a2V5OlxcXCJfYWRkQnJlYWtwb2ludHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7Zm9yKHZhciB0IGluIEZvdW5kYXRpb24uTWVkaWFRdWVyeS5xdWVyaWVzKXt2YXIgaT1Gb3VuZGF0aW9uLk1lZGlhUXVlcnkucXVlcmllc1t0XTtlLlNQRUNJQUxfUVVFUklFU1tpLm5hbWVdPWkudmFsdWU7fX19LHtrZXk6XFxcIl9nZW5lcmF0ZVJ1bGVzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgaSxuPVtdO2k9dGhpcy5vcHRpb25zLnJ1bGVzP3RoaXMub3B0aW9ucy5ydWxlczp0aGlzLiRlbGVtZW50LmRhdGEoXFxcImludGVyY2hhbmdlXFxcIikubWF0Y2goL1xcXFxbLio/XFxcXF0vZyk7Zm9yKHZhciBzIGluIGkpe3ZhciBvPWlbc10uc2xpY2UoMSwtMSkuc3BsaXQoXFxcIiwgXFxcIiksYT1vLnNsaWNlKDAsLTEpLmpvaW4oXFxcIlxcXCIpLHI9b1tvLmxlbmd0aC0xXTtlLlNQRUNJQUxfUVVFUklFU1tyXSYmKHI9ZS5TUEVDSUFMX1FVRVJJRVNbcl0pLG4ucHVzaCh7cGF0aDphLHF1ZXJ5OnJ9KTt9dGhpcy5ydWxlcz1uO319LHtrZXk6XFxcInJlcGxhY2VcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe2lmKHRoaXMuY3VycmVudFBhdGghPT1lKXt2YXIgaT10aGlzLG49XFxcInJlcGxhY2VkLnpmLmludGVyY2hhbmdlXFxcIjtcXFwiSU1HXFxcIj09PXRoaXMuJGVsZW1lbnRbMF0ubm9kZU5hbWU/dGhpcy4kZWxlbWVudC5hdHRyKFxcXCJzcmNcXFwiLGUpLmxvYWQoZnVuY3Rpb24oKXtpLmN1cnJlbnRQYXRoPWU7fSkudHJpZ2dlcihuKTplLm1hdGNoKC9cXFxcLihnaWZ8anBnfGpwZWd8dGlmZnxwbmcpKFs/I10uKik/L2kpP3RoaXMuJGVsZW1lbnQuY3NzKHtcXFwiYmFja2dyb3VuZC1pbWFnZVxcXCI6XFxcInVybChcXFwiK2UrXFxcIilcXFwifSkudHJpZ2dlcihuKTp0LmdldChlLGZ1bmN0aW9uKHMpe2kuJGVsZW1lbnQuaHRtbChzKS50cmlnZ2VyKG4pLHQocykuZm91bmRhdGlvbigpLGkuY3VycmVudFBhdGg9ZTt9KTt9fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e3J1bGVzOm51bGx9LGUuU1BFQ0lBTF9RVUVSSUVTPXtsYW5kc2NhcGU6XFxcInNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpXFxcIixwb3J0cmFpdDpcXFwic2NyZWVuIGFuZCAob3JpZW50YXRpb246IHBvcnRyYWl0KVxcXCIscmV0aW5hOlxcXCJvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMiksIG9ubHkgc2NyZWVuIGFuZCAobWluLS1tb3otZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwgb25seSBzY3JlZW4gYW5kICgtby1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyLzEpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAxOTJkcGkpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAyZHBweClcXFwifSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJJbnRlcmNoYW5nZVxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiTWFnZWxsYW5cXFwiKTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzLiRlbGVtZW50WzBdLmlkfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXFxcIm1hZ2VsbGFuXFxcIik7dGhpcy4kdGFyZ2V0cz10KFxcXCJbZGF0YS1tYWdlbGxhbi10YXJnZXRdXFxcIiksdGhpcy4kbGlua3M9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJhXFxcIiksdGhpcy4kZWxlbWVudC5hdHRyKHtcXFwiZGF0YS1yZXNpemVcXFwiOmUsXFxcImRhdGEtc2Nyb2xsXFxcIjplLGlkOmV9KSx0aGlzLiRhY3RpdmU9dCgpLHRoaXMuc2Nyb2xsUG9zPXBhcnNlSW50KHdpbmRvdy5wYWdlWU9mZnNldCwxMCksdGhpcy5fZXZlbnRzKCk7fX0se2tleTpcXFwiY2FsY1BvaW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzLGk9ZG9jdW1lbnQuYm9keSxuPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudDt0aGlzLnBvaW50cz1bXSx0aGlzLndpbkhlaWdodD1NYXRoLnJvdW5kKE1hdGgubWF4KHdpbmRvdy5pbm5lckhlaWdodCxuLmNsaWVudEhlaWdodCkpLHRoaXMuZG9jSGVpZ2h0PU1hdGgucm91bmQoTWF0aC5tYXgoaS5zY3JvbGxIZWlnaHQsaS5vZmZzZXRIZWlnaHQsbi5jbGllbnRIZWlnaHQsbi5zY3JvbGxIZWlnaHQsbi5vZmZzZXRIZWlnaHQpKSx0aGlzLiR0YXJnZXRzLmVhY2goZnVuY3Rpb24oKXt2YXIgaT10KHRoaXMpLG49TWF0aC5yb3VuZChpLm9mZnNldCgpLnRvcC1lLm9wdGlvbnMudGhyZXNob2xkKTtpLnRhcmdldFBvaW50PW4sZS5wb2ludHMucHVzaChuKTt9KTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dChcXFwiaHRtbCwgYm9keVxcXCIpLHtkdXJhdGlvbjplLm9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sZWFzaW5nOmUub3B0aW9ucy5hbmltYXRpb25FYXNpbmd9O3Qod2luZG93KS5vbmUoXFxcImxvYWRcXFwiLGZ1bmN0aW9uKCl7ZS5vcHRpb25zLmRlZXBMaW5raW5nJiZsb2NhdGlvbi5oYXNoJiZlLnNjcm9sbFRvTG9jKGxvY2F0aW9uLmhhc2gpLGUuY2FsY1BvaW50cygpLGUuX3VwZGF0ZUFjdGl2ZSgpO30pLHRoaXMuJGVsZW1lbnQub24oe1xcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIjp0aGlzLnJlZmxvdy5iaW5kKHRoaXMpLFxcXCJzY3JvbGxtZS56Zi50cmlnZ2VyXFxcIjp0aGlzLl91cGRhdGVBY3RpdmUuYmluZCh0aGlzKX0pLm9uKFxcXCJjbGljay56Zi5tYWdlbGxhblxcXCIsJ2FbaHJlZl49XFxcIiNcXFwiXScsZnVuY3Rpb24odCl7dC5wcmV2ZW50RGVmYXVsdCgpO3ZhciBpPXRoaXMuZ2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIik7ZS5zY3JvbGxUb0xvYyhpKTt9KTt9fSx7a2V5OlxcXCJzY3JvbGxUb0xvY1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGk9TWF0aC5yb3VuZCh0KGUpLm9mZnNldCgpLnRvcC10aGlzLm9wdGlvbnMudGhyZXNob2xkLzItdGhpcy5vcHRpb25zLmJhck9mZnNldCk7dChcXFwiaHRtbCwgYm9keVxcXCIpLnN0b3AoITApLmFuaW1hdGUoe3Njcm9sbFRvcDppfSx0aGlzLm9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sdGhpcy5vcHRpb25zLmFuaW1hdGlvbkVhc2luZyk7fX0se2tleTpcXFwicmVmbG93XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuY2FsY1BvaW50cygpLHRoaXMuX3VwZGF0ZUFjdGl2ZSgpO319LHtrZXk6XFxcIl91cGRhdGVBY3RpdmVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQsZT1wYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQsMTApO2lmKGUrdGhpcy53aW5IZWlnaHQ9PT10aGlzLmRvY0hlaWdodCl0PXRoaXMucG9pbnRzLmxlbmd0aC0xO2Vsc2UgaWYoZTx0aGlzLnBvaW50c1swXSl0PTA7ZWxzZXt2YXIgaT10aGlzLnNjcm9sbFBvczxlLG49dGhpcyxzPXRoaXMucG9pbnRzLmZpbHRlcihmdW5jdGlvbih0LHMpe3JldHVybiBpP2U+PXQ6dC1uLm9wdGlvbnMudGhyZXNob2xkPD1lO30pO3Q9cy5sZW5ndGg/cy5sZW5ndGgtMTowO31pZih0aGlzLiRhY3RpdmUucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSx0aGlzLiRhY3RpdmU9dGhpcy4kbGlua3MuZXEodCkuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSx0aGlzLm9wdGlvbnMuZGVlcExpbmtpbmcpe3ZhciBvPXRoaXMuJGFjdGl2ZVswXS5nZXRBdHRyaWJ1dGUoXFxcImhyZWZcXFwiKTt3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGU/d2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsbnVsbCxvKTp3aW5kb3cubG9jYXRpb24uaGFzaD1vO310aGlzLnNjcm9sbFBvcz1lLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwidXBkYXRlLnpmLm1hZ2VsbGFuXFxcIixbdGhpcy4kYWN0aXZlXSk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtpZih0aGlzLiRlbGVtZW50Lm9mZihcXFwiLnpmLnRyaWdnZXIgLnpmLm1hZ2VsbGFuXFxcIikuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpLHRoaXMub3B0aW9ucy5kZWVwTGlua2luZyl7dmFyIHQ9dGhpcy4kYWN0aXZlWzBdLmdldEF0dHJpYnV0ZShcXFwiaHJlZlxcXCIpO3dpbmRvdy5sb2NhdGlvbi5oYXNoLnJlcGxhY2UodCxcXFwiXFxcIik7fUZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e2FuaW1hdGlvbkR1cmF0aW9uOjUwMCxhbmltYXRpb25FYXNpbmc6XFxcImxpbmVhclxcXCIsdGhyZXNob2xkOjUwLGFjdGl2ZUNsYXNzOlxcXCJhY3RpdmVcXFwiLGRlZXBMaW5raW5nOiExLGJhck9mZnNldDowfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJNYWdlbGxhblxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy4kbGFzdFRyaWdnZXI9dCgpLHRoaXMuX2luaXQoKSx0aGlzLl9ldmVudHMoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIk9mZkNhbnZhc1xcXCIpO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXMuJGVsZW1lbnQuYXR0cihcXFwiaWRcXFwiKTtpZih0aGlzLiRlbGVtZW50LmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIixcXFwidHJ1ZVxcXCIpLHQoZG9jdW1lbnQpLmZpbmQoJ1tkYXRhLW9wZW49XFxcIicrZSsnXFxcIl0sIFtkYXRhLWNsb3NlPVxcXCInK2UrJ1xcXCJdLCBbZGF0YS10b2dnbGU9XFxcIicrZSsnXFxcIl0nKS5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIixcXFwiZmFsc2VcXFwiKS5hdHRyKFxcXCJhcmlhLWNvbnRyb2xzXFxcIixlKSx0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKWlmKHQoXFxcIi5qcy1vZmYtY2FudmFzLWV4aXRcXFwiKS5sZW5ndGgpdGhpcy4kZXhpdGVyPXQoXFxcIi5qcy1vZmYtY2FudmFzLWV4aXRcXFwiKTtlbHNle3ZhciBpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO2kuc2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIsXFxcImpzLW9mZi1jYW52YXMtZXhpdFxcXCIpLHQoXFxcIltkYXRhLW9mZi1jYW52YXMtY29udGVudF1cXFwiKS5hcHBlbmQoaSksdGhpcy4kZXhpdGVyPXQoaSk7fXRoaXMub3B0aW9ucy5pc1JldmVhbGVkPXRoaXMub3B0aW9ucy5pc1JldmVhbGVkfHxuZXcgUmVnRXhwKHRoaXMub3B0aW9ucy5yZXZlYWxDbGFzcyxcXFwiZ1xcXCIpLnRlc3QodGhpcy4kZWxlbWVudFswXS5jbGFzc05hbWUpLHRoaXMub3B0aW9ucy5pc1JldmVhbGVkJiYodGhpcy5vcHRpb25zLnJldmVhbE9uPXRoaXMub3B0aW9ucy5yZXZlYWxPbnx8dGhpcy4kZWxlbWVudFswXS5jbGFzc05hbWUubWF0Y2goLyhyZXZlYWwtZm9yLW1lZGl1bXxyZXZlYWwtZm9yLWxhcmdlKS9nKVswXS5zcGxpdChcXFwiLVxcXCIpWzJdLHRoaXMuX3NldE1RQ2hlY2tlcigpKSx0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWV8fCh0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWU9MWUzKnBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUodChcXFwiW2RhdGEtb2ZmLWNhbnZhcy13cmFwcGVyXVxcXCIpWzBdKS50cmFuc2l0aW9uRHVyYXRpb24pKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQub2ZmKFxcXCIuemYudHJpZ2dlciAuemYub2ZmY2FudmFzXFxcIikub24oe1xcXCJvcGVuLnpmLnRyaWdnZXJcXFwiOnRoaXMub3Blbi5iaW5kKHRoaXMpLFxcXCJjbG9zZS56Zi50cmlnZ2VyXFxcIjp0aGlzLmNsb3NlLmJpbmQodGhpcyksXFxcInRvZ2dsZS56Zi50cmlnZ2VyXFxcIjp0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxcXCJrZXlkb3duLnpmLm9mZmNhbnZhc1xcXCI6dGhpcy5faGFuZGxlS2V5Ym9hcmQuYmluZCh0aGlzKX0pLHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2smJnRoaXMuJGV4aXRlci5sZW5ndGgmJnRoaXMuJGV4aXRlci5vbih7XFxcImNsaWNrLnpmLm9mZmNhbnZhc1xcXCI6dGhpcy5jbG9zZS5iaW5kKHRoaXMpfSk7fX0se2tleTpcXFwiX3NldE1RQ2hlY2tlclxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3Qod2luZG93KS5vbihcXFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFxcIixmdW5jdGlvbigpe0ZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KGUub3B0aW9ucy5yZXZlYWxPbik/ZS5yZXZlYWwoITApOmUucmV2ZWFsKCExKTt9KS5vbmUoXFxcImxvYWQuemYub2ZmY2FudmFzXFxcIixmdW5jdGlvbigpe0ZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KGUub3B0aW9ucy5yZXZlYWxPbikmJmUucmV2ZWFsKCEwKTt9KTt9fSx7a2V5OlxcXCJyZXZlYWxcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtY2xvc2VdXFxcIik7dD8odGhpcy5jbG9zZSgpLHRoaXMuaXNSZXZlYWxlZD0hMCx0aGlzLiRlbGVtZW50Lm9mZihcXFwib3Blbi56Zi50cmlnZ2VyIHRvZ2dsZS56Zi50cmlnZ2VyXFxcIiksZS5sZW5ndGgmJmUuaGlkZSgpKToodGhpcy5pc1JldmVhbGVkPSExLHRoaXMuJGVsZW1lbnQub24oe1xcXCJvcGVuLnpmLnRyaWdnZXJcXFwiOnRoaXMub3Blbi5iaW5kKHRoaXMpLFxcXCJ0b2dnbGUuemYudHJpZ2dlclxcXCI6dGhpcy50b2dnbGUuYmluZCh0aGlzKX0pLGUubGVuZ3RoJiZlLnNob3coKSk7fX0se2tleTpcXFwib3BlblxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSxpKXtpZighdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcXFwiaXMtb3BlblxcXCIpJiYhdGhpcy5pc1JldmVhbGVkKXt2YXIgbj10aGlzO3QoZG9jdW1lbnQuYm9keSk7dGhpcy5vcHRpb25zLmZvcmNlVG9wJiZ0KFxcXCJib2R5XFxcIikuc2Nyb2xsVG9wKDApLEZvdW5kYXRpb24uTW92ZSh0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUsdGhpcy4kZWxlbWVudCxmdW5jdGlvbigpe3QoXFxcIltkYXRhLW9mZi1jYW52YXMtd3JhcHBlcl1cXFwiKS5hZGRDbGFzcyhcXFwiaXMtb2ZmLWNhbnZhcy1vcGVuIGlzLW9wZW4tXFxcIituLm9wdGlvbnMucG9zaXRpb24pLG4uJGVsZW1lbnQuYWRkQ2xhc3MoXFxcImlzLW9wZW5cXFwiKTt9KSx0aGlzLiRlbGVtZW50LmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIixcXFwiZmFsc2VcXFwiKS50cmlnZ2VyKFxcXCJvcGVuZWQuemYub2ZmY2FudmFzXFxcIiksdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayYmdGhpcy4kZXhpdGVyLmFkZENsYXNzKFxcXCJpcy12aXNpYmxlXFxcIiksaSYmKHRoaXMuJGxhc3RUcmlnZ2VyPWkuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsXFxcInRydWVcXFwiKSksdGhpcy5vcHRpb25zLmF1dG9Gb2N1cyYmdGhpcy4kZWxlbWVudC5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKHRoaXMuJGVsZW1lbnQpLGZ1bmN0aW9uKCl7bi4kZWxlbWVudC5maW5kKFxcXCJhLCBidXR0b25cXFwiKS5lcSgwKS5mb2N1cygpO30pLHRoaXMub3B0aW9ucy50cmFwRm9jdXMmJih0KFxcXCJbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdXFxcIikuYXR0cihcXFwidGFiaW5kZXhcXFwiLFxcXCItMVxcXCIpLHRoaXMuX3RyYXBGb2N1cygpKTt9fX0se2tleTpcXFwiX3RyYXBGb2N1c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD1Gb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUodGhpcy4kZWxlbWVudCksZT10LmVxKDApLGk9dC5lcSgtMSk7dC5vZmYoXFxcIi56Zi5vZmZjYW52YXNcXFwiKS5vbihcXFwia2V5ZG93bi56Zi5vZmZjYW52YXNcXFwiLGZ1bmN0aW9uKHQpezkhPT10LndoaWNoJiY5IT09dC5rZXljb2RlfHwodC50YXJnZXQhPT1pWzBdfHx0LnNoaWZ0S2V5fHwodC5wcmV2ZW50RGVmYXVsdCgpLGUuZm9jdXMoKSksdC50YXJnZXQ9PT1lWzBdJiZ0LnNoaWZ0S2V5JiYodC5wcmV2ZW50RGVmYXVsdCgpLGkuZm9jdXMoKSkpO30pO319LHtrZXk6XFxcImNsb3NlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXtpZih0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJpcy1vcGVuXFxcIikmJiF0aGlzLmlzUmV2ZWFsZWQpe3ZhciBpPXRoaXM7dChcXFwiW2RhdGEtb2ZmLWNhbnZhcy13cmFwcGVyXVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJpcy1vZmYtY2FudmFzLW9wZW4gaXMtb3Blbi1cXFwiK2kub3B0aW9ucy5wb3NpdGlvbiksaS4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwiaXMtb3BlblxcXCIpLHRoaXMuJGVsZW1lbnQuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLFxcXCJ0cnVlXFxcIikudHJpZ2dlcihcXFwiY2xvc2VkLnpmLm9mZmNhbnZhc1xcXCIpLHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2smJnRoaXMuJGV4aXRlci5yZW1vdmVDbGFzcyhcXFwiaXMtdmlzaWJsZVxcXCIpLHRoaXMuJGxhc3RUcmlnZ2VyLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLFxcXCJmYWxzZVxcXCIpLHRoaXMub3B0aW9ucy50cmFwRm9jdXMmJnQoXFxcIltkYXRhLW9mZi1jYW52YXMtY29udGVudF1cXFwiKS5yZW1vdmVBdHRyKFxcXCJ0YWJpbmRleFxcXCIpO319fSx7a2V5OlxcXCJ0b2dnbGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQsZSl7dGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcXFwiaXMtb3BlblxcXCIpP3RoaXMuY2xvc2UodCxlKTp0aGlzLm9wZW4odCxlKTt9fSx7a2V5OlxcXCJfaGFuZGxlS2V5Ym9hcmRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpezI3PT09dC53aGljaCYmKHQuc3RvcFByb3BhZ2F0aW9uKCksdC5wcmV2ZW50RGVmYXVsdCgpLHRoaXMuY2xvc2UoKSx0aGlzLiRsYXN0VHJpZ2dlci5mb2N1cygpKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuY2xvc2UoKSx0aGlzLiRlbGVtZW50Lm9mZihcXFwiLnpmLnRyaWdnZXIgLnpmLm9mZmNhbnZhc1xcXCIpLHRoaXMuJGV4aXRlci5vZmYoXFxcIi56Zi5vZmZjYW52YXNcXFwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtjbG9zZU9uQ2xpY2s6ITAsdHJhbnNpdGlvblRpbWU6MCxwb3NpdGlvbjpcXFwibGVmdFxcXCIsZm9yY2VUb3A6ITAsaXNSZXZlYWxlZDohMSxyZXZlYWxPbjpudWxsLGF1dG9Gb2N1czohMCxyZXZlYWxDbGFzczpcXFwicmV2ZWFsLWZvci1cXFwiLHRyYXBGb2N1czohMX0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiT2ZmQ2FudmFzXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJPcmJpdFxcXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIk9yYml0XFxcIix7bHRyOntBUlJPV19SSUdIVDpcXFwibmV4dFxcXCIsQVJST1dfTEVGVDpcXFwicHJldmlvdXNcXFwifSxydGw6e0FSUk9XX0xFRlQ6XFxcIm5leHRcXFwiLEFSUk9XX1JJR0hUOlxcXCJwcmV2aW91c1xcXCJ9fSk7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kd3JhcHBlcj10aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcyksdGhpcy4kc2xpZGVzPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpO3ZhciB0PXRoaXMuJGVsZW1lbnQuZmluZChcXFwiaW1nXFxcIiksZT10aGlzLiRzbGlkZXMuZmlsdGVyKFxcXCIuaXMtYWN0aXZlXFxcIik7ZS5sZW5ndGh8fHRoaXMuJHNsaWRlcy5lcSgwKS5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIiksdGhpcy5vcHRpb25zLnVzZU1VSXx8dGhpcy4kc2xpZGVzLmFkZENsYXNzKFxcXCJuby1tb3Rpb251aVxcXCIpLHQubGVuZ3RoP0ZvdW5kYXRpb24ub25JbWFnZXNMb2FkZWQodCx0aGlzLl9wcmVwYXJlRm9yT3JiaXQuYmluZCh0aGlzKSk6dGhpcy5fcHJlcGFyZUZvck9yYml0KCksdGhpcy5vcHRpb25zLmJ1bGxldHMmJnRoaXMuX2xvYWRCdWxsZXRzKCksdGhpcy5fZXZlbnRzKCksdGhpcy5vcHRpb25zLmF1dG9QbGF5JiZ0aGlzLiRzbGlkZXMubGVuZ3RoPjEmJnRoaXMuZ2VvU3luYygpLHRoaXMub3B0aW9ucy5hY2Nlc3NpYmxlJiZ0aGlzLiR3cmFwcGVyLmF0dHIoXFxcInRhYmluZGV4XFxcIiwwKTt9fSx7a2V5OlxcXCJfbG9hZEJ1bGxldHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kYnVsbGV0cz10aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5ib3hPZkJ1bGxldHMpLmZpbmQoXFxcImJ1dHRvblxcXCIpO319LHtrZXk6XFxcImdlb1N5bmNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpczt0aGlzLnRpbWVyPW5ldyBGb3VuZGF0aW9uLlRpbWVyKHRoaXMuJGVsZW1lbnQse2R1cmF0aW9uOnRoaXMub3B0aW9ucy50aW1lckRlbGF5LGluZmluaXRlOiExfSxmdW5jdGlvbigpe3QuY2hhbmdlU2xpZGUoITApO30pLHRoaXMudGltZXIuc3RhcnQoKTt9fSx7a2V5OlxcXCJfcHJlcGFyZUZvck9yYml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXM7dGhpcy5fc2V0V3JhcHBlckhlaWdodChmdW5jdGlvbihlKXt0Ll9zZXRTbGlkZUhlaWdodChlKTt9KTt9fSx7a2V5OlxcXCJfc2V0V3JhcHBlckhlaWdodFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGksbj0wLHM9MDt0aGlzLiRzbGlkZXMuZWFjaChmdW5jdGlvbigpe2k9dGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQsdCh0aGlzKS5hdHRyKFxcXCJkYXRhLXNsaWRlXFxcIixzKSxzJiZ0KHRoaXMpLmNzcyh7cG9zaXRpb246XFxcInJlbGF0aXZlXFxcIixkaXNwbGF5OlxcXCJub25lXFxcIn0pLG49aT5uP2k6bixzKys7fSkscz09PXRoaXMuJHNsaWRlcy5sZW5ndGgmJih0aGlzLiR3cmFwcGVyLmNzcyh7aGVpZ2h0Om59KSxlKG4pKTt9fSx7a2V5OlxcXCJfc2V0U2xpZGVIZWlnaHRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3RoaXMuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKCl7dCh0aGlzKS5jc3MoXFxcIm1heC1oZWlnaHRcXFwiLGUpO30pO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcztpZih0aGlzLiRzbGlkZXMubGVuZ3RoPjEpe2lmKHRoaXMub3B0aW9ucy5zd2lwZSYmdGhpcy4kc2xpZGVzLm9mZihcXFwic3dpcGVsZWZ0LnpmLm9yYml0IHN3aXBlcmlnaHQuemYub3JiaXRcXFwiKS5vbihcXFwic3dpcGVsZWZ0LnpmLm9yYml0XFxcIixmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCksZS5jaGFuZ2VTbGlkZSghMCk7fSkub24oXFxcInN3aXBlcmlnaHQuemYub3JiaXRcXFwiLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKSxlLmNoYW5nZVNsaWRlKCExKTt9KSx0aGlzLm9wdGlvbnMuYXV0b1BsYXkmJih0aGlzLiRzbGlkZXMub24oXFxcImNsaWNrLnpmLm9yYml0XFxcIixmdW5jdGlvbigpe2UuJGVsZW1lbnQuZGF0YShcXFwiY2xpY2tlZE9uXFxcIiwhZS4kZWxlbWVudC5kYXRhKFxcXCJjbGlja2VkT25cXFwiKSksZS50aW1lcltlLiRlbGVtZW50LmRhdGEoXFxcImNsaWNrZWRPblxcXCIpP1xcXCJwYXVzZVxcXCI6XFxcInN0YXJ0XFxcIl0oKTt9KSx0aGlzLm9wdGlvbnMucGF1c2VPbkhvdmVyJiZ0aGlzLiRlbGVtZW50Lm9uKFxcXCJtb3VzZWVudGVyLnpmLm9yYml0XFxcIixmdW5jdGlvbigpe2UudGltZXIucGF1c2UoKTt9KS5vbihcXFwibW91c2VsZWF2ZS56Zi5vcmJpdFxcXCIsZnVuY3Rpb24oKXtlLiRlbGVtZW50LmRhdGEoXFxcImNsaWNrZWRPblxcXCIpfHxlLnRpbWVyLnN0YXJ0KCk7fSkpLHRoaXMub3B0aW9ucy5uYXZCdXR0b25zKXt2YXIgaT10aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5uZXh0Q2xhc3MrXFxcIiwgLlxcXCIrdGhpcy5vcHRpb25zLnByZXZDbGFzcyk7aS5hdHRyKFxcXCJ0YWJpbmRleFxcXCIsMCkub24oXFxcImNsaWNrLnpmLm9yYml0IHRvdWNoZW5kLnpmLm9yYml0XFxcIixmdW5jdGlvbigpe2UuY2hhbmdlU2xpZGUodCh0aGlzKS5oYXNDbGFzcyhlLm9wdGlvbnMubmV4dENsYXNzKSk7fSk7fXRoaXMub3B0aW9ucy5idWxsZXRzJiZ0aGlzLiRidWxsZXRzLm9uKFxcXCJjbGljay56Zi5vcmJpdCB0b3VjaGVuZC56Zi5vcmJpdFxcXCIsZnVuY3Rpb24oKXtpZigvaXMtYWN0aXZlL2cudGVzdCh0aGlzLmNsYXNzTmFtZSkpcmV0dXJuITE7dmFyIGk9dCh0aGlzKS5kYXRhKFxcXCJzbGlkZVxcXCIpLG49aT5lLiRzbGlkZXMuZmlsdGVyKFxcXCIuaXMtYWN0aXZlXFxcIikuZGF0YShcXFwic2xpZGVcXFwiKSxzPWUuJHNsaWRlcy5lcShpKTtlLmNoYW5nZVNsaWRlKG4scyxpKTt9KSx0aGlzLiR3cmFwcGVyLmFkZCh0aGlzLiRidWxsZXRzKS5vbihcXFwia2V5ZG93bi56Zi5vcmJpdFxcXCIsZnVuY3Rpb24oaSl7Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoaSxcXFwiT3JiaXRcXFwiLHtuZXh0OmZ1bmN0aW9uIG5leHQoKXtlLmNoYW5nZVNsaWRlKCEwKTt9LHByZXZpb3VzOmZ1bmN0aW9uIHByZXZpb3VzKCl7ZS5jaGFuZ2VTbGlkZSghMSk7fSxoYW5kbGVkOmZ1bmN0aW9uIGhhbmRsZWQoKXt0KGkudGFyZ2V0KS5pcyhlLiRidWxsZXRzKSYmZS4kYnVsbGV0cy5maWx0ZXIoXFxcIi5pcy1hY3RpdmVcXFwiKS5mb2N1cygpO319KTt9KTt9fX0se2tleTpcXFwiY2hhbmdlU2xpZGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQsZSxpKXt2YXIgbj10aGlzLiRzbGlkZXMuZmlsdGVyKFxcXCIuaXMtYWN0aXZlXFxcIikuZXEoMCk7aWYoL211aS9nLnRlc3QoblswXS5jbGFzc05hbWUpKXJldHVybiExO3ZhciBzLG89dGhpcy4kc2xpZGVzLmZpcnN0KCksYT10aGlzLiRzbGlkZXMubGFzdCgpLHI9dD9cXFwiUmlnaHRcXFwiOlxcXCJMZWZ0XFxcIixsPXQ/XFxcIkxlZnRcXFwiOlxcXCJSaWdodFxcXCIsdT10aGlzO3M9ZT9lOnQ/dGhpcy5vcHRpb25zLmluZmluaXRlV3JhcD9uLm5leHQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzKS5sZW5ndGg/bi5uZXh0KFxcXCIuXFxcIit0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcyk6bzpuLm5leHQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzKTp0aGlzLm9wdGlvbnMuaW5maW5pdGVXcmFwP24ucHJldihcXFwiLlxcXCIrdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpLmxlbmd0aD9uLnByZXYoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzKTphOm4ucHJldihcXFwiLlxcXCIrdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpLHMubGVuZ3RoJiYodGhpcy5vcHRpb25zLmJ1bGxldHMmJihpPWl8fHRoaXMuJHNsaWRlcy5pbmRleChzKSx0aGlzLl91cGRhdGVCdWxsZXRzKGkpKSx0aGlzLm9wdGlvbnMudXNlTVVJPyhGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlSW4ocy5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikuY3NzKHtwb3NpdGlvbjpcXFwiYWJzb2x1dGVcXFwiLHRvcDowfSksdGhpcy5vcHRpb25zW1xcXCJhbmltSW5Gcm9tXFxcIityXSxmdW5jdGlvbigpe3MuY3NzKHtwb3NpdGlvbjpcXFwicmVsYXRpdmVcXFwiLGRpc3BsYXk6XFxcImJsb2NrXFxcIn0pLmF0dHIoXFxcImFyaWEtbGl2ZVxcXCIsXFxcInBvbGl0ZVxcXCIpO30pLEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQobi5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIiksdGhpcy5vcHRpb25zW1xcXCJhbmltT3V0VG9cXFwiK2xdLGZ1bmN0aW9uKCl7bi5yZW1vdmVBdHRyKFxcXCJhcmlhLWxpdmVcXFwiKSx1Lm9wdGlvbnMuYXV0b1BsYXkmJiF1LnRpbWVyLmlzUGF1c2VkJiZ1LnRpbWVyLnJlc3RhcnQoKTt9KSk6KG4ucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZSBpcy1pblxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtbGl2ZVxcXCIpLmhpZGUoKSxzLmFkZENsYXNzKFxcXCJpcy1hY3RpdmUgaXMtaW5cXFwiKS5hdHRyKFxcXCJhcmlhLWxpdmVcXFwiLFxcXCJwb2xpdGVcXFwiKS5zaG93KCksdGhpcy5vcHRpb25zLmF1dG9QbGF5JiYhdGhpcy50aW1lci5pc1BhdXNlZCYmdGhpcy50aW1lci5yZXN0YXJ0KCkpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwic2xpZGVjaGFuZ2UuemYub3JiaXRcXFwiLFtzXSkpO319LHtrZXk6XFxcIl91cGRhdGVCdWxsZXRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT10aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5ib3hPZkJ1bGxldHMpLmZpbmQoXFxcIi5pcy1hY3RpdmVcXFwiKS5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikuYmx1cigpLGk9ZS5maW5kKFxcXCJzcGFuOmxhc3RcXFwiKS5kZXRhY2goKTt0aGlzLiRidWxsZXRzLmVxKHQpLmFkZENsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKS5hcHBlbmQoaSk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50Lm9mZihcXFwiLnpmLm9yYml0XFxcIikuZmluZChcXFwiKlxcXCIpLm9mZihcXFwiLnpmLm9yYml0XFxcIikuZW5kKCkuaGlkZSgpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e2J1bGxldHM6ITAsbmF2QnV0dG9uczohMCxhbmltSW5Gcm9tUmlnaHQ6XFxcInNsaWRlLWluLXJpZ2h0XFxcIixhbmltT3V0VG9SaWdodDpcXFwic2xpZGUtb3V0LXJpZ2h0XFxcIixhbmltSW5Gcm9tTGVmdDpcXFwic2xpZGUtaW4tbGVmdFxcXCIsYW5pbU91dFRvTGVmdDpcXFwic2xpZGUtb3V0LWxlZnRcXFwiLGF1dG9QbGF5OiEwLHRpbWVyRGVsYXk6NWUzLGluZmluaXRlV3JhcDohMCxzd2lwZTohMCxwYXVzZU9uSG92ZXI6ITAsYWNjZXNzaWJsZTohMCxjb250YWluZXJDbGFzczpcXFwib3JiaXQtY29udGFpbmVyXFxcIixzbGlkZUNsYXNzOlxcXCJvcmJpdC1zbGlkZVxcXCIsYm94T2ZCdWxsZXRzOlxcXCJvcmJpdC1idWxsZXRzXFxcIixuZXh0Q2xhc3M6XFxcIm9yYml0LW5leHRcXFwiLHByZXZDbGFzczpcXFwib3JiaXQtcHJldmlvdXNcXFwiLHVzZU1VSTohMH0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiT3JiaXRcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD10KGkpLHRoaXMucnVsZXM9dGhpcy4kZWxlbWVudC5kYXRhKFxcXCJyZXNwb25zaXZlLW1lbnVcXFwiKSx0aGlzLmN1cnJlbnRNcT1udWxsLHRoaXMuY3VycmVudFBsdWdpbj1udWxsLHRoaXMuX2luaXQoKSx0aGlzLl9ldmVudHMoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIlJlc3BvbnNpdmVNZW51XFxcIik7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7Zm9yKHZhciBlPXt9LG49dGhpcy5ydWxlcy5zcGxpdChcXFwiIFxcXCIpLHM9MDtzPG4ubGVuZ3RoO3MrKyl7dmFyIG89bltzXS5zcGxpdChcXFwiLVxcXCIpLGE9by5sZW5ndGg+MT9vWzBdOlxcXCJzbWFsbFxcXCIscj1vLmxlbmd0aD4xP29bMV06b1swXTtudWxsIT09aVtyXSYmKGVbYV09aVtyXSk7fXRoaXMucnVsZXM9ZSx0LmlzRW1wdHlPYmplY3QoZSl8fHRoaXMuX2NoZWNrTWVkaWFRdWVyaWVzKCk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3Qod2luZG93KS5vbihcXFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFxcIixmdW5jdGlvbigpe2UuX2NoZWNrTWVkaWFRdWVyaWVzKCk7fSk7fX0se2tleTpcXFwiX2NoZWNrTWVkaWFRdWVyaWVzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlLG49dGhpczt0LmVhY2godGhpcy5ydWxlcyxmdW5jdGlvbih0KXtGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0KSYmKGU9dCk7fSksZSYmKHRoaXMuY3VycmVudFBsdWdpbiBpbnN0YW5jZW9mIHRoaXMucnVsZXNbZV0ucGx1Z2lufHwodC5lYWNoKGksZnVuY3Rpb24odCxlKXtuLiRlbGVtZW50LnJlbW92ZUNsYXNzKGUuY3NzQ2xhc3MpO30pLHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5ydWxlc1tlXS5jc3NDbGFzcyksdGhpcy5jdXJyZW50UGx1Z2luJiZ0aGlzLmN1cnJlbnRQbHVnaW4uZGVzdHJveSgpLHRoaXMuY3VycmVudFBsdWdpbj1uZXcgdGhpcy5ydWxlc1tlXS5wbHVnaW4odGhpcy4kZWxlbWVudCx7fSkpKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuY3VycmVudFBsdWdpbi5kZXN0cm95KCksdCh3aW5kb3cpLm9mZihcXFwiLnpmLlJlc3BvbnNpdmVNZW51XFxcIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17fTt2YXIgaT17ZHJvcGRvd246e2Nzc0NsYXNzOlxcXCJkcm9wZG93blxcXCIscGx1Z2luOkZvdW5kYXRpb24uX3BsdWdpbnNbXFxcImRyb3Bkb3duLW1lbnVcXFwiXXx8bnVsbH0sZHJpbGxkb3duOntjc3NDbGFzczpcXFwiZHJpbGxkb3duXFxcIixwbHVnaW46Rm91bmRhdGlvbi5fcGx1Z2lucy5kcmlsbGRvd258fG51bGx9LGFjY29yZGlvbjp7Y3NzQ2xhc3M6XFxcImFjY29yZGlvbi1tZW51XFxcIixwbHVnaW46Rm91bmRhdGlvbi5fcGx1Z2luc1tcXFwiYWNjb3JkaW9uLW1lbnVcXFwiXXx8bnVsbH19O0ZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIlJlc3BvbnNpdmVNZW51XFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9dChpKSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLl9pbml0KCksdGhpcy5fZXZlbnRzKCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJSZXNwb25zaXZlVG9nZ2xlXFxcIik7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcy4kZWxlbWVudC5kYXRhKFxcXCJyZXNwb25zaXZlLXRvZ2dsZVxcXCIpO2V8fGNvbnNvbGUuZXJyb3IoXFxcIllvdXIgdGFiIGJhciBuZWVkcyBhbiBJRCBvZiBhIE1lbnUgYXMgdGhlIHZhbHVlIG9mIGRhdGEtdGFiLWJhci5cXFwiKSx0aGlzLiR0YXJnZXRNZW51PXQoXFxcIiNcXFwiK2UpLHRoaXMuJHRvZ2dsZXI9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS10b2dnbGVdXFxcIiksdGhpcy5fdXBkYXRlKCk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0KHdpbmRvdykub24oXFxcImNoYW5nZWQuemYubWVkaWFxdWVyeVxcXCIsdGhpcy5fdXBkYXRlLmJpbmQodGhpcykpLHRoaXMuJHRvZ2dsZXIub24oXFxcImNsaWNrLnpmLnJlc3BvbnNpdmVUb2dnbGVcXFwiLHRoaXMudG9nZ2xlTWVudS5iaW5kKHRoaXMpKTt9fSx7a2V5OlxcXCJfdXBkYXRlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe0ZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5oaWRlRm9yKT8odGhpcy4kZWxlbWVudC5oaWRlKCksdGhpcy4kdGFyZ2V0TWVudS5zaG93KCkpOih0aGlzLiRlbGVtZW50LnNob3coKSx0aGlzLiR0YXJnZXRNZW51LmhpZGUoKSk7fX0se2tleTpcXFwidG9nZ2xlTWVudVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuaGlkZUZvcil8fCh0aGlzLiR0YXJnZXRNZW51LnRvZ2dsZSgwKSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInRvZ2dsZWQuemYucmVzcG9uc2l2ZVRvZ2dsZVxcXCIpKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe319XSksZTt9KCk7ZS5kZWZhdWx0cz17aGlkZUZvcjpcXFwibWVkaXVtXFxcIn0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiUmVzcG9uc2l2ZVRvZ2dsZVxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIC9pUChhZHxob25lfG9kKS4qT1MvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO312YXIgaT1mdW5jdGlvbigpe2Z1bmN0aW9uIGkoZSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxpKSx0aGlzLiRlbGVtZW50PWUsdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGkuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiUmV2ZWFsXFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiUmV2ZWFsXFxcIix7RU5URVI6XFxcIm9wZW5cXFwiLFNQQUNFOlxcXCJvcGVuXFxcIixFU0NBUEU6XFxcImNsb3NlXFxcIixUQUI6XFxcInRhYl9mb3J3YXJkXFxcIixTSElGVF9UQUI6XFxcInRhYl9iYWNrd2FyZFxcXCJ9KTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhpLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtpZih0aGlzLmlkPXRoaXMuJGVsZW1lbnQuYXR0cihcXFwiaWRcXFwiKSx0aGlzLmlzQWN0aXZlPSExLHRoaXMuY2FjaGVkPXttcTpGb3VuZGF0aW9uLk1lZGlhUXVlcnkuY3VycmVudH0sdGhpcy5pc2lPUz1lKCksdGhpcy5pc2lPUyYmdGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcXFwiaXMtaW9zXFxcIiksdGhpcy4kYW5jaG9yPXQodCgnW2RhdGEtb3Blbj1cXFwiJyt0aGlzLmlkKydcXFwiXScpLmxlbmd0aD8nW2RhdGEtb3Blbj1cXFwiJyt0aGlzLmlkKydcXFwiXSc6J1tkYXRhLXRvZ2dsZT1cXFwiJyt0aGlzLmlkKydcXFwiXScpLHRoaXMuJGFuY2hvci5sZW5ndGgpe3ZhciBpPXRoaXMuJGFuY2hvclswXS5pZHx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJyZXZlYWxcXFwiKTt0aGlzLiRhbmNob3IuYXR0cih7XFxcImFyaWEtY29udHJvbHNcXFwiOnRoaXMuaWQsaWQ6aSxcXFwiYXJpYS1oYXNwb3B1cFxcXCI6ITAsdGFiaW5kZXg6MH0pLHRoaXMuJGVsZW1lbnQuYXR0cih7XFxcImFyaWEtbGFiZWxsZWRieVxcXCI6aX0pO30odGhpcy5vcHRpb25zLmZ1bGxTY3JlZW58fHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXFxcImZ1bGxcXFwiKSkmJih0aGlzLm9wdGlvbnMuZnVsbFNjcmVlbj0hMCx0aGlzLm9wdGlvbnMub3ZlcmxheT0hMSksdGhpcy5vcHRpb25zLm92ZXJsYXkmJiF0aGlzLiRvdmVybGF5JiYodGhpcy4kb3ZlcmxheT10aGlzLl9tYWtlT3ZlcmxheSh0aGlzLmlkKSksdGhpcy4kZWxlbWVudC5hdHRyKHtyb2xlOlxcXCJkaWFsb2dcXFwiLFxcXCJhcmlhLWhpZGRlblxcXCI6ITAsXFxcImRhdGEteWV0aS1ib3hcXFwiOnRoaXMuaWQsXFxcImRhdGEtcmVzaXplXFxcIjp0aGlzLmlkfSksdGhpcy4kb3ZlcmxheT90aGlzLiRlbGVtZW50LmRldGFjaCgpLmFwcGVuZFRvKHRoaXMuJG92ZXJsYXkpOih0aGlzLiRlbGVtZW50LmRldGFjaCgpLmFwcGVuZFRvKHQoXFxcImJvZHlcXFwiKSksdGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcXFwid2l0aG91dC1vdmVybGF5XFxcIikpLHRoaXMuX2V2ZW50cygpLHRoaXMub3B0aW9ucy5kZWVwTGluayYmd2luZG93LmxvY2F0aW9uLmhhc2g9PT1cXFwiI1xcXCIrdGhpcy5pZCYmdCh3aW5kb3cpLm9uZShcXFwibG9hZC56Zi5yZXZlYWxcXFwiLHRoaXMub3Blbi5iaW5kKHRoaXMpKTt9fSx7a2V5OlxcXCJfbWFrZU92ZXJsYXlcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3ZhciBpPXQoXFxcIjxkaXY+PC9kaXY+XFxcIikuYWRkQ2xhc3MoXFxcInJldmVhbC1vdmVybGF5XFxcIikuYXR0cih7dGFiaW5kZXg6LTEsXFxcImFyaWEtaGlkZGVuXFxcIjohMH0pLmFwcGVuZFRvKFxcXCJib2R5XFxcIik7cmV0dXJuIGk7fX0se2tleTpcXFwiX3VwZGF0ZVBvc2l0aW9uXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlLGk9dGhpcy4kZWxlbWVudC5vdXRlcldpZHRoKCksbj10KHdpbmRvdykud2lkdGgoKSxzPXRoaXMuJGVsZW1lbnQub3V0ZXJIZWlnaHQoKSxvPXQod2luZG93KS5oZWlnaHQoKSxhPXBhcnNlSW50KChuLWkpLzIsMTApO2U9cz5vP3BhcnNlSW50KE1hdGgubWluKDEwMCxvLzEwKSwxMCk6cGFyc2VJbnQoKG8tcykvNCwxMCksdGhpcy4kZWxlbWVudC5jc3Moe3RvcDplK1xcXCJweFxcXCJ9KSx0aGlzLiRvdmVybGF5fHx0aGlzLiRlbGVtZW50LmNzcyh7bGVmdDphK1xcXCJweFxcXCJ9KTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dGhpcy4kZWxlbWVudC5vbih7XFxcIm9wZW4uemYudHJpZ2dlclxcXCI6dGhpcy5vcGVuLmJpbmQodGhpcyksXFxcImNsb3NlLnpmLnRyaWdnZXJcXFwiOnRoaXMuY2xvc2UuYmluZCh0aGlzKSxcXFwidG9nZ2xlLnpmLnRyaWdnZXJcXFwiOnRoaXMudG9nZ2xlLmJpbmQodGhpcyksXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiOmZ1bmN0aW9uIHJlc2l6ZW1lWmZUcmlnZ2VyKCl7ZS5fdXBkYXRlUG9zaXRpb24oKTt9fSksdGhpcy4kYW5jaG9yLmxlbmd0aCYmdGhpcy4kYW5jaG9yLm9uKFxcXCJrZXlkb3duLnpmLnJldmVhbFxcXCIsZnVuY3Rpb24odCl7MTMhPT10LndoaWNoJiYzMiE9PXQud2hpY2h8fCh0LnN0b3BQcm9wYWdhdGlvbigpLHQucHJldmVudERlZmF1bHQoKSxlLm9wZW4oKSk7fSksdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayYmdGhpcy5vcHRpb25zLm92ZXJsYXkmJnRoaXMuJG92ZXJsYXkub2ZmKFxcXCIuemYucmV2ZWFsXFxcIikub24oXFxcImNsaWNrLnpmLnJldmVhbFxcXCIsZnVuY3Rpb24oaSl7aS50YXJnZXQ9PT1lLiRlbGVtZW50WzBdfHx0LmNvbnRhaW5zKGUuJGVsZW1lbnRbMF0saS50YXJnZXQpfHxlLmNsb3NlKCk7fSksdGhpcy5vcHRpb25zLmRlZXBMaW5rJiZ0KHdpbmRvdykub24oXFxcInBvcHN0YXRlLnpmLnJldmVhbDpcXFwiK3RoaXMuaWQsdGhpcy5faGFuZGxlU3RhdGUuYmluZCh0aGlzKSk7fX0se2tleTpcXFwiX2hhbmRsZVN0YXRlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt3aW5kb3cubG9jYXRpb24uaGFzaCE9PVxcXCIjXFxcIit0aGlzLmlkfHx0aGlzLmlzQWN0aXZlP3RoaXMuY2xvc2UoKTp0aGlzLm9wZW4oKTt9fSx7a2V5OlxcXCJvcGVuXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7aWYodGhpcy5vcHRpb25zLmRlZXBMaW5rKXt2YXIgaT1cXFwiI1xcXCIrdGhpcy5pZDt3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGU/d2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsbnVsbCxpKTp3aW5kb3cubG9jYXRpb24uaGFzaD1pO31pZih0aGlzLmlzQWN0aXZlPSEwLHRoaXMuJGVsZW1lbnQuY3NzKHt2aXNpYmlsaXR5OlxcXCJoaWRkZW5cXFwifSkuc2hvdygpLnNjcm9sbFRvcCgwKSx0aGlzLm9wdGlvbnMub3ZlcmxheSYmdGhpcy4kb3ZlcmxheS5jc3Moe3Zpc2liaWxpdHk6XFxcImhpZGRlblxcXCJ9KS5zaG93KCksdGhpcy5fdXBkYXRlUG9zaXRpb24oKSx0aGlzLiRlbGVtZW50LmhpZGUoKS5jc3Moe3Zpc2liaWxpdHk6XFxcIlxcXCJ9KSx0aGlzLiRvdmVybGF5JiZ0aGlzLiRvdmVybGF5LmNzcyh7dmlzaWJpbGl0eTpcXFwiXFxcIn0pLmhpZGUoKSx0aGlzLm9wdGlvbnMubXVsdGlwbGVPcGVuZWR8fHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiY2xvc2VtZS56Zi5yZXZlYWxcXFwiLHRoaXMuaWQpLHRoaXMub3B0aW9ucy5hbmltYXRpb25Jbj8odGhpcy5vcHRpb25zLm92ZXJsYXkmJkZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbih0aGlzLiRvdmVybGF5LFxcXCJmYWRlLWluXFxcIiksRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZUluKHRoaXMuJGVsZW1lbnQsdGhpcy5vcHRpb25zLmFuaW1hdGlvbkluLGZ1bmN0aW9uKCl7dGhpcy5mb2N1c2FibGVFbGVtZW50cz1Gb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUodGhpcy4kZWxlbWVudCk7fSkpOih0aGlzLm9wdGlvbnMub3ZlcmxheSYmdGhpcy4kb3ZlcmxheS5zaG93KDApLHRoaXMuJGVsZW1lbnQuc2hvdyh0aGlzLm9wdGlvbnMuc2hvd0RlbGF5KSksdGhpcy4kZWxlbWVudC5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOiExLHRhYmluZGV4Oi0xfSkuZm9jdXMoKSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcIm9wZW4uemYucmV2ZWFsXFxcIiksdGhpcy5pc2lPUyl7dmFyIG49d2luZG93LnBhZ2VZT2Zmc2V0O3QoXFxcImh0bWwsIGJvZHlcXFwiKS5hZGRDbGFzcyhcXFwiaXMtcmV2ZWFsLW9wZW5cXFwiKS5zY3JvbGxUb3Aobik7fWVsc2UgdChcXFwiYm9keVxcXCIpLmFkZENsYXNzKFxcXCJpcy1yZXZlYWwtb3BlblxcXCIpO3QoXFxcImJvZHlcXFwiKS5hZGRDbGFzcyhcXFwiaXMtcmV2ZWFsLW9wZW5cXFwiKS5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsISghdGhpcy5vcHRpb25zLm92ZXJsYXkmJiF0aGlzLm9wdGlvbnMuZnVsbFNjcmVlbikpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLl9leHRyYUhhbmRsZXJzKCk7fSwwKTt9fSx7a2V5OlxcXCJfZXh0cmFIYW5kbGVyc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3RoaXMuZm9jdXNhYmxlRWxlbWVudHM9Rm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKHRoaXMuJGVsZW1lbnQpLHRoaXMub3B0aW9ucy5vdmVybGF5fHwhdGhpcy5vcHRpb25zLmNsb3NlT25DbGlja3x8dGhpcy5vcHRpb25zLmZ1bGxTY3JlZW58fHQoXFxcImJvZHlcXFwiKS5vbihcXFwiY2xpY2suemYucmV2ZWFsXFxcIixmdW5jdGlvbihpKXtpLnRhcmdldD09PWUuJGVsZW1lbnRbMF18fHQuY29udGFpbnMoZS4kZWxlbWVudFswXSxpLnRhcmdldCl8fGUuY2xvc2UoKTt9KSx0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYyYmdCh3aW5kb3cpLm9uKFxcXCJrZXlkb3duLnpmLnJldmVhbFxcXCIsZnVuY3Rpb24odCl7Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkodCxcXFwiUmV2ZWFsXFxcIix7Y2xvc2U6ZnVuY3Rpb24gY2xvc2UoKXtlLm9wdGlvbnMuY2xvc2VPbkVzYyYmKGUuY2xvc2UoKSxlLiRhbmNob3IuZm9jdXMoKSk7fX0pLDA9PT1lLmZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCYmdC5wcmV2ZW50RGVmYXVsdCgpO30pLHRoaXMuJGVsZW1lbnQub24oXFxcImtleWRvd24uemYucmV2ZWFsXFxcIixmdW5jdGlvbihpKXt2YXIgbj10KHRoaXMpO0ZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGksXFxcIlJldmVhbFxcXCIse3RhYl9mb3J3YXJkOmZ1bmN0aW9uIHRhYl9mb3J3YXJkKCl7ZS4kZWxlbWVudC5maW5kKFxcXCI6Zm9jdXNcXFwiKS5pcyhlLmZvY3VzYWJsZUVsZW1lbnRzLmVxKC0xKSkmJihlLmZvY3VzYWJsZUVsZW1lbnRzLmVxKDApLmZvY3VzKCksaS5wcmV2ZW50RGVmYXVsdCgpKTt9LHRhYl9iYWNrd2FyZDpmdW5jdGlvbiB0YWJfYmFja3dhcmQoKXsoZS4kZWxlbWVudC5maW5kKFxcXCI6Zm9jdXNcXFwiKS5pcyhlLmZvY3VzYWJsZUVsZW1lbnRzLmVxKDApKXx8ZS4kZWxlbWVudC5pcyhcXFwiOmZvY3VzXFxcIikpJiYoZS5mb2N1c2FibGVFbGVtZW50cy5lcSgtMSkuZm9jdXMoKSxpLnByZXZlbnREZWZhdWx0KCkpO30sb3BlbjpmdW5jdGlvbiBvcGVuKCl7ZS4kZWxlbWVudC5maW5kKFxcXCI6Zm9jdXNcXFwiKS5pcyhlLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLWNsb3NlXVxcXCIpKT9zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS4kYW5jaG9yLmZvY3VzKCk7fSwxKTpuLmlzKGUuZm9jdXNhYmxlRWxlbWVudHMpJiZlLm9wZW4oKTt9LGNsb3NlOmZ1bmN0aW9uIGNsb3NlKCl7ZS5vcHRpb25zLmNsb3NlT25Fc2MmJihlLmNsb3NlKCksZS4kYW5jaG9yLmZvY3VzKCkpO319KTt9KTt9fSx7a2V5OlxcXCJjbG9zZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtmdW5jdGlvbiBlKCl7aS5pc2lPUz90KFxcXCJodG1sLCBib2R5XFxcIikucmVtb3ZlQ2xhc3MoXFxcImlzLXJldmVhbC1vcGVuXFxcIik6dChcXFwiYm9keVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJpcy1yZXZlYWwtb3BlblxcXCIpLHQoXFxcImJvZHlcXFwiKS5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOiExLHRhYmluZGV4OlxcXCJcXFwifSksaS4kZWxlbWVudC5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsITApLGkuJGVsZW1lbnQudHJpZ2dlcihcXFwiY2xvc2VkLnpmLnJldmVhbFxcXCIpO31pZighdGhpcy5pc0FjdGl2ZXx8IXRoaXMuJGVsZW1lbnQuaXMoXFxcIjp2aXNpYmxlXFxcIikpcmV0dXJuITE7dmFyIGk9dGhpczt0aGlzLm9wdGlvbnMuYW5pbWF0aW9uT3V0Pyh0aGlzLm9wdGlvbnMub3ZlcmxheT9Gb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJG92ZXJsYXksXFxcImZhZGUtb3V0XFxcIixlKTplKCksRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dCh0aGlzLiRlbGVtZW50LHRoaXMub3B0aW9ucy5hbmltYXRpb25PdXQpKToodGhpcy5vcHRpb25zLm92ZXJsYXk/dGhpcy4kb3ZlcmxheS5oaWRlKDAsZSk6ZSgpLHRoaXMuJGVsZW1lbnQuaGlkZSh0aGlzLm9wdGlvbnMuaGlkZURlbGF5KSksdGhpcy5vcHRpb25zLmNsb3NlT25Fc2MmJnQod2luZG93KS5vZmYoXFxcImtleWRvd24uemYucmV2ZWFsXFxcIiksIXRoaXMub3B0aW9ucy5vdmVybGF5JiZ0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrJiZ0KFxcXCJib2R5XFxcIikub2ZmKFxcXCJjbGljay56Zi5yZXZlYWxcXFwiKSx0aGlzLiRlbGVtZW50Lm9mZihcXFwia2V5ZG93bi56Zi5yZXZlYWxcXFwiKSx0aGlzLm9wdGlvbnMucmVzZXRPbkNsb3NlJiZ0aGlzLiRlbGVtZW50Lmh0bWwodGhpcy4kZWxlbWVudC5odG1sKCkpLHRoaXMuaXNBY3RpdmU9ITEsaS5vcHRpb25zLmRlZXBMaW5rJiYod2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlP3dpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShcXFwiXFxcIixkb2N1bWVudC50aXRsZSx3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpOndpbmRvdy5sb2NhdGlvbi5oYXNoPVxcXCJcXFwiKTt9fSx7a2V5OlxcXCJ0b2dnbGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5pc0FjdGl2ZT90aGlzLmNsb3NlKCk6dGhpcy5vcGVuKCk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLm9wdGlvbnMub3ZlcmxheSYmdGhpcy4kb3ZlcmxheS5oaWRlKCkub2ZmKCkucmVtb3ZlKCksdGhpcy4kZWxlbWVudC5oaWRlKCkub2ZmKCksdGhpcy4kYW5jaG9yLm9mZihcXFwiLnpmXFxcIiksdCh3aW5kb3cpLm9mZihcXFwiLnpmLnJldmVhbDpcXFwiK3RoaXMuaWQpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGk7fSgpO2kuZGVmYXVsdHM9e2FuaW1hdGlvbkluOlxcXCJcXFwiLGFuaW1hdGlvbk91dDpcXFwiXFxcIixzaG93RGVsYXk6MCxoaWRlRGVsYXk6MCxjbG9zZU9uQ2xpY2s6ITAsY2xvc2VPbkVzYzohMCxtdWx0aXBsZU9wZW5lZDohMSx2T2Zmc2V0OjEwMCxoT2Zmc2V0OjAsZnVsbFNjcmVlbjohMSxidG1PZmZzZXRQY3Q6MTAsb3ZlcmxheTohMCxyZXNldE9uQ2xvc2U6ITEsZGVlcExpbms6ITF9LEZvdW5kYXRpb24ucGx1Z2luKGksXFxcIlJldmVhbFxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSl7cmV0dXJuIHQvZTt9ZnVuY3Rpb24gaSh0LGUsaSxuKXtyZXR1cm4gTWF0aC5hYnModC5wb3NpdGlvbigpW2VdK3Rbbl0oKS8yLWkpO312YXIgbj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4oZSxpKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxuKSx0aGlzLiRlbGVtZW50PWUsdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LG4uZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksaSksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiU2xpZGVyXFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiU2xpZGVyXFxcIix7bHRyOntBUlJPV19SSUdIVDpcXFwiaW5jcmVhc2VcXFwiLEFSUk9XX1VQOlxcXCJpbmNyZWFzZVxcXCIsQVJST1dfRE9XTjpcXFwiZGVjcmVhc2VcXFwiLEFSUk9XX0xFRlQ6XFxcImRlY3JlYXNlXFxcIixTSElGVF9BUlJPV19SSUdIVDpcXFwiaW5jcmVhc2VfZmFzdFxcXCIsU0hJRlRfQVJST1dfVVA6XFxcImluY3JlYXNlX2Zhc3RcXFwiLFNISUZUX0FSUk9XX0RPV046XFxcImRlY3JlYXNlX2Zhc3RcXFwiLFNISUZUX0FSUk9XX0xFRlQ6XFxcImRlY3JlYXNlX2Zhc3RcXFwifSxydGw6e0FSUk9XX0xFRlQ6XFxcImluY3JlYXNlXFxcIixBUlJPV19SSUdIVDpcXFwiZGVjcmVhc2VcXFwiLFNISUZUX0FSUk9XX0xFRlQ6XFxcImluY3JlYXNlX2Zhc3RcXFwiLFNISUZUX0FSUk9XX1JJR0hUOlxcXCJkZWNyZWFzZV9mYXN0XFxcIn19KTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhuLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLmlucHV0cz10aGlzLiRlbGVtZW50LmZpbmQoXFxcImlucHV0XFxcIiksdGhpcy5oYW5kbGVzPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtc2xpZGVyLWhhbmRsZV1cXFwiKSx0aGlzLiRoYW5kbGU9dGhpcy5oYW5kbGVzLmVxKDApLHRoaXMuJGlucHV0PXRoaXMuaW5wdXRzLmxlbmd0aD90aGlzLmlucHV0cy5lcSgwKTp0KFxcXCIjXFxcIit0aGlzLiRoYW5kbGUuYXR0cihcXFwiYXJpYS1jb250cm9sc1xcXCIpKSx0aGlzLiRmaWxsPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtc2xpZGVyLWZpbGxdXFxcIikuY3NzKHRoaXMub3B0aW9ucy52ZXJ0aWNhbD9cXFwiaGVpZ2h0XFxcIjpcXFwid2lkdGhcXFwiLDApO3ZhciBlPSExLGk9dGhpczsodGhpcy5vcHRpb25zLmRpc2FibGVkfHx0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5kaXNhYmxlZENsYXNzKSkmJih0aGlzLm9wdGlvbnMuZGlzYWJsZWQ9ITAsdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcykpLHRoaXMuaW5wdXRzLmxlbmd0aHx8KHRoaXMuaW5wdXRzPXQoKS5hZGQodGhpcy4kaW5wdXQpLHRoaXMub3B0aW9ucy5iaW5kaW5nPSEwKSx0aGlzLl9zZXRJbml0QXR0cigwKSx0aGlzLl9ldmVudHModGhpcy4kaGFuZGxlKSx0aGlzLmhhbmRsZXNbMV0mJih0aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQ9ITAsdGhpcy4kaGFuZGxlMj10aGlzLmhhbmRsZXMuZXEoMSksdGhpcy4kaW5wdXQyPXRoaXMuaW5wdXRzLmxlbmd0aD4xP3RoaXMuaW5wdXRzLmVxKDEpOnQoXFxcIiNcXFwiK3RoaXMuJGhhbmRsZTIuYXR0cihcXFwiYXJpYS1jb250cm9sc1xcXCIpKSx0aGlzLmlucHV0c1sxXXx8KHRoaXMuaW5wdXRzPXRoaXMuaW5wdXRzLmFkZCh0aGlzLiRpbnB1dDIpKSxlPSEwLHRoaXMuX3NldEhhbmRsZVBvcyh0aGlzLiRoYW5kbGUsdGhpcy5vcHRpb25zLmluaXRpYWxTdGFydCwhMCxmdW5jdGlvbigpe2kuX3NldEhhbmRsZVBvcyhpLiRoYW5kbGUyLGkub3B0aW9ucy5pbml0aWFsRW5kLCEwKTt9KSx0aGlzLl9zZXRJbml0QXR0cigxKSx0aGlzLl9ldmVudHModGhpcy4kaGFuZGxlMikpLGV8fHRoaXMuX3NldEhhbmRsZVBvcyh0aGlzLiRoYW5kbGUsdGhpcy5vcHRpb25zLmluaXRpYWxTdGFydCwhMCk7fX0se2tleTpcXFwiX3NldEhhbmRsZVBvc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxpLG4scyl7aT1wYXJzZUZsb2F0KGkpLGk8dGhpcy5vcHRpb25zLnN0YXJ0P2k9dGhpcy5vcHRpb25zLnN0YXJ0Omk+dGhpcy5vcHRpb25zLmVuZCYmKGk9dGhpcy5vcHRpb25zLmVuZCk7dmFyIG89dGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkO2lmKG8paWYoMD09PXRoaXMuaGFuZGxlcy5pbmRleCh0KSl7dmFyIGE9cGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyLmF0dHIoXFxcImFyaWEtdmFsdWVub3dcXFwiKSk7aT1pPj1hP2EtdGhpcy5vcHRpb25zLnN0ZXA6aTt9ZWxzZXt2YXIgcj1wYXJzZUZsb2F0KHRoaXMuJGhhbmRsZS5hdHRyKFxcXCJhcmlhLXZhbHVlbm93XFxcIikpO2k9cj49aT9yK3RoaXMub3B0aW9ucy5zdGVwOmk7fXRoaXMub3B0aW9ucy52ZXJ0aWNhbCYmIW4mJihpPXRoaXMub3B0aW9ucy5lbmQtaSk7dmFyIGw9dGhpcyx1PXRoaXMub3B0aW9ucy52ZXJ0aWNhbCxkPXU/XFxcImhlaWdodFxcXCI6XFxcIndpZHRoXFxcIixoPXU/XFxcInRvcFxcXCI6XFxcImxlZnRcXFwiLGM9dFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkXSxmPXRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZF0scD1lKGksdGhpcy5vcHRpb25zLmVuZCkudG9GaXhlZCgyKSxtPShmLWMpKnAsdj0oMTAwKmUobSxmKSkudG9GaXhlZCh0aGlzLm9wdGlvbnMuZGVjaW1hbCk7aT1wYXJzZUZsb2F0KGkudG9GaXhlZCh0aGlzLm9wdGlvbnMuZGVjaW1hbCkpO3ZhciBnPXt9O2lmKHRoaXMuX3NldFZhbHVlcyh0LGkpLG8pe3ZhciB3LHk9MD09PXRoaXMuaGFuZGxlcy5pbmRleCh0KSxiPX5+KDEwMCplKGMsZikpO2lmKHkpZ1toXT12K1xcXCIlXFxcIix3PXBhcnNlRmxvYXQodGhpcy4kaGFuZGxlMlswXS5zdHlsZVtoXSktditiLHMmJlxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBzJiZzKCk7ZWxzZXt2YXIgJD1wYXJzZUZsb2F0KHRoaXMuJGhhbmRsZVswXS5zdHlsZVtoXSk7dz12LShpc05hTigkKT90aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXJ0LygodGhpcy5vcHRpb25zLmVuZC10aGlzLm9wdGlvbnMuc3RhcnQpLzEwMCk6JCkrYjt9Z1tcXFwibWluLVxcXCIrZF09dytcXFwiJVxcXCI7fXRoaXMuJGVsZW1lbnQub25lKFxcXCJmaW5pc2hlZC56Zi5hbmltYXRlXFxcIixmdW5jdGlvbigpe2wuJGVsZW1lbnQudHJpZ2dlcihcXFwibW92ZWQuemYuc2xpZGVyXFxcIixbdF0pO30pO3ZhciBDPXRoaXMuJGVsZW1lbnQuZGF0YShcXFwiZHJhZ2dpbmdcXFwiKT8xZTMvNjA6dGhpcy5vcHRpb25zLm1vdmVUaW1lO0ZvdW5kYXRpb24uTW92ZShDLHQsZnVuY3Rpb24oKXt0LmNzcyhoLHYrXFxcIiVcXFwiKSxsLm9wdGlvbnMuZG91YmxlU2lkZWQ/bC4kZmlsbC5jc3MoZyk6bC4kZmlsbC5jc3MoZCwxMDAqcCtcXFwiJVxcXCIpO30pO319LHtrZXk6XFxcIl9zZXRJbml0QXR0clxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpcy5pbnB1dHMuZXEodCkuYXR0cihcXFwiaWRcXFwiKXx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJzbGlkZXJcXFwiKTt0aGlzLmlucHV0cy5lcSh0KS5hdHRyKHtpZDplLG1heDp0aGlzLm9wdGlvbnMuZW5kLG1pbjp0aGlzLm9wdGlvbnMuc3RhcnQsc3RlcDp0aGlzLm9wdGlvbnMuc3RlcH0pLHRoaXMuaGFuZGxlcy5lcSh0KS5hdHRyKHtyb2xlOlxcXCJzbGlkZXJcXFwiLFxcXCJhcmlhLWNvbnRyb2xzXFxcIjplLFxcXCJhcmlhLXZhbHVlbWF4XFxcIjp0aGlzLm9wdGlvbnMuZW5kLFxcXCJhcmlhLXZhbHVlbWluXFxcIjp0aGlzLm9wdGlvbnMuc3RhcnQsXFxcImFyaWEtdmFsdWVub3dcXFwiOjA9PT10P3RoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQ6dGhpcy5vcHRpb25zLmluaXRpYWxFbmQsXFxcImFyaWEtb3JpZW50YXRpb25cXFwiOnRoaXMub3B0aW9ucy52ZXJ0aWNhbD9cXFwidmVydGljYWxcXFwiOlxcXCJob3Jpem9udGFsXFxcIix0YWJpbmRleDowfSk7fX0se2tleTpcXFwiX3NldFZhbHVlc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlKXt2YXIgaT10aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQ/dGhpcy5oYW5kbGVzLmluZGV4KHQpOjA7dGhpcy5pbnB1dHMuZXEoaSkudmFsKGUpLHQuYXR0cihcXFwiYXJpYS12YWx1ZW5vd1xcXCIsZSk7fX0se2tleTpcXFwiX2hhbmRsZUV2ZW50XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0LG4scyl7dmFyIG8sYTtpZihzKW89dGhpcy5fYWRqdXN0VmFsdWUobnVsbCxzKSxhPSEwO2Vsc2V7dC5wcmV2ZW50RGVmYXVsdCgpO3ZhciByPXRoaXMsbD10aGlzLm9wdGlvbnMudmVydGljYWwsdT1sP1xcXCJoZWlnaHRcXFwiOlxcXCJ3aWR0aFxcXCIsZD1sP1xcXCJ0b3BcXFwiOlxcXCJsZWZ0XFxcIixoPWw/dC5wYWdlWTp0LnBhZ2VYLGM9dGhpcy4kaGFuZGxlWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3VdLzIsZj10aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3VdLHA9dGhpcy4kZWxlbWVudC5vZmZzZXQoKVtkXS1oLG09cD4wPy1jOi1mPnAtYz9mOk1hdGguYWJzKHApLHY9ZShtLGYpO2lmKG89KHRoaXMub3B0aW9ucy5lbmQtdGhpcy5vcHRpb25zLnN0YXJ0KSp2LEZvdW5kYXRpb24ucnRsKCkmJiF0aGlzLm9wdGlvbnMudmVydGljYWwmJihvPXRoaXMub3B0aW9ucy5lbmQtbyksbz1yLl9hZGp1c3RWYWx1ZShudWxsLG8pLGE9ITEsIW4pe3ZhciBnPWkodGhpcy4kaGFuZGxlLGQsbSx1KSx3PWkodGhpcy4kaGFuZGxlMixkLG0sdSk7bj13Pj1nP3RoaXMuJGhhbmRsZTp0aGlzLiRoYW5kbGUyO319dGhpcy5fc2V0SGFuZGxlUG9zKG4sbyxhKTt9fSx7a2V5OlxcXCJfYWRqdXN0VmFsdWVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQsZSl7dmFyIGksbixzLG8sYT10aGlzLm9wdGlvbnMuc3RlcCxyPXBhcnNlRmxvYXQoYS8yKTtyZXR1cm4gaT10P3BhcnNlRmxvYXQodC5hdHRyKFxcXCJhcmlhLXZhbHVlbm93XFxcIikpOmUsbj1pJWEscz1pLW4sbz1zK2EsMD09PW4/aTppPWk+PXMrcj9vOnM7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7aWYodGhpcy5vcHRpb25zLmRpc2FibGVkKXJldHVybiExO3ZhciBpLG49dGhpcztpZih0aGlzLmlucHV0cy5vZmYoXFxcImNoYW5nZS56Zi5zbGlkZXJcXFwiKS5vbihcXFwiY2hhbmdlLnpmLnNsaWRlclxcXCIsZnVuY3Rpb24oZSl7dmFyIGk9bi5pbnB1dHMuaW5kZXgodCh0aGlzKSk7bi5faGFuZGxlRXZlbnQoZSxuLmhhbmRsZXMuZXEoaSksdCh0aGlzKS52YWwoKSk7fSksdGhpcy5vcHRpb25zLmNsaWNrU2VsZWN0JiZ0aGlzLiRlbGVtZW50Lm9mZihcXFwiY2xpY2suemYuc2xpZGVyXFxcIikub24oXFxcImNsaWNrLnpmLnNsaWRlclxcXCIsZnVuY3Rpb24oZSl7cmV0dXJuIG4uJGVsZW1lbnQuZGF0YShcXFwiZHJhZ2dpbmdcXFwiKT8hMTp2b2lkKHQoZS50YXJnZXQpLmlzKFxcXCJbZGF0YS1zbGlkZXItaGFuZGxlXVxcXCIpfHwobi5vcHRpb25zLmRvdWJsZVNpZGVkP24uX2hhbmRsZUV2ZW50KGUpOm4uX2hhbmRsZUV2ZW50KGUsbi4kaGFuZGxlKSkpO30pLHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpe3RoaXMuaGFuZGxlcy5hZGRUb3VjaCgpO3ZhciBzPXQoXFxcImJvZHlcXFwiKTtlLm9mZihcXFwibW91c2Vkb3duLnpmLnNsaWRlclxcXCIpLm9uKFxcXCJtb3VzZWRvd24uemYuc2xpZGVyXFxcIixmdW5jdGlvbihvKXtlLmFkZENsYXNzKFxcXCJpcy1kcmFnZ2luZ1xcXCIpLG4uJGZpbGwuYWRkQ2xhc3MoXFxcImlzLWRyYWdnaW5nXFxcIiksbi4kZWxlbWVudC5kYXRhKFxcXCJkcmFnZ2luZ1xcXCIsITApLGk9dChvLmN1cnJlbnRUYXJnZXQpLHMub24oXFxcIm1vdXNlbW92ZS56Zi5zbGlkZXJcXFwiLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKSxuLl9oYW5kbGVFdmVudCh0LGkpO30pLm9uKFxcXCJtb3VzZXVwLnpmLnNsaWRlclxcXCIsZnVuY3Rpb24odCl7bi5faGFuZGxlRXZlbnQodCxpKSxlLnJlbW92ZUNsYXNzKFxcXCJpcy1kcmFnZ2luZ1xcXCIpLG4uJGZpbGwucmVtb3ZlQ2xhc3MoXFxcImlzLWRyYWdnaW5nXFxcIiksbi4kZWxlbWVudC5kYXRhKFxcXCJkcmFnZ2luZ1xcXCIsITEpLHMub2ZmKFxcXCJtb3VzZW1vdmUuemYuc2xpZGVyIG1vdXNldXAuemYuc2xpZGVyXFxcIik7fSk7fSk7fWUub2ZmKFxcXCJrZXlkb3duLnpmLnNsaWRlclxcXCIpLm9uKFxcXCJrZXlkb3duLnpmLnNsaWRlclxcXCIsZnVuY3Rpb24oZSl7dmFyIGkscz10KHRoaXMpLG89bi5vcHRpb25zLmRvdWJsZVNpZGVkP24uaGFuZGxlcy5pbmRleChzKTowLGE9cGFyc2VGbG9hdChuLmlucHV0cy5lcShvKS52YWwoKSk7Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSxcXFwiU2xpZGVyXFxcIix7ZGVjcmVhc2U6ZnVuY3Rpb24gZGVjcmVhc2UoKXtpPWEtbi5vcHRpb25zLnN0ZXA7fSxpbmNyZWFzZTpmdW5jdGlvbiBpbmNyZWFzZSgpe2k9YStuLm9wdGlvbnMuc3RlcDt9LGRlY3JlYXNlX2Zhc3Q6ZnVuY3Rpb24gZGVjcmVhc2VfZmFzdCgpe2k9YS0xMCpuLm9wdGlvbnMuc3RlcDt9LGluY3JlYXNlX2Zhc3Q6ZnVuY3Rpb24gaW5jcmVhc2VfZmFzdCgpe2k9YSsxMCpuLm9wdGlvbnMuc3RlcDt9LGhhbmRsZWQ6ZnVuY3Rpb24gaGFuZGxlZCgpe2UucHJldmVudERlZmF1bHQoKSxuLl9zZXRIYW5kbGVQb3MocyxpLCEwKTt9fSk7fSk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLmhhbmRsZXMub2ZmKFxcXCIuemYuc2xpZGVyXFxcIiksdGhpcy5pbnB1dHMub2ZmKFxcXCIuemYuc2xpZGVyXFxcIiksdGhpcy4kZWxlbWVudC5vZmYoXFxcIi56Zi5zbGlkZXJcXFwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxuO30oKTtuLmRlZmF1bHRzPXtzdGFydDowLGVuZDoxMDAsc3RlcDoxLGluaXRpYWxTdGFydDowLGluaXRpYWxFbmQ6MTAwLGJpbmRpbmc6ITEsY2xpY2tTZWxlY3Q6ITAsdmVydGljYWw6ITEsZHJhZ2dhYmxlOiEwLGRpc2FibGVkOiExLGRvdWJsZVNpZGVkOiExLGRlY2ltYWw6Mixtb3ZlVGltZToyMDAsZGlzYWJsZWRDbGFzczpcXFwiZGlzYWJsZWRcXFwiLGludmVydFZlcnRpY2FsOiExfSxGb3VuZGF0aW9uLnBsdWdpbihuLFxcXCJTbGlkZXJcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtyZXR1cm4gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSxudWxsKS5mb250U2l6ZSwxMCkqdDt9dmFyIGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBpKGUsbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsaSksdGhpcy4kZWxlbWVudD1lLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxpLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIlN0aWNreVxcXCIpO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGksW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXMuJGVsZW1lbnQucGFyZW50KFxcXCJbZGF0YS1zdGlja3ktY29udGFpbmVyXVxcXCIpLGk9dGhpcy4kZWxlbWVudFswXS5pZHx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJzdGlja3lcXFwiKSxuPXRoaXM7ZS5sZW5ndGh8fCh0aGlzLndhc1dyYXBwZWQ9ITApLHRoaXMuJGNvbnRhaW5lcj1lLmxlbmd0aD9lOnQodGhpcy5vcHRpb25zLmNvbnRhaW5lcikud3JhcElubmVyKHRoaXMuJGVsZW1lbnQpLHRoaXMuJGNvbnRhaW5lci5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY29udGFpbmVyQ2xhc3MpLHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnN0aWNreUNsYXNzKS5hdHRyKHtcXFwiZGF0YS1yZXNpemVcXFwiOml9KSx0aGlzLnNjcm9sbENvdW50PXRoaXMub3B0aW9ucy5jaGVja0V2ZXJ5LHRoaXMuaXNTdHVjaz0hMSx0KHdpbmRvdykub25lKFxcXCJsb2FkLnpmLnN0aWNreVxcXCIsZnVuY3Rpb24oKXtcXFwiXFxcIiE9PW4ub3B0aW9ucy5hbmNob3I/bi4kYW5jaG9yPXQoXFxcIiNcXFwiK24ub3B0aW9ucy5hbmNob3IpOm4uX3BhcnNlUG9pbnRzKCksbi5fc2V0U2l6ZXMoZnVuY3Rpb24oKXtuLl9jYWxjKCExKTt9KSxuLl9ldmVudHMoaS5zcGxpdChcXFwiLVxcXCIpLnJldmVyc2UoKS5qb2luKFxcXCItXFxcIikpO30pO319LHtrZXk6XFxcIl9wYXJzZVBvaW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzLm9wdGlvbnMudG9wQW5jaG9yLGk9dGhpcy5vcHRpb25zLmJ0bUFuY2hvcixuPVtlLGldLHM9e307aWYoZSYmaSlmb3IodmFyIG89MCxhPW4ubGVuZ3RoO2E+byYmbltvXTtvKyspe3ZhciByO2lmKFxcXCJudW1iZXJcXFwiPT10eXBlb2YgbltvXSlyPW5bb107ZWxzZXt2YXIgbD1uW29dLnNwbGl0KFxcXCI6XFxcIiksdT10KFxcXCIjXFxcIitsWzBdKTtyPXUub2Zmc2V0KCkudG9wLGxbMV0mJlxcXCJib3R0b21cXFwiPT09bFsxXS50b0xvd2VyQ2FzZSgpJiYocis9dVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpO31zW29dPXI7fWVsc2Ugcz17MDoxLDE6ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodH07dGhpcy5wb2ludHM9czt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT10aGlzLG49dGhpcy5zY3JvbGxMaXN0ZW5lcj1cXFwic2Nyb2xsLnpmLlxcXCIrZTt0aGlzLmlzT258fCh0aGlzLmNhblN0aWNrJiYodGhpcy5pc09uPSEwLHQod2luZG93KS5vZmYobikub24obixmdW5jdGlvbih0KXswPT09aS5zY3JvbGxDb3VudD8oaS5zY3JvbGxDb3VudD1pLm9wdGlvbnMuY2hlY2tFdmVyeSxpLl9zZXRTaXplcyhmdW5jdGlvbigpe2kuX2NhbGMoITEsd2luZG93LnBhZ2VZT2Zmc2V0KTt9KSk6KGkuc2Nyb2xsQ291bnQtLSxpLl9jYWxjKCExLHdpbmRvdy5wYWdlWU9mZnNldCkpO30pKSx0aGlzLiRlbGVtZW50Lm9mZihcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCIpLm9uKFxcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIixmdW5jdGlvbih0LHMpe2kuX3NldFNpemVzKGZ1bmN0aW9uKCl7aS5fY2FsYyghMSksaS5jYW5TdGljaz9pLmlzT258fGkuX2V2ZW50cyhlKTppLmlzT24mJmkuX3BhdXNlTGlzdGVuZXJzKG4pO30pO30pKTt9fSx7a2V5OlxcXCJfcGF1c2VMaXN0ZW5lcnNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3RoaXMuaXNPbj0hMSx0KHdpbmRvdykub2ZmKGUpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwicGF1c2UuemYuc3RpY2t5XFxcIik7fX0se2tleTpcXFwiX2NhbGNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQsZSl7cmV0dXJuIHQmJnRoaXMuX3NldFNpemVzKCksdGhpcy5jYW5TdGljaz8oZXx8KGU9d2luZG93LnBhZ2VZT2Zmc2V0KSx2b2lkKGU+PXRoaXMudG9wUG9pbnQ/ZTw9dGhpcy5ib3R0b21Qb2ludD90aGlzLmlzU3R1Y2t8fHRoaXMuX3NldFN0aWNreSgpOnRoaXMuaXNTdHVjayYmdGhpcy5fcmVtb3ZlU3RpY2t5KCExKTp0aGlzLmlzU3R1Y2smJnRoaXMuX3JlbW92ZVN0aWNreSghMCkpKToodGhpcy5pc1N0dWNrJiZ0aGlzLl9yZW1vdmVTdGlja3koITApLCExKTt9fSx7a2V5OlxcXCJfc2V0U3RpY2t5XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXMub3B0aW9ucy5zdGlja1RvLGU9XFxcInRvcFxcXCI9PT10P1xcXCJtYXJnaW5Ub3BcXFwiOlxcXCJtYXJnaW5Cb3R0b21cXFwiLGk9XFxcInRvcFxcXCI9PT10P1xcXCJib3R0b21cXFwiOlxcXCJ0b3BcXFwiLG49e307bltlXT10aGlzLm9wdGlvbnNbZV0rXFxcImVtXFxcIixuW3RdPTAsbltpXT1cXFwiYXV0b1xcXCIsbi5sZWZ0PXRoaXMuJGNvbnRhaW5lci5vZmZzZXQoKS5sZWZ0K3BhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJGNvbnRhaW5lclswXSlbXFxcInBhZGRpbmctbGVmdFxcXCJdLDEwKSx0aGlzLmlzU3R1Y2s9ITAsdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwiaXMtYW5jaG9yZWQgaXMtYXQtXFxcIitpKS5hZGRDbGFzcyhcXFwiaXMtc3R1Y2sgaXMtYXQtXFxcIit0KS5jc3MobikudHJpZ2dlcihcXFwic3RpY2t5LnpmLnN0dWNrdG86XFxcIit0KTt9fSx7a2V5OlxcXCJfcmVtb3ZlU3RpY2t5XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT10aGlzLm9wdGlvbnMuc3RpY2tUbyxpPVxcXCJ0b3BcXFwiPT09ZSxuPXt9LHM9KHRoaXMucG9pbnRzP3RoaXMucG9pbnRzWzFdLXRoaXMucG9pbnRzWzBdOnRoaXMuYW5jaG9ySGVpZ2h0KS10aGlzLmVsZW1IZWlnaHQsbz1pP1xcXCJtYXJnaW5Ub3BcXFwiOlxcXCJtYXJnaW5Cb3R0b21cXFwiLGE9aT9cXFwiYm90dG9tXFxcIjpcXFwidG9wXFxcIixyPXQ/XFxcInRvcFxcXCI6XFxcImJvdHRvbVxcXCI7bltvXT0wLHQmJiFpfHxpJiYhdD8obltlXT1zLG5bYV09MCk6KG5bZV09MCxuW2FdPXMpLG4ubGVmdD1cXFwiXFxcIix0aGlzLmlzU3R1Y2s9ITEsdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwiaXMtc3R1Y2sgaXMtYXQtXFxcIitlKS5hZGRDbGFzcyhcXFwiaXMtYW5jaG9yZWQgaXMtYXQtXFxcIityKS5jc3MobikudHJpZ2dlcihcXFwic3RpY2t5LnpmLnVuc3R1Y2tmcm9tOlxcXCIrcik7fX0se2tleTpcXFwiX3NldFNpemVzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt0aGlzLmNhblN0aWNrPUZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5zdGlja3lPbiksdGhpcy5jYW5TdGlja3x8dCgpO3ZhciBlPXRoaXMuJGNvbnRhaW5lclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCxpPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJGNvbnRhaW5lclswXSksbj1wYXJzZUludChpW1xcXCJwYWRkaW5nLXJpZ2h0XFxcIl0sMTApO3RoaXMuJGFuY2hvciYmdGhpcy4kYW5jaG9yLmxlbmd0aD90aGlzLmFuY2hvckhlaWdodD10aGlzLiRhbmNob3JbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0OnRoaXMuX3BhcnNlUG9pbnRzKCksdGhpcy4kZWxlbWVudC5jc3Moe1xcXCJtYXgtd2lkdGhcXFwiOmUtbitcXFwicHhcXFwifSk7dmFyIHM9dGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHR8fHRoaXMuY29udGFpbmVySGVpZ2h0O3RoaXMuY29udGFpbmVySGVpZ2h0PXMsdGhpcy4kY29udGFpbmVyLmNzcyh7aGVpZ2h0OnN9KSx0aGlzLmVsZW1IZWlnaHQ9cyx0aGlzLmlzU3R1Y2smJnRoaXMuJGVsZW1lbnQuY3NzKHtsZWZ0OnRoaXMuJGNvbnRhaW5lci5vZmZzZXQoKS5sZWZ0K3BhcnNlSW50KGlbXFxcInBhZGRpbmctbGVmdFxcXCJdLDEwKX0pLHRoaXMuX3NldEJyZWFrUG9pbnRzKHMsZnVuY3Rpb24oKXt0JiZ0KCk7fSk7fX0se2tleTpcXFwiX3NldEJyZWFrUG9pbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0LGkpe2lmKCF0aGlzLmNhblN0aWNrKXtpZighaSlyZXR1cm4hMTtpKCk7fXZhciBuPWUodGhpcy5vcHRpb25zLm1hcmdpblRvcCkscz1lKHRoaXMub3B0aW9ucy5tYXJnaW5Cb3R0b20pLG89dGhpcy5wb2ludHM/dGhpcy5wb2ludHNbMF06dGhpcy4kYW5jaG9yLm9mZnNldCgpLnRvcCxhPXRoaXMucG9pbnRzP3RoaXMucG9pbnRzWzFdOm8rdGhpcy5hbmNob3JIZWlnaHQscj13aW5kb3cuaW5uZXJIZWlnaHQ7XFxcInRvcFxcXCI9PT10aGlzLm9wdGlvbnMuc3RpY2tUbz8oby09bixhLT10K24pOlxcXCJib3R0b21cXFwiPT09dGhpcy5vcHRpb25zLnN0aWNrVG8mJihvLT1yLSh0K3MpLGEtPXItcyksdGhpcy50b3BQb2ludD1vLHRoaXMuYm90dG9tUG9pbnQ9YSxpJiZpKCk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLl9yZW1vdmVTdGlja3koITApLHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnN0aWNreUNsYXNzK1xcXCIgaXMtYW5jaG9yZWQgaXMtYXQtdG9wXFxcIikuY3NzKHtoZWlnaHQ6XFxcIlxcXCIsdG9wOlxcXCJcXFwiLGJvdHRvbTpcXFwiXFxcIixcXFwibWF4LXdpZHRoXFxcIjpcXFwiXFxcIn0pLm9mZihcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCIpLHRoaXMuJGFuY2hvci5vZmYoXFxcImNoYW5nZS56Zi5zdGlja3lcXFwiKSx0KHdpbmRvdykub2ZmKHRoaXMuc2Nyb2xsTGlzdGVuZXIpLHRoaXMud2FzV3JhcHBlZD90aGlzLiRlbGVtZW50LnVud3JhcCgpOnRoaXMuJGNvbnRhaW5lci5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuY29udGFpbmVyQ2xhc3MpLmNzcyh7aGVpZ2h0OlxcXCJcXFwifSksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksaTt9KCk7aS5kZWZhdWx0cz17Y29udGFpbmVyOlxcXCI8ZGl2IGRhdGEtc3RpY2t5LWNvbnRhaW5lcj48L2Rpdj5cXFwiLHN0aWNrVG86XFxcInRvcFxcXCIsYW5jaG9yOlxcXCJcXFwiLHRvcEFuY2hvcjpcXFwiXFxcIixidG1BbmNob3I6XFxcIlxcXCIsbWFyZ2luVG9wOjEsbWFyZ2luQm90dG9tOjEsc3RpY2t5T246XFxcIm1lZGl1bVxcXCIsc3RpY2t5Q2xhc3M6XFxcInN0aWNreVxcXCIsY29udGFpbmVyQ2xhc3M6XFxcInN0aWNreS1jb250YWluZXJcXFwiLGNoZWNrRXZlcnk6LTF9LEZvdW5kYXRpb24ucGx1Z2luKGksXFxcIlN0aWNreVxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiVGFic1xcXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIlRhYnNcXFwiLHtFTlRFUjpcXFwib3BlblxcXCIsU1BBQ0U6XFxcIm9wZW5cXFwiLEFSUk9XX1JJR0hUOlxcXCJuZXh0XFxcIixBUlJPV19VUDpcXFwicHJldmlvdXNcXFwiLEFSUk9XX0RPV046XFxcIm5leHRcXFwiLEFSUk9XX0xFRlQ6XFxcInByZXZpb3VzXFxcIn0pO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7aWYodGhpcy4kdGFiVGl0bGVzPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmxpbmtDbGFzcyksdGhpcy4kdGFiQ29udGVudD10KCdbZGF0YS10YWJzLWNvbnRlbnQ9XFxcIicrdGhpcy4kZWxlbWVudFswXS5pZCsnXFxcIl0nKSx0aGlzLiR0YWJUaXRsZXMuZWFjaChmdW5jdGlvbigpe3ZhciBpPXQodGhpcyksbj1pLmZpbmQoXFxcImFcXFwiKSxzPWkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLG89blswXS5oYXNoLnNsaWNlKDEpLGE9blswXS5pZD9uWzBdLmlkOm8rXFxcIi1sYWJlbFxcXCIscj10KFxcXCIjXFxcIitvKTtpLmF0dHIoe3JvbGU6XFxcInByZXNlbnRhdGlvblxcXCJ9KSxuLmF0dHIoe3JvbGU6XFxcInRhYlxcXCIsXFxcImFyaWEtY29udHJvbHNcXFwiOm8sXFxcImFyaWEtc2VsZWN0ZWRcXFwiOnMsaWQ6YX0pLHIuYXR0cih7cm9sZTpcXFwidGFicGFuZWxcXFwiLFxcXCJhcmlhLWhpZGRlblxcXCI6IXMsXFxcImFyaWEtbGFiZWxsZWRieVxcXCI6YX0pLHMmJmUub3B0aW9ucy5hdXRvRm9jdXMmJm4uZm9jdXMoKTt9KSx0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQpe3ZhciBpPXRoaXMuJHRhYkNvbnRlbnQuZmluZChcXFwiaW1nXFxcIik7aS5sZW5ndGg/Rm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZChpLHRoaXMuX3NldEhlaWdodC5iaW5kKHRoaXMpKTp0aGlzLl9zZXRIZWlnaHQoKTt9dGhpcy5fZXZlbnRzKCk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLl9hZGRLZXlIYW5kbGVyKCksdGhpcy5fYWRkQ2xpY2tIYW5kbGVyKCksdGhpcy5vcHRpb25zLm1hdGNoSGVpZ2h0JiZ0KHdpbmRvdykub24oXFxcImNoYW5nZWQuemYubWVkaWFxdWVyeVxcXCIsdGhpcy5fc2V0SGVpZ2h0LmJpbmQodGhpcykpO319LHtrZXk6XFxcIl9hZGRDbGlja0hhbmRsZXJcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpczt0aGlzLiRlbGVtZW50Lm9mZihcXFwiY2xpY2suemYudGFic1xcXCIpLm9uKFxcXCJjbGljay56Zi50YWJzXFxcIixcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmxpbmtDbGFzcyxmdW5jdGlvbihpKXtpLnByZXZlbnREZWZhdWx0KCksaS5zdG9wUHJvcGFnYXRpb24oKSx0KHRoaXMpLmhhc0NsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKXx8ZS5faGFuZGxlVGFiQ2hhbmdlKHQodGhpcykpO30pO319LHtrZXk6XFxcIl9hZGRLZXlIYW5kbGVyXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7ZS4kZWxlbWVudC5maW5kKFxcXCJsaTpmaXJzdC1vZi10eXBlXFxcIiksZS4kZWxlbWVudC5maW5kKFxcXCJsaTpsYXN0LW9mLXR5cGVcXFwiKTt0aGlzLiR0YWJUaXRsZXMub2ZmKFxcXCJrZXlkb3duLnpmLnRhYnNcXFwiKS5vbihcXFwia2V5ZG93bi56Zi50YWJzXFxcIixmdW5jdGlvbihpKXtpZig5IT09aS53aGljaCl7aS5zdG9wUHJvcGFnYXRpb24oKSxpLnByZXZlbnREZWZhdWx0KCk7dmFyIG4scyxvPXQodGhpcyksYT1vLnBhcmVudChcXFwidWxcXFwiKS5jaGlsZHJlbihcXFwibGlcXFwiKTthLmVhY2goZnVuY3Rpb24oaSl7cmV0dXJuIHQodGhpcykuaXMobyk/dm9pZChlLm9wdGlvbnMud3JhcE9uS2V5cz8obj0wPT09aT9hLmxhc3QoKTphLmVxKGktMSkscz1pPT09YS5sZW5ndGgtMT9hLmZpcnN0KCk6YS5lcShpKzEpKToobj1hLmVxKE1hdGgubWF4KDAsaS0xKSkscz1hLmVxKE1hdGgubWluKGkrMSxhLmxlbmd0aC0xKSkpKTp2b2lkIDA7fSksRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoaSxcXFwiVGFic1xcXCIse29wZW46ZnVuY3Rpb24gb3Blbigpe28uZmluZCgnW3JvbGU9XFxcInRhYlxcXCJdJykuZm9jdXMoKSxlLl9oYW5kbGVUYWJDaGFuZ2Uobyk7fSxwcmV2aW91czpmdW5jdGlvbiBwcmV2aW91cygpe24uZmluZCgnW3JvbGU9XFxcInRhYlxcXCJdJykuZm9jdXMoKSxlLl9oYW5kbGVUYWJDaGFuZ2Uobik7fSxuZXh0OmZ1bmN0aW9uIG5leHQoKXtzLmZpbmQoJ1tyb2xlPVxcXCJ0YWJcXFwiXScpLmZvY3VzKCksZS5faGFuZGxlVGFiQ2hhbmdlKHMpO319KTt9fSk7fX0se2tleTpcXFwiX2hhbmRsZVRhYkNoYW5nZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGk9ZS5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKSxuPWlbMF0uaGFzaCxzPXRoaXMuJHRhYkNvbnRlbnQuZmluZChuKSxvPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmxpbmtDbGFzcytcXFwiLmlzLWFjdGl2ZVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKS5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKS5hdHRyKHtcXFwiYXJpYS1zZWxlY3RlZFxcXCI6XFxcImZhbHNlXFxcIn0pO3QoXFxcIiNcXFwiK28uYXR0cihcXFwiYXJpYS1jb250cm9sc1xcXCIpKS5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikuYXR0cih7XFxcImFyaWEtaGlkZGVuXFxcIjpcXFwidHJ1ZVxcXCJ9KSxlLmFkZENsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKSxpLmF0dHIoe1xcXCJhcmlhLXNlbGVjdGVkXFxcIjpcXFwidHJ1ZVxcXCJ9KSxzLmFkZENsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKS5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOlxcXCJmYWxzZVxcXCJ9KSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcImNoYW5nZS56Zi50YWJzXFxcIixbZV0pO319LHtrZXk6XFxcInNlbGVjdFRhYlxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU7ZT1cXFwib2JqZWN0XFxcIj09KHR5cGVvZiB0PT09XFxcInVuZGVmaW5lZFxcXCI/XFxcInVuZGVmaW5lZFxcXCI6X3R5cGVvZih0KSk/dFswXS5pZDp0LGUuaW5kZXhPZihcXFwiI1xcXCIpPDAmJihlPVxcXCIjXFxcIitlKTt2YXIgaT10aGlzLiR0YWJUaXRsZXMuZmluZCgnW2hyZWY9XFxcIicrZSsnXFxcIl0nKS5wYXJlbnQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5saW5rQ2xhc3MpO3RoaXMuX2hhbmRsZVRhYkNoYW5nZShpKTt9fSx7a2V5OlxcXCJfc2V0SGVpZ2h0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPTA7dGhpcy4kdGFiQ29udGVudC5maW5kKFxcXCIuXFxcIit0aGlzLm9wdGlvbnMucGFuZWxDbGFzcykuY3NzKFxcXCJoZWlnaHRcXFwiLFxcXCJcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGk9dCh0aGlzKSxuPWkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpO258fGkuY3NzKHt2aXNpYmlsaXR5OlxcXCJoaWRkZW5cXFwiLGRpc3BsYXk6XFxcImJsb2NrXFxcIn0pO3ZhciBzPXRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O258fGkuY3NzKHt2aXNpYmlsaXR5OlxcXCJcXFwiLGRpc3BsYXk6XFxcIlxcXCJ9KSxlPXM+ZT9zOmU7fSkuY3NzKFxcXCJoZWlnaHRcXFwiLGUrXFxcInB4XFxcIik7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5saW5rQ2xhc3MpLm9mZihcXFwiLnpmLnRhYnNcXFwiKS5oaWRlKCkuZW5kKCkuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLnBhbmVsQ2xhc3MpLmhpZGUoKSx0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQmJnQod2luZG93KS5vZmYoXFxcImNoYW5nZWQuemYubWVkaWFxdWVyeVxcXCIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e2F1dG9Gb2N1czohMSx3cmFwT25LZXlzOiEwLG1hdGNoSGVpZ2h0OiExLGxpbmtDbGFzczpcXFwidGFicy10aXRsZVxcXCIscGFuZWxDbGFzczpcXFwidGFicy1wYW5lbFxcXCJ9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIlRhYnNcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLGkuZGF0YSgpLG4pLHRoaXMuY2xhc3NOYW1lPVxcXCJcXFwiLHRoaXMuX2luaXQoKSx0aGlzLl9ldmVudHMoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIlRvZ2dsZXJcXFwiKTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZTt0aGlzLm9wdGlvbnMuYW5pbWF0ZT8oZT10aGlzLm9wdGlvbnMuYW5pbWF0ZS5zcGxpdChcXFwiIFxcXCIpLHRoaXMuYW5pbWF0aW9uSW49ZVswXSx0aGlzLmFuaW1hdGlvbk91dD1lWzFdfHxudWxsKTooZT10aGlzLiRlbGVtZW50LmRhdGEoXFxcInRvZ2dsZXJcXFwiKSx0aGlzLmNsYXNzTmFtZT1cXFwiLlxcXCI9PT1lWzBdP2Uuc2xpY2UoMSk6ZSk7dmFyIGk9dGhpcy4kZWxlbWVudFswXS5pZDt0KCdbZGF0YS1vcGVuPVxcXCInK2krJ1xcXCJdLCBbZGF0YS1jbG9zZT1cXFwiJytpKydcXFwiXSwgW2RhdGEtdG9nZ2xlPVxcXCInK2krJ1xcXCJdJykuYXR0cihcXFwiYXJpYS1jb250cm9sc1xcXCIsaSksdGhpcy4kZWxlbWVudC5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhdGhpcy4kZWxlbWVudC5pcyhcXFwiOmhpZGRlblxcXCIpKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQub2ZmKFxcXCJ0b2dnbGUuemYudHJpZ2dlclxcXCIpLm9uKFxcXCJ0b2dnbGUuemYudHJpZ2dlclxcXCIsdGhpcy50b2dnbGUuYmluZCh0aGlzKSk7fX0se2tleTpcXFwidG9nZ2xlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXNbdGhpcy5vcHRpb25zLmFuaW1hdGU/XFxcIl90b2dnbGVBbmltYXRlXFxcIjpcXFwiX3RvZ2dsZUNsYXNzXFxcIl0oKTt9fSx7a2V5OlxcXCJfdG9nZ2xlQ2xhc3NcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLmNsYXNzTmFtZSk7dmFyIHQ9dGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLmNsYXNzTmFtZSk7dD90aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcIm9uLnpmLnRvZ2dsZXJcXFwiKTp0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcIm9mZi56Zi50b2dnbGVyXFxcIiksdGhpcy5fdXBkYXRlQVJJQSh0KTt9fSx7a2V5OlxcXCJfdG9nZ2xlQW5pbWF0ZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzO3RoaXMuJGVsZW1lbnQuaXMoXFxcIjpoaWRkZW5cXFwiKT9Gb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlSW4odGhpcy4kZWxlbWVudCx0aGlzLmFuaW1hdGlvbkluLGZ1bmN0aW9uKCl7dGhpcy50cmlnZ2VyKFxcXCJvbi56Zi50b2dnbGVyXFxcIiksdC5fdXBkYXRlQVJJQSghMCk7fSk6Rm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dCh0aGlzLiRlbGVtZW50LHRoaXMuYW5pbWF0aW9uT3V0LGZ1bmN0aW9uKCl7dGhpcy50cmlnZ2VyKFxcXCJvZmYuemYudG9nZ2xlclxcXCIpLHQuX3VwZGF0ZUFSSUEoITEpO30pO319LHtrZXk6XFxcIl91cGRhdGVBUklBXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt0aGlzLiRlbGVtZW50LmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCEhdCk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50Lm9mZihcXFwiLnpmLnRvZ2dsZXJcXFwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXthbmltYXRlOiExfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJUb2dnbGVyXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLmlzQWN0aXZlPSExLHRoaXMuaXNDbGljaz0hMSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJUb29sdGlwXFxcIik7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcy4kZWxlbWVudC5hdHRyKFxcXCJhcmlhLWRlc2NyaWJlZGJ5XFxcIil8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNixcXFwidG9vbHRpcFxcXCIpO3RoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzPXRoaXMuX2dldFBvc2l0aW9uQ2xhc3ModGhpcy4kZWxlbWVudCksdGhpcy5vcHRpb25zLnRpcFRleHQ9dGhpcy5vcHRpb25zLnRpcFRleHR8fHRoaXMuJGVsZW1lbnQuYXR0cihcXFwidGl0bGVcXFwiKSx0aGlzLnRlbXBsYXRlPXRoaXMub3B0aW9ucy50ZW1wbGF0ZT90KHRoaXMub3B0aW9ucy50ZW1wbGF0ZSk6dGhpcy5fYnVpbGRUZW1wbGF0ZShlKSx0aGlzLnRlbXBsYXRlLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpLnRleHQodGhpcy5vcHRpb25zLnRpcFRleHQpLmhpZGUoKSx0aGlzLiRlbGVtZW50LmF0dHIoe3RpdGxlOlxcXCJcXFwiLFxcXCJhcmlhLWRlc2NyaWJlZGJ5XFxcIjplLFxcXCJkYXRhLXlldGktYm94XFxcIjplLFxcXCJkYXRhLXRvZ2dsZVxcXCI6ZSxcXFwiZGF0YS1yZXNpemVcXFwiOmV9KS5hZGRDbGFzcyh0aGlzLnRyaWdnZXJDbGFzcyksdGhpcy51c2VkUG9zaXRpb25zPVtdLHRoaXMuY291bnRlcj00LHRoaXMuY2xhc3NDaGFuZ2VkPSExLHRoaXMuX2V2ZW50cygpO319LHtrZXk6XFxcIl9nZXRQb3NpdGlvbkNsYXNzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXtpZighdClyZXR1cm5cXFwiXFxcIjt2YXIgZT10WzBdLmNsYXNzTmFtZS5tYXRjaCgvXFxcXGIodG9wfGxlZnR8cmlnaHQpXFxcXGIvZyk7cmV0dXJuIGU9ZT9lWzBdOlxcXCJcXFwiO319LHtrZXk6XFxcIl9idWlsZFRlbXBsYXRlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT0odGhpcy5vcHRpb25zLnRvb2x0aXBDbGFzcytcXFwiIFxcXCIrdGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MrXFxcIiBcXFwiK3RoaXMub3B0aW9ucy50ZW1wbGF0ZUNsYXNzZXMpLnRyaW0oKSxuPXQoXFxcIjxkaXY+PC9kaXY+XFxcIikuYWRkQ2xhc3MoaSkuYXR0cih7cm9sZTpcXFwidG9vbHRpcFxcXCIsXFxcImFyaWEtaGlkZGVuXFxcIjohMCxcXFwiZGF0YS1pcy1hY3RpdmVcXFwiOiExLFxcXCJkYXRhLWlzLWZvY3VzXFxcIjohMSxpZDplfSk7cmV0dXJuIG47fX0se2tleTpcXFwiX3JlcG9zaXRpb25cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3RoaXMudXNlZFBvc2l0aW9ucy5wdXNoKHQ/dDpcXFwiYm90dG9tXFxcIiksIXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJ0b3BcXFwiKTwwP3RoaXMudGVtcGxhdGUuYWRkQ2xhc3MoXFxcInRvcFxcXCIpOlxcXCJ0b3BcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImJvdHRvbVxcXCIpPDA/dGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0KTpcXFwibGVmdFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwicmlnaHRcXFwiKTwwP3RoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3ModCkuYWRkQ2xhc3MoXFxcInJpZ2h0XFxcIik6XFxcInJpZ2h0XFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIik8MD90aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQpLmFkZENsYXNzKFxcXCJsZWZ0XFxcIik6IXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJ0b3BcXFwiKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImxlZnRcXFwiKTwwP3RoaXMudGVtcGxhdGUuYWRkQ2xhc3MoXFxcImxlZnRcXFwiKTpcXFwidG9wXFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJib3R0b21cXFwiKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImxlZnRcXFwiKTwwP3RoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3ModCkuYWRkQ2xhc3MoXFxcImxlZnRcXFwiKTpcXFwibGVmdFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwicmlnaHRcXFwiKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImJvdHRvbVxcXCIpPDA/dGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0KTpcXFwicmlnaHRcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImxlZnRcXFwiKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImJvdHRvbVxcXCIpPDA/dGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0KTp0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQpLHRoaXMuY2xhc3NDaGFuZ2VkPSEwLHRoaXMuY291bnRlci0tO319LHtrZXk6XFxcIl9zZXRQb3NpdGlvblxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzLl9nZXRQb3NpdGlvbkNsYXNzKHRoaXMudGVtcGxhdGUpLGU9Rm91bmRhdGlvbi5Cb3guR2V0RGltZW5zaW9ucyh0aGlzLnRlbXBsYXRlKSxpPUZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy4kZWxlbWVudCksbj1cXFwibGVmdFxcXCI9PT10P1xcXCJsZWZ0XFxcIjpcXFwicmlnaHRcXFwiPT09dD9cXFwibGVmdFxcXCI6XFxcInRvcFxcXCIscz1cXFwidG9wXFxcIj09PW4/XFxcImhlaWdodFxcXCI6XFxcIndpZHRoXFxcIjtcXFwiaGVpZ2h0XFxcIj09PXM/dGhpcy5vcHRpb25zLnZPZmZzZXQ6dGhpcy5vcHRpb25zLmhPZmZzZXQ7aWYoZS53aWR0aD49ZS53aW5kb3dEaW1zLndpZHRofHwhdGhpcy5jb3VudGVyJiYhRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLnRlbXBsYXRlKSlyZXR1cm4gdGhpcy50ZW1wbGF0ZS5vZmZzZXQoRm91bmRhdGlvbi5Cb3guR2V0T2Zmc2V0cyh0aGlzLnRlbXBsYXRlLHRoaXMuJGVsZW1lbnQsXFxcImNlbnRlciBib3R0b21cXFwiLHRoaXMub3B0aW9ucy52T2Zmc2V0LHRoaXMub3B0aW9ucy5oT2Zmc2V0LCEwKSkuY3NzKHt3aWR0aDppLndpbmRvd0RpbXMud2lkdGgtMip0aGlzLm9wdGlvbnMuaE9mZnNldCxoZWlnaHQ6XFxcImF1dG9cXFwifSksITE7Zm9yKHRoaXMudGVtcGxhdGUub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy50ZW1wbGF0ZSx0aGlzLiRlbGVtZW50LFxcXCJjZW50ZXIgXFxcIisodHx8XFxcImJvdHRvbVxcXCIpLHRoaXMub3B0aW9ucy52T2Zmc2V0LHRoaXMub3B0aW9ucy5oT2Zmc2V0KSk7IUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy50ZW1wbGF0ZSkmJnRoaXMuY291bnRlcjspe3RoaXMuX3JlcG9zaXRpb24odCksdGhpcy5fc2V0UG9zaXRpb24oKTt9fX0se2tleTpcXFwic2hvd1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtpZihcXFwiYWxsXFxcIiE9PXRoaXMub3B0aW9ucy5zaG93T24mJiFGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuc2hvd09uKSlyZXR1cm4hMTt2YXIgdD10aGlzO3RoaXMudGVtcGxhdGUuY3NzKFxcXCJ2aXNpYmlsaXR5XFxcIixcXFwiaGlkZGVuXFxcIikuc2hvdygpLHRoaXMuX3NldFBvc2l0aW9uKCksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJjbG9zZW1lLnpmLnRvb2x0aXBcXFwiLHRoaXMudGVtcGxhdGUuYXR0cihcXFwiaWRcXFwiKSksdGhpcy50ZW1wbGF0ZS5hdHRyKHtcXFwiZGF0YS1pcy1hY3RpdmVcXFwiOiEwLFxcXCJhcmlhLWhpZGRlblxcXCI6ITF9KSx0LmlzQWN0aXZlPSEwLHRoaXMudGVtcGxhdGUuc3RvcCgpLmhpZGUoKS5jc3MoXFxcInZpc2liaWxpdHlcXFwiLFxcXCJcXFwiKS5mYWRlSW4odGhpcy5vcHRpb25zLmZhZGVJbkR1cmF0aW9uLGZ1bmN0aW9uKCl7fSksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJzaG93LnpmLnRvb2x0aXBcXFwiKTt9fSx7a2V5OlxcXCJoaWRlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXM7dGhpcy50ZW1wbGF0ZS5zdG9wKCkuYXR0cih7XFxcImFyaWEtaGlkZGVuXFxcIjohMCxcXFwiZGF0YS1pcy1hY3RpdmVcXFwiOiExfSkuZmFkZU91dCh0aGlzLm9wdGlvbnMuZmFkZU91dER1cmF0aW9uLGZ1bmN0aW9uKCl7dC5pc0FjdGl2ZT0hMSx0LmlzQ2xpY2s9ITEsdC5jbGFzc0NoYW5nZWQmJih0LnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQuX2dldFBvc2l0aW9uQ2xhc3ModC50ZW1wbGF0ZSkpLmFkZENsYXNzKHQub3B0aW9ucy5wb3NpdGlvbkNsYXNzKSx0LnVzZWRQb3NpdGlvbnM9W10sdC5jb3VudGVyPTQsdC5jbGFzc0NoYW5nZWQ9ITEpO30pLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiaGlkZS56Zi50b29sdGlwXFxcIik7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzLGU9KHRoaXMudGVtcGxhdGUsITEpO3RoaXMub3B0aW9ucy5kaXNhYmxlSG92ZXJ8fHRoaXMuJGVsZW1lbnQub24oXFxcIm1vdXNlZW50ZXIuemYudG9vbHRpcFxcXCIsZnVuY3Rpb24oZSl7dC5pc0FjdGl2ZXx8KHQudGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dC5zaG93KCk7fSx0Lm9wdGlvbnMuaG92ZXJEZWxheSkpO30pLm9uKFxcXCJtb3VzZWxlYXZlLnpmLnRvb2x0aXBcXFwiLGZ1bmN0aW9uKGkpe2NsZWFyVGltZW91dCh0LnRpbWVvdXQpLCghZXx8IXQuaXNDbGljayYmdC5vcHRpb25zLmNsaWNrT3BlbikmJnQuaGlkZSgpO30pLHRoaXMub3B0aW9ucy5jbGlja09wZW4mJnRoaXMuJGVsZW1lbnQub24oXFxcIm1vdXNlZG93bi56Zi50b29sdGlwXFxcIixmdW5jdGlvbihlKXtlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLHQuaXNDbGljaz90LmhpZGUoKToodC5pc0NsaWNrPSEwLCF0Lm9wdGlvbnMuZGlzYWJsZUhvdmVyJiZ0LiRlbGVtZW50LmF0dHIoXFxcInRhYmluZGV4XFxcIil8fHQuaXNBY3RpdmV8fHQuc2hvdygpKTt9KSx0aGlzLm9wdGlvbnMuZGlzYWJsZUZvclRvdWNofHx0aGlzLiRlbGVtZW50Lm9uKFxcXCJ0YXAuemYudG9vbHRpcCB0b3VjaGVuZC56Zi50b29sdGlwXFxcIixmdW5jdGlvbihlKXt0LmlzQWN0aXZlP3QuaGlkZSgpOnQuc2hvdygpO30pLHRoaXMuJGVsZW1lbnQub24oe1xcXCJjbG9zZS56Zi50cmlnZ2VyXFxcIjp0aGlzLmhpZGUuYmluZCh0aGlzKX0pLHRoaXMuJGVsZW1lbnQub24oXFxcImZvY3VzLnpmLnRvb2x0aXBcXFwiLGZ1bmN0aW9uKGkpe3JldHVybiBlPSEwLHQuaXNDbGljaz8hMTp2b2lkIHQuc2hvdygpO30pLm9uKFxcXCJmb2N1c291dC56Zi50b29sdGlwXFxcIixmdW5jdGlvbihpKXtlPSExLHQuaXNDbGljaz0hMSx0LmhpZGUoKTt9KS5vbihcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCIsZnVuY3Rpb24oKXt0LmlzQWN0aXZlJiZ0Ll9zZXRQb3NpdGlvbigpO30pO319LHtrZXk6XFxcInRvZ2dsZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLmlzQWN0aXZlP3RoaXMuaGlkZSgpOnRoaXMuc2hvdygpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC5hdHRyKFxcXCJ0aXRsZVxcXCIsdGhpcy50ZW1wbGF0ZS50ZXh0KCkpLm9mZihcXFwiLnpmLnRyaWdnZXIgLnpmLnRvb3RpcFxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtZGVzY3JpYmVkYnlcXFwiKS5yZW1vdmVBdHRyKFxcXCJkYXRhLXlldGktYm94XFxcIikucmVtb3ZlQXR0cihcXFwiZGF0YS10b2dnbGVcXFwiKS5yZW1vdmVBdHRyKFxcXCJkYXRhLXJlc2l6ZVxcXCIpLHRoaXMudGVtcGxhdGUucmVtb3ZlKCksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17ZGlzYWJsZUZvclRvdWNoOiExLGhvdmVyRGVsYXk6MjAwLGZhZGVJbkR1cmF0aW9uOjE1MCxmYWRlT3V0RHVyYXRpb246MTUwLGRpc2FibGVIb3ZlcjohMSx0ZW1wbGF0ZUNsYXNzZXM6XFxcIlxcXCIsdG9vbHRpcENsYXNzOlxcXCJ0b29sdGlwXFxcIix0cmlnZ2VyQ2xhc3M6XFxcImhhcy10aXBcXFwiLHNob3dPbjpcXFwic21hbGxcXFwiLHRlbXBsYXRlOlxcXCJcXFwiLHRpcFRleHQ6XFxcIlxcXCIsdG91Y2hDbG9zZVRleHQ6XFxcIlRhcCB0byBjbG9zZS5cXFwiLGNsaWNrT3BlbjohMCxwb3NpdGlvbkNsYXNzOlxcXCJcXFwiLHZPZmZzZXQ6MTAsaE9mZnNldDoxMn0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiVG9vbHRpcFxcXCIpO30oalF1ZXJ5KTtcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYXctbG9hZGVyIS4vfi9iYWJlbC1sb2FkZXI/e1wicHJlc2V0c1wiOltcInJlYWN0XCIsXCJlczIwMTVcIl19IS4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvZm91bmRhdGlvbi5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XHJcbmltcG9ydCB7IFJvdXRlLCBSb3V0ZXIsIEluZGV4Um91dGUsIGhhc2hIaXN0b3J5IH0gZnJvbSAncmVhY3Qtcm91dGVyJztcclxuXHJcbmltcG9ydCBNYWluIGZyb20gJy4vY29tcG9uZW50cy9NYWluJztcclxuaW1wb3J0IFdlYXRoZXIgZnJvbSAnLi9jb21wb25lbnRzL1dlYXRoZXInO1xyXG5pbXBvcnQgQWJvdXQgZnJvbSAnLi9jb21wb25lbnRzL0Fib3V0JztcclxuaW1wb3J0IEV4YW1wbGVzIGZyb20gJy4vY29tcG9uZW50cy9FeGFtcGxlcyc7XHJcblxyXG4vLyBMb2FkIEZvdW5kYXRpb25cclxucmVxdWlyZSgnc3R5bGUhY3NzIWZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLm1pbi5jc3MnKTtcclxuJChkb2N1bWVudCkuZm91bmRhdGlvbigpO1xyXG5cclxuLy8gQXBwIHN0eWxlc1xyXG5yZXF1aXJlKCdzdHlsZSFjc3Mhc2FzcyFhcHBsaWNhdGlvblN0eWxlcycpO1xyXG5cclxuUmVhY3RET00ucmVuZGVyKFxyXG4gICAgPFJvdXRlciBoaXN0b3J5PXtoYXNoSGlzdG9yeX0+XHJcbiAgICAgICAgPFJvdXRlIHBhdGg9XCIvXCIgY29tcG9uZW50PXtNYWlufT5cclxuICAgICAgICAgICAgPFJvdXRlIHBhdGg9XCJhYm91dFwiIGNvbXBvbmVudD17QWJvdXR9IC8+XHJcbiAgICAgICAgICAgIDxSb3V0ZSBwYXRoPVwiZXhhbXBsZXNcIiBjb21wb25lbnQ9e0V4YW1wbGVzfSAvPlxyXG4gICAgICAgICAgICA8SW5kZXhSb3V0ZSBjb21wb25lbnQ9e1dlYXRoZXJ9IC8+XHJcbiAgICAgICAgPC9Sb3V0ZT5cclxuICAgIDwvUm91dGVyPixcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcHAnKVxyXG4pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hcHAvYXBwLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBqUXVlcnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJqUXVlcnlcIlxuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvUmVhY3QnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvcmVhY3QuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRyZW4nKTtcbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdFB1cmVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0UHVyZUNvbXBvbmVudCcpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKCcuL1JlYWN0Q2xhc3MnKTtcbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IHJlcXVpcmUoJy4vUmVhY3RET01GYWN0b3JpZXMnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlcycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cbnZhciBvbmx5Q2hpbGQgPSByZXF1aXJlKCcuL29ubHlDaGlsZCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQ7XG52YXIgY3JlYXRlRmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5O1xudmFyIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQ7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcicpO1xuICBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQ7XG4gIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeTtcbiAgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNsb25lRWxlbWVudDtcbn1cblxudmFyIF9fc3ByZWFkID0gX2Fzc2lnbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh3YXJuZWQsICdSZWFjdC5fX3NwcmVhZCBpcyBkZXByZWNhdGVkIGFuZCBzaG91bGQgbm90IGJlIHVzZWQuIFVzZSAnICsgJ09iamVjdC5hc3NpZ24gZGlyZWN0bHkgb3IgYW5vdGhlciBoZWxwZXIgZnVuY3Rpb24gd2l0aCBzaW1pbGFyICcgKyAnc2VtYW50aWNzLiBZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIHlvdXIgY29tcGlsZXIuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtc3ByZWFkLWRlcHJlY2F0aW9uIGZvciBtb3JlIGRldGFpbHMuJykgOiB2b2lkIDA7XG4gICAgd2FybmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gX2Fzc2lnbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgUmVhY3QgPSB7XG5cbiAgLy8gTW9kZXJuXG5cbiAgQ2hpbGRyZW46IHtcbiAgICBtYXA6IFJlYWN0Q2hpbGRyZW4ubWFwLFxuICAgIGZvckVhY2g6IFJlYWN0Q2hpbGRyZW4uZm9yRWFjaCxcbiAgICBjb3VudDogUmVhY3RDaGlsZHJlbi5jb3VudCxcbiAgICB0b0FycmF5OiBSZWFjdENoaWxkcmVuLnRvQXJyYXksXG4gICAgb25seTogb25seUNoaWxkXG4gIH0sXG5cbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUmVhY3RQdXJlQ29tcG9uZW50LFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG4gIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50LFxuICBpc1ZhbGlkRWxlbWVudDogUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50LFxuXG4gIC8vIENsYXNzaWNcblxuICBQcm9wVHlwZXM6IFJlYWN0UHJvcFR5cGVzLFxuICBjcmVhdGVDbGFzczogUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyxcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeSxcbiAgY3JlYXRlTWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIC8vIEN1cnJlbnRseSBhIG5vb3AuIFdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBhbmQgdHJhY2UgbWl4aW5zLlxuICAgIHJldHVybiBtaXhpbjtcbiAgfSxcblxuICAvLyBUaGlzIGxvb2tzIERPTSBzcGVjaWZpYyBidXQgdGhlc2UgYXJlIGFjdHVhbGx5IGlzb21vcnBoaWMgaGVscGVyc1xuICAvLyBzaW5jZSB0aGV5IGFyZSBqdXN0IGdlbmVyYXRpbmcgRE9NIHN0cmluZ3MuXG4gIERPTTogUmVhY3RET01GYWN0b3JpZXMsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIC8vIERlcHJlY2F0ZWQgaG9vayBmb3IgSlNYIHNwcmVhZCwgZG9uJ3QgdXNlIHRoaXMgZm9yIGFueXRoaW5nLlxuICBfX3NwcmVhZDogX19zcHJlYWRcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3QuanMiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L29iamVjdC1hc3NpZ24vaW5kZXguanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcjtcbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXI7XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogdHJhdmVyc2FsLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIEZvckVhY2hCb29rS2VlcGluZ1xuICogQHBhcmFtIHshZnVuY3Rpb259IGZvckVhY2hGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIHRyYXZlcnNhbCB3aXRoLlxuICogQHBhcmFtIHs/Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIGNvbnRleHQgd2l0aC5cbiAqL1xuZnVuY3Rpb24gRm9yRWFjaEJvb2tLZWVwaW5nKGZvckVhY2hGdW5jdGlvbiwgZm9yRWFjaENvbnRleHQpIHtcbiAgdGhpcy5mdW5jID0gZm9yRWFjaEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBmb3JFYWNoQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5Gb3JFYWNoQm9va0tlZXBpbmcucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZnVuYyA9IG51bGw7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMuY291bnQgPSAwO1xufTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhGb3JFYWNoQm9va0tlZXBpbmcsIHR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gRm9yRWFjaEJvb2tLZWVwaW5nLmdldFBvb2xlZChmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIEZvckVhY2hCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiBtYXBwaW5nLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIE1hcEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyEqfSBtYXBSZXN1bHQgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gbWFwRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKiBAcGFyYW0gez8qfSBtYXBDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKi9cbmZ1bmN0aW9uIE1hcEJvb2tLZWVwaW5nKG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICB0aGlzLnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgdGhpcy5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gIHRoaXMuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbk1hcEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlc3VsdCA9IG51bGw7XG4gIHRoaXMua2V5UHJlZml4ID0gbnVsbDtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKE1hcEJvb2tLZWVwaW5nLCBmb3VyQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdCxcbiAgICAgIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeCxcbiAgICAgIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cblxuICB2YXIgbWFwcGVkQ2hpbGQgPSBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xuICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKG1hcHBlZENoaWxkLCByZXN1bHQsIGNoaWxkS2V5LCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLFxuICAgICAgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAga2V5UHJlZml4ICsgKG1hcHBlZENoaWxkLmtleSAmJiAoIWNoaWxkIHx8IGNoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IGVzY2FwZVVzZXJQcm92aWRlZEtleShtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChtYXBwZWRDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgYXJyYXksIHByZWZpeCwgZnVuYywgY29udGV4dCkge1xuICB2YXIgZXNjYXBlZFByZWZpeCA9ICcnO1xuICBpZiAocHJlZml4ICE9IG51bGwpIHtcbiAgICBlc2NhcGVkUHJlZml4ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHByZWZpeCkgKyAnLyc7XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IE1hcEJvb2tLZWVwaW5nLmdldFBvb2xlZChhcnJheSwgZXNjYXBlZFByZWZpeCwgZnVuYywgY29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIE1hcEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXksIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi50b2FycmF5XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBSZWFjdENoaWxkcmVuID0ge1xuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWw6IG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwsXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRyZW47XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChjb3B5RmllbGRzRnJvbSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBjb3B5RmllbGRzRnJvbSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoY29weUZpZWxkc0Zyb20pO1xuICB9XG59O1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMik7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyKTtcbiAgfVxufTtcblxudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQpO1xuICB9XG59O1xuXG52YXIgZml2ZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gIH1cbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IF9wcm9kSW52YXJpYW50KCcyNScpIDogdm9pZCAwO1xuICBpbnN0YW5jZS5kZXN0cnVjdG9yKCk7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoIDwgS2xhc3MucG9vbFNpemUpIHtcbiAgICBLbGFzcy5pbnN0YW5jZVBvb2wucHVzaChpbnN0YW5jZSk7XG4gIH1cbn07XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogQXVnbWVudHMgYENvcHlDb25zdHJ1Y3RvcmAgdG8gYmUgYSBwb29sYWJsZSBjbGFzcywgYXVnbWVudGluZyBvbmx5IHRoZSBjbGFzc1xuICogaXRzZWxmIChzdGF0aWNhbGx5KSBub3QgYWRkaW5nIGFueSBwcm90b3R5cGljYWwgZmllbGRzLiBBbnkgQ29weUNvbnN0cnVjdG9yXG4gKiB5b3UgZ2l2ZSB0aGlzIG1heSBoYXZlIGEgYHBvb2xTaXplYCBwcm9wZXJ0eSwgYW5kIHdpbGwgbG9vayBmb3IgYVxuICogcHJvdG90eXBpY2FsIGBkZXN0cnVjdG9yYCBvbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29weUNvbnN0cnVjdG9yIENvbnN0cnVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb29sZXIgQ3VzdG9taXphYmxlIHBvb2xlci5cbiAqL1xudmFyIGFkZFBvb2xpbmdUbyA9IGZ1bmN0aW9uIChDb3B5Q29uc3RydWN0b3IsIHBvb2xlcikge1xuICAvLyBDYXN0aW5nIGFzIGFueSBzbyB0aGF0IGZsb3cgaWdub3JlcyB0aGUgYWN0dWFsIGltcGxlbWVudGF0aW9uIGFuZCB0cnVzdHNcbiAgLy8gaXQgdG8gbWF0Y2ggdGhlIHR5cGUgd2UgZGVjbGFyZWRcbiAgdmFyIE5ld0tsYXNzID0gQ29weUNvbnN0cnVjdG9yO1xuICBOZXdLbGFzcy5pbnN0YW5jZVBvb2wgPSBbXTtcbiAgTmV3S2xhc3MuZ2V0UG9vbGVkID0gcG9vbGVyIHx8IERFRkFVTFRfUE9PTEVSO1xuICBpZiAoIU5ld0tsYXNzLnBvb2xTaXplKSB7XG4gICAgTmV3S2xhc3MucG9vbFNpemUgPSBERUZBVUxUX1BPT0xfU0laRTtcbiAgfVxuICBOZXdLbGFzcy5yZWxlYXNlID0gc3RhbmRhcmRSZWxlYXNlcjtcbiAgcmV0dXJuIE5ld0tsYXNzO1xufTtcblxudmFyIFBvb2xlZENsYXNzID0ge1xuICBhZGRQb29saW5nVG86IGFkZFBvb2xpbmdUbyxcbiAgb25lQXJndW1lbnRQb29sZXI6IG9uZUFyZ3VtZW50UG9vbGVyLFxuICB0d29Bcmd1bWVudFBvb2xlcjogdHdvQXJndW1lbnRQb29sZXIsXG4gIHRocmVlQXJndW1lbnRQb29sZXI6IHRocmVlQXJndW1lbnRQb29sZXIsXG4gIGZvdXJBcmd1bWVudFBvb2xlcjogZm91ckFyZ3VtZW50UG9vbGVyLFxuICBmaXZlQXJndW1lbnRQb29sZXI6IGZpdmVBcmd1bWVudFBvb2xlclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sZWRDbGFzcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9Qb29sZWRDbGFzcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuZnVuY3Rpb24gcmVhY3RQcm9kSW52YXJpYW50KGNvZGUpIHtcbiAgdmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG5cbiAgdmFyIG1lc3NhZ2UgPSAnTWluaWZpZWQgUmVhY3QgZXJyb3IgIycgKyBjb2RlICsgJzsgdmlzaXQgJyArICdodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD0nICsgY29kZTtcblxuICBmb3IgKHZhciBhcmdJZHggPSAwOyBhcmdJZHggPCBhcmdDb3VudDsgYXJnSWR4KyspIHtcbiAgICBtZXNzYWdlICs9ICcmYXJnc1tdPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2FyZ0lkeCArIDFdKTtcbiAgfVxuXG4gIG1lc3NhZ2UgKz0gJyBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQnICsgJyBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nO1xuXG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IHJlYWN0UHJvZEludmFyaWFudCdzIG93biBmcmFtZVxuXG4gIHRocm93IGVycm9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0UHJvZEludmFyaWFudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9yZWFjdFByb2RJbnZhcmlhbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZmJqcy9saWIvaW52YXJpYW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRTeW1ib2wnKTtcblxudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcblxudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcblxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcblxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzZWxmXG4gICAgICB9KTtcbiAgICAgIC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHNvdXJjZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgZWxlbWVudC5fc2VsZiA9IHNlbGY7XG4gICAgICBlbGVtZW50Ll9zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWVsZW1lbnRcbiAqL1xuUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIgcHJvcHMgPSB7fTtcblxuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy4kJHR5cGVvZiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMuJCR0eXBlb2YgIT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIFJlYWN0RWxlbWVudHMgb2YgYSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWZhY3RvcnlcbiAqL1xuUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgZmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIEV4cG9zZSB0aGUgdHlwZSBvbiB0aGUgZmFjdG9yeSBhbmQgdGhlIHByb3RvdHlwZSBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyBlYXNpbHkgYWNjZXNzZWQgb24gZWxlbWVudHMuIEUuZy4gYDxGb28gLz4udHlwZSA9PT0gRm9vYC5cbiAgLy8gVGhpcyBzaG91bGQgbm90IGJlIG5hbWVkIGBjb25zdHJ1Y3RvcmAgc2luY2UgdGhpcyBtYXkgbm90IGJlIHRoZSBmdW5jdGlvblxuICAvLyB0aGF0IGNyZWF0ZWQgdGhlIGVsZW1lbnQsIGFuZCBpdCBtYXkgbm90IGV2ZW4gYmUgYSBjb25zdHJ1Y3Rvci5cbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gIGZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIHJldHVybiBmYWN0b3J5O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleSA9IGZ1bmN0aW9uIChvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2xvbmVlbGVtZW50XG4gKi9cblJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxuICogQGZpbmFsXG4gKi9cblJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEN1cnJlbnRPd25lcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCAoeCkge31cbiAgICB9O1xuXG4gICAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICAgIH1cblxuICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL3dhcm5pbmcuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gZmFsc2U7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB0cnkge1xuICAgIC8vICRGbG93Rml4TWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7IGdldDogZnVuY3Rpb24gKCkge30gfSk7XG4gICAgY2FuRGVmaW5lUHJvcGVydHkgPSB0cnVlO1xuICB9IGNhdGNoICh4KSB7XG4gICAgLy8gSUUgd2lsbCBmYWlsIG9uIGRlZmluZVByb3BlcnR5XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW5EZWZpbmVQcm9wZXJ0eTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9jYW5EZWZpbmVQcm9wZXJ0eS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50IHR5cGUuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgfHwgMHhlYWM3O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRTeW1ib2wuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRTeW1ib2wnKTtcblxudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6JztcblxuLyoqXG4gKiBUaGlzIGlzIGlubGluZWQgZnJvbSBSZWFjdEVsZW1lbnQgc2luY2UgdGhpcyBmaWxlIGlzIHNoYXJlZCBiZXR3ZWVuXG4gKiBpc29tb3JwaGljIGFuZCByZW5kZXJlcnMuIFdlIGNvdWxkIGV4dHJhY3QgdGhpcyB0byBhXG4gKlxuICovXG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmIChjb21wb25lbnQgJiYgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIEtleUVzY2FwZVV0aWxzLmVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicgfHxcbiAgLy8gVGhlIGZvbGxvd2luZyBpcyBpbmxpbmVkIGZyb20gUmVhY3RFbGVtZW50LiBUaGlzIG1lYW5zIHdlIGNhbiBvcHRpbWl6ZVxuICAvLyBzb21lIGNoZWNrcy4gUmVhY3QgRmliZXIgYWxzbyBpbmxpbmVzIHRoaXMgbG9naWMgZm9yIHNpbWlsYXIgcHVycG9zZXMuXG4gIHR5cGUgPT09ICdvYmplY3QnICYmIGNoaWxkcmVuLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpaSA9IDA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0gPSAnJztcbiAgICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgICBpZiAobWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkLiBJdCBpcyBhbiAnICsgJ2V4cGVyaW1lbnRhbCBmZWF0dXJlIHRoYXQgbWlnaHQgYmUgcmVtb3ZlZC4gQ29udmVydCBpdCB0byBhICcgKyAnc2VxdWVuY2UgLyBpdGVyYWJsZSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIEtleUVzY2FwZVV0aWxzLmVzY2FwZShlbnRyeVswXSkgKyBTVUJTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIDApO1xuICAgICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQgb3Igd3JhcCB0aGUgb2JqZWN0IHVzaW5nIGNyZWF0ZUZyYWdtZW50KG9iamVjdCkgZnJvbSB0aGUgJyArICdSZWFjdCBhZGQtb25zLic7XG4gICAgICAgIGlmIChjaGlsZHJlbi5faXNSZWFjdEVsZW1lbnQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSXQgbG9va3MgbGlrZSB5b3VcXCdyZSB1c2luZyBhbiBlbGVtZW50IGNyZWF0ZWQgYnkgYSBkaWZmZXJlbnQgJyArICd2ZXJzaW9uIG9mIFJlYWN0LiBNYWtlIHN1cmUgdG8gdXNlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtICs9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IF9wcm9kSW52YXJpYW50KCczMScsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhdmVyc2VBbGxDaGlsZHJlbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgU3ltYm9sICovXG5cbnZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4vKipcbiAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAqXG4gKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAqXG4gKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gKiAgICAgICAuLi5cbiAqICAgICB9XG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEl0ZXJhdG9yRm47XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBVbmVzY2FwZSBhbmQgdW53cmFwIGtleSBmb3IgaHVtYW4tcmVhZGFibGUgZGlzcGxheVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gdW5lc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSB1bmVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiB1bmVzY2FwZShrZXkpIHtcbiAgdmFyIHVuZXNjYXBlUmVnZXggPSAvKD0wfD0yKS9nO1xuICB2YXIgdW5lc2NhcGVyTG9va3VwID0ge1xuICAgICc9MCc6ICc9JyxcbiAgICAnPTInOiAnOidcbiAgfTtcbiAgdmFyIGtleVN1YnN0cmluZyA9IGtleVswXSA9PT0gJy4nICYmIGtleVsxXSA9PT0gJyQnID8ga2V5LnN1YnN0cmluZygyKSA6IGtleS5zdWJzdHJpbmcoMSk7XG5cbiAgcmV0dXJuICgnJyArIGtleVN1YnN0cmluZykucmVwbGFjZSh1bmVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG59XG5cbnZhciBLZXlFc2NhcGVVdGlscyA9IHtcbiAgZXNjYXBlOiBlc2NhcGUsXG4gIHVuZXNjYXBlOiB1bmVzY2FwZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlFc2NhcGVVdGlscztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9LZXlFc2NhcGVVdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBSZWFjdENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gICEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiBfcHJvZEludmFyaWFudCgnODUnKSA6IHZvaWQgMDtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKSA6IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaykge30sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdE5vb3BVcGRhdGVRdWV1ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gUmVhY3RDb21wb25lbnQuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBSZWFjdENvbXBvbmVudC5wcm90b3R5cGU7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVhY3RQdXJlQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKFJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSk7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFB1cmVDb21wb25lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RQdXJlQ29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgTUlYSU5TX0tFWSA9ICdtaXhpbnMnO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gYWxsb3cgdGhlIGNyZWF0aW9uIG9mIGFub255bW91cyBmdW5jdGlvbnMgd2hpY2ggZG8gbm90XG4vLyBoYXZlIC5uYW1lIHNldCB0byB0aGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgYmVpbmcgYXNzaWduZWQgdG8uXG5mdW5jdGlvbiBpZGVudGl0eShmbikge1xuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogUG9saWNpZXMgdGhhdCBkZXNjcmliZSBtZXRob2RzIGluIGBSZWFjdENsYXNzSW50ZXJmYWNlYC5cbiAqL1xuXG5cbnZhciBpbmplY3RlZE1peGlucyA9IFtdO1xuXG4vKipcbiAqIENvbXBvc2l0ZSBjb21wb25lbnRzIGFyZSBoaWdoZXItbGV2ZWwgY29tcG9uZW50cyB0aGF0IGNvbXBvc2Ugb3RoZXIgY29tcG9zaXRlXG4gKiBvciBob3N0IGNvbXBvbmVudHMuXG4gKlxuICogVG8gY3JlYXRlIGEgbmV3IHR5cGUgb2YgYFJlYWN0Q2xhc3NgLCBwYXNzIGEgc3BlY2lmaWNhdGlvbiBvZlxuICogeW91ciBuZXcgY2xhc3MgdG8gYFJlYWN0LmNyZWF0ZUNsYXNzYC4gVGhlIG9ubHkgcmVxdWlyZW1lbnQgb2YgeW91ciBjbGFzc1xuICogc3BlY2lmaWNhdGlvbiBpcyB0aGF0IHlvdSBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuXG4gKlxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiA8ZGl2PkhlbGxvIFdvcmxkPC9kaXY+O1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogVGhlIGNsYXNzIHNwZWNpZmljYXRpb24gc3VwcG9ydHMgYSBzcGVjaWZpYyBwcm90b2NvbCBvZiBtZXRob2RzIHRoYXQgaGF2ZVxuICogc3BlY2lhbCBtZWFuaW5nIChlLmcuIGByZW5kZXJgKS4gU2VlIGBSZWFjdENsYXNzSW50ZXJmYWNlYCBmb3JcbiAqIG1vcmUgdGhlIGNvbXByZWhlbnNpdmUgcHJvdG9jb2wuIEFueSBvdGhlciBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGluIHRoZVxuICogY2xhc3Mgc3BlY2lmaWNhdGlvbiB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGUgcHJvdG90eXBlLlxuICpcbiAqIEBpbnRlcmZhY2UgUmVhY3RDbGFzc0ludGVyZmFjZVxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdENsYXNzSW50ZXJmYWNlID0ge1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBNaXhpbiBvYmplY3RzIHRvIGluY2x1ZGUgd2hlbiBkZWZpbmluZyB5b3VyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge2FycmF5fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIG1peGluczogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0aGF0IHNob3VsZCBiZSBkZWZpbmVkIG9uXG4gICAqIHRoZSBjb21wb25lbnQncyBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIGl0cyBwcm90b3R5cGUgKHN0YXRpYyBtZXRob2RzKS5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzdGF0aWNzOiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIHByb3AgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHByb3BUeXBlczogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb250ZXh0VHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyB0aGlzIGNvbXBvbmVudCBzZXRzIGZvciBpdHMgY2hpbGRyZW4uXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY2hpbGRDb250ZXh0VHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgLy8gPT09PSBEZWZpbml0aW9uIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBWYWx1ZXMgaW4gdGhlIG1hcHBpbmcgd2lsbCBiZSBzZXQgb25cbiAgICogYHRoaXMucHJvcHNgIGlmIHRoYXQgcHJvcCBpcyBub3Qgc3BlY2lmaWVkIChpLmUuIHVzaW5nIGFuIGBpbmAgY2hlY2spLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIGJlZm9yZSBgZ2V0SW5pdGlhbFN0YXRlYCBhbmQgdGhlcmVmb3JlIGNhbm5vdCByZWx5XG4gICAqIG9uIGB0aGlzLnN0YXRlYCBvciB1c2UgYHRoaXMuc2V0U3RhdGVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0RGVmYXVsdFByb3BzOiAnREVGSU5FX01BTllfTUVSR0VEJyxcblxuICAvKipcbiAgICogSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAqIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIGB0aGlzLnN0YXRlYC5cbiAgICpcbiAgICogICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgcmV0dXJuIHtcbiAgICogICAgICAgaXNPbjogZmFsc2UsXG4gICAqICAgICAgIGZvb0JhejogbmV3IEJhekZvbygpXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0SW5pdGlhbFN0YXRlOiAnREVGSU5FX01BTllfTUVSR0VEJyxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldENoaWxkQ29udGV4dDogJ0RFRklORV9NQU5ZX01FUkdFRCcsXG5cbiAgLyoqXG4gICAqIFVzZXMgcHJvcHMgZnJvbSBgdGhpcy5wcm9wc2AgYW5kIHN0YXRlIGZyb20gYHRoaXMuc3RhdGVgIHRvIHJlbmRlciB0aGVcbiAgICogc3RydWN0dXJlIG9mIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIE5vIGd1YXJhbnRlZXMgYXJlIG1hZGUgYWJvdXQgd2hlbiBvciBob3cgb2Z0ZW4gdGhpcyBtZXRob2QgaXMgaW52b2tlZCwgc29cbiAgICogaXQgbXVzdCBub3QgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gICAqXG4gICAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgKiAgICAgcmV0dXJuIDxkaXY+SGVsbG8sIHtuYW1lfSE8L2Rpdj47XG4gICAqICAgfVxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAgICogQG5vc2lkZWVmZmVjdHNcbiAgICogQHJlcXVpcmVkXG4gICAqL1xuICByZW5kZXI6ICdERUZJTkVfT05DRScsXG5cbiAgLy8gPT09PSBEZWxlZ2F0ZSBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGx5IGNyZWF0ZWQgYW5kIGFib3V0IHRvIGJlIG1vdW50ZWQuXG4gICAqIFRoaXMgbWF5IGhhdmUgc2lkZSBlZmZlY3RzLCBidXQgYW55IGV4dGVybmFsIHN1YnNjcmlwdGlvbnMgb3IgZGF0YSBjcmVhdGVkXG4gICAqIGJ5IHRoaXMgbWV0aG9kIG11c3QgYmUgY2xlYW5lZCB1cCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgLlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCBhbmQgaGFzIGEgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKiBIb3dldmVyLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgRE9NIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgKiBiZWVuIG1vdW50ZWQgKGluaXRpYWxpemVkIGFuZCByZW5kZXJlZCkgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50OiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJlZm9yZSB0aGUgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wcy5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVhY3QgdG8gYSBwcm9wIHRyYW5zaXRpb24gYnkgdXBkYXRpbmcgdGhlXG4gICAqIHN0YXRlIHVzaW5nIGB0aGlzLnNldFN0YXRlYC4gQ3VycmVudCBwcm9wcyBhcmUgYWNjZXNzZWQgdmlhIGB0aGlzLnByb3BzYC5cbiAgICpcbiAgICogICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICogICAgICAgbGlrZXNJbmNyZWFzaW5nOiBuZXh0UHJvcHMubGlrZUNvdW50ID4gdGhpcy5wcm9wcy5saWtlQ291bnRcbiAgICogICAgIH0pO1xuICAgKiAgIH1cbiAgICpcbiAgICogTk9URTogVGhlcmUgaXMgbm8gZXF1aXZhbGVudCBgY29tcG9uZW50V2lsbFJlY2VpdmVTdGF0ZWAuIEFuIGluY29taW5nIHByb3BcbiAgICogdHJhbnNpdGlvbiBtYXkgY2F1c2UgYSBzdGF0ZSBjaGFuZ2UsIGJ1dCB0aGUgb3Bwb3NpdGUgaXMgbm90IHRydWUuIElmIHlvdVxuICAgKiBuZWVkIGl0LCB5b3UgYXJlIHByb2JhYmx5IGxvb2tpbmcgZm9yIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hpbGUgZGVjaWRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZlxuICAgKiByZWNlaXZpbmcgbmV3IHByb3BzLCBzdGF0ZSBhbmQvb3IgY29udGV4dC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gYHJldHVybiBmYWxzZWAgd2hlbiB5b3UncmUgY2VydGFpbiB0aGF0IHRoZVxuICAgKiB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgcHJvcHMvc3RhdGUvY29udGV4dCB3aWxsIG5vdCByZXF1aXJlIGEgY29tcG9uZW50XG4gICAqIHVwZGF0ZS5cbiAgICpcbiAgICogICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xuICAgKiAgICAgcmV0dXJuICFlcXVhbChuZXh0UHJvcHMsIHRoaXMucHJvcHMpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0U3RhdGUsIHRoaXMuc3RhdGUpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0Q29udGV4dCwgdGhpcy5jb250ZXh0KTtcbiAgICogICB9XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIHVwZGF0ZS5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzaG91bGRDb21wb25lbnRVcGRhdGU6ICdERUZJTkVfT05DRScsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIHVwZGF0ZSBkdWUgdG8gYSB0cmFuc2l0aW9uIGZyb21cbiAgICogYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgIHRvIGBuZXh0UHJvcHNgLCBgbmV4dFN0YXRlYFxuICAgKiBhbmQgYG5leHRDb250ZXh0YC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcGVyZm9ybSBwcmVwYXJhdGlvbiBiZWZvcmUgYW4gdXBkYXRlIG9jY3Vycy5cbiAgICpcbiAgICogTk9URTogWW91ICoqY2Fubm90KiogdXNlIGB0aGlzLnNldFN0YXRlKClgIGluIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVcGRhdGU6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50J3MgRE9NIHJlcHJlc2VudGF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHByZXZQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDb250ZXh0XG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBhbmQgaGF2ZVxuICAgKiBpdHMgRE9NIHJlcHJlc2VudGF0aW9uIGRlc3Ryb3llZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gZGVhbGxvY2F0ZSBhbnkgZXh0ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBgY29tcG9uZW50RGlkVW5tb3VudGAgc2luY2UgeW91ciBjb21wb25lbnQgd2lsbCBoYXZlIGJlZW5cbiAgICogZGVzdHJveWVkIGJ5IHRoYXQgcG9pbnQuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6ICdERUZJTkVfTUFOWScsXG5cbiAgLy8gPT09PSBBZHZhbmNlZCBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50J3MgY3VycmVudGx5IG1vdW50ZWQgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiAnT1ZFUlJJREVfQkFTRSdcblxufTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gY2xhc3Mgc3BlY2lmaWNhdGlvbiBrZXlzIHRvIHNwZWNpYWwgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG4gKlxuICogQWx0aG91Z2ggdGhlc2UgYXJlIGRlY2xhcmVkIGxpa2UgaW5zdGFuY2UgcHJvcGVydGllcyBpbiB0aGUgc3BlY2lmaWNhdGlvblxuICogd2hlbiBkZWZpbmluZyBjbGFzc2VzIHVzaW5nIGBSZWFjdC5jcmVhdGVDbGFzc2AsIHRoZXkgYXJlIGFjdHVhbGx5IHN0YXRpY1xuICogYW5kIGFyZSBhY2Nlc3NpYmxlIG9uIHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIHRoZSBwcm90b3R5cGUuIERlc3BpdGVcbiAqIGJlaW5nIHN0YXRpYywgdGhleSBtdXN0IGJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgXCJzdGF0aWNzXCIga2V5IHVuZGVyXG4gKiB3aGljaCBhbGwgb3RoZXIgc3RhdGljIG1ldGhvZHMgYXJlIGRlZmluZWQuXG4gKi9cbnZhciBSRVNFUlZFRF9TUEVDX0tFWVMgPSB7XG4gIGRpc3BsYXlOYW1lOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGRpc3BsYXlOYW1lKSB7XG4gICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgfSxcbiAgbWl4aW5zOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIG1peGlucykge1xuICAgIGlmIChtaXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBtaXhpbnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY2hpbGRDb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcywgJ2NoaWxkQ29udGV4dCcpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHRUeXBlcyk7XG4gIH0sXG4gIGNvbnRleHRUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMsICdjb250ZXh0Jyk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcywgY29udGV4dFR5cGVzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgKiBhdXRvbWF0aWMgbWVyZ2luZy5cbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBnZXREZWZhdWx0UHJvcHMpIHtcbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsIGdldERlZmF1bHRQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcztcbiAgICB9XG4gIH0sXG4gIHByb3BUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMsICdwcm9wJyk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLnByb3BUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLnByb3BUeXBlcywgcHJvcFR5cGVzKTtcbiAgfSxcbiAgc3RhdGljczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gICAgbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpO1xuICB9LFxuICBhdXRvYmluZDogZnVuY3Rpb24gKCkge30gfTtcblxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0eXBlRGVmKSB7XG4gICAgaWYgKHR5cGVEZWYuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAvLyB1c2UgYSB3YXJuaW5nIGluc3RlYWQgb2YgYW4gaW52YXJpYW50IHNvIGNvbXBvbmVudHNcbiAgICAgIC8vIGRvbid0IHNob3cgdXAgaW4gcHJvZCBidXQgb25seSBpbiBfX0RFVl9fXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgdHlwZURlZltwcm9wTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAnUmVhY3QuUHJvcFR5cGVzLicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSkge1xuICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSkgPyBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdIDogbnVsbDtcblxuICAvLyBEaXNhbGxvdyBvdmVycmlkaW5nIG9mIGJhc2UgY2xhc3MgbWV0aG9kcyB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICBpZiAoUmVhY3RDbGFzc01peGluLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSAnT1ZFUlJJREVfQkFTRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBvdmVycmlkZSBgJXNgIGZyb20geW91ciBjbGFzcyBzcGVjaWZpY2F0aW9uLiBFbnN1cmUgdGhhdCB5b3VyIG1ldGhvZCBuYW1lcyBkbyBub3Qgb3ZlcmxhcCB3aXRoIFJlYWN0IG1ldGhvZHMuJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzMnLCBuYW1lKSA6IHZvaWQgMDtcbiAgfVxuXG4gIC8vIERpc2FsbG93IGRlZmluaW5nIG1ldGhvZHMgbW9yZSB0aGFuIG9uY2UgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAhKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWScgfHwgc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlIHRvIGEgbWl4aW4uJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzQnLCBuYW1lKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAqIE1peGluIGhlbHBlciB3aGljaCBoYW5kbGVzIHBvbGljeSB2YWxpZGF0aW9uIGFuZCByZXNlcnZlZFxuICogc3BlY2lmaWNhdGlvbiBrZXlzIHdoZW4gYnVpbGRpbmcgUmVhY3QgY2xhc3Nlcy5cbiAqL1xuZnVuY3Rpb24gbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpIHtcbiAgaWYgKCFzcGVjKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB0eXBlb2ZTcGVjID0gdHlwZW9mIHNwZWM7XG4gICAgICB2YXIgaXNNaXhpblZhbGlkID0gdHlwZW9mU3BlYyA9PT0gJ29iamVjdCcgJiYgc3BlYyAhPT0gbnVsbDtcblxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaXNNaXhpblZhbGlkLCAnJXM6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gaW5jbHVkZSBhIG1peGluIHRoYXQgaXMgZWl0aGVyIG51bGwgJyArICdvciBub3QgYW4gb2JqZWN0LiBDaGVjayB0aGUgbWl4aW5zIGluY2x1ZGVkIGJ5IHRoZSBjb21wb25lbnQsICcgKyAnYXMgd2VsbCBhcyBhbnkgbWl4aW5zIHRoZXkgaW5jbHVkZSB0aGVtc2VsdmVzLiAnICsgJ0V4cGVjdGVkIG9iamVjdCBidXQgZ290ICVzLicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJywgc3BlYyA9PT0gbnVsbCA/IG51bGwgOiB0eXBlb2ZTcGVjKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAhKHR5cGVvZiBzcGVjICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGNvbXBvbmVudCBjbGFzcyBvciBmdW5jdGlvbiBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LicpIDogX3Byb2RJbnZhcmlhbnQoJzc1JykgOiB2b2lkIDA7XG4gICEhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHNwZWMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdXNlIGEgY29tcG9uZW50IGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBfcHJvZEludmFyaWFudCgnNzYnKSA6IHZvaWQgMDtcblxuICB2YXIgcHJvdG8gPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIHZhciBhdXRvQmluZFBhaXJzID0gcHJvdG8uX19yZWFjdEF1dG9CaW5kUGFpcnM7XG5cbiAgLy8gQnkgaGFuZGxpbmcgbWl4aW5zIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcywgd2UgZW5zdXJlIHRoZSBzYW1lXG4gIC8vIGNoYWluaW5nIG9yZGVyIGlzIGFwcGxpZWQgdG8gbWV0aG9kcyB3aXRoIERFRklORV9NQU5ZIHBvbGljeSwgd2hldGhlclxuICAvLyBtaXhpbnMgYXJlIGxpc3RlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlc2UgbWV0aG9kcyBpbiB0aGUgc3BlYy5cbiAgaWYgKHNwZWMuaGFzT3duUHJvcGVydHkoTUlYSU5TX0tFWSkpIHtcbiAgICBSRVNFUlZFRF9TUEVDX0tFWVMubWl4aW5zKENvbnN0cnVjdG9yLCBzcGVjLm1peGlucyk7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIHNwZWMpIHtcbiAgICBpZiAoIXNwZWMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSBNSVhJTlNfS0VZKSB7XG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgaGFuZGxlZCBtaXhpbnMgaW4gYSBzcGVjaWFsIGNhc2UgYWJvdmUuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHkgPSBzcGVjW25hbWVdO1xuICAgIHZhciBpc0FscmVhZHlEZWZpbmVkID0gcHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgdmFsaWRhdGVNZXRob2RPdmVycmlkZShpc0FscmVhZHlEZWZpbmVkLCBuYW1lKTtcblxuICAgIGlmIChSRVNFUlZFRF9TUEVDX0tFWVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIFJFU0VSVkVEX1NQRUNfS0VZU1tuYW1lXShDb25zdHJ1Y3RvciwgcHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXR1cCBtZXRob2RzIG9uIHByb3RvdHlwZTpcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbWVtYmVyIG1ldGhvZHMgc2hvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kOlxuICAgICAgLy8gMS4gRXhwZWN0ZWQgUmVhY3RDbGFzcyBtZXRob2RzIChpbiB0aGUgXCJpbnRlcmZhY2VcIikuXG4gICAgICAvLyAyLiBPdmVycmlkZGVuIG1ldGhvZHMgKHRoYXQgd2VyZSBtaXhlZCBpbikuXG4gICAgICB2YXIgaXNSZWFjdENsYXNzTWV0aG9kID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nO1xuICAgICAgdmFyIHNob3VsZEF1dG9CaW5kID0gaXNGdW5jdGlvbiAmJiAhaXNSZWFjdENsYXNzTWV0aG9kICYmICFpc0FscmVhZHlEZWZpbmVkICYmIHNwZWMuYXV0b2JpbmQgIT09IGZhbHNlO1xuXG4gICAgICBpZiAoc2hvdWxkQXV0b0JpbmQpIHtcbiAgICAgICAgYXV0b0JpbmRQYWlycy5wdXNoKG5hbWUsIHByb3BlcnR5KTtcbiAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdO1xuXG4gICAgICAgICAgLy8gVGhlc2UgY2FzZXMgc2hvdWxkIGFscmVhZHkgYmUgY2F1Z2h0IGJ5IHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUuXG4gICAgICAgICAgIShpc1JlYWN0Q2xhc3NNZXRob2QgJiYgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnIHx8IHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWScpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBVbmV4cGVjdGVkIHNwZWMgcG9saWN5ICVzIGZvciBrZXkgJXMgd2hlbiBtaXhpbmcgaW4gY29tcG9uZW50IHNwZWNzLicsIHNwZWNQb2xpY3ksIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc3Jywgc3BlY1BvbGljeSwgbmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgICAvLyBGb3IgbWV0aG9kcyB3aGljaCBhcmUgZGVmaW5lZCBtb3JlIHRoYW4gb25jZSwgY2FsbCB0aGUgZXhpc3RpbmdcbiAgICAgICAgICAvLyBtZXRob2RzIGJlZm9yZSBjYWxsaW5nIHRoZSBuZXcgcHJvcGVydHksIG1lcmdpbmcgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgaWYgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBBZGQgdmVyYm9zZSBkaXNwbGF5TmFtZSB0byB0aGUgZnVuY3Rpb24sIHdoaWNoIGhlbHBzIHdoZW4gbG9va2luZ1xuICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyAmJiBzcGVjLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdLmRpc3BsYXlOYW1lID0gc3BlYy5kaXNwbGF5TmFtZSArICdfJyArIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gIGlmICghc3RhdGljcykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBuYW1lIGluIHN0YXRpY3MpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBzdGF0aWNzW25hbWVdO1xuICAgIGlmICghc3RhdGljcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBuYW1lIGluIFJFU0VSVkVEX1NQRUNfS0VZUztcbiAgICAhIWlzUmVzZXJ2ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBhIHJlc2VydmVkIHByb3BlcnR5LCBgJXNgLCB0aGF0IHNob3VsZG5cXCd0IGJlIG9uIHRoZSBcInN0YXRpY3NcIiBrZXkuIERlZmluZSBpdCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBpbnN0ZWFkOyBpdCB3aWxsIHN0aWxsIGJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc4JywgbmFtZSkgOiB2b2lkIDA7XG5cbiAgICB2YXIgaXNJbmhlcml0ZWQgPSBuYW1lIGluIENvbnN0cnVjdG9yO1xuICAgICEhaXNJbmhlcml0ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgdG8gYSBtaXhpbi4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3OScsIG5hbWUpIDogdm9pZCAwO1xuICAgIENvbnN0cnVjdG9yW25hbWVdID0gcHJvcGVydHk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb2JqZWN0cywgYnV0IHRocm93IGlmIGJvdGggY29udGFpbiB0aGUgc2FtZSBrZXkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9uZSBUaGUgZmlyc3Qgb2JqZWN0LCB3aGljaCBpcyBtdXRhdGVkLlxuICogQHBhcmFtIHtvYmplY3R9IHR3byBUaGUgc2Vjb25kIG9iamVjdFxuICogQHJldHVybiB7b2JqZWN0fSBvbmUgYWZ0ZXIgaXQgaGFzIGJlZW4gbXV0YXRlZCB0byBjb250YWluIGV2ZXJ5dGhpbmcgaW4gdHdvLlxuICovXG5mdW5jdGlvbiBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKG9uZSwgdHdvKSB7XG4gICEob25lICYmIHR3byAmJiB0eXBlb2Ygb25lID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdHdvID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiBDYW5ub3QgbWVyZ2Ugbm9uLW9iamVjdHMuJykgOiBfcHJvZEludmFyaWFudCgnODAnKSA6IHZvaWQgMDtcblxuICBmb3IgKHZhciBrZXkgaW4gdHdvKSB7XG4gICAgaWYgKHR3by5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAhKG9uZVtrZXldID09PSB1bmRlZmluZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogVHJpZWQgdG8gbWVyZ2UgdHdvIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBrZXk6IGAlc2AuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSB0byBhIG1peGluOyBpbiBwYXJ0aWN1bGFyLCB0aGlzIG1heSBiZSBjYXVzZWQgYnkgdHdvIGdldEluaXRpYWxTdGF0ZSgpIG9yIGdldERlZmF1bHRQcm9wcygpIG1ldGhvZHMgcmV0dXJuaW5nIG9iamVjdHMgd2l0aCBjbGFzaGluZyBrZXlzLicsIGtleSkgOiBfcHJvZEludmFyaWFudCgnODEnLCBrZXkpIDogdm9pZCAwO1xuICAgICAgb25lW2tleV0gPSB0d29ba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9uZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIG1lcmdlcyB0aGVpciByZXR1cm4gdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkUmVzdWx0KCkge1xuICAgIHZhciBhID0gb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGIgPSB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9IGVsc2UgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHZhciBjID0ge307XG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBhKTtcbiAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGIpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgaWdub3JlcyB0aGVpciByZXR1cm4gdmFsZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uKCkge1xuICAgIG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIEJpbmRzIGEgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1ldGhvZCB0byBiZSBib3VuZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgYm91bmQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpIHtcbiAgdmFyIGJvdW5kTWV0aG9kID0gbWV0aG9kLmJpbmQoY29tcG9uZW50KTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lO1xuICAgIHZhciBfYmluZCA9IGJvdW5kTWV0aG9kLmJpbmQ7XG4gICAgYm91bmRNZXRob2QuYmluZCA9IGZ1bmN0aW9uIChuZXdUaGlzKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZXIgaXMgdHJ5aW5nIHRvIGJpbmQoKSBhbiBhdXRvYm91bmQgbWV0aG9kOyB3ZSBlZmZlY3RpdmVseSB3aWxsXG4gICAgICAvLyBpZ25vcmUgdGhlIHZhbHVlIG9mIFwidGhpc1wiIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSwgc29cbiAgICAgIC8vIGxldCdzIHdhcm4uXG4gICAgICBpZiAobmV3VGhpcyAhPT0gY29tcG9uZW50ICYmIG5ld1RoaXMgIT09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFJlYWN0IGNvbXBvbmVudCBtZXRob2RzIG1heSBvbmx5IGJlIGJvdW5kIHRvIHRoZSAnICsgJ2NvbXBvbmVudCBpbnN0YW5jZS4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XG4gICAgICB9IGVsc2UgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogWW91IGFyZSBiaW5kaW5nIGEgY29tcG9uZW50IG1ldGhvZCB0byB0aGUgY29tcG9uZW50LiAnICsgJ1JlYWN0IGRvZXMgdGhpcyBmb3IgeW91IGF1dG9tYXRpY2FsbHkgaW4gYSBoaWdoLXBlcmZvcm1hbmNlICcgKyAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICAgICAgfVxuICAgICAgdmFyIHJlYm91bmRNZXRob2QgPSBfYmluZC5hcHBseShib3VuZE1ldGhvZCwgYXJndW1lbnRzKTtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBhcmdzO1xuICAgICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gYm91bmRNZXRob2Q7XG59XG5cbi8qKlxuICogQmluZHMgYWxsIGF1dG8tYm91bmQgbWV0aG9kcyBpbiBhIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gKi9cbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZHMoY29tcG9uZW50KSB7XG4gIHZhciBwYWlycyA9IGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRQYWlycztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBhdXRvQmluZEtleSA9IHBhaXJzW2ldO1xuICAgIHZhciBtZXRob2QgPSBwYWlyc1tpICsgMV07XG4gICAgY29tcG9uZW50W2F1dG9CaW5kS2V5XSA9IGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgbW9yZSB0byB0aGUgUmVhY3RDbGFzcyBiYXNlIGNsYXNzLiBUaGVzZSBhcmUgYWxsIGxlZ2FjeSBmZWF0dXJlcyBhbmRcbiAqIHRoZXJlZm9yZSBub3QgYWxyZWFkeSBwYXJ0IG9mIHRoZSBtb2Rlcm4gUmVhY3RDb21wb25lbnQuXG4gKi9cbnZhciBSZWFjdENsYXNzTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIFRPRE86IFRoaXMgd2lsbCBiZSBkZXByZWNhdGVkIGJlY2F1c2Ugc3RhdGUgc2hvdWxkIGFsd2F5cyBrZWVwIGEgY29uc2lzdGVudFxuICAgKiB0eXBlIHNpZ25hdHVyZSBhbmQgdGhlIG9ubHkgdXNlIGNhc2UgZm9yIHRoaXMsIGlzIHRvIGF2b2lkIHRoYXQuXG4gICAqL1xuICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChuZXdTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZSh0aGlzLCBuZXdTdGF0ZSk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAncmVwbGFjZVN0YXRlJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlci5pc01vdW50ZWQodGhpcyk7XG4gIH1cbn07XG5cbnZhciBSZWFjdENsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge307XG5fYXNzaWduKFJlYWN0Q2xhc3NDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q2xhc3NNaXhpbik7XG5cbi8qKlxuICogTW9kdWxlIGZvciBjcmVhdGluZyBjb21wb3NpdGUgY29tcG9uZW50cy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RDbGFzc1xuICovXG52YXIgUmVhY3RDbGFzcyA9IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgY2xhc3MgZ2l2ZW4gYSBjbGFzcyBzcGVjaWZpY2F0aW9uLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHNwZWMgQ2xhc3Mgc3BlY2lmaWNhdGlvbiAod2hpY2ggbXVzdCBkZWZpbmUgYHJlbmRlcmApLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gQ29tcG9uZW50IGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjcmVhdGVDbGFzczogZnVuY3Rpb24gKHNwZWMpIHtcbiAgICAvLyBUbyBrZWVwIG91ciB3YXJuaW5ncyBtb3JlIHVuZGVyc3RhbmRhYmxlLCB3ZSdsbCB1c2UgYSBsaXR0bGUgaGFjayBoZXJlIHRvXG4gICAgLy8gZW5zdXJlIHRoYXQgQ29uc3RydWN0b3IubmFtZSAhPT0gJ0NvbnN0cnVjdG9yJy4gVGhpcyBtYWtlcyBzdXJlIHdlIGRvbid0XG4gICAgLy8gdW5uZWNlc3NhcmlseSBpZGVudGlmeSBhIGNsYXNzIHdpdGhvdXQgZGlzcGxheU5hbWUgYXMgJ0NvbnN0cnVjdG9yJy5cbiAgICB2YXIgQ29uc3RydWN0b3IgPSBpZGVudGl0eShmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgIC8vIFRoaXMgY29uc3RydWN0b3IgZ2V0cyBvdmVycmlkZGVuIGJ5IG1vY2tzLiBUaGUgYXJndW1lbnQgaXMgdXNlZFxuICAgICAgLy8gYnkgbW9ja3MgdG8gYXNzZXJ0IG9uIHdoYXQgZ2V0cyBtb3VudGVkLlxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0aGlzIGluc3RhbmNlb2YgQ29uc3RydWN0b3IsICdTb21ldGhpbmcgaXMgY2FsbGluZyBhIFJlYWN0IGNvbXBvbmVudCBkaXJlY3RseS4gVXNlIGEgZmFjdG9yeSBvciAnICsgJ0pTWCBpbnN0ZWFkLiBTZWU6IGh0dHBzOi8vZmIubWUvcmVhY3QtbGVnYWN5ZmFjdG9yeScpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICAvLyBXaXJlIHVwIGF1dG8tYmluZGluZ1xuICAgICAgaWYgKHRoaXMuX19yZWFjdEF1dG9CaW5kUGFpcnMubGVuZ3RoKSB7XG4gICAgICAgIGJpbmRBdXRvQmluZE1ldGhvZHModGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuXG4gICAgICAvLyBSZWFjdENsYXNzZXMgZG9lc24ndCBoYXZlIGNvbnN0cnVjdG9ycy4gSW5zdGVhZCwgdGhleSB1c2UgdGhlXG4gICAgICAvLyBnZXRJbml0aWFsU3RhdGUgYW5kIGNvbXBvbmVudFdpbGxNb3VudCBtZXRob2RzIGZvciBpbml0aWFsaXphdGlvbi5cblxuICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlID8gdGhpcy5nZXRJbml0aWFsU3RhdGUoKSA6IG51bGw7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgaWYgKGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuZ2V0SW5pdGlhbFN0YXRlLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgICBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldEluaXRpYWxTdGF0ZSgpOiBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgbnVsbCcsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzgyJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgfSk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gbmV3IFJlYWN0Q2xhc3NDb21wb25lbnQoKTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuX19yZWFjdEF1dG9CaW5kUGFpcnMgPSBbXTtcblxuICAgIGluamVjdGVkTWl4aW5zLmZvckVhY2gobWl4U3BlY0ludG9Db21wb25lbnQuYmluZChudWxsLCBDb25zdHJ1Y3RvcikpO1xuXG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGVmYXVsdFByb3BzIHByb3BlcnR5IGFmdGVyIGFsbCBtaXhpbnMgaGF2ZSBiZWVuIG1lcmdlZC5cbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5kZWZhdWx0UHJvcHMgPSBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMoKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHRhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSB1c2Ugb2YgdGhlc2UgbWV0aG9kIG5hbWVzIGlzIG9rLFxuICAgICAgLy8gc2luY2UgaXQncyB1c2VkIHdpdGggY3JlYXRlQ2xhc3MuIElmIGl0J3Mgbm90LCB0aGVuIGl0J3MgbGlrZWx5IGFcbiAgICAgIC8vIG1pc3Rha2Ugc28gd2UnbGwgd2FybiB5b3UgdG8gdXNlIHRoZSBzdGF0aWMgcHJvcGVydHksIHByb3BlcnR5XG4gICAgICAvLyBpbml0aWFsaXplciBvciBjb25zdHJ1Y3RvciByZXNwZWN0aXZlbHkuXG4gICAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUpIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgICFDb25zdHJ1Y3Rvci5wcm90b3R5cGUucmVuZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZUNsYXNzKC4uLik6IENsYXNzIHNwZWNpZmljYXRpb24gbXVzdCBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuJykgOiBfcHJvZEludmFyaWFudCgnODMnKSA6IHZvaWQgMDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gUmVkdWNlIHRpbWUgc3BlbnQgZG9pbmcgbG9va3VwcyBieSBzZXR0aW5nIHRoZXNlIG9uIHRoZSBwcm90b3R5cGUuXG4gICAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiBSZWFjdENsYXNzSW50ZXJmYWNlKSB7XG4gICAgICBpZiAoIUNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfSxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XG4gICAgICBpbmplY3RlZE1peGlucy5wdXNoKG1peGluKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENsYXNzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0Q2xhc3MuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcbiAgICBwcm9wOiAncHJvcCcsXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBmYWN0b3J5IHRoYXQgY3JlYXRlcyBIVE1MIHRhZyBlbGVtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY3JlYXRlRE9NRmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50VmFsaWRhdG9yJyk7XG4gIGNyZWF0ZURPTUZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwcGluZyBmcm9tIHN1cHBvcnRlZCBIVE1MIHRhZ3MgdG8gYFJlYWN0RE9NQ29tcG9uZW50YCBjbGFzc2VzLlxuICogVGhpcyBpcyBhbHNvIGFjY2Vzc2libGUgdmlhIGBSZWFjdC5ET01gLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0ge1xuICBhOiBjcmVhdGVET01GYWN0b3J5KCdhJyksXG4gIGFiYnI6IGNyZWF0ZURPTUZhY3RvcnkoJ2FiYnInKSxcbiAgYWRkcmVzczogY3JlYXRlRE9NRmFjdG9yeSgnYWRkcmVzcycpLFxuICBhcmVhOiBjcmVhdGVET01GYWN0b3J5KCdhcmVhJyksXG4gIGFydGljbGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2FydGljbGUnKSxcbiAgYXNpZGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2FzaWRlJyksXG4gIGF1ZGlvOiBjcmVhdGVET01GYWN0b3J5KCdhdWRpbycpLFxuICBiOiBjcmVhdGVET01GYWN0b3J5KCdiJyksXG4gIGJhc2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2Jhc2UnKSxcbiAgYmRpOiBjcmVhdGVET01GYWN0b3J5KCdiZGknKSxcbiAgYmRvOiBjcmVhdGVET01GYWN0b3J5KCdiZG8nKSxcbiAgYmlnOiBjcmVhdGVET01GYWN0b3J5KCdiaWcnKSxcbiAgYmxvY2txdW90ZTogY3JlYXRlRE9NRmFjdG9yeSgnYmxvY2txdW90ZScpLFxuICBib2R5OiBjcmVhdGVET01GYWN0b3J5KCdib2R5JyksXG4gIGJyOiBjcmVhdGVET01GYWN0b3J5KCdicicpLFxuICBidXR0b246IGNyZWF0ZURPTUZhY3RvcnkoJ2J1dHRvbicpLFxuICBjYW52YXM6IGNyZWF0ZURPTUZhY3RvcnkoJ2NhbnZhcycpLFxuICBjYXB0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdjYXB0aW9uJyksXG4gIGNpdGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NpdGUnKSxcbiAgY29kZTogY3JlYXRlRE9NRmFjdG9yeSgnY29kZScpLFxuICBjb2w6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvbCcpLFxuICBjb2xncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnY29sZ3JvdXAnKSxcbiAgZGF0YTogY3JlYXRlRE9NRmFjdG9yeSgnZGF0YScpLFxuICBkYXRhbGlzdDogY3JlYXRlRE9NRmFjdG9yeSgnZGF0YWxpc3QnKSxcbiAgZGQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2RkJyksXG4gIGRlbDogY3JlYXRlRE9NRmFjdG9yeSgnZGVsJyksXG4gIGRldGFpbHM6IGNyZWF0ZURPTUZhY3RvcnkoJ2RldGFpbHMnKSxcbiAgZGZuOiBjcmVhdGVET01GYWN0b3J5KCdkZm4nKSxcbiAgZGlhbG9nOiBjcmVhdGVET01GYWN0b3J5KCdkaWFsb2cnKSxcbiAgZGl2OiBjcmVhdGVET01GYWN0b3J5KCdkaXYnKSxcbiAgZGw6IGNyZWF0ZURPTUZhY3RvcnkoJ2RsJyksXG4gIGR0OiBjcmVhdGVET01GYWN0b3J5KCdkdCcpLFxuICBlbTogY3JlYXRlRE9NRmFjdG9yeSgnZW0nKSxcbiAgZW1iZWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2VtYmVkJyksXG4gIGZpZWxkc2V0OiBjcmVhdGVET01GYWN0b3J5KCdmaWVsZHNldCcpLFxuICBmaWdjYXB0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdmaWdjYXB0aW9uJyksXG4gIGZpZ3VyZTogY3JlYXRlRE9NRmFjdG9yeSgnZmlndXJlJyksXG4gIGZvb3RlcjogY3JlYXRlRE9NRmFjdG9yeSgnZm9vdGVyJyksXG4gIGZvcm06IGNyZWF0ZURPTUZhY3RvcnkoJ2Zvcm0nKSxcbiAgaDE6IGNyZWF0ZURPTUZhY3RvcnkoJ2gxJyksXG4gIGgyOiBjcmVhdGVET01GYWN0b3J5KCdoMicpLFxuICBoMzogY3JlYXRlRE9NRmFjdG9yeSgnaDMnKSxcbiAgaDQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2g0JyksXG4gIGg1OiBjcmVhdGVET01GYWN0b3J5KCdoNScpLFxuICBoNjogY3JlYXRlRE9NRmFjdG9yeSgnaDYnKSxcbiAgaGVhZDogY3JlYXRlRE9NRmFjdG9yeSgnaGVhZCcpLFxuICBoZWFkZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ2hlYWRlcicpLFxuICBoZ3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ2hncm91cCcpLFxuICBocjogY3JlYXRlRE9NRmFjdG9yeSgnaHInKSxcbiAgaHRtbDogY3JlYXRlRE9NRmFjdG9yeSgnaHRtbCcpLFxuICBpOiBjcmVhdGVET01GYWN0b3J5KCdpJyksXG4gIGlmcmFtZTogY3JlYXRlRE9NRmFjdG9yeSgnaWZyYW1lJyksXG4gIGltZzogY3JlYXRlRE9NRmFjdG9yeSgnaW1nJyksXG4gIGlucHV0OiBjcmVhdGVET01GYWN0b3J5KCdpbnB1dCcpLFxuICBpbnM6IGNyZWF0ZURPTUZhY3RvcnkoJ2lucycpLFxuICBrYmQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2tiZCcpLFxuICBrZXlnZW46IGNyZWF0ZURPTUZhY3RvcnkoJ2tleWdlbicpLFxuICBsYWJlbDogY3JlYXRlRE9NRmFjdG9yeSgnbGFiZWwnKSxcbiAgbGVnZW5kOiBjcmVhdGVET01GYWN0b3J5KCdsZWdlbmQnKSxcbiAgbGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpJyksXG4gIGxpbms6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmsnKSxcbiAgbWFpbjogY3JlYXRlRE9NRmFjdG9yeSgnbWFpbicpLFxuICBtYXA6IGNyZWF0ZURPTUZhY3RvcnkoJ21hcCcpLFxuICBtYXJrOiBjcmVhdGVET01GYWN0b3J5KCdtYXJrJyksXG4gIG1lbnU6IGNyZWF0ZURPTUZhY3RvcnkoJ21lbnUnKSxcbiAgbWVudWl0ZW06IGNyZWF0ZURPTUZhY3RvcnkoJ21lbnVpdGVtJyksXG4gIG1ldGE6IGNyZWF0ZURPTUZhY3RvcnkoJ21ldGEnKSxcbiAgbWV0ZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ21ldGVyJyksXG4gIG5hdjogY3JlYXRlRE9NRmFjdG9yeSgnbmF2JyksXG4gIG5vc2NyaXB0OiBjcmVhdGVET01GYWN0b3J5KCdub3NjcmlwdCcpLFxuICBvYmplY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ29iamVjdCcpLFxuICBvbDogY3JlYXRlRE9NRmFjdG9yeSgnb2wnKSxcbiAgb3B0Z3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ29wdGdyb3VwJyksXG4gIG9wdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnb3B0aW9uJyksXG4gIG91dHB1dDogY3JlYXRlRE9NRmFjdG9yeSgnb3V0cHV0JyksXG4gIHA6IGNyZWF0ZURPTUZhY3RvcnkoJ3AnKSxcbiAgcGFyYW06IGNyZWF0ZURPTUZhY3RvcnkoJ3BhcmFtJyksXG4gIHBpY3R1cmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3BpY3R1cmUnKSxcbiAgcHJlOiBjcmVhdGVET01GYWN0b3J5KCdwcmUnKSxcbiAgcHJvZ3Jlc3M6IGNyZWF0ZURPTUZhY3RvcnkoJ3Byb2dyZXNzJyksXG4gIHE6IGNyZWF0ZURPTUZhY3RvcnkoJ3EnKSxcbiAgcnA6IGNyZWF0ZURPTUZhY3RvcnkoJ3JwJyksXG4gIHJ0OiBjcmVhdGVET01GYWN0b3J5KCdydCcpLFxuICBydWJ5OiBjcmVhdGVET01GYWN0b3J5KCdydWJ5JyksXG4gIHM6IGNyZWF0ZURPTUZhY3RvcnkoJ3MnKSxcbiAgc2FtcDogY3JlYXRlRE9NRmFjdG9yeSgnc2FtcCcpLFxuICBzY3JpcHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3NjcmlwdCcpLFxuICBzZWN0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdzZWN0aW9uJyksXG4gIHNlbGVjdDogY3JlYXRlRE9NRmFjdG9yeSgnc2VsZWN0JyksXG4gIHNtYWxsOiBjcmVhdGVET01GYWN0b3J5KCdzbWFsbCcpLFxuICBzb3VyY2U6IGNyZWF0ZURPTUZhY3RvcnkoJ3NvdXJjZScpLFxuICBzcGFuOiBjcmVhdGVET01GYWN0b3J5KCdzcGFuJyksXG4gIHN0cm9uZzogY3JlYXRlRE9NRmFjdG9yeSgnc3Ryb25nJyksXG4gIHN0eWxlOiBjcmVhdGVET01GYWN0b3J5KCdzdHlsZScpLFxuICBzdWI6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1YicpLFxuICBzdW1tYXJ5OiBjcmVhdGVET01GYWN0b3J5KCdzdW1tYXJ5JyksXG4gIHN1cDogY3JlYXRlRE9NRmFjdG9yeSgnc3VwJyksXG4gIHRhYmxlOiBjcmVhdGVET01GYWN0b3J5KCd0YWJsZScpLFxuICB0Ym9keTogY3JlYXRlRE9NRmFjdG9yeSgndGJvZHknKSxcbiAgdGQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RkJyksXG4gIHRleHRhcmVhOiBjcmVhdGVET01GYWN0b3J5KCd0ZXh0YXJlYScpLFxuICB0Zm9vdDogY3JlYXRlRE9NRmFjdG9yeSgndGZvb3QnKSxcbiAgdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ3RoJyksXG4gIHRoZWFkOiBjcmVhdGVET01GYWN0b3J5KCd0aGVhZCcpLFxuICB0aW1lOiBjcmVhdGVET01GYWN0b3J5KCd0aW1lJyksXG4gIHRpdGxlOiBjcmVhdGVET01GYWN0b3J5KCd0aXRsZScpLFxuICB0cjogY3JlYXRlRE9NRmFjdG9yeSgndHInKSxcbiAgdHJhY2s6IGNyZWF0ZURPTUZhY3RvcnkoJ3RyYWNrJyksXG4gIHU6IGNyZWF0ZURPTUZhY3RvcnkoJ3UnKSxcbiAgdWw6IGNyZWF0ZURPTUZhY3RvcnkoJ3VsJyksXG4gICd2YXInOiBjcmVhdGVET01GYWN0b3J5KCd2YXInKSxcbiAgdmlkZW86IGNyZWF0ZURPTUZhY3RvcnkoJ3ZpZGVvJyksXG4gIHdicjogY3JlYXRlRE9NRmFjdG9yeSgnd2JyJyksXG5cbiAgLy8gU1ZHXG4gIGNpcmNsZTogY3JlYXRlRE9NRmFjdG9yeSgnY2lyY2xlJyksXG4gIGNsaXBQYXRoOiBjcmVhdGVET01GYWN0b3J5KCdjbGlwUGF0aCcpLFxuICBkZWZzOiBjcmVhdGVET01GYWN0b3J5KCdkZWZzJyksXG4gIGVsbGlwc2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2VsbGlwc2UnKSxcbiAgZzogY3JlYXRlRE9NRmFjdG9yeSgnZycpLFxuICBpbWFnZTogY3JlYXRlRE9NRmFjdG9yeSgnaW1hZ2UnKSxcbiAgbGluZTogY3JlYXRlRE9NRmFjdG9yeSgnbGluZScpLFxuICBsaW5lYXJHcmFkaWVudDogY3JlYXRlRE9NRmFjdG9yeSgnbGluZWFyR3JhZGllbnQnKSxcbiAgbWFzazogY3JlYXRlRE9NRmFjdG9yeSgnbWFzaycpLFxuICBwYXRoOiBjcmVhdGVET01GYWN0b3J5KCdwYXRoJyksXG4gIHBhdHRlcm46IGNyZWF0ZURPTUZhY3RvcnkoJ3BhdHRlcm4nKSxcbiAgcG9seWdvbjogY3JlYXRlRE9NRmFjdG9yeSgncG9seWdvbicpLFxuICBwb2x5bGluZTogY3JlYXRlRE9NRmFjdG9yeSgncG9seWxpbmUnKSxcbiAgcmFkaWFsR3JhZGllbnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3JhZGlhbEdyYWRpZW50JyksXG4gIHJlY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ3JlY3QnKSxcbiAgc3RvcDogY3JlYXRlRE9NRmFjdG9yeSgnc3RvcCcpLFxuICBzdmc6IGNyZWF0ZURPTUZhY3RvcnkoJ3N2ZycpLFxuICB0ZXh0OiBjcmVhdGVET01GYWN0b3J5KCd0ZXh0JyksXG4gIHRzcGFuOiBjcmVhdGVET01GYWN0b3J5KCd0c3BhbicpXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRmFjdG9yaWVzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0RE9NRmFjdG9yaWVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qKlxuICogUmVhY3RFbGVtZW50VmFsaWRhdG9yIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYSBlbGVtZW50IGZhY3RvcnlcbiAqIHdoaWNoIHZhbGlkYXRlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIHRoZSBlbGVtZW50LiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4gKiB1c2VkIG9ubHkgaW4gREVWIGFuZCBjb3VsZCBiZSByZXBsYWNlZCBieSBhIHN0YXRpYyB0eXBlIGNoZWNrZXIgZm9yIGxhbmd1YWdlc1xuICogdGhhdCBzdXBwb3J0IGl0LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgY2hlY2tSZWFjdFR5cGVTcGVjID0gcmVxdWlyZSgnLi9jaGVja1JlYWN0VHlwZVNwZWMnKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9ICcgQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgbWVtb2l6ZXIgPSBvd25lckhhc0tleVVzZVdhcm5pbmcudW5pcXVlS2V5IHx8IChvd25lckhhc0tleVVzZVdhcm5pbmcudW5pcXVlS2V5ID0ge30pO1xuXG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcbiAgaWYgKG1lbW9pemVyW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG1lbW9pemVyW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nO1xuICB9XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLiVzJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lciwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDdXJyZW50U3RhY2tBZGRlbmR1bShlbGVtZW50KSkgOiB2b2lkIDA7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgLy8gRW50cnkgaXRlcmF0b3JzIHByb3ZpZGUgaW1wbGljaXQga2V5cy5cbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgY29tcG9uZW50Q2xhc3MgPSBlbGVtZW50LnR5cGU7XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5hbWUgPSBjb21wb25lbnRDbGFzcy5kaXNwbGF5TmFtZSB8fCBjb21wb25lbnRDbGFzcy5uYW1lO1xuICBpZiAoY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzKSB7XG4gICAgY2hlY2tSZWFjdFR5cGVTcGVjKGNvbXBvbmVudENsYXNzLnByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50LCBudWxsKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgfVxufVxuXG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0ge1xuXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nO1xuICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIHNob3VsZCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBib29sZWFuLCBvciAnICsgJ251bWJlci4gSXQgc2hvdWxkIGJlIGEgc3RyaW5nIChmb3IgRE9NIGVsZW1lbnRzKSBvciBhIFJlYWN0Q2xhc3MgJyArICcoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIGNyZWF0ZUZhY3Rvcnk6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAgIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICAgIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpIDogdm9pZCAwO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xuICB9LFxuXG4gIGNsb25lRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gICAgfVxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudFZhbGlkYXRvci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gaXNOYXRpdmUoZm4pIHtcbiAgLy8gQmFzZWQgb24gaXNOYXRpdmUoKSBmcm9tIExvZGFzaFxuICB2YXIgZnVuY1RvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgKyBmdW5jVG9TdHJpbmdcbiAgLy8gVGFrZSBhbiBleGFtcGxlIG5hdGl2ZSBmdW5jdGlvbiBzb3VyY2UgZm9yIGNvbXBhcmlzb25cbiAgLmNhbGwoaGFzT3duUHJvcGVydHkpXG4gIC8vIFN0cmlwIHJlZ2V4IGNoYXJhY3RlcnMgc28gd2UgY2FuIHVzZSBpdCBmb3IgcmVnZXhcbiAgLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgLy8gUmVtb3ZlIGhhc093blByb3BlcnR5IGZyb20gdGhlIHRlbXBsYXRlIHRvIG1ha2UgaXQgZ2VuZXJpY1xuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCcpO1xuICB0cnkge1xuICAgIHZhciBzb3VyY2UgPSBmdW5jVG9TdHJpbmcuY2FsbChmbik7XG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChzb3VyY2UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxudmFyIGNhblVzZUNvbGxlY3Rpb25zID1cbi8vIEFycmF5LmZyb21cbnR5cGVvZiBBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nICYmXG4vLyBNYXBcbnR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoTWFwKSAmJlxuLy8gTWFwLnByb3RvdHlwZS5rZXlzXG5NYXAucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIE1hcC5wcm90b3R5cGUua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShNYXAucHJvdG90eXBlLmtleXMpICYmXG4vLyBTZXRcbnR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoU2V0KSAmJlxuLy8gU2V0LnByb3RvdHlwZS5rZXlzXG5TZXQucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIFNldC5wcm90b3R5cGUua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShTZXQucHJvdG90eXBlLmtleXMpO1xuXG5pZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgdmFyIGl0ZW1NYXAgPSBuZXcgTWFwKCk7XG4gIHZhciByb290SURTZXQgPSBuZXcgU2V0KCk7XG5cbiAgdmFyIHNldEl0ZW0gPSBmdW5jdGlvbiAoaWQsIGl0ZW0pIHtcbiAgICBpdGVtTWFwLnNldChpZCwgaXRlbSk7XG4gIH07XG4gIHZhciBnZXRJdGVtID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGl0ZW1NYXAuZ2V0KGlkKTtcbiAgfTtcbiAgdmFyIHJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICBpdGVtTWFwWydkZWxldGUnXShpZCk7XG4gIH07XG4gIHZhciBnZXRJdGVtSURzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGl0ZW1NYXAua2V5cygpKTtcbiAgfTtcblxuICB2YXIgYWRkUm9vdCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJvb3RJRFNldC5hZGQoaWQpO1xuICB9O1xuICB2YXIgcmVtb3ZlUm9vdCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJvb3RJRFNldFsnZGVsZXRlJ10oaWQpO1xuICB9O1xuICB2YXIgZ2V0Um9vdElEcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShyb290SURTZXQua2V5cygpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBpdGVtQnlLZXkgPSB7fTtcbiAgdmFyIHJvb3RCeUtleSA9IHt9O1xuXG4gIC8vIFVzZSBub24tbnVtZXJpYyBrZXlzIHRvIHByZXZlbnQgVjggcGVyZm9ybWFuY2UgaXNzdWVzOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MjMyXG4gIHZhciBnZXRLZXlGcm9tSUQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gJy4nICsgaWQ7XG4gIH07XG4gIHZhciBnZXRJREZyb21LZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGtleS5zdWJzdHIoMSksIDEwKTtcbiAgfTtcblxuICB2YXIgc2V0SXRlbSA9IGZ1bmN0aW9uIChpZCwgaXRlbSkge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIGl0ZW1CeUtleVtrZXldID0gaXRlbTtcbiAgfTtcbiAgdmFyIGdldEl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICByZXR1cm4gaXRlbUJ5S2V5W2tleV07XG4gIH07XG4gIHZhciByZW1vdmVJdGVtID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgZGVsZXRlIGl0ZW1CeUtleVtrZXldO1xuICB9O1xuICB2YXIgZ2V0SXRlbUlEcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoaXRlbUJ5S2V5KS5tYXAoZ2V0SURGcm9tS2V5KTtcbiAgfTtcblxuICB2YXIgYWRkUm9vdCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIHJvb3RCeUtleVtrZXldID0gdHJ1ZTtcbiAgfTtcbiAgdmFyIHJlbW92ZVJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICBkZWxldGUgcm9vdEJ5S2V5W2tleV07XG4gIH07XG4gIHZhciBnZXRSb290SURzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhyb290QnlLZXkpLm1hcChnZXRJREZyb21LZXkpO1xuICB9O1xufVxuXG52YXIgdW5tb3VudGVkSURzID0gW107XG5cbmZ1bmN0aW9uIHB1cmdlRGVlcChpZCkge1xuICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICBpZiAoaXRlbSkge1xuICAgIHZhciBjaGlsZElEcyA9IGl0ZW0uY2hpbGRJRHM7XG5cbiAgICByZW1vdmVJdGVtKGlkKTtcbiAgICBjaGlsZElEcy5mb3JFYWNoKHB1cmdlRGVlcCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIChzb3VyY2UgPyAnIChhdCAnICsgc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknIDogb3duZXJOYW1lID8gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknIDogJycpO1xufVxuXG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gJyNlbXB0eSc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiAnI3RleHQnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlLmRpc3BsYXlOYW1lIHx8IGVsZW1lbnQudHlwZS5uYW1lIHx8ICdVbmtub3duJztcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZUlEKGlkKSB7XG4gIHZhciBuYW1lID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShpZCk7XG4gIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgdmFyIG93bmVySUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldE93bmVySUQoaWQpO1xuICB2YXIgb3duZXJOYW1lO1xuICBpZiAob3duZXJJRCkge1xuICAgIG93bmVyTmFtZSA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUob3duZXJJRCk7XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZWxlbWVudCwgJ1JlYWN0Q29tcG9uZW50VHJlZUhvb2s6IE1pc3NpbmcgUmVhY3QgZWxlbWVudCBmb3IgZGVidWdJRCAlcyB3aGVuICcgKyAnYnVpbGRpbmcgc3RhY2snLCBpZCkgOiB2b2lkIDA7XG4gIHJldHVybiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGVsZW1lbnQgJiYgZWxlbWVudC5fc291cmNlLCBvd25lck5hbWUpO1xufVxuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHtcbiAgb25TZXRDaGlsZHJlbjogZnVuY3Rpb24gKGlkLCBuZXh0Q2hpbGRJRHMpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgICFpdGVtID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0l0ZW0gbXVzdCBoYXZlIGJlZW4gc2V0JykgOiBfcHJvZEludmFyaWFudCgnMTQ0JykgOiB2b2lkIDA7XG4gICAgaXRlbS5jaGlsZElEcyA9IG5leHRDaGlsZElEcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV4dENoaWxkSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dENoaWxkSUQgPSBuZXh0Q2hpbGRJRHNbaV07XG4gICAgICB2YXIgbmV4dENoaWxkID0gZ2V0SXRlbShuZXh0Q2hpbGRJRCk7XG4gICAgICAhbmV4dENoaWxkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGhvb2sgZXZlbnRzIHRvIGZpcmUgZm9yIHRoZSBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnMTQwJykgOiB2b2lkIDA7XG4gICAgICAhKG5leHRDaGlsZC5jaGlsZElEcyAhPSBudWxsIHx8IHR5cGVvZiBuZXh0Q2hpbGQuZWxlbWVudCAhPT0gJ29iamVjdCcgfHwgbmV4dENoaWxkLmVsZW1lbnQgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25TZXRDaGlsZHJlbigpIHRvIGZpcmUgZm9yIGEgY29udGFpbmVyIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxNDEnKSA6IHZvaWQgMDtcbiAgICAgICFuZXh0Q2hpbGQuaXNNb3VudGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uTW91bnRDb21wb25lbnQoKSB0byBmaXJlIGZvciB0aGUgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzcxJykgOiB2b2lkIDA7XG4gICAgICBpZiAobmV4dENoaWxkLnBhcmVudElEID09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkLnBhcmVudElEID0gaWQ7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSBidXQgbW91bnRpbmcgYSBuZXcgcm9vdCBkdXJpbmcgaW5cbiAgICAgICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGN1cnJlbnRseSBjYXVzZXMgbm90LXlldC1tb3VudGVkIGNvbXBvbmVudHMgdG9cbiAgICAgICAgLy8gYmUgcHVyZ2VkIGZyb20gb3VyIHRyZWUgZGF0YSBzbyB0aGVpciBwYXJlbnQgaWQgaXMgbWlzc2luZy5cbiAgICAgIH1cbiAgICAgICEobmV4dENoaWxkLnBhcmVudElEID09PSBpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25CZWZvcmVNb3VudENvbXBvbmVudCgpIHBhcmVudCBhbmQgb25TZXRDaGlsZHJlbigpIHRvIGJlIGNvbnNpc3RlbnQgKCVzIGhhcyBwYXJlbnRzICVzIGFuZCAlcykuJywgbmV4dENoaWxkSUQsIG5leHRDaGlsZC5wYXJlbnRJRCwgaWQpIDogX3Byb2RJbnZhcmlhbnQoJzE0MicsIG5leHRDaGlsZElELCBuZXh0Q2hpbGQucGFyZW50SUQsIGlkKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0sXG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCwgZWxlbWVudCwgcGFyZW50SUQpIHtcbiAgICB2YXIgaXRlbSA9IHtcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgICB0ZXh0OiBudWxsLFxuICAgICAgY2hpbGRJRHM6IFtdLFxuICAgICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICAgIHVwZGF0ZUNvdW50OiAwXG4gICAgfTtcbiAgICBzZXRJdGVtKGlkLCBpdGVtKTtcbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCwgZWxlbWVudCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgaWYgKCFpdGVtIHx8ICFpdGVtLmlzTW91bnRlZCkge1xuICAgICAgLy8gV2UgbWF5IGVuZCB1cCBoZXJlIGFzIGEgcmVzdWx0IG9mIHNldFN0YXRlKCkgaW4gY29tcG9uZW50V2lsbFVubW91bnQoKS5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgaWdub3JlIHRoZSBlbGVtZW50LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpdGVtLmVsZW1lbnQgPSBlbGVtZW50O1xuICB9LFxuICBvbk1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgICFpdGVtID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0l0ZW0gbXVzdCBoYXZlIGJlZW4gc2V0JykgOiBfcHJvZEludmFyaWFudCgnMTQ0JykgOiB2b2lkIDA7XG4gICAgaXRlbS5pc01vdW50ZWQgPSB0cnVlO1xuICAgIHZhciBpc1Jvb3QgPSBpdGVtLnBhcmVudElEID09PSAwO1xuICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgIGFkZFJvb3QoaWQpO1xuICAgIH1cbiAgfSxcbiAgb25VcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgaWYgKCFpdGVtIHx8ICFpdGVtLmlzTW91bnRlZCkge1xuICAgICAgLy8gV2UgbWF5IGVuZCB1cCBoZXJlIGFzIGEgcmVzdWx0IG9mIHNldFN0YXRlKCkgaW4gY29tcG9uZW50V2lsbFVubW91bnQoKS5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgaWdub3JlIHRoZSBlbGVtZW50LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpdGVtLnVwZGF0ZUNvdW50Kys7XG4gIH0sXG4gIG9uVW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiBpdCBleGlzdHMuXG4gICAgICAvLyBgaXRlbWAgbWlnaHQgbm90IGV4aXN0IGlmIGl0IGlzIGluc2lkZSBhbiBlcnJvciBib3VuZGFyeSwgYW5kIGEgc2libGluZ1xuICAgICAgLy8gZXJyb3IgYm91bmRhcnkgY2hpbGQgdGhyZXcgd2hpbGUgbW91bnRpbmcuIFRoZW4gdGhpcyBpbnN0YW5jZSBuZXZlclxuICAgICAgLy8gZ290IGEgY2hhbmNlIHRvIG1vdW50LCBidXQgaXQgc3RpbGwgZ2V0cyBhbiB1bm1vdW50aW5nIGV2ZW50IGR1cmluZ1xuICAgICAgLy8gdGhlIGVycm9yIGJvdW5kYXJ5IGNsZWFudXAuXG4gICAgICBpdGVtLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgdmFyIGlzUm9vdCA9IGl0ZW0ucGFyZW50SUQgPT09IDA7XG4gICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgIHJlbW92ZVJvb3QoaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICB1bm1vdW50ZWRJRHMucHVzaChpZCk7XG4gIH0sXG4gIHB1cmdlVW5tb3VudGVkQ29tcG9uZW50czogZnVuY3Rpb24gKCkge1xuICAgIGlmIChSZWFjdENvbXBvbmVudFRyZWVIb29rLl9wcmV2ZW50UHVyZ2luZykge1xuICAgICAgLy8gU2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgdGVzdGluZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVubW91bnRlZElEcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkID0gdW5tb3VudGVkSURzW2ldO1xuICAgICAgcHVyZ2VEZWVwKGlkKTtcbiAgICB9XG4gICAgdW5tb3VudGVkSURzLmxlbmd0aCA9IDA7XG4gIH0sXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uaXNNb3VudGVkIDogZmFsc2U7XG4gIH0sXG4gIGdldEN1cnJlbnRTdGFja0FkZGVuZHVtOiBmdW5jdGlvbiAodG9wRWxlbWVudCkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgaWYgKHRvcEVsZW1lbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0RGlzcGxheU5hbWUodG9wRWxlbWVudCk7XG4gICAgICB2YXIgb3duZXIgPSB0b3BFbGVtZW50Ll9vd25lcjtcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCB0b3BFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRPd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgdmFyIGlkID0gY3VycmVudE93bmVyICYmIGN1cnJlbnRPd25lci5fZGVidWdJRDtcblxuICAgIGluZm8gKz0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChpZCk7XG4gICAgcmV0dXJuIGluZm87XG4gIH0sXG4gIGdldFN0YWNrQWRkZW5kdW1CeUlEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHdoaWxlIChpZCkge1xuICAgICAgaW5mbyArPSBkZXNjcmliZUlEKGlkKTtcbiAgICAgIGlkID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRQYXJlbnRJRChpZCk7XG4gICAgfVxuICAgIHJldHVybiBpbmZvO1xuICB9LFxuICBnZXRDaGlsZElEczogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uY2hpbGRJRHMgOiBbXTtcbiAgfSxcbiAgZ2V0RGlzcGxheU5hbWU6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RGlzcGxheU5hbWUoZWxlbWVudCk7XG4gIH0sXG4gIGdldEVsZW1lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmVsZW1lbnQgOiBudWxsO1xuICB9LFxuICBnZXRPd25lcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50Ll9vd25lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50Ll9vd25lci5fZGVidWdJRDtcbiAgfSxcbiAgZ2V0UGFyZW50SUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnBhcmVudElEIDogbnVsbDtcbiAgfSxcbiAgZ2V0U291cmNlOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHZhciBlbGVtZW50ID0gaXRlbSA/IGl0ZW0uZWxlbWVudCA6IG51bGw7XG4gICAgdmFyIHNvdXJjZSA9IGVsZW1lbnQgIT0gbnVsbCA/IGVsZW1lbnQuX3NvdXJjZSA6IG51bGw7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfSxcbiAgZ2V0VGV4dDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJycgKyBlbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGdldFVwZGF0ZUNvdW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS51cGRhdGVDb3VudCA6IDA7XG4gIH0sXG5cblxuICBnZXRSb290SURzOiBnZXRSb290SURzLFxuICBnZXRSZWdpc3RlcmVkSURzOiBnZXRJdGVtSURzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vay5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/b2JqZWN0fSBlbGVtZW50IFRoZSBSZWFjdCBlbGVtZW50IHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0gez9udW1iZXJ9IGRlYnVnSUQgVGhlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIHR5cGUtY2hlY2tlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tSZWFjdFR5cGVTcGVjKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCwgZGVidWdJRCkge1xuICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICB2YXIgZXJyb3I7XG4gICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgISh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzg0JywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiB2b2lkIDA7XG4gICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgfVxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpIDogdm9pZCAwO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGNvbXBvbmVudFN0YWNrSW5mbyA9ICcnO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XG4gICAgICAgICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWJ1Z0lEICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0luZm8gPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDdXJyZW50U3RhY2tBZGRlbmR1bShlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCAlcyB0eXBlOiAlcyVzJywgbG9jYXRpb24sIGVycm9yLm1lc3NhZ2UsIGNvbXBvbmVudFN0YWNrSW5mbykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tSZWFjdFR5cGVTcGVjO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL2NoZWNrUmVhY3RUeXBlU3BlYy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcHJvcFR5cGVzOiB7XG4gKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICpcbiAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAqXG4gKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAqICAgICB9LFxuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gKiAgIH0pO1xuICpcbiAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAqXG4gKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICpcbiAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgIHByb3BUeXBlczoge1xuICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICogICAgICAgICAgKTtcbiAqICAgICAgICB9XG4gKiAgICAgIH1cbiAqICAgIH0sXG4gKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAqICB9KTtcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG52YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG52YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXJcbn07XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbi8qKlxuICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciB3ZSBkb24ndCB1c2UgcmVhbFxuICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICovXG5mdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5zdGFjayA9ICcnO1xufVxuLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgaWYgKCFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0pIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgKyAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgKyAnYW5kIHdpbGwgbm90IHdvcmsgaW4gcHJvZHVjdGlvbiB3aXRoIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uICcgKyAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICsgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsIHByb3BGdWxsTmFtZSwgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XG4gICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zKG51bGwpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgfVxuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICghUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICB9XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICByZXR1cm4gJ2FycmF5JztcbiAgfVxuICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgIHJldHVybiAnb2JqZWN0JztcbiAgfVxuICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICByZXR1cm4gJ3N5bWJvbCc7XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4vLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbmZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICByZXR1cm4gQU5PTllNT1VTO1xuICB9XG4gIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gJzE1LjQuMCc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJykgOiBfcHJvZEludmFyaWFudCgnMTQzJykgOiB2b2lkIDA7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbmx5Q2hpbGQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvb25seUNoaWxkLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL1JlYWN0RE9NJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9pbmRleC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4vKiBnbG9iYWxzIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3REZWZhdWx0SW5qZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRJbmplY3Rpb24nKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cbnZhciBmaW5kRE9NTm9kZSA9IHJlcXVpcmUoJy4vZmluZERPTU5vZGUnKTtcbnZhciBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZSA9IHJlcXVpcmUoJy4vZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUnKTtcbnZhciByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IHJlcXVpcmUoJy4vcmVuZGVyU3VidHJlZUludG9Db250YWluZXInKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5SZWFjdERlZmF1bHRJbmplY3Rpb24uaW5qZWN0KCk7XG5cbnZhciBSZWFjdERPTSA9IHtcbiAgZmluZERPTU5vZGU6IGZpbmRET01Ob2RlLFxuICByZW5kZXI6IFJlYWN0TW91bnQucmVuZGVyLFxuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyxcbiAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyXG59O1xuXG4vLyBJbmplY3QgdGhlIHJ1bnRpbWUgaW50byBhIGRldnRvb2xzIGdsb2JhbCBob29rIHJlZ2FyZGxlc3Mgb2YgYnJvd3Nlci5cbi8vIEFsbG93cyBmb3IgZGVidWdnaW5nIHdoZW4gdGhlIGhvb2sgaXMgaW5qZWN0ZWQgb24gdGhlIHBhZ2UuXG5pZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCh7XG4gICAgQ29tcG9uZW50VHJlZToge1xuICAgICAgZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcbiAgICAgIGdldE5vZGVGcm9tSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIC8vIGluc3QgaXMgYW4gaW50ZXJuYWwgaW5zdGFuY2UgKGJ1dCBjb3VsZCBiZSBhIGNvbXBvc2l0ZSlcbiAgICAgICAgaWYgKGluc3QuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgICAgICAgaW5zdCA9IGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlKGluc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgICAgcmV0dXJuIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBNb3VudDogUmVhY3RNb3VudCxcbiAgICBSZWNvbmNpbGVyOiBSZWFjdFJlY29uY2lsZXJcbiAgfSk7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG4gIGlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcblxuICAgIC8vIEZpcnN0IGNoZWNrIGlmIGRldnRvb2xzIGlzIG5vdCBpbnN0YWxsZWRcbiAgICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIElmIHdlJ3JlIGluIENocm9tZSBvciBGaXJlZm94LCBwcm92aWRlIGEgZG93bmxvYWQgbGluayBpZiBub3QgaW5zdGFsbGVkLlxuICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgICAvLyBGaXJlZm94IGRvZXMgbm90IGhhdmUgdGhlIGlzc3VlIHdpdGggZGV2dG9vbHMgbG9hZGVkIG92ZXIgZmlsZTovL1xuICAgICAgICB2YXIgc2hvd0ZpbGVVcmxNZXNzYWdlID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoJ2h0dHAnKSA9PT0gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xuICAgICAgICBjb25zb2xlLmRlYnVnKCdEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJyArIChzaG93RmlsZVVybE1lc3NhZ2UgPyAnYW5kIHVzZSBhbiBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBhIGZpbGU6IFVSTCkgJyA6ICcnKSArICdmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRlc3RGdW5jID0gZnVuY3Rpb24gdGVzdEZuKCkge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoKHRlc3RGdW5jLm5hbWUgfHwgdGVzdEZ1bmMudG9TdHJpbmcoKSkuaW5kZXhPZigndGVzdEZuJykgIT09IC0xLCAnSXQgbG9va3MgbGlrZSB5b3VcXCdyZSB1c2luZyBhIG1pbmlmaWVkIGNvcHkgb2YgdGhlIGRldmVsb3BtZW50IGJ1aWxkICcgKyAnb2YgUmVhY3QuIFdoZW4gZGVwbG95aW5nIFJlYWN0IGFwcHMgdG8gcHJvZHVjdGlvbiwgbWFrZSBzdXJlIHRvIHVzZSAnICsgJ3RoZSBwcm9kdWN0aW9uIGJ1aWxkIHdoaWNoIHNraXBzIGRldmVsb3BtZW50IHdhcm5pbmdzIGFuZCBpcyBmYXN0ZXIuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtbWluaWZpY2F0aW9uIGZvciBtb3JlIGRldGFpbHMuJykgOiB2b2lkIDA7XG5cbiAgICAvLyBJZiB3ZSdyZSBpbiBJRTgsIGNoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgaW4gY29tcGF0aWJpbGl0eSBtb2RlIGFuZCBwcm92aWRlXG4gICAgLy8gaW5mb3JtYXRpb24gb24gcHJldmVudGluZyBjb21wYXRpYmlsaXR5IG1vZGVcbiAgICB2YXIgaWVDb21wYXRpYmlsaXR5TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZSAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPCA4O1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWllQ29tcGF0aWJpbGl0eU1vZGUsICdJbnRlcm5ldCBFeHBsb3JlciBpcyBydW5uaW5nIGluIGNvbXBhdGliaWxpdHkgbW9kZTsgcGxlYXNlIGFkZCB0aGUgJyArICdmb2xsb3dpbmcgdGFnIHRvIHlvdXIgSFRNTCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmc6ICcgKyAnPG1ldGEgaHR0cC1lcXVpdj1cIlgtVUEtQ29tcGF0aWJsZVwiIGNvbnRlbnQ9XCJJRT1lZGdlXCIgLz4nKSA6IHZvaWQgMDtcblxuICAgIHZhciBleHBlY3RlZEZlYXR1cmVzID0gW1xuICAgIC8vIHNoaW1zXG4gICAgQXJyYXkuaXNBcnJheSwgQXJyYXkucHJvdG90eXBlLmV2ZXJ5LCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YsIEFycmF5LnByb3RvdHlwZS5tYXAsIERhdGUubm93LCBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCwgT2JqZWN0LmtleXMsIFN0cmluZy5wcm90b3R5cGUudHJpbV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkRmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZXhwZWN0ZWRGZWF0dXJlc1tpXSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ09uZSBvciBtb3JlIEVTNSBzaGltcyBleHBlY3RlZCBieSBSZWFjdCBhcmUgbm90IGF2YWlsYWJsZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctcG9seWZpbGxzJykgOiB2b2lkIDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG4gIHZhciBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vaycpO1xuICB2YXIgUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rID0gcmVxdWlyZSgnLi9SZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2snKTtcbiAgdmFyIFJlYWN0RE9NSW52YWxpZEFSSUFIb29rID0gcmVxdWlyZSgnLi9SZWFjdERPTUludmFsaWRBUklBSG9vaycpO1xuXG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5hZGRIb29rKFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayk7XG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5hZGRIb29rKFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayk7XG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5hZGRIb29rKFJlYWN0RE9NSW52YWxpZEFSSUFIb29rKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET00uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRGbGFncycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBBVFRSX05BTUUgPSBET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRTtcbnZhciBGbGFncyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3M7XG5cbnZhciBpbnRlcm5hbEluc3RhbmNlS2V5ID0gJ19fcmVhY3RJbnRlcm5hbEluc3RhbmNlJCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuLyoqXG4gKiBEcmlsbCBkb3duICh0aHJvdWdoIGNvbXBvc2l0ZXMgYW5kIGVtcHR5IGNvbXBvbmVudHMpIHVudGlsIHdlIGdldCBhIGhvc3Qgb3JcbiAqIGhvc3QgdGV4dCBjb21wb25lbnQuXG4gKlxuICogVGhpcyBpcyBwcmV0dHkgcG9seW1vcnBoaWMgYnV0IHVuYXZvaWRhYmxlIHdpdGggdGhlIGN1cnJlbnQgc3RydWN0dXJlIHdlIGhhdmVcbiAqIGZvciBgX3JlbmRlcmVkQ2hpbGRyZW5gLlxuICovXG5mdW5jdGlvbiBnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICB2YXIgcmVuZGVyZWQ7XG4gIHdoaWxlIChyZW5kZXJlZCA9IGNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICBjb21wb25lbnQgPSByZW5kZXJlZDtcbiAgfVxuICByZXR1cm4gY29tcG9uZW50O1xufVxuXG4vKipcbiAqIFBvcHVsYXRlIGBfaG9zdE5vZGVgIG9uIHRoZSByZW5kZXJlZCBob3N0L3RleHQgY29tcG9uZW50IHdpdGggdGhlIGdpdmVuXG4gKiBET00gbm9kZS4gVGhlIHBhc3NlZCBgaW5zdGAgY2FuIGJlIGEgY29tcG9zaXRlLlxuICovXG5mdW5jdGlvbiBwcmVjYWNoZU5vZGUoaW5zdCwgbm9kZSkge1xuICB2YXIgaG9zdEluc3QgPSBnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50KGluc3QpO1xuICBob3N0SW5zdC5faG9zdE5vZGUgPSBub2RlO1xuICBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldID0gaG9zdEluc3Q7XG59XG5cbmZ1bmN0aW9uIHVuY2FjaGVOb2RlKGluc3QpIHtcbiAgdmFyIG5vZGUgPSBpbnN0Ll9ob3N0Tm9kZTtcbiAgaWYgKG5vZGUpIHtcbiAgICBkZWxldGUgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgICBpbnN0Ll9ob3N0Tm9kZSA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBQb3B1bGF0ZSBgX2hvc3ROb2RlYCBvbiBlYWNoIGNoaWxkIG9mIGBpbnN0YCwgYXNzdW1pbmcgdGhhdCB0aGUgY2hpbGRyZW5cbiAqIG1hdGNoIHVwIHdpdGggdGhlIERPTSAoZWxlbWVudCkgY2hpbGRyZW4gb2YgYG5vZGVgLlxuICpcbiAqIFdlIGNhY2hlIGVudGlyZSBsZXZlbHMgYXQgb25jZSB0byBhdm9pZCBhbiBuXjIgcHJvYmxlbSB3aGVyZSB3ZSBhY2Nlc3MgdGhlXG4gKiBjaGlsZHJlbiBvZiBhIG5vZGUgc2VxdWVudGlhbGx5IGFuZCBoYXZlIHRvIHdhbGsgZnJvbSB0aGUgc3RhcnQgdG8gb3VyIHRhcmdldFxuICogbm9kZSBldmVyeSB0aW1lLlxuICpcbiAqIFNpbmNlIHdlIHVwZGF0ZSBgX3JlbmRlcmVkQ2hpbGRyZW5gIGFuZCB0aGUgYWN0dWFsIERPTSBhdCAoc2xpZ2h0bHkpXG4gKiBkaWZmZXJlbnQgdGltZXMsIHdlIGNvdWxkIHJhY2UgaGVyZSBhbmQgc2VlIGEgbmV3ZXIgYF9yZW5kZXJlZENoaWxkcmVuYCB0aGFuXG4gKiB0aGUgRE9NIG5vZGVzIHdlIHNlZS4gVG8gYXZvaWQgdGhpcywgUmVhY3RNdWx0aUNoaWxkIGNhbGxzXG4gKiBgcHJlcGFyZVRvTWFuYWdlQ2hpbGRyZW5gIGJlZm9yZSB3ZSBjaGFuZ2UgYF9yZW5kZXJlZENoaWxkcmVuYCwgYXQgd2hpY2hcbiAqIHRpbWUgdGhlIGNvbnRhaW5lcidzIGNoaWxkIG5vZGVzIGFyZSBhbHdheXMgY2FjaGVkICh1bnRpbCBpdCB1bm1vdW50cykuXG4gKi9cbmZ1bmN0aW9uIHByZWNhY2hlQ2hpbGROb2RlcyhpbnN0LCBub2RlKSB7XG4gIGlmIChpbnN0Ll9mbGFncyAmIEZsYWdzLmhhc0NhY2hlZENoaWxkTm9kZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNoaWxkcmVuID0gaW5zdC5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgdmFyIGNoaWxkTm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgb3V0ZXI6IGZvciAodmFyIG5hbWUgaW4gY2hpbGRyZW4pIHtcbiAgICBpZiAoIWNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGNoaWxkSW5zdCA9IGNoaWxkcmVuW25hbWVdO1xuICAgIHZhciBjaGlsZElEID0gZ2V0UmVuZGVyZWRIb3N0T3JUZXh0RnJvbUNvbXBvbmVudChjaGlsZEluc3QpLl9kb21JRDtcbiAgICBpZiAoY2hpbGRJRCA9PT0gMCkge1xuICAgICAgLy8gV2UncmUgY3VycmVudGx5IHVubW91bnRpbmcgdGhpcyBjaGlsZCBpbiBSZWFjdE11bHRpQ2hpbGQ7IHNraXAgaXQuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gV2UgYXNzdW1lIHRoZSBjaGlsZCBub2RlcyBhcmUgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIGNoaWxkIGluc3RhbmNlcy5cbiAgICBmb3IgKDsgY2hpbGROb2RlICE9PSBudWxsOyBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDEgJiYgY2hpbGROb2RlLmdldEF0dHJpYnV0ZShBVFRSX05BTUUpID09PSBTdHJpbmcoY2hpbGRJRCkgfHwgY2hpbGROb2RlLm5vZGVUeXBlID09PSA4ICYmIGNoaWxkTm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtdGV4dDogJyArIGNoaWxkSUQgKyAnICcgfHwgY2hpbGROb2RlLm5vZGVUeXBlID09PSA4ICYmIGNoaWxkTm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtZW1wdHk6ICcgKyBjaGlsZElEICsgJyAnKSB7XG4gICAgICAgIHByZWNhY2hlTm9kZShjaGlsZEluc3QsIGNoaWxkTm9kZSk7XG4gICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIERPTSBjaGlsZHJlbiB3aXRob3V0IGZpbmRpbmcgYW4gSUQgbWF0Y2guXG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIGVsZW1lbnQgd2l0aCBJRCAlcy4nLCBjaGlsZElEKSA6IF9wcm9kSW52YXJpYW50KCczMicsIGNoaWxkSUQpIDogdm9pZCAwO1xuICB9XG4gIGluc3QuX2ZsYWdzIHw9IEZsYWdzLmhhc0NhY2hlZENoaWxkTm9kZXM7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBjbG9zZXN0IFJlYWN0RE9NQ29tcG9uZW50IG9yXG4gKiBSZWFjdERPTVRleHRDb21wb25lbnQgaW5zdGFuY2UgYW5jZXN0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgaWYgKG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICByZXR1cm4gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhbiBhbmNlc3RvciB3aG9zZSBpbnN0YW5jZSB3ZSBoYXZlIGNhY2hlZC5cbiAgdmFyIHBhcmVudHMgPSBbXTtcbiAgd2hpbGUgKCFub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XG4gICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRvcCBvZiB0aGUgdHJlZS4gVGhpcyBub2RlIG11c3Qgbm90IGJlIHBhcnQgb2YgYSBSZWFjdCB0cmVlIChvciBpc1xuICAgICAgLy8gdW5tb3VudGVkLCBwb3RlbnRpYWxseSkuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY2xvc2VzdDtcbiAgdmFyIGluc3Q7XG4gIGZvciAoOyBub2RlICYmIChpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSk7IG5vZGUgPSBwYXJlbnRzLnBvcCgpKSB7XG4gICAgY2xvc2VzdCA9IGluc3Q7XG4gICAgaWYgKHBhcmVudHMubGVuZ3RoKSB7XG4gICAgICBwcmVjYWNoZUNoaWxkTm9kZXMoaW5zdCwgbm9kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsb3Nlc3Q7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIGluc3RhbmNlLCBvciBudWxsIGlmIHRoZSBub2RlIHdhcyBub3QgcmVuZGVyZWQgYnkgdGhpcyBSZWFjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKSB7XG4gIHZhciBpbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XG4gIGlmIChpbnN0ICE9IG51bGwgJiYgaW5zdC5faG9zdE5vZGUgPT09IG5vZGUpIHtcbiAgICByZXR1cm4gaW5zdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50LCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAqIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlKGluc3QpIHtcbiAgLy8gV2l0aG91dCB0aGlzIGZpcnN0IGludmFyaWFudCwgcGFzc2luZyBhIG5vbi1ET00tY29tcG9uZW50IHRyaWdnZXJzIHRoZSBuZXh0XG4gIC8vIGludmFyaWFudCBmb3IgYSBtaXNzaW5nIHBhcmVudCwgd2hpY2ggaXMgc3VwZXIgY29uZnVzaW5nLlxuICAhKGluc3QuX2hvc3ROb2RlICE9PSB1bmRlZmluZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzMnKSA6IHZvaWQgMDtcblxuICBpZiAoaW5zdC5faG9zdE5vZGUpIHtcbiAgICByZXR1cm4gaW5zdC5faG9zdE5vZGU7XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYW4gYW5jZXN0b3Igd2hvc2UgRE9NIG5vZGUgd2UgaGF2ZSBjYWNoZWQuXG4gIHZhciBwYXJlbnRzID0gW107XG4gIHdoaWxlICghaW5zdC5faG9zdE5vZGUpIHtcbiAgICBwYXJlbnRzLnB1c2goaW5zdCk7XG4gICAgIWluc3QuX2hvc3RQYXJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgRE9NIHRyZWUgcm9vdCBzaG91bGQgYWx3YXlzIGhhdmUgYSBub2RlIHJlZmVyZW5jZS4nKSA6IF9wcm9kSW52YXJpYW50KCczNCcpIDogdm9pZCAwO1xuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xuICB9XG5cbiAgLy8gTm93IHBhcmVudHMgY29udGFpbnMgZWFjaCBhbmNlc3RvciB0aGF0IGRvZXMgKm5vdCogaGF2ZSBhIGNhY2hlZCBuYXRpdmVcbiAgLy8gbm9kZSwgYW5kIGBpbnN0YCBpcyB0aGUgZGVlcGVzdCBhbmNlc3RvciB0aGF0IGRvZXMuXG4gIGZvciAoOyBwYXJlbnRzLmxlbmd0aDsgaW5zdCA9IHBhcmVudHMucG9wKCkpIHtcbiAgICBwcmVjYWNoZUNoaWxkTm9kZXMoaW5zdCwgaW5zdC5faG9zdE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIGluc3QuX2hvc3ROb2RlO1xufVxuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0ge1xuICBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIGdldEluc3RhbmNlRnJvbU5vZGU6IGdldEluc3RhbmNlRnJvbU5vZGUsXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGdldE5vZGVGcm9tSW5zdGFuY2UsXG4gIHByZWNhY2hlQ2hpbGROb2RlczogcHJlY2FjaGVDaGlsZE5vZGVzLFxuICBwcmVjYWNoZU5vZGU6IHByZWNhY2hlTm9kZSxcbiAgdW5jYWNoZU5vZGU6IHVuY2FjaGVOb2RlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01Db21wb25lbnRUcmVlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogV0FSTklORzogRE8gTk9UIG1hbnVhbGx5IHJlcXVpcmUgdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGBpbnZhcmlhbnQoLi4uKWAgdXNlZCBieSB0aGUgZXJyb3IgY29kZSBzeXN0ZW1cbiAqIGFuZCB3aWxsIF9vbmx5XyBiZSByZXF1aXJlZCBieSB0aGUgY29ycmVzcG9uZGluZyBiYWJlbCBwYXNzLlxuICogSXQgYWx3YXlzIHRocm93cy5cbiAqL1xuXG5mdW5jdGlvbiByZWFjdFByb2RJbnZhcmlhbnQoY29kZSkge1xuICB2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcblxuICB2YXIgbWVzc2FnZSA9ICdNaW5pZmllZCBSZWFjdCBlcnJvciAjJyArIGNvZGUgKyAnOyB2aXNpdCAnICsgJ2h0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PScgKyBjb2RlO1xuXG4gIGZvciAodmFyIGFyZ0lkeCA9IDA7IGFyZ0lkeCA8IGFyZ0NvdW50OyBhcmdJZHgrKykge1xuICAgIG1lc3NhZ2UgKz0gJyZhcmdzW109JyArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbYXJnSWR4ICsgMV0pO1xuICB9XG5cbiAgbWVzc2FnZSArPSAnIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCcgKyAnIGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLic7XG5cbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgcmVhY3RQcm9kSW52YXJpYW50J3Mgb3duIGZyYW1lXG5cbiAgdGhyb3cgZXJyb3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhY3RQcm9kSW52YXJpYW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9yZWFjdFByb2RJbnZhcmlhbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDEsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDQsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDIwLFxuXG4gIC8qKlxuICAgKiBJbmplY3Qgc29tZSBzcGVjaWFsaXplZCBrbm93bGVkZ2UgYWJvdXQgdGhlIERPTS4gVGhpcyB0YWtlcyBhIGNvbmZpZyBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiB0aGF0IGdpdmVuIGFuIGF0dHJpYnV0ZSBuYW1lIHdpbGwgcmV0dXJuIHRydWVcbiAgICogaWYgaXQgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIERPTSB2ZXJiYXRpbS4gVXNlZnVsIGZvciBkYXRhLSogb3IgYXJpYS0qXG4gICAqIGF0dHJpYnV0ZXMgd2hlcmUgaXQncyBpbXBvc3NpYmxlIHRvIGVudW1lcmF0ZSBhbGwgb2YgdGhlIHBvc3NpYmxlXG4gICAqIGF0dHJpYnV0ZSBuYW1lcyxcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01Qcm9wZXJ0eU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NUHJvcGVydHlOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NTXV0YXRpb25NZXRob2RzID0gZG9tUHJvcGVydHlDb25maWcuRE9NTXV0YXRpb25NZXRob2RzIHx8IHt9O1xuXG4gICAgaWYgKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKSB7XG4gICAgICBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMucHVzaChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gUHJvcGVydGllcykge1xuICAgICAgISFET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyguLi4pOiBZb3VcXCdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSBcXCclc1xcJyB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkLiBZb3UgbWF5IGJlIGFjY2lkZW50YWxseSBpbmplY3RpbmcgdGhlIHNhbWUgRE9NIHByb3BlcnR5IGNvbmZpZyB0d2ljZSwgb3IgeW91IG1heSBiZSBpbmplY3RpbmcgdHdvIGNvbmZpZ3MgdGhhdCBoYXZlIGNvbmZsaWN0aW5nIHByb3BlcnR5IG5hbWVzLicsIHByb3BOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc0OCcsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgdmFyIGxvd2VyQ2FzZWQgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbG93ZXJDYXNlZCxcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlOiBudWxsLFxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BOYW1lLFxuICAgICAgICBtdXRhdGlvbk1ldGhvZDogbnVsbCxcblxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSlcbiAgICAgIH07XG4gICAgICAhKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICsgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgPD0gMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRE9NUHJvcGVydHk6IFZhbHVlIGNhbiBiZSBvbmUgb2YgYm9vbGVhbiwgb3ZlcmxvYWRlZCBib29sZWFuLCBvciBudW1lcmljIHZhbHVlLCBidXQgbm90IGEgY29tYmluYXRpb246ICVzJywgcHJvcE5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzUwJywgcHJvcE5hbWUpIDogdm9pZCAwO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkXSA9IHByb3BOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gRE9NQXR0cmlidXRlTmFtZXNbcHJvcE5hbWVdO1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbYXR0cmlidXRlTmFtZV0gPSBwcm9wTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NUHJvcGVydHlOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZSA9IERPTVByb3BlcnR5TmFtZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IHByb3BlcnR5SW5mbztcbiAgICB9XG4gIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gJzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkQnO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogRE9NUHJvcGVydHkgZXhwb3J0cyBsb29rdXAgb2JqZWN0cyB0aGF0IGNhbiBiZSB1c2VkIGxpa2UgZnVuY3Rpb25zOlxuICpcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydpZCddXG4gKiAgIHRydWVcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydmb29iYXInXVxuICogICB1bmRlZmluZWRcbiAqXG4gKiBBbHRob3VnaCB0aGlzIG1heSBiZSBjb25mdXNpbmcsIGl0IHBlcmZvcm1zIGJldHRlciBpbiBnZW5lcmFsLlxuICpcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LWV4aXN0c1xuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktbWlzc2luZ1xuICovXG52YXIgRE9NUHJvcGVydHkgPSB7XG5cbiAgSURfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0aWQnLFxuICBST09UX0FUVFJJQlVURV9OQU1FOiAnZGF0YS1yZWFjdHJvb3QnLFxuXG4gIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVI6IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIsXG4gIEFUVFJJQlVURV9OQU1FX0NIQVI6IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDAnLFxuXG4gIC8qKlxuICAgKiBNYXAgZnJvbSBwcm9wZXJ0eSBcInN0YW5kYXJkIG5hbWVcIiB0byBhbiBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGhvdyB0byBzZXRcbiAgICogdGhlIHByb3BlcnR5IGluIHRoZSBET00uIEVhY2ggb2JqZWN0IGNvbnRhaW5zOlxuICAgKlxuICAgKiBhdHRyaWJ1dGVOYW1lOlxuICAgKiAgIFVzZWQgd2hlbiByZW5kZXJpbmcgbWFya3VwIG9yIHdpdGggYCpBdHRyaWJ1dGUoKWAuXG4gICAqIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICAgKiBwcm9wZXJ0eU5hbWU6XG4gICAqICAgVXNlZCBvbiBET00gbm9kZSBpbnN0YW5jZXMuIChUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBtdXRhdGUgZHVlIHRvXG4gICAqICAgZXh0ZXJuYWwgZmFjdG9ycy4pXG4gICAqIG11dGF0aW9uTWV0aG9kOlxuICAgKiAgIElmIG5vbi1udWxsLCB1c2VkIGluc3RlYWQgb2YgdGhlIHByb3BlcnR5IG9yIGBzZXRBdHRyaWJ1dGUoKWAgYWZ0ZXJcbiAgICogICBpbml0aWFsIHJlbmRlci5cbiAgICogbXVzdFVzZVByb3BlcnR5OlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICAgKiBoYXNCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc051bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljIGFuZCBzaG91bGQgYmVcbiAgICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZVxuICAgKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbiAgICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAgICogICBzdHJpY3RseSBlcXVhbCB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gICAqL1xuICBwcm9wZXJ0aWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbiwgdXNlZFxuICAgKiB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgcHJvcGVydGllcy4gQXZhaWxhYmxlIG9ubHkgaW4gX19ERVZfXy5cbiAgICpcbiAgICogYXV0b2ZvY3VzIGlzIHByZWRlZmluZWQsIGJlY2F1c2UgYWRkaW5nIGl0IHRvIHRoZSBwcm9wZXJ0eSB3aGl0ZWxpc3RcbiAgICogY2F1c2VzIHVuaW50ZW5kZWQgc2lkZSBlZmZlY3RzLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UG9zc2libGVTdGFuZGFyZE5hbWU6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB7IGF1dG9mb2N1czogJ2F1dG9Gb2N1cycgfSA6IG51bGwsXG5cbiAgLyoqXG4gICAqIEFsbCBvZiB0aGUgaXNDdXN0b21BdHRyaWJ1dGUoKSBmdW5jdGlvbnMgdGhhdCBoYXZlIGJlZW4gaW5qZWN0ZWQuXG4gICAqL1xuICBfaXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSBjdXN0b20gYXR0cmlidXRlLlxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlzQ3VzdG9tQXR0cmlidXRlRm4gPSBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnNbaV07XG4gICAgICBpZiAoaXNDdXN0b21BdHRyaWJ1dGVGbihhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIGluamVjdGlvbjogRE9NUHJvcGVydHlJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NUHJvcGVydHk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL0RPTVByb3BlcnR5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NQ29tcG9uZW50RmxhZ3MgPSB7XG4gIGhhc0NhY2hlZENoaWxkTm9kZXM6IDEgPDwgMFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbXBvbmVudEZsYWdzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbXBvbmVudEZsYWdzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEFSSUFET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vQVJJQURPTVByb3BlcnR5Q29uZmlnJyk7XG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vQmVmb3JlSW5wdXRFdmVudFBsdWdpbicpO1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9DaGFuZ2VFdmVudFBsdWdpbicpO1xudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gcmVxdWlyZSgnLi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlcicpO1xudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vRW50ZXJMZWF2ZUV2ZW50UGx1Z2luJyk7XG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZSgnLi9IVE1MRE9NUHJvcGVydHlDb25maWcnKTtcbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnQnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NRW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NRW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdERPTVRyZWVUcmF2ZXJzYWwgPSByZXF1aXJlKCcuL1JlYWN0RE9NVHJlZVRyYXZlcnNhbCcpO1xudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneScpO1xudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4vUmVhY3RFdmVudExpc3RlbmVyJyk7XG52YXIgUmVhY3RJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbicpO1xudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZSgnLi9TVkdET01Qcm9wZXJ0eUNvbmZpZycpO1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9TZWxlY3RFdmVudFBsdWdpbicpO1xudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9TaW1wbGVFdmVudFBsdWdpbicpO1xuXG52YXIgYWxyZWFkeUluamVjdGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGluamVjdCgpIHtcbiAgaWYgKGFscmVhZHlJbmplY3RlZCkge1xuICAgIC8vIFRPRE86IFRoaXMgaXMgY3VycmVudGx5IHRydWUgYmVjYXVzZSB0aGVzZSBpbmplY3Rpb25zIGFyZSBzaGFyZWQgYmV0d2VlblxuICAgIC8vIHRoZSBjbGllbnQgYW5kIHRoZSBzZXJ2ZXIgcGFja2FnZS4gVGhleSBzaG91bGQgYmUgYnVpbHQgaW5kZXBlbmRlbnRseVxuICAgIC8vIGFuZCBub3Qgc2hhcmUgYW55IGluamVjdGlvbiBzdGF0ZS4gVGhlbiB0aGlzIHByb2JsZW0gd2lsbCBiZSBzb2x2ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGFscmVhZHlJbmplY3RlZCA9IHRydWU7XG5cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRFbWl0dGVyLmluamVjdFJlYWN0RXZlbnRMaXN0ZW5lcihSZWFjdEV2ZW50TGlzdGVuZXIpO1xuXG4gIC8qKlxuICAgKiBJbmplY3QgbW9kdWxlcyBmb3IgcmVzb2x2aW5nIERPTSBoaWVyYXJjaHkgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAgICovXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpblV0aWxzLmluamVjdENvbXBvbmVudFRyZWUoUmVhY3RET01Db21wb25lbnRUcmVlKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5VdGlscy5pbmplY3RUcmVlVHJhdmVyc2FsKFJlYWN0RE9NVHJlZVRyYXZlcnNhbCk7XG5cbiAgLyoqXG4gICAqIFNvbWUgaW1wb3J0YW50IGV2ZW50IHBsdWdpbnMgaW5jbHVkZWQgYnkgZGVmYXVsdCAod2l0aG91dCBoYXZpbmcgdG8gcmVxdWlyZVxuICAgKiB0aGVtKS5cbiAgICovXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7XG4gICAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICAgIEVudGVyTGVhdmVFdmVudFBsdWdpbjogRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLFxuICAgIENoYW5nZUV2ZW50UGx1Z2luOiBDaGFuZ2VFdmVudFBsdWdpbixcbiAgICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gICAgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICB9KTtcblxuICBSZWFjdEluamVjdGlvbi5Ib3N0Q29tcG9uZW50LmluamVjdEdlbmVyaWNDb21wb25lbnRDbGFzcyhSZWFjdERPTUNvbXBvbmVudCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uSG9zdENvbXBvbmVudC5pbmplY3RUZXh0Q29tcG9uZW50Q2xhc3MoUmVhY3RET01UZXh0Q29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhBUklBRE9NUHJvcGVydHlDb25maWcpO1xuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhIVE1MRE9NUHJvcGVydHlDb25maWcpO1xuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhTVkdET01Qcm9wZXJ0eUNvbmZpZyk7XG5cbiAgUmVhY3RJbmplY3Rpb24uRW1wdHlDb21wb25lbnQuaW5qZWN0RW1wdHlDb21wb25lbnRGYWN0b3J5KGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICAgIHJldHVybiBuZXcgUmVhY3RET01FbXB0eUNvbXBvbmVudChpbnN0YW50aWF0ZSk7XG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcblxuICBSZWFjdEluamVjdGlvbi5Db21wb25lbnQuaW5qZWN0RW52aXJvbm1lbnQoUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5qZWN0OiBpbmplY3Rcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RGVmYXVsdEluamVjdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBUklBRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHtcbiAgICAvLyBHbG9iYWwgU3RhdGVzIGFuZCBQcm9wZXJ0aWVzXG4gICAgJ2FyaWEtY3VycmVudCc6IDAsIC8vIHN0YXRlXG4gICAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICAgJ2FyaWEtZGlzYWJsZWQnOiAwLCAvLyBzdGF0ZVxuICAgICdhcmlhLWhpZGRlbic6IDAsIC8vIHN0YXRlXG4gICAgJ2FyaWEtaW52YWxpZCc6IDAsIC8vIHN0YXRlXG4gICAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgICAnYXJpYS1sYWJlbCc6IDAsXG4gICAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAgICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAgICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgICAnYXJpYS1sZXZlbCc6IDAsXG4gICAgJ2FyaWEtbW9kYWwnOiAwLFxuICAgICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAgICdhcmlhLXByZXNzZWQnOiAwLFxuICAgICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAgICdhcmlhLXNvcnQnOiAwLFxuICAgICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAgICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gICAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAgICdhcmlhLWF0b21pYyc6IDAsXG4gICAgJ2FyaWEtYnVzeSc6IDAsXG4gICAgJ2FyaWEtbGl2ZSc6IDAsXG4gICAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAgIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAgICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAgICdhcmlhLWdyYWJiZWQnOiAwLFxuICAgIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAgICdhcmlhLWNvbGluZGV4JzogMCxcbiAgICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgICAnYXJpYS1jb250cm9scyc6IDAsXG4gICAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAgICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgICAnYXJpYS1vd25zJzogMCxcbiAgICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAgICdhcmlhLXJvd2luZGV4JzogMCxcbiAgICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgICAnYXJpYS1zZXRzaXplJzogMFxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge30sXG4gIERPTVByb3BlcnR5TmFtZXM6IHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFSSUFET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvQVJJQURPTVByb3BlcnR5Q29uZmlnLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50IEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUgPSByZXF1aXJlKCcuL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZScpO1xudmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQnKTtcbnZhciBTeW50aGV0aWNJbnB1dEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNJbnB1dEV2ZW50Jyk7XG5cbnZhciBFTkRfS0VZQ09ERVMgPSBbOSwgMTMsIDI3LCAzMl07IC8vIFRhYiwgUmV0dXJuLCBFc2MsIFNwYWNlXG52YXIgU1RBUlRfS0VZQ09ERSA9IDIyOTtcblxudmFyIGNhblVzZUNvbXBvc2l0aW9uRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ0NvbXBvc2l0aW9uRXZlbnQnIGluIHdpbmRvdztcblxudmFyIGRvY3VtZW50TW9kZSA9IG51bGw7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB7XG4gIGRvY3VtZW50TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcbn1cblxuLy8gV2Via2l0IG9mZmVycyBhIHZlcnkgdXNlZnVsIGB0ZXh0SW5wdXRgIGV2ZW50IHRoYXQgY2FuIGJlIHVzZWQgdG9cbi8vIGRpcmVjdGx5IHJlcHJlc2VudCBgYmVmb3JlSW5wdXRgLiBUaGUgSUUgYHRleHRpbnB1dGAgZXZlbnQgaXMgbm90IGFzXG4vLyB1c2VmdWwsIHNvIHdlIGRvbid0IHVzZSBpdC5cbnZhciBjYW5Vc2VUZXh0SW5wdXRFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSAmJiAhaXNQcmVzdG8oKTtcblxuLy8gSW4gSUU5Kywgd2UgaGF2ZSBhY2Nlc3MgdG8gY29tcG9zaXRpb24gZXZlbnRzLCBidXQgdGhlIGRhdGEgc3VwcGxpZWRcbi8vIGJ5IHRoZSBuYXRpdmUgY29tcG9zaXRpb25lbmQgZXZlbnQgbWF5IGJlIGluY29ycmVjdC4gSmFwYW5lc2UgaWRlb2dyYXBoaWNcbi8vIHNwYWNlcywgZm9yIGluc3RhbmNlIChcXHUzMDAwKSBhcmUgbm90IHJlY29yZGVkIGNvcnJlY3RseS5cbnZhciB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgfHwgZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50TW9kZSA+IDggJiYgZG9jdW1lbnRNb2RlIDw9IDExKTtcblxuLyoqXG4gKiBPcGVyYSA8PSAxMiBpbmNsdWRlcyBUZXh0RXZlbnQgaW4gd2luZG93LCBidXQgZG9lcyBub3QgZmlyZVxuICogdGV4dCBpbnB1dCBldmVudHMuIFJlbHkgb24ga2V5cHJlc3MgaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gaXNQcmVzdG8oKSB7XG4gIHZhciBvcGVyYSA9IHdpbmRvdy5vcGVyYTtcbiAgcmV0dXJuIHR5cGVvZiBvcGVyYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wZXJhLnZlcnNpb24gPT09ICdmdW5jdGlvbicgJiYgcGFyc2VJbnQob3BlcmEudmVyc2lvbigpLCAxMCkgPD0gMTI7XG59XG5cbnZhciBTUEFDRUJBUl9DT0RFID0gMzI7XG52YXIgU1BBQ0VCQVJfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7XG5cbi8vIEV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcy5cbnZhciBldmVudFR5cGVzID0ge1xuICBiZWZvcmVJbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25CZWZvcmVJbnB1dCcsXG4gICAgICBjYXB0dXJlZDogJ29uQmVmb3JlSW5wdXRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcENvbXBvc2l0aW9uRW5kJywgJ3RvcEtleVByZXNzJywgJ3RvcFRleHRJbnB1dCcsICd0b3BQYXN0ZSddXG4gIH0sXG4gIGNvbXBvc2l0aW9uRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uRW5kJyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvbkVuZENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvbkVuZCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH0sXG4gIGNvbXBvc2l0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25TdGFydCcsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25TdGFydENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvblN0YXJ0JywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfSxcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25VcGRhdGUnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uVXBkYXRlJywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfVxufTtcblxuLy8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxudmFyIGhhc1NwYWNlS2V5cHJlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhIG5hdGl2ZSBrZXlwcmVzcyBldmVudCBpcyBhc3N1bWVkIHRvIGJlIGEgY29tbWFuZC5cbiAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBGaXJlZm94IGZpcmVzIGBrZXlwcmVzc2AgZXZlbnRzIGZvciBrZXkgY29tbWFuZHNcbiAqIChjdXQsIGNvcHksIHNlbGVjdC1hbGwsIGV0Yy4pIGV2ZW4gdGhvdWdoIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJlxuICAvLyBjdHJsS2V5ICYmIGFsdEtleSBpcyBlcXVpdmFsZW50IHRvIEFsdEdyLCBhbmQgaXMgbm90IGEgY29tbWFuZC5cbiAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSk7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIG5hdGl2ZSB0b3AgbGV2ZWwgZXZlbnRzIGludG8gZXZlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvblN0YXJ0JzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25VcGRhdGUnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25VcGRhdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleURvd24nICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREU7XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgbW9kZSB0aGluayB0aGF0IHRoaXMgZXZlbnQgaXMgdGhlIGVuZCBvZiBjb21wb3NpdGlvbj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgLy8gQ29tbWFuZCBrZXlzIGluc2VydCBvciBjbGVhciBJTUUgaW5wdXQuXG4gICAgICByZXR1cm4gRU5EX0tFWUNPREVTLmluZGV4T2YobmF0aXZlRXZlbnQua2V5Q29kZSkgIT09IC0xO1xuICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG4gICAgICByZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERTtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgIC8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGRldGFpbCA9IG5hdGl2ZUV2ZW50LmRldGFpbDtcbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT09ICdvYmplY3QnICYmICdkYXRhJyBpbiBkZXRhaWwpIHtcbiAgICByZXR1cm4gZGV0YWlsLmRhdGE7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBmYWxsYmFjayBvYmplY3QsIGlmIGFueS5cbnZhciBjdXJyZW50Q29tcG9zaXRpb24gPSBudWxsO1xuXG4vKipcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50VHlwZTtcbiAgdmFyIGZhbGxiYWNrRGF0YTtcblxuICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudCkge1xuICAgIGV2ZW50VHlwZSA9IGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSk7XG4gIH0gZWxzZSBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICB9XG5cbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbiAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmdldFBvb2xlZChuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQpIHtcbiAgICAgIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gY3VycmVudENvbXBvc2l0aW9uLmdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmdldFBvb2xlZChldmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSAndG9wVGV4dElucHV0JzpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIGZhbGxiYWNrIHN0cmluZyBmb3IgdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICAvLyBJZiBjb21wb3NpdGlvbiBldmVudCBpcyBhdmFpbGFibGUsIHdlIGV4dHJhY3QgYSBzdHJpbmcgb25seSBhdFxuICAvLyBjb21wb3NpdGlvbmV2ZW50LCBvdGhlcndpc2UgZXh0cmFjdCBpdCBhdCBmYWxsYmFjayBldmVudHMuXG4gIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ29tcG9zaXRpb25FbmQnIHx8ICFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ICYmIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gY3VycmVudENvbXBvc2l0aW9uLmdldERhdGEoKTtcbiAgICAgIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5yZWxlYXNlKGN1cnJlbnRDb21wb3NpdGlvbik7XG4gICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBudWxsO1xuICAgICAgcmV0dXJuIGNoYXJzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wUGFzdGUnOlxuICAgICAgLy8gSWYgYSBwYXN0ZSBldmVudCBvY2N1cnMgYWZ0ZXIgYSBrZXlwcmVzcywgdGhyb3cgb3V0IHRoZSBpbnB1dFxuICAgICAgLy8gY2hhcnMuIFBhc3RlIGV2ZW50cyBzaG91bGQgbm90IGxlYWQgdG8gQmVmb3JlSW5wdXQgZXZlbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBBcyBvZiB2MjcsIEZpcmVmb3ggbWF5IGZpcmUga2V5cHJlc3MgZXZlbnRzIGV2ZW4gd2hlbiBubyBjaGFyYWN0ZXJcbiAgICAgICAqIHdpbGwgYmUgaW5zZXJ0ZWQuIEEgZmV3IHBvc3NpYmlsaXRpZXM6XG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIGAwYC4gQXJyb3cga2V5cywgRXNjIGtleSwgZXRjLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IG5vIGNoYXIgaXMgYXZhaWxhYmxlLlxuICAgICAgICogICBFeDogJ0FsdEdyICsgZGAgaW4gUG9saXNoLiBUaGVyZSBpcyBubyBtb2RpZmllZCBjaGFyYWN0ZXIgZm9yXG4gICAgICAgKiAgIHRoaXMga2V5IGNvbWJpbmF0aW9uIGFuZCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICAgICAqICAgZG9jdW1lbnQsIGJ1dCBGRiBmaXJlcyB0aGUga2V5cHJlc3MgZm9yIGNoYXIgY29kZSBgMTAwYCBhbnl3YXkuXG4gICAgICAgKiAgIE5vIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBhIGNvbW1hbmQgY29tYmluYXRpb24gaXNcbiAgICAgICAqICAgYmVpbmcgdXNlZC4gRXg6IGBDbWQrQ2AuIE5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgYW5kIG5vXG4gICAgICAgKiAgIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqL1xuICAgICAgaWYgKG5hdGl2ZUV2ZW50LndoaWNoICYmICFpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID8gbnVsbCA6IG5hdGl2ZUV2ZW50LmRhdGE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBhIFN5bnRoZXRpY0lucHV0RXZlbnQgZm9yIGBiZWZvcmVJbnB1dGAsIGJhc2VkIG9uIGVpdGhlciBuYXRpdmVcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxuICpcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGNoYXJzO1xuXG4gIGlmIChjYW5Vc2VUZXh0SW5wdXRFdmVudCkge1xuICAgIGNoYXJzID0gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjaGFycyA9IGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfVxuXG4gIC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcbiAgLy8gYmUgZmlyZWQuXG4gIGlmICghY2hhcnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0lucHV0RXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuYmVmb3JlSW5wdXQsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgZXZlbnQuZGF0YSA9IGNoYXJzO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGBvbkJlZm9yZUlucHV0YCBldmVudCB0byBtYXRjaFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDUvI2V2ZW50cy1pbnB1dGV2ZW50cy5cbiAqXG4gKiBUaGlzIGV2ZW50IHBsdWdpbiBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50XG4gKiBhdmFpbGFibGUgaW4gQ2hyb21lLCBTYWZhcmksIE9wZXJhLCBhbmQgSUUuIFRoaXMgZXZlbnQgZmlyZXMgYWZ0ZXJcbiAqIGBvbktleVByZXNzYCBhbmQgYG9uQ29tcG9zaXRpb25FbmRgLCBidXQgYmVmb3JlIGBvbklucHV0YC5cbiAqXG4gKiBgYmVmb3JlSW5wdXRgIGlzIHNwZWMnZCBidXQgbm90IGltcGxlbWVudGVkIGluIGFueSBicm93c2VycywgYW5kXG4gKiB0aGUgYGlucHV0YCBldmVudCBkb2VzIG5vdCBwcm92aWRlIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBoYXNcbiAqIGFjdHVhbGx5IGJlZW4gYWRkZWQsIGNvbnRyYXJ5IHRvIHRoZSBzcGVjLiBUaHVzLCBgdGV4dElucHV0YCBpcyB0aGUgYmVzdFxuICogYXZhaWxhYmxlIGV2ZW50IHRvIGlkZW50aWZ5IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGluc2VydGVkXG4gKiBpbnRvIHRoZSB0YXJnZXQgbm9kZS5cbiAqXG4gKiBUaGlzIHBsdWdpbiBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBlbWl0dGluZyBgY29tcG9zaXRpb25gIGV2ZW50cywgdGh1c1xuICogYWxsb3dpbmcgdXMgdG8gc2hhcmUgY29tcG9zaXRpb24gZmFsbGJhY2sgY29kZSBmb3IgYm90aCBgYmVmb3JlSW5wdXRgIGFuZFxuICogYGNvbXBvc2l0aW9uYCBldmVudCB0eXBlcy5cbiAqL1xudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICByZXR1cm4gW2V4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSwgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGdldExpc3RlbmVyID0gRXZlbnRQbHVnaW5IdWIuZ2V0TGlzdGVuZXI7XG5cbi8qKlxuICogU29tZSBldmVudCB0eXBlcyBoYXZlIGEgbm90aW9uIG9mIGRpZmZlcmVudCByZWdpc3RyYXRpb24gbmFtZXMgZm9yIGRpZmZlcmVudFxuICogXCJwaGFzZXNcIiBvZiBwcm9wYWdhdGlvbi4gVGhpcyBmaW5kcyBsaXN0ZW5lcnMgYnkgYSBnaXZlbiBwaGFzZS5cbiAqL1xuZnVuY3Rpb24gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwcm9wYWdhdGlvblBoYXNlKSB7XG4gIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcHJvcGFnYXRpb25QaGFzZV07XG4gIHJldHVybiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbn1cblxuLyoqXG4gKiBUYWdzIGEgYFN5bnRoZXRpY0V2ZW50YCB3aXRoIGRpc3BhdGNoZWQgbGlzdGVuZXJzLiBDcmVhdGluZyB0aGlzIGZ1bmN0aW9uXG4gKiBoZXJlLCBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gYmluZCBvciBjcmVhdGUgZnVuY3Rpb25zIGZvciBlYWNoIGV2ZW50LlxuICogTXV0YXRpbmcgdGhlIGV2ZW50J3MgbWVtYmVycyBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gY3JlYXRlIGEgd3JhcHBpbmdcbiAqIFwiZGlzcGF0Y2hcIiBvYmplY3QgdGhhdCBwYWlycyB0aGUgZXZlbnQgd2l0aCB0aGUgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMoaW5zdCwgcGhhc2UsIGV2ZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaW5zdCwgJ0Rpc3BhdGNoaW5nIGluc3QgbXVzdCBub3QgYmUgbnVsbCcpIDogdm9pZCAwO1xuICB9XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxuICogdGVzdHMpLiBMYXppbHkgYWxsb2NhdGUgdGhlIGFycmF5IHRvIGNvbnNlcnZlIG1lbW9yeS4gIFdlIG11c3QgbG9vcCB0aHJvdWdoXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW5ub3QgcGVyZm9ybSBhXG4gKiBzaW5nbGUgdHJhdmVyc2FsIGZvciB0aGUgZW50aXJlIGNvbGxlY3Rpb24gb2YgZXZlbnRzIGJlY2F1c2UgZWFjaCBldmVudCBtYXlcbiAqIGhhdmUgYSBkaWZmZXJlbnQgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIEV2ZW50UGx1Z2luVXRpbHMudHJhdmVyc2VUd29QaGFzZShldmVudC5fdGFyZ2V0SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogU2FtZSBhcyBgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZWAsIGJ1dCBza2lwcyBvdmVyIHRoZSB0YXJnZXRJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgdmFyIHRhcmdldEluc3QgPSBldmVudC5fdGFyZ2V0SW5zdDtcbiAgICB2YXIgcGFyZW50SW5zdCA9IHRhcmdldEluc3QgPyBFdmVudFBsdWdpblV0aWxzLmdldFBhcmVudEluc3RhbmNlKHRhcmdldEluc3QpIDogbnVsbDtcbiAgICBFdmVudFBsdWdpblV0aWxzLnRyYXZlcnNlVHdvUGhhc2UocGFyZW50SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaW5zdCwgaWdub3JlZERpcmVjdGlvbiwgZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgdmFyIGxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgZGlzcGF0Y2hlcyBvbiBhbiBgU3ludGhldGljRXZlbnRgLCBidXQgb25seSBmb3IgdGhlXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhldmVudC5fdGFyZ2V0SW5zdCwgbnVsbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldChldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0bykge1xuICBFdmVudFBsdWdpblV0aWxzLnRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcHJvcGFnYXRpb24gcGF0dGVybnMsIGVhY2ggb2Ygd2hpY2ggd2lsbCBhY2NlcHQgYSBzbWFsbCBhbW91bnRcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxuICogbGlzdGVuZXIgZnVuY3Rpb25zL2lkcy4gVGhlIEFQSSBpcyBkZXNpZ25lZCB0aGlzIHdheSB0byBkaXNjb3VyYWdlIHRoZXNlXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbnQgYVxuICogc2luZ2xlIG9uZS5cbiAqXG4gKiBAY29uc3RydWN0b3IgRXZlbnRQcm9wYWdhdG9yc1xuICovXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHtcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyxcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQ6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0LFxuICBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlczogYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlczogYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UHJvcGFnYXRvcnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL0V2ZW50UHJvcGFnYXRvcnMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKCcuL2FjY3VtdWxhdGVJbnRvJyk7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZSgnLi9mb3JFYWNoQWNjdW11bGF0ZWQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBJbnRlcm5hbCBzdG9yZSBmb3IgZXZlbnQgbGlzdGVuZXJzXG4gKi9cbnZhciBsaXN0ZW5lckJhbmsgPSB7fTtcblxuLyoqXG4gKiBJbnRlcm5hbCBxdWV1ZSBvZiBldmVudHMgdGhhdCBoYXZlIGFjY3VtdWxhdGVkIHRoZWlyIGRpc3BhdGNoZXMgYW5kIGFyZVxuICogd2FpdGluZyB0byBoYXZlIHRoZWlyIGRpc3BhdGNoZXMgZXhlY3V0ZWQuXG4gKi9cbnZhciBldmVudFF1ZXVlID0gbnVsbDtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCByZWxlYXNlcyBpdCBiYWNrIGludG8gdGhlIHBvb2wsIHVubGVzcyBwZXJzaXN0ZW50LlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnQgU3ludGhldGljIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UgPSBmdW5jdGlvbiAoZXZlbnQsIHNpbXVsYXRlZCkge1xuICBpZiAoZXZlbnQpIHtcbiAgICBFdmVudFBsdWdpblV0aWxzLmV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKTtcblxuICAgIGlmICghZXZlbnQuaXNQZXJzaXN0ZW50KCkpIHtcbiAgICAgIGV2ZW50LmNvbnN0cnVjdG9yLnJlbGVhc2UoZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIHRydWUpO1xufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgZmFsc2UpO1xufTtcblxudmFyIGdldERpY3Rpb25hcnlLZXkgPSBmdW5jdGlvbiAoaW5zdCkge1xuICAvLyBQcmV2ZW50cyBWOCBwZXJmb3JtYW5jZSBpc3N1ZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzIzMlxuICByZXR1cm4gJy4nICsgaW5zdC5fcm9vdE5vZGVJRDtcbn07XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIEV2ZW50UGx1Z2luSHViID0ge1xuXG4gIC8qKlxuICAgKiBNZXRob2RzIGZvciBpbmplY3RpbmcgZGVwZW5kZW5jaWVzLlxuICAgKi9cbiAgaW5qZWN0aW9uOiB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxuXG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0b3JlcyBgbGlzdGVuZXJgIGF0IGBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1ba2V5XWAuIElzIGlkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGNhbGxiYWNrIHRvIHN0b3JlLlxuICAgKi9cbiAgcHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgICEodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCAlcyBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCB0eXBlICVzJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IF9wcm9kSW52YXJpYW50KCc5NCcsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiB2b2lkIDA7XG5cbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gfHwgKGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSA9IHt9KTtcbiAgICBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtrZXldID0gbGlzdGVuZXI7XG5cbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS5kaWRQdXRMaXN0ZW5lcikge1xuICAgICAgUGx1Z2luTW9kdWxlLmRpZFB1dExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICAgKi9cbiAgZ2V0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgIHJldHVybiBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSAmJiBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtrZXldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgbGlzdGVuZXIgZnJvbSB0aGUgcmVnaXN0cmF0aW9uIGJhbmsuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICovXG4gIGRlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcikge1xuICAgICAgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgLy8gVE9ETzogVGhpcyBzaG91bGQgbmV2ZXIgYmUgbnVsbCAtLSB3aGVuIGlzIGl0P1xuICAgIGlmIChiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgICBkZWxldGUgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVba2V5XTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYWxsIGxpc3RlbmVycyBmb3IgdGhlIERPTSBlbGVtZW50IHdpdGggdGhlIHN1cHBsaWVkIElELlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKi9cbiAgZGVsZXRlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gbGlzdGVuZXJCYW5rKSB7XG4gICAgICBpZiAoIWxpc3RlbmVyQmFuay5oYXNPd25Qcm9wZXJ0eShyZWdpc3RyYXRpb25OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1ba2V5XSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgICAgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtrZXldO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWxsb3dzIHJlZ2lzdGVyZWQgcGx1Z2lucyBhbiBvcHBvcnR1bml0eSB0byBleHRyYWN0IGV2ZW50cyBmcm9tIHRvcC1sZXZlbFxuICAgKiBuYXRpdmUgYnJvd3NlciBldmVudHMuXG4gICAqXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBldmVudHM7XG4gICAgdmFyIHBsdWdpbnMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgICB2YXIgcG9zc2libGVQbHVnaW4gPSBwbHVnaW5zW2ldO1xuICAgICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgaWYgKGV4dHJhY3RlZEV2ZW50cykge1xuICAgICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAgICogYHByb2Nlc3NFdmVudFF1ZXVlYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRXZlbnRzOiBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzRXZlbnRRdWV1ZTogZnVuY3Rpb24gKHNpbXVsYXRlZCkge1xuICAgIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgICAvLyBldmVudHMgZ2V0IGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcuXG4gICAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcbiAgICBldmVudFF1ZXVlID0gbnVsbDtcbiAgICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwpO1xuICAgIH1cbiAgICAhIWV2ZW50UXVldWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc0V2ZW50UXVldWUoKTogQWRkaXRpb25hbCBldmVudHMgd2VyZSBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nIGFuIGV2ZW50IHF1ZXVlLiBTdXBwb3J0IGZvciB0aGlzIGhhcyBub3QgeWV0IGJlZW4gaW1wbGVtZW50ZWQuJykgOiBfcHJvZEludmFyaWFudCgnOTUnKSA6IHZvaWQgMDtcbiAgICAvLyBUaGlzIHdvdWxkIGJlIGEgZ29vZCB0aW1lIHRvIHJldGhyb3cgaWYgYW55IG9mIHRoZSBldmVudCBoYW5kbGVycyB0aHJldy5cbiAgICBSZWFjdEVycm9yVXRpbHMucmV0aHJvd0NhdWdodEVycm9yKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZXNlIGFyZSBuZWVkZWQgZm9yIHRlc3RzIG9ubHkuIERvIG5vdCB1c2UhXG4gICAqL1xuICBfX3B1cmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgbGlzdGVuZXJCYW5rID0ge307XG4gIH0sXG5cbiAgX19nZXRMaXN0ZW5lckJhbms6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbGlzdGVuZXJCYW5rO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5IdWI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luSHViLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxuICovXG52YXIgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXG4gKi9cbnZhciBuYW1lc1RvUGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIFJlY29tcHV0ZXMgdGhlIHBsdWdpbiBsaXN0IHVzaW5nIHRoZSBpbmplY3RlZCBwbHVnaW5zIGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XG4gIGlmICghZXZlbnRQbHVnaW5PcmRlcikge1xuICAgIC8vIFdhaXQgdW50aWwgYW4gYGV2ZW50UGx1Z2luT3JkZXJgIGlzIGluamVjdGVkLlxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIHZhciBwbHVnaW5JbmRleCA9IGV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcbiAgICAhKHBsdWdpbkluZGV4ID4gLTEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2lucyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgcGx1Z2luIG9yZGVyaW5nLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk2JywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgaWYgKEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2luc1twbHVnaW5JbmRleF0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAhcGx1Z2luTW9kdWxlLmV4dHJhY3RFdmVudHMgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnQgcGx1Z2lucyBtdXN0IGltcGxlbWVudCBhbiBgZXh0cmFjdEV2ZW50c2AgbWV0aG9kLCBidXQgYCVzYCBkb2VzIG5vdC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCc5NycsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2luc1twbHVnaW5JbmRleF0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgdmFyIHB1Ymxpc2hlZEV2ZW50cyA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcbiAgICAgICFwdWJsaXNoRXZlbnRGb3JQbHVnaW4ocHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBGYWlsZWQgdG8gcHVibGlzaCBldmVudCBgJXNgIGZvciBwbHVnaW4gYCVzYC4nLCBldmVudE5hbWUsIHBsdWdpbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk4JywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgZGlzcGF0Y2hlZCBieSB0aGUgc3VwcGxpZWQgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBEaXNwYXRjaCBjb25maWd1cmF0aW9uIGZvciB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaEV2ZW50Rm9yUGx1Z2luKGRpc3BhdGNoQ29uZmlnLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIUV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIGV2ZW50IG5hbWUsIGAlc2AuJywgZXZlbnROYW1lKSA6IF9wcm9kSW52YXJpYW50KCc5OScsIGV2ZW50TmFtZSkgOiB2b2lkIDA7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV0gPSBkaXNwYXRjaENvbmZpZztcblxuICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcbiAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgZm9yICh2YXIgcGhhc2VOYW1lIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2VOYW1lKSkge1xuICAgICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZSA9IHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlTmFtZV07XG4gICAgICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGEgcmVnaXN0cmF0aW9uIG5hbWUgdGhhdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGRpc3BhdGNoZWQgZXZlbnRzIGFuZFxuICogY2FuIGJlIHVzZWQgd2l0aCBgRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXJgIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgcmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiBfcHJvZEludmFyaWFudCgnMTAwJywgcmVnaXN0cmF0aW9uTmFtZSkgOiB2b2lkIDA7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzW2V2ZW50TmFtZV0uZGVwZW5kZW5jaWVzO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcmVnaXN0cmF0aW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gPSByZWdpc3RyYXRpb25OYW1lO1xuXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvbkRvdWJsZUNsaWNrJykge1xuICAgICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLm9uZGJsY2xpY2sgPSByZWdpc3RyYXRpb25OYW1lO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHtcblxuICAvKipcbiAgICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gICAqL1xuICBwbHVnaW5zOiBbXSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gICAqL1xuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxuICAgKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gICAqIG9ubHkgaW4gX19ERVZfXy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB7fSA6IG51bGwsXG4gIC8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiBfX0RFVl9fXG5cbiAgLyoqXG4gICAqIEluamVjdHMgYW4gb3JkZXJpbmcgb2YgcGx1Z2lucyAoYnkgcGx1Z2luIG5hbWUpLiBUaGlzIGFsbG93cyB0aGUgb3JkZXJpbmdcbiAgICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gICAqIGFsd2F5cyBkZXRlcm1pbmlzdGljIHJlZ2FyZGxlc3Mgb2YgcGFja2FnaW5nLCBvbi10aGUtZmx5IGluamVjdGlvbiwgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogZnVuY3Rpb24gKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcikge1xuICAgICEhZXZlbnRQbHVnaW5PcmRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbiBvcmRlcmluZyBtb3JlIHRoYW4gb25jZS4gWW91IGFyZSBsaWtlbHkgdHJ5aW5nIHRvIGxvYWQgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0LicpIDogX3Byb2RJbnZhcmlhbnQoJzEwMScpIDogdm9pZCAwO1xuICAgIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgICBldmVudFBsdWdpbk9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKTtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbmplY3RzIHBsdWdpbnMgdG8gYmUgdXNlZCBieSBgRXZlbnRQbHVnaW5IdWJgLiBUaGUgcGx1Z2luIG5hbWVzIG11c3QgYmVcbiAgICogaW4gdGhlIG9yZGVyaW5nIGluamVjdGVkIGJ5IGBpbmplY3RFdmVudFBsdWdpbk9yZGVyYC5cbiAgICpcbiAgICogUGx1Z2lucyBjYW4gYmUgaW5qZWN0ZWQgYXMgcGFydCBvZiBwYWdlIGluaXRpYWxpemF0aW9uIG9yIG9uLXRoZS1mbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZX1cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogZnVuY3Rpb24gKGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgICBpZiAoIWluamVjdGVkTmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcGx1Z2luTW9kdWxlID0gaW5qZWN0ZWROYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IHBsdWdpbk1vZHVsZSkge1xuICAgICAgICAhIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zIHVzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnMTAyJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICAgICAgICBpc09yZGVyaW5nRGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNPcmRlcmluZ0RpcnR5KSB7XG4gICAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTG9va3MgdXAgdGhlIHBsdWdpbiBmb3IgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgQSBzeW50aGV0aWMgZXZlbnQuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IFRoZSBwbHVnaW4gdGhhdCBjcmVhdGVkIHRoZSBzdXBwbGllZCBldmVudC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRQbHVnaW5Nb2R1bGVGb3JFdmVudDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gZXZlbnQuZGlzcGF0Y2hDb25maWc7XG4gICAgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAgIHJldHVybiBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW2Rpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWVdIHx8IG51bGw7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBwdWxsaW5nIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzIG91dCBvZiBkaXNwYXRjaENvbmZpZyBoZWxwcyBGbG93IHNlZVxuICAgICAgLy8gdGhhdCBpdCBpcyBub3QgdW5kZWZpbmVkLlxuICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG5cbiAgICAgIGZvciAodmFyIHBoYXNlIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICAgIGlmICghcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2UpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VdXTtcbiAgICAgICAgaWYgKHBsdWdpbk1vZHVsZSkge1xuICAgICAgICAgIHJldHVybiBwbHVnaW5Nb2R1bGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldEV2ZW50UGx1Z2luczogZnVuY3Rpb24gKCkge1xuICAgIGV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmIChuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBkZWxldGUgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MpIHtcbiAgICAgIGlmIChldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICBkZWxldGUgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcztcbiAgICAgIGZvciAodmFyIGxvd2VyQ2FzZWROYW1lIGluIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgICAgaWYgKHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICAgICAgZGVsZXRlIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5SZWdpc3RyeTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvRXZlbnRQbHVnaW5SZWdpc3RyeS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBJbmplY3RlZCBkZXBlbmRlbmNpZXM6XG4gKi9cblxuLyoqXG4gKiAtIGBDb21wb25lbnRUcmVlYDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBjYW4gY29udmVydCBiZXR3ZWVuIFJlYWN0IGluc3RhbmNlc1xuICogICBhbmQgYWN0dWFsIG5vZGUgcmVmZXJlbmNlcy5cbiAqL1xudmFyIENvbXBvbmVudFRyZWU7XG52YXIgVHJlZVRyYXZlcnNhbDtcbnZhciBpbmplY3Rpb24gPSB7XG4gIGluamVjdENvbXBvbmVudFRyZWU6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIENvbXBvbmVudFRyZWUgPSBJbmplY3RlZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoSW5qZWN0ZWQgJiYgSW5qZWN0ZWQuZ2V0Tm9kZUZyb21JbnN0YW5jZSAmJiBJbmplY3RlZC5nZXRJbnN0YW5jZUZyb21Ob2RlLCAnRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0Q29tcG9uZW50VHJlZSguLi4pOiBJbmplY3RlZCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGdldE5vZGVGcm9tSW5zdGFuY2Ugb3IgZ2V0SW5zdGFuY2VGcm9tTm9kZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0sXG4gIGluamVjdFRyZWVUcmF2ZXJzYWw6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIFRyZWVUcmF2ZXJzYWwgPSBJbmplY3RlZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoSW5qZWN0ZWQgJiYgSW5qZWN0ZWQuaXNBbmNlc3RvciAmJiBJbmplY3RlZC5nZXRMb3dlc3RDb21tb25BbmNlc3RvciwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdFRyZWVUcmF2ZXJzYWwoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBpc0FuY2VzdG9yIG9yIGdldExvd2VzdENvbW1vbkFuY2VzdG9yLicpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaXNFbmRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZVVwJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BUb3VjaEVuZCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wVG91Y2hDYW5jZWwnO1xufVxuXG5mdW5jdGlvbiBpc01vdmVpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZU1vdmUnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcFRvdWNoTW92ZSc7XG59XG5mdW5jdGlvbiBpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VEb3duJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BUb3VjaFN0YXJ0Jztcbn1cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHZhciBpbnN0YW5jZXNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICAgIHZhciBpbnN0YW5jZXNMZW4gPSBpbnN0YW5jZXNJc0FyciA/IGRpc3BhdGNoSW5zdGFuY2VzLmxlbmd0aCA6IGRpc3BhdGNoSW5zdGFuY2VzID8gMSA6IDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0YW5jZXNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgaW5zdGFuY2VzTGVuID09PSBsaXN0ZW5lcnNMZW4sICdFdmVudFBsdWdpblV0aWxzOiBJbnZhbGlkIGBldmVudGAuJykgOiB2b2lkIDA7XG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggdGhlIGV2ZW50IHRvIHRoZSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFN5bnRoZXRpY0V2ZW50IHRvIGhhbmRsZVxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBBcHBsaWNhdGlvbi1sZXZlbCBjYWxsYmFja1xuICogQHBhcmFtIHsqfSBpbnN0IEludGVybmFsIGNvbXBvbmVudCBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgbGlzdGVuZXIsIGluc3QpIHtcbiAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8ICd1bmtub3duLWV2ZW50JztcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IEV2ZW50UGx1Z2luVXRpbHMuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2godHlwZSwgbGlzdGVuZXIsIGV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrKHR5cGUsIGxpc3RlbmVyLCBldmVudCk7XG4gIH1cbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcywgYnV0IHN0b3BzXG4gKiBhdCB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHJldHVybmluZyB0cnVlLCBhbmQgcmV0dXJucyB0aGF0IGlkLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IGlkIG9mIHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gd2hvJ3MgbGlzdGVuZXIgcmV0dXJuc1xuICogdHJ1ZSwgb3IgbnVsbCBpZiBubyBsaXN0ZW5lciByZXR1cm5lZCB0cnVlLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGlmIChkaXNwYXRjaExpc3RlbmVyc1tpXShldmVudCwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEluc3RhbmNlc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMoZXZlbnQsIGRpc3BhdGNoSW5zdGFuY2VzKSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoSW5zdGFuY2VzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUoZXZlbnQpIHtcbiAgdmFyIHJldCA9IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KTtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlyZWN0RGlzcGF0Y2goZXZlbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXIgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICAhIUFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZXhlY3V0ZURpcmVjdERpc3BhdGNoKC4uLik6IEludmFsaWQgYGV2ZW50YC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMDMnKSA6IHZvaWQgMDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGRpc3BhdGNoTGlzdGVuZXIgPyBFdmVudFBsdWdpblV0aWxzLmdldE5vZGVGcm9tSW5zdGFuY2UoZGlzcGF0Y2hJbnN0YW5jZSkgOiBudWxsO1xuICB2YXIgcmVzID0gZGlzcGF0Y2hMaXN0ZW5lciA/IGRpc3BhdGNoTGlzdGVuZXIoZXZlbnQpIDogbnVsbDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5mdW5jdGlvbiBoYXNEaXNwYXRjaGVzKGV2ZW50KSB7XG4gIHJldHVybiAhIWV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbn1cblxuLyoqXG4gKiBHZW5lcmFsIHV0aWxpdGllcyB0aGF0IGFyZSB1c2VmdWwgaW4gY3JlYXRpbmcgY3VzdG9tIEV2ZW50IFBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpblV0aWxzID0ge1xuICBpc0VuZGlzaDogaXNFbmRpc2gsXG4gIGlzTW92ZWlzaDogaXNNb3ZlaXNoLFxuICBpc1N0YXJ0aXNoOiBpc1N0YXJ0aXNoLFxuXG4gIGV4ZWN1dGVEaXJlY3REaXNwYXRjaDogZXhlY3V0ZURpcmVjdERpc3BhdGNoLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXI6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcixcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZTogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSxcbiAgaGFzRGlzcGF0Y2hlczogaGFzRGlzcGF0Y2hlcyxcblxuICBnZXRJbnN0YW5jZUZyb21Ob2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBDb21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XG4gIH0sXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIENvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShub2RlKTtcbiAgfSxcbiAgaXNBbmNlc3RvcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5pc0FuY2VzdG9yKGEsIGIpO1xuICB9LFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5nZXRMb3dlc3RDb21tb25BbmNlc3RvcihhLCBiKTtcbiAgfSxcbiAgZ2V0UGFyZW50SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwuZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCk7XG4gIH0sXG4gIHRyYXZlcnNlVHdvUGhhc2U6IGZ1bmN0aW9uICh0YXJnZXQsIGZuLCBhcmcpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZVR3b1BoYXNlKHRhcmdldCwgZm4sIGFyZyk7XG4gIH0sXG4gIHRyYXZlcnNlRW50ZXJMZWF2ZTogZnVuY3Rpb24gKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbyk7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBpbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5VdGlscztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvRXZlbnRQbHVnaW5VdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhdWdodEVycm9yID0gbnVsbDtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGEgRmlyc3QgYXJndW1lbnRcbiAqIEBwYXJhbSB7Kn0gYiBTZWNvbmQgYXJndW1lbnRcbiAqL1xuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGZ1bmMsIGEpIHtcbiAgdHJ5IHtcbiAgICBmdW5jKGEpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgaWYgKGNhdWdodEVycm9yID09PSBudWxsKSB7XG4gICAgICBjYXVnaHRFcnJvciA9IHg7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEVycm9yVXRpbHMgPSB7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFjazogaW52b2tlR3VhcmRlZENhbGxiYWNrLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJ5IFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlIHNvIHRoYXQgYW55IGVycm9ycyB0aHJvd24gYnkgdGhlIGV2ZW50XG4gICAqIGhhbmRsZXIgYXJlIHN1cmUgdG8gYmUgcmV0aHJvd24gYnkgcmV0aHJvd0NhdWdodEVycm9yLlxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrV2l0aENhdGNoOiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssXG5cbiAgLyoqXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICAgKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAqL1xuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2F1Z2h0RXJyb3IpIHtcbiAgICAgIHZhciBlcnJvciA9IGNhdWdodEVycm9yO1xuICAgICAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvKipcbiAgICogVG8gaGVscCBkZXZlbG9wbWVudCB3ZSBjYW4gZ2V0IGJldHRlciBkZXZ0b29scyBpbnRlZ3JhdGlvbiBieSBzaW11bGF0aW5nIGFcbiAgICogcmVhbCBicm93c2VyIGV2ZW50LlxuICAgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBmYWtlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlYWN0Jyk7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBhKSB7XG4gICAgICB2YXIgYm91bmRGdW5jID0gZnVuYy5iaW5kKG51bGwsIGEpO1xuICAgICAgdmFyIGV2dFR5cGUgPSAncmVhY3QtJyArIG5hbWU7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGJvdW5kRnVuYywgZmFsc2UpO1xuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgLy8gJEZsb3dGaXhNZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjMzNlxuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBib3VuZEZ1bmMsIGZhbHNlKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFcnJvclV0aWxzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdEVycm9yVXRpbHMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBpdGVtcyB0aGF0IG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGludG8gdGhlIGZpcnN0IG9uZS4gVGhpc1xuICogaXMgdXNlZCB0byBjb25zZXJ2ZSBtZW1vcnkgYnkgYXZvaWRpbmcgYXJyYXkgYWxsb2NhdGlvbnMsIGFuZCB0aHVzIHNhY3JpZmljZXNcbiAqIEFQSSBjbGVhbm5lc3MuIFNpbmNlIGBjdXJyZW50YCBjYW4gYmUgbnVsbCBiZWZvcmUgYmVpbmcgcGFzc2VkIGluIGFuZCBub3RcbiAqIG51bGwgYWZ0ZXIgdGhpcyBmdW5jdGlvbiwgbWFrZSBzdXJlIHRvIGFzc2lnbiBpdCBiYWNrIHRvIGBjdXJyZW50YDpcbiAqXG4gKiBgYSA9IGFjY3VtdWxhdGVJbnRvKGEsIGIpO2BcbiAqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgc3BhcmluZ2x5IHVzZWQuIFRyeSBgYWNjdW11bGF0ZWAgZm9yIHNvbWV0aGluZyBjbGVhbmVyLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBhY2N1bXVsYXRlSW50byhjdXJyZW50LCBuZXh0KSB7XG4gICEobmV4dCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhY2N1bXVsYXRlSW50byguLi4pOiBBY2N1bXVsYXRlZCBpdGVtcyBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKSA6IF9wcm9kSW52YXJpYW50KCczMCcpIDogdm9pZCAwO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XG4gIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWNjdW11bGF0ZUludG87XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2FjY3VtdWxhdGVJbnRvLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxuICogc2ltcGxlIHV0aWxpdHkgdGhhdCBhbGxvd3MgdXMgdG8gcmVhc29uIGFib3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtcywgYnV0XG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxuICovXG5cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaEFjY3VtdWxhdGVkO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbi8qKlxuICogU2ltcGxlLCBsaWdodHdlaWdodCBtb2R1bGUgYXNzaXN0aW5nIHdpdGggdGhlIGRldGVjdGlvbiBhbmQgY29udGV4dCBvZlxuICogV29ya2VyLiBIZWxwcyBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYW5kIGFsbG93cyBjb2RlIHRvIHJlYXNvbiBhYm91dFxuICogd2hldGhlciBvciBub3QgdGhleSBhcmUgaW4gYSBXb3JrZXIsIGV2ZW4gaWYgdGhleSBuZXZlciBpbmNsdWRlIHRoZSBtYWluXG4gKiBgUmVhY3RXb3JrZXJgIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHtcblxuICBjYW5Vc2VET006IGNhblVzZURPTSxcblxuICBjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuICBjYW5Vc2VFdmVudExpc3RlbmVyczogY2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cbiAgY2FuVXNlVmlld3BvcnQ6IGNhblVzZURPTSAmJiAhIXdpbmRvdy5zY3JlZW4sXG5cbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKCcuL2dldFRleHRDb250ZW50QWNjZXNzb3InKTtcblxuLyoqXG4gKiBUaGlzIGhlbHBlciBjbGFzcyBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSByb290XG4gKi9cbmZ1bmN0aW9uIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZShyb290KSB7XG4gIHRoaXMuX3Jvb3QgPSByb290O1xuICB0aGlzLl9zdGFydFRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbn1cblxuX2Fzc2lnbihGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucHJvdG90eXBlLCB7XG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICB0aGlzLl9zdGFydFRleHQgPSBudWxsO1xuICAgIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IHRleHQgb2YgaW5wdXQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldFRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ3ZhbHVlJyBpbiB0aGlzLl9yb290KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcm9vdC52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXTtcbiAgfSxcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBkaWZmZXJpbmcgc3Vic3RyaW5nIGJldHdlZW4gdGhlIGluaXRpYWxseSBzdG9yZWRcbiAgICogdGV4dCBjb250ZW50IGFuZCB0aGUgY3VycmVudCBjb250ZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2ZhbGxiYWNrVGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZhbGxiYWNrVGV4dDtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQ7XG4gICAgdmFyIHN0YXJ0VmFsdWUgPSB0aGlzLl9zdGFydFRleHQ7XG4gICAgdmFyIHN0YXJ0TGVuZ3RoID0gc3RhcnRWYWx1ZS5sZW5ndGg7XG4gICAgdmFyIGVuZDtcbiAgICB2YXIgZW5kVmFsdWUgPSB0aGlzLmdldFRleHQoKTtcbiAgICB2YXIgZW5kTGVuZ3RoID0gZW5kVmFsdWUubGVuZ3RoO1xuXG4gICAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgc3RhcnRMZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0XSAhPT0gZW5kVmFsdWVbc3RhcnRdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuICAgIGZvciAoZW5kID0gMTsgZW5kIDw9IG1pbkVuZDsgZW5kKyspIHtcbiAgICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2xpY2VUYWlsID0gZW5kID4gMSA/IDEgLSBlbmQgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gZW5kVmFsdWUuc2xpY2Uoc3RhcnQsIHNsaWNlVGFpbCk7XG4gICAgcmV0dXJuIHRoaXMuX2ZhbGxiYWNrVGV4dDtcbiAgfVxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogU3RhdGljIHBvb2xlcnMuIFNldmVyYWwgY3VzdG9tIHZlcnNpb25zIGZvciBlYWNoIHBvdGVudGlhbCBudW1iZXIgb2ZcbiAqIGFyZ3VtZW50cy4gQSBjb21wbGV0ZWx5IGdlbmVyaWMgcG9vbGVyIGlzIGVhc3kgdG8gaW1wbGVtZW50LCBidXQgd291bGRcbiAqIHJlcXVpcmUgYWNjZXNzaW5nIHRoZSBgYXJndW1lbnRzYCBvYmplY3QuIEluIGVhY2ggb2YgdGhlc2UsIGB0aGlzYCByZWZlcnMgdG9cbiAqIHRoZSBDbGFzcyBpdHNlbGYsIG5vdCBhbiBpbnN0YW5jZS4gSWYgYW55IG90aGVycyBhcmUgbmVlZGVkLCBzaW1wbHkgYWRkIHRoZW1cbiAqIGhlcmUsIG9yIGluIHRoZWlyIG93biBmaWxlcy5cbiAqL1xudmFyIG9uZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGNvcHlGaWVsZHNGcm9tKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGNvcHlGaWVsZHNGcm9tKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhjb3B5RmllbGRzRnJvbSk7XG4gIH1cbn07XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIpO1xuICB9XG59O1xuXG52YXIgdGhyZWVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMpO1xuICB9XG59O1xuXG52YXIgZm91ckFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0KSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMsIGE0KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzLCBhNCk7XG4gIH1cbn07XG5cbnZhciBmaXZlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQsIGE1KTtcbiAgfVxufTtcblxudmFyIHN0YW5kYXJkUmVsZWFzZXIgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgIShpbnN0YW5jZSBpbnN0YW5jZW9mIEtsYXNzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBpbnN0YW5jZSBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLicpIDogX3Byb2RJbnZhcmlhbnQoJzI1JykgOiB2b2lkIDA7XG4gIGluc3RhbmNlLmRlc3RydWN0b3IoKTtcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGggPCBLbGFzcy5wb29sU2l6ZSkge1xuICAgIEtsYXNzLmluc3RhbmNlUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufTtcblxudmFyIERFRkFVTFRfUE9PTF9TSVpFID0gMTA7XG52YXIgREVGQVVMVF9QT09MRVIgPSBvbmVBcmd1bWVudFBvb2xlcjtcblxuLyoqXG4gKiBBdWdtZW50cyBgQ29weUNvbnN0cnVjdG9yYCB0byBiZSBhIHBvb2xhYmxlIGNsYXNzLCBhdWdtZW50aW5nIG9ubHkgdGhlIGNsYXNzXG4gKiBpdHNlbGYgKHN0YXRpY2FsbHkpIG5vdCBhZGRpbmcgYW55IHByb3RvdHlwaWNhbCBmaWVsZHMuIEFueSBDb3B5Q29uc3RydWN0b3JcbiAqIHlvdSBnaXZlIHRoaXMgbWF5IGhhdmUgYSBgcG9vbFNpemVgIHByb3BlcnR5LCBhbmQgd2lsbCBsb29rIGZvciBhXG4gKiBwcm90b3R5cGljYWwgYGRlc3RydWN0b3JgIG9uIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb3B5Q29uc3RydWN0b3IgQ29uc3RydWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvb2xlciBDdXN0b21pemFibGUgcG9vbGVyLlxuICovXG52YXIgYWRkUG9vbGluZ1RvID0gZnVuY3Rpb24gKENvcHlDb25zdHJ1Y3RvciwgcG9vbGVyKSB7XG4gIC8vIENhc3RpbmcgYXMgYW55IHNvIHRoYXQgZmxvdyBpZ25vcmVzIHRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gYW5kIHRydXN0c1xuICAvLyBpdCB0byBtYXRjaCB0aGUgdHlwZSB3ZSBkZWNsYXJlZFxuICB2YXIgTmV3S2xhc3MgPSBDb3B5Q29uc3RydWN0b3I7XG4gIE5ld0tsYXNzLmluc3RhbmNlUG9vbCA9IFtdO1xuICBOZXdLbGFzcy5nZXRQb29sZWQgPSBwb29sZXIgfHwgREVGQVVMVF9QT09MRVI7XG4gIGlmICghTmV3S2xhc3MucG9vbFNpemUpIHtcbiAgICBOZXdLbGFzcy5wb29sU2l6ZSA9IERFRkFVTFRfUE9PTF9TSVpFO1xuICB9XG4gIE5ld0tsYXNzLnJlbGVhc2UgPSBzdGFuZGFyZFJlbGVhc2VyO1xuICByZXR1cm4gTmV3S2xhc3M7XG59O1xuXG52YXIgUG9vbGVkQ2xhc3MgPSB7XG4gIGFkZFBvb2xpbmdUbzogYWRkUG9vbGluZ1RvLFxuICBvbmVBcmd1bWVudFBvb2xlcjogb25lQXJndW1lbnRQb29sZXIsXG4gIHR3b0FyZ3VtZW50UG9vbGVyOiB0d29Bcmd1bWVudFBvb2xlcixcbiAgdGhyZWVBcmd1bWVudFBvb2xlcjogdGhyZWVBcmd1bWVudFBvb2xlcixcbiAgZm91ckFyZ3VtZW50UG9vbGVyOiBmb3VyQXJndW1lbnRQb29sZXIsXG4gIGZpdmVBcmd1bWVudFBvb2xlcjogZml2ZUFyZ3VtZW50UG9vbGVyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9Qb29sZWRDbGFzcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjb250ZW50S2V5ID0gbnVsbDtcblxuLyoqXG4gKiBHZXRzIHRoZSBrZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50IG9uIGEgRE9NIG5vZGUuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gS2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudEFjY2Vzc29yKCkge1xuICBpZiAoIWNvbnRlbnRLZXkgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgLy8gUHJlZmVyIHRleHRDb250ZW50IHRvIGlubmVyVGV4dCBiZWNhdXNlIG1hbnkgYnJvd3NlcnMgc3VwcG9ydCBib3RoIGJ1dFxuICAgIC8vIFNWRyA8dGV4dD4gZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpbm5lclRleHQgZXZlbiB3aGVuIDxkaXY+IGRvZXMuXG4gICAgY29udGVudEtleSA9ICd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gJ3RleHRDb250ZW50JyA6ICdpbm5lclRleHQnO1xuICB9XG4gIHJldHVybiBjb250ZW50S2V5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRleHRDb250ZW50QWNjZXNzb3I7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xuICovXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ29tcG9zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LCBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gZmFsc2U7XG52YXIgaXNQcm94eVN1cHBvcnRlZCA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIHRoZXNlIGhhdmUgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xuICAgIGRlbGV0ZSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGRlbGV0ZSB0aGlzLnByZXZlbnREZWZhdWx0O1xuICAgIGRlbGV0ZSB0aGlzLnN0b3BQcm9wYWdhdGlvbjtcbiAgfVxuXG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcbiAgdGhpcy5fdGFyZ2V0SW5zdCA9IHRhcmdldEluc3Q7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblxuICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgIGlmICghSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBkZWxldGUgdGhpc1twcm9wTmFtZV07IC8vIHRoaXMgaGFzIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtwcm9wTmFtZV07XG4gICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBub3JtYWxpemUobmF0aXZlRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcE5hbWUgPT09ICd0YXJnZXQnKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbCA/IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZSA9PT0gZmFsc2U7XG4gIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgfVxuICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICByZXR1cm4gdGhpcztcbn1cblxuX2Fzc2lnbihTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcblxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LnJldHVyblZhbHVlICE9PSAndW5rbm93bicpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgdmFsaWQtdHlwZW9mXG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHZhbGlkLXR5cGVvZlxuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcE5hbWUsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIEludGVyZmFjZVtwcm9wTmFtZV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpc1tzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllc1tpXV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYXRpdmVFdmVudCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ25hdGl2ZUV2ZW50JywgbnVsbCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwcmV2ZW50RGVmYXVsdCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3ByZXZlbnREZWZhdWx0JywgZW1wdHlGdW5jdGlvbikpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdG9wUHJvcGFnYXRpb24nLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdzdG9wUHJvcGFnYXRpb24nLCBlbXB0eUZ1bmN0aW9uKSk7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5TeW50aGV0aWNFdmVudC5JbnRlcmZhY2UgPSBFdmVudEludGVyZmFjZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgaWYgKGlzUHJveHlTdXBwb3J0ZWQpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gICAgU3ludGhldGljRXZlbnQgPSBuZXcgUHJveHkoU3ludGhldGljRXZlbnQsIHtcbiAgICAgIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRhcmdldCwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseSh0YXJnZXQsIE9iamVjdC5jcmVhdGUodGFyZ2V0LnByb3RvdHlwZSksIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbiAoY29uc3RydWN0b3IsIHRoYXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShjb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmdzKSwge1xuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wICE9PSAnaXNQZXJzaXN0ZW50JyAmJiAhdGFyZ2V0LmNvbnN0cnVjdG9yLkludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSB8fCB0YXJnZXQuaXNQZXJzaXN0ZW50KCksICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlICcgKyAnc2VlaW5nIHRoaXMsIHlvdVxcJ3JlIGFkZGluZyBhIG5ldyBwcm9wZXJ0eSBpbiB0aGUgc3ludGhldGljIGV2ZW50IG9iamVjdC4gJyArICdUaGUgcHJvcGVydHkgaXMgbmV2ZXIgcmVsZWFzZWQuIFNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qZXNsaW50LWVuYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICB9XG59XG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzXG4gKiBAcGFyYW0gez9vYmplY3R9IEludGVyZmFjZVxuICovXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MsIEludGVyZmFjZSkge1xuICB2YXIgU3VwZXIgPSB0aGlzO1xuXG4gIHZhciBFID0gZnVuY3Rpb24gKCkge307XG4gIEUucHJvdG90eXBlID0gU3VwZXIucHJvdG90eXBlO1xuICB2YXIgcHJvdG90eXBlID0gbmV3IEUoKTtcblxuICBfYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBTdXBlci5JbnRlcmZhY2UsIEludGVyZmFjZSk7XG4gIENsYXNzLmF1Z21lbnRDbGFzcyA9IFN1cGVyLmF1Z21lbnRDbGFzcztcblxuICBQb29sZWRDbGFzcy5hZGRQb29saW5nVG8oQ2xhc3MsIFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcik7XG59O1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oU3ludGhldGljRXZlbnQsIFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRXZlbnQ7XG5cbi8qKlxuICAqIEhlbHBlciB0byBudWxsaWZ5IHN5bnRoZXRpY0V2ZW50IGluc3RhbmNlIHByb3BlcnRpZXMgd2hlbiBkZXN0cnVjdGluZ1xuICAqXG4gICogQHBhcmFtIHtvYmplY3R9IFN5bnRoZXRpY0V2ZW50XG4gICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gICogQHJldHVybiB7b2JqZWN0fSBkZWZpbmVQcm9wZXJ0eSBvYmplY3RcbiAgKi9cbmZ1bmN0aW9uIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIGdldFZhbCkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBnZXRWYWwgPT09ICdmdW5jdGlvbic7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHNldDogc2V0LFxuICAgIGdldDogZ2V0XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ3NldHRpbmcgdGhlIG1ldGhvZCcgOiAnc2V0dGluZyB0aGUgcHJvcGVydHknO1xuICAgIHdhcm4oYWN0aW9uLCAnVGhpcyBpcyBlZmZlY3RpdmVseSBhIG5vLW9wJyk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdhY2Nlc3NpbmcgdGhlIG1ldGhvZCcgOiAnYWNjZXNzaW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgdmFyIHJlc3VsdCA9IGlzRnVuY3Rpb24gPyAnVGhpcyBpcyBhIG5vLW9wIGZ1bmN0aW9uJyA6ICdUaGlzIGlzIHNldCB0byBudWxsJztcbiAgICB3YXJuKGFjdGlvbiwgcmVzdWx0KTtcbiAgICByZXR1cm4gZ2V0VmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FybihhY3Rpb24sIHJlc3VsdCkge1xuICAgIHZhciB3YXJuaW5nQ29uZGl0aW9uID0gZmFsc2U7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcod2FybmluZ0NvbmRpdGlvbiwgJ1RoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91XFwncmUgc2VlaW5nIHRoaXMsICcgKyAneW91XFwncmUgJXMgYCVzYCBvbiBhIHJlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuICVzLiAnICsgJ0lmIHlvdSBtdXN0IGtlZXAgdGhlIG9yaWdpbmFsIHN5bnRoZXRpYyBldmVudCBhcm91bmQsIHVzZSBldmVudC5wZXJzaXN0KCkuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBhY3Rpb24sIHByb3BOYW1lLCByZXN1bHQpIDogdm9pZCAwO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0V2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIElucHV0RXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0lucHV0RXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljSW5wdXRFdmVudCwgSW5wdXRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljSW5wdXRFdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljSW5wdXRFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKCcuL2lzVGV4dElucHV0RWxlbWVudCcpO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNoYW5nZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ2hhbmdlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENoYW5nZScsICd0b3BDbGljaycsICd0b3BGb2N1cycsICd0b3BJbnB1dCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbi8qKlxuICogRm9yIElFIHNoaW1zXG4gKi9cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxudmFyIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBTZWUgYGhhbmRsZUNoYW5nZWAgY29tbWVudCBiZWxvd1xuICBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBpc0V2ZW50U3VwcG9ydGVkKCdjaGFuZ2UnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA4KTtcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIGFjdGl2ZUVsZW1lbnRJbnN0LCBuYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpKTtcbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcblxuICAvLyBJZiBjaGFuZ2UgYW5kIHByb3BlcnR5Y2hhbmdlIGJ1YmJsZWQsIHdlJ2QganVzdCBiaW5kIHRvIGl0IGxpa2UgYWxsIHRoZVxuICAvLyBvdGhlciBldmVudHMgYW5kIGhhdmUgaXQgZ28gdGhyb3VnaCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuIFNpbmNlIGl0XG4gIC8vIGRvZXNuJ3QsIHdlIG1hbnVhbGx5IGxpc3RlbiBmb3IgdGhlIGV2ZW50cyBhbmQgc28gd2UgaGF2ZSB0byBlbnF1ZXVlIGFuZFxuICAvLyBwcm9jZXNzIHRoZSBhYnN0cmFjdCBldmVudCBtYW51YWxseS5cbiAgLy9cbiAgLy8gQmF0Y2hpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgYWxsIGV2ZW50IGhhbmRsZXJzIHJ1blxuICAvLyBiZWZvcmUgdGhlIG5leHQgcmVyZW5kZXIgKGluY2x1ZGluZyBldmVudCBoYW5kbGVycyBhdHRhY2hlZCB0byBhbmNlc3RvclxuICAvLyBlbGVtZW50cyBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBpbnB1dCkuIFdpdGhvdXQgdGhpcywgY29udHJvbGxlZFxuICAvLyBjb21wb25lbnRzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gY29uanVuY3Rpb24gd2l0aCBldmVudCBidWJibGluZyBiZWNhdXNlXG4gIC8vIHRoZSBjb21wb25lbnQgaXMgcmVyZW5kZXJlZCBhbmQgdGhlIHZhbHVlIHJldmVydGVkIGJlZm9yZSBhbGwgdGhlIGV2ZW50XG4gIC8vIGhhbmRsZXJzIGNhbiBydW4uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcwOC5cbiAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKHJ1bkV2ZW50SW5CYXRjaCwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZXZlbnQpIHtcbiAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudCk7XG4gIEV2ZW50UGx1Z2luSHViLnByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG59XG5cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ2hhbmdlJykge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFOCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XG4gKi9cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU5IGNsYWltcyB0byBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBidXQgZmFpbHMgdG8gdHJpZ2dlciBpdCB3aGVuXG4gIC8vIGRlbGV0aW5nIHRleHQsIHNvIHdlIGlnbm9yZSBpdHMgaW5wdXQgZXZlbnRzLlxuICAvLyBJRTEwKyBmaXJlIGlucHV0IGV2ZW50cyB0byBvZnRlbiwgc3VjaCB3aGVuIGEgcGxhY2Vob2xkZXJcbiAgLy8gY2hhbmdlcyBvciB3aGVuIGFuIGlucHV0IHdpdGggYSBwbGFjZWhvbGRlciBpcyBmb2N1c2VkLlxuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBpc0V2ZW50U3VwcG9ydGVkKCdpbnB1dCcpICYmICghZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDExKTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9MTEpIFJlcGxhY2VtZW50IGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgdmFsdWVgIHByb3BlcnR5IHRoYXQgZ2V0c1xuICogc2V0IG9uIHRoZSBhY3RpdmUgZWxlbWVudC5cbiAqL1xudmFyIG5ld1ZhbHVlUHJvcCA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AuZ2V0LmNhbGwodGhpcyk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgIC8vIENhc3QgdG8gYSBzdHJpbmcgc28gd2UgY2FuIGRvIGVxdWFsaXR5IGNoZWNrcy5cbiAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSAnJyArIHZhbDtcbiAgICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wLnNldC5jYWxsKHRoaXMsIHZhbCk7XG4gIH1cbn07XG5cbi8qKlxuICogKEZvciBJRSA8PTExKSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdGFyZ2V0LnZhbHVlO1xuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuY29uc3RydWN0b3IucHJvdG90eXBlLCAndmFsdWUnKTtcblxuICAvLyBOb3QgZ3VhcmRlZCBpbiBhIGNhbkRlZmluZVByb3BlcnR5IGNoZWNrOiBJRTggc3VwcG9ydHMgZGVmaW5lUHJvcGVydHkgb25seVxuICAvLyBvbiBET00gZWxlbWVudHNcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFjdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5ld1ZhbHVlUHJvcCk7XG4gIGlmIChhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgfSBlbHNlIHtcbiAgICBhY3RpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UsIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZGVsZXRlIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZWZpbml0aW9uXG4gIGRlbGV0ZSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuXG4gIGlmIChhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KSB7XG4gICAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgfSBlbHNlIHtcbiAgICBhY3RpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UsIGZhbHNlKTtcbiAgfVxuXG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgSGFuZGxlcyBhIHByb3BlcnR5Y2hhbmdlIGV2ZW50LCBzZW5kaW5nIGEgYGNoYW5nZWAgZXZlbnQgaWZcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgYWN0aXZlIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5Q2hhbmdlKG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5wcm9wZXJ0eU5hbWUgIT09ICd2YWx1ZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHZhbHVlID0gbmF0aXZlRXZlbnQuc3JjRWxlbWVudC52YWx1ZTtcbiAgaWYgKHZhbHVlID09PSBhY3RpdmVFbGVtZW50VmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdmFsdWU7XG5cbiAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG59XG5cbi8qKlxuICogSWYgYSBgY2hhbmdlYCBldmVudCBzaG91bGQgYmUgZmlyZWQsIHJldHVybnMgdGhlIHRhcmdldCdzIElELlxuICovXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcElucHV0Jykge1xuICAgIC8vIEluIG1vZGVybiBicm93c2VycyAoaS5lLiwgbm90IElFOCBvciBJRTkpLCB0aGUgaW5wdXQgZXZlbnQgaXMgZXhhY3RseVxuICAgIC8vIHdoYXQgd2Ugd2FudCBzbyBmYWxsIHRocm91Z2ggaGVyZSBhbmQgdHJpZ2dlciBhbiBhYnN0cmFjdCBldmVudFxuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gSW4gSUU4LCB3ZSBjYW4gY2FwdHVyZSBhbG1vc3QgYWxsIC52YWx1ZSBjaGFuZ2VzIGJ5IGFkZGluZyBhXG4gICAgLy8gcHJvcGVydHljaGFuZ2UgaGFuZGxlciBhbmQgbG9va2luZyBmb3IgZXZlbnRzIHdpdGggcHJvcGVydHlOYW1lXG4gICAgLy8gZXF1YWwgdG8gJ3ZhbHVlJ1xuICAgIC8vIEluIElFOS0xMSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn1cblxuLy8gRm9yIElFOCBhbmQgSUU5LlxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcFNlbGVjdGlvbkNoYW5nZScgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5VXAnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleURvd24nKSB7XG4gICAgLy8gT24gdGhlIHNlbGVjdGlvbmNoYW5nZSBldmVudCwgdGhlIHRhcmdldCBpcyBqdXN0IGRvY3VtZW50IHdoaWNoIGlzbid0XG4gICAgLy8gaGVscGZ1bCBmb3IgdXMgc28ganVzdCBjaGVjayBhY3RpdmVFbGVtZW50IGluc3RlYWQuXG4gICAgLy9cbiAgICAvLyA5OSUgb2YgdGhlIHRpbWUsIGtleWRvd24gYW5kIGtleXVwIGFyZW4ndCBuZWNlc3NhcnkuIElFOCBmYWlscyB0byBmaXJlXG4gICAgLy8gcHJvcGVydHljaGFuZ2Ugb24gdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFmdGVyIHNldHRpbmcgYHZhbHVlYCBmcm9tIGFcbiAgICAvLyBzY3JpcHQgYW5kIGZpcmVzIG9ubHkga2V5ZG93biwga2V5cHJlc3MsIGtleXVwLiBDYXRjaGluZyBrZXl1cCB1c3VhbGx5XG4gICAgLy8gZ2V0cyBpdCBhbmQgY2F0Y2hpbmcga2V5ZG93biBsZXRzIHVzIGZpcmUgYW4gZXZlbnQgZm9yIHRoZSBmaXJzdFxuICAgIC8vIGtleXN0cm9rZSBpZiB1c2VyIGRvZXMgYSBrZXkgcmVwZWF0IChpdCdsbCBiZSBhIGxpdHRsZSBkZWxheWVkOiByaWdodFxuICAgIC8vIGJlZm9yZSB0aGUgc2Vjb25kIGtleXN0cm9rZSkuIE90aGVyIGlucHV0IG1ldGhvZHMgKGUuZy4sIHBhc3RlKSBzZWVtIHRvXG4gICAgLy8gZmlyZSBzZWxlY3Rpb25jaGFuZ2Ugbm9ybWFsbHkuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC52YWx1ZSAhPT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRJbnN0O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDbGljaycpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHZhciBnZXRUYXJnZXRJbnN0RnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50SUU7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIGV2ZW50LnR5cGUgPSAnY2hhbmdlJztcbiAgICAgICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZUV2ZW50UGx1Z2luO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RGZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBkaXJ0eUNvbXBvbmVudHMgPSBbXTtcbnZhciB1cGRhdGVCYXRjaE51bWJlciA9IDA7XG52YXIgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xudmFyIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuXG52YXIgYmF0Y2hpbmdTdHJhdGVneSA9IG51bGw7XG5cbmZ1bmN0aW9uIGVuc3VyZUluamVjdGVkKCkge1xuICAhKFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uICYmIGJhdGNoaW5nU3RyYXRlZ3kpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBpbmplY3QgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MgYW5kIGJhdGNoaW5nIHN0cmF0ZWd5JykgOiBfcHJvZEludmFyaWFudCgnMTIzJykgOiB2b2lkIDA7XG59XG5cbnZhciBORVNURURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gZGlydHlDb21wb25lbnRzLmxlbmd0aDtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggIT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIEFkZGl0aW9uYWwgdXBkYXRlcyB3ZXJlIGVucXVldWVkIGJ5IGNvbXBvbmVudERpZFVwZGF0ZSBoYW5kbGVycyBvclxuICAgICAgLy8gc2ltaWxhcjsgYmVmb3JlIG91ciBvd24gVVBEQVRFX1FVRVVFSU5HIHdyYXBwZXIgY2xvc2VzLCB3ZSB3YW50IHRvIHJ1blxuICAgICAgLy8gdGhlc2UgbmV3IHVwZGF0ZXMgc28gdGhhdCBpZiBBJ3MgY29tcG9uZW50RGlkVXBkYXRlIGNhbGxzIHNldFN0YXRlIG9uXG4gICAgICAvLyBCLCBCIHdpbGwgdXBkYXRlIGJlZm9yZSB0aGUgY2FsbGJhY2sgQSdzIHVwZGF0ZXIgcHJvdmlkZWQgd2hlbiBjYWxsaW5nXG4gICAgICAvLyBzZXRTdGF0ZS5cbiAgICAgIGRpcnR5Q29tcG9uZW50cy5zcGxpY2UoMCwgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGgpO1xuICAgICAgZmx1c2hCYXRjaGVkVXBkYXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBVUERBVEVfUVVFVUVJTkcgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUucmVzZXQoKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtORVNURURfVVBEQVRFUywgVVBEQVRFX1FVRVVFSU5HXTtcblxuZnVuY3Rpb24gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXG4gIC8qIHVzZUNyZWF0ZUVsZW1lbnQgKi90cnVlKTtcbn1cblxuX2Fzc2lnbihSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLmNhbGxiYWNrUXVldWUpO1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IG51bGw7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gbnVsbDtcbiAgfSxcblxuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSkge1xuICAgIC8vIEVzc2VudGlhbGx5IGNhbGxzIGB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0obWV0aG9kLCBzY29wZSwgYSlgXG4gICAgLy8gd2l0aCB0aGlzIHRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgYXJvdW5kIGl0LlxuICAgIHJldHVybiBUcmFuc2FjdGlvbi5wZXJmb3JtLmNhbGwodGhpcywgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLCBtZXRob2QsIHNjb3BlLCBhKTtcbiAgfVxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKTtcblxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcbiAgcmV0dXJuIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpO1xufVxuXG4vKipcbiAqIEFycmF5IGNvbXBhcmF0b3IgZm9yIFJlYWN0Q29tcG9uZW50cyBieSBtb3VudCBvcmRlcmluZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMSBmaXJzdCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gYzIgc2Vjb25kIGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJldHVybiB2YWx1ZSB1c2FibGUgYnkgQXJyYXkucHJvdG90eXBlLnNvcnQoKS5cbiAqL1xuZnVuY3Rpb24gbW91bnRPcmRlckNvbXBhcmF0b3IoYzEsIGMyKSB7XG4gIHJldHVybiBjMS5fbW91bnRPcmRlciAtIGMyLl9tb3VudE9yZGVyO1xufVxuXG5mdW5jdGlvbiBydW5CYXRjaGVkVXBkYXRlcyh0cmFuc2FjdGlvbikge1xuICB2YXIgbGVuID0gdHJhbnNhY3Rpb24uZGlydHlDb21wb25lbnRzTGVuZ3RoO1xuICAhKGxlbiA9PT0gZGlydHlDb21wb25lbnRzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgZmx1c2ggdHJhbnNhY3Rpb25cXCdzIHN0b3JlZCBkaXJ0eS1jb21wb25lbnRzIGxlbmd0aCAoJXMpIHRvIG1hdGNoIGRpcnR5LWNvbXBvbmVudHMgYXJyYXkgbGVuZ3RoICglcykuJywgbGVuLCBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA6IF9wcm9kSW52YXJpYW50KCcxMjQnLCBsZW4sIGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIDogdm9pZCAwO1xuXG4gIC8vIFNpbmNlIHJlY29uY2lsaW5nIGEgY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgb3duZXIgaGllcmFyY2h5IHVzdWFsbHkgKG5vdFxuICAvLyBhbHdheXMgLS0gc2VlIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpKSB3aWxsIHJlY29uY2lsZSBjaGlsZHJlbiwgcmVjb25jaWxlXG4gIC8vIHRoZW0gYmVmb3JlIHRoZWlyIGNoaWxkcmVuIGJ5IHNvcnRpbmcgdGhlIGFycmF5LlxuICBkaXJ0eUNvbXBvbmVudHMuc29ydChtb3VudE9yZGVyQ29tcGFyYXRvcik7XG5cbiAgLy8gQW55IHVwZGF0ZXMgZW5xdWV1ZWQgd2hpbGUgcmVjb25jaWxpbmcgbXVzdCBiZSBwZXJmb3JtZWQgYWZ0ZXIgdGhpcyBlbnRpcmVcbiAgLy8gYmF0Y2guIE90aGVyd2lzZSwgaWYgZGlydHlDb21wb25lbnRzIGlzIFtBLCBCXSB3aGVyZSBBIGhhcyBjaGlsZHJlbiBCIGFuZFxuICAvLyBDLCBCIGNvdWxkIHVwZGF0ZSB0d2ljZSBpbiBhIHNpbmdsZSBiYXRjaCBpZiBDJ3MgcmVuZGVyIGVucXVldWVzIGFuIHVwZGF0ZVxuICAvLyB0byBCIChzaW5jZSBCIHdvdWxkIGhhdmUgYWxyZWFkeSB1cGRhdGVkLCB3ZSBzaG91bGQgc2tpcCBpdCwgYW5kIHRoZSBvbmx5XG4gIC8vIHdheSB3ZSBjYW4ga25vdyB0byBkbyBzbyBpcyBieSBjaGVja2luZyB0aGUgYmF0Y2ggY291bnRlcikuXG4gIHVwZGF0ZUJhdGNoTnVtYmVyKys7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIC8vIElmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBiZWZvcmUgcGVuZGluZyBjaGFuZ2VzIGFwcGx5LCBpdCB3aWxsIHN0aWxsXG4gICAgLy8gYmUgaGVyZSwgYnV0IHdlIGFzc3VtZSB0aGF0IGl0IGhhcyBjbGVhcmVkIGl0cyBfcGVuZGluZ0NhbGxiYWNrcyBhbmRcbiAgICAvLyB0aGF0IHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBpcyBhIG5vb3AuXG4gICAgdmFyIGNvbXBvbmVudCA9IGRpcnR5Q29tcG9uZW50c1tpXTtcblxuICAgIC8vIElmIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBoYXBwZW5zIHRvIGVucXVldWUgYW55IG5ldyB1cGRhdGVzLCB3ZVxuICAgIC8vIHNob3VsZG4ndCBleGVjdXRlIHRoZSBjYWxsYmFja3MgdW50aWwgdGhlIG5leHQgcmVuZGVyIGhhcHBlbnMsIHNvXG4gICAgLy8gc3Rhc2ggdGhlIGNhbGxiYWNrcyBmaXJzdFxuICAgIHZhciBjYWxsYmFja3MgPSBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3M7XG4gICAgY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcblxuICAgIHZhciBtYXJrZXJOYW1lO1xuICAgIGlmIChSZWFjdEZlYXR1cmVGbGFncy5sb2dUb3BMZXZlbFJlbmRlcnMpIHtcbiAgICAgIHZhciBuYW1lZENvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgIC8vIER1Y2sgdHlwZSBUb3BMZXZlbFdyYXBwZXIuIFRoaXMgaXMgcHJvYmFibHkgYWx3YXlzIHRydWUuXG4gICAgICBpZiAoY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC50eXBlLmlzUmVhY3RUb3BMZXZlbFdyYXBwZXIpIHtcbiAgICAgICAgbmFtZWRDb21wb25lbnQgPSBjb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgICAgfVxuICAgICAgbWFya2VyTmFtZSA9ICdSZWFjdCB1cGRhdGU6ICcgKyBuYW1lZENvbXBvbmVudC5nZXROYW1lKCk7XG4gICAgICBjb25zb2xlLnRpbWUobWFya2VyTmFtZSk7XG4gICAgfVxuXG4gICAgUmVhY3RSZWNvbmNpbGVyLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeShjb21wb25lbnQsIHRyYW5zYWN0aW9uLnJlY29uY2lsZVRyYW5zYWN0aW9uLCB1cGRhdGVCYXRjaE51bWJlcik7XG5cbiAgICBpZiAobWFya2VyTmFtZSkge1xuICAgICAgY29uc29sZS50aW1lRW5kKG1hcmtlck5hbWUpO1xuICAgIH1cblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmNhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFja3Nbal0sIGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGZsdXNoQmF0Y2hlZFVwZGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ncyB3cmFwcGVycyB3aWxsIGNsZWFyIHRoZSBkaXJ0eUNvbXBvbmVudHNcbiAgLy8gYXJyYXkgYW5kIHBlcmZvcm0gYW55IHVwZGF0ZXMgZW5xdWV1ZWQgYnkgbW91bnQtcmVhZHkgaGFuZGxlcnMgKGkuZS4sXG4gIC8vIGNvbXBvbmVudERpZFVwZGF0ZSkgYnV0IHdlIG5lZWQgdG8gY2hlY2sgaGVyZSB0b28gaW4gb3JkZXIgdG8gY2F0Y2hcbiAgLy8gdXBkYXRlcyBlbnF1ZXVlZCBieSBzZXRTdGF0ZSBjYWxsYmFja3MgYW5kIGFzYXAgY2FsbHMuXG4gIHdoaWxlIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoIHx8IGFzYXBFbnF1ZXVlZCkge1xuICAgIGlmIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLmdldFBvb2xlZCgpO1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShydW5CYXRjaGVkVXBkYXRlcywgbnVsbCwgdHJhbnNhY3Rpb24pO1xuICAgICAgUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYXNhcEVucXVldWVkKSB7XG4gICAgICBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBxdWV1ZSA9IGFzYXBDYWxsYmFja1F1ZXVlO1xuICAgICAgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICAgICAgcXVldWUubm90aWZ5QWxsKCk7XG4gICAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UocXVldWUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNYXJrIGEgY29tcG9uZW50IGFzIG5lZWRpbmcgYSByZXJlbmRlciwgYWRkaW5nIGFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIGFcbiAqIGxpc3Qgb2YgZnVuY3Rpb25zIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgb25jZSB0aGUgcmVyZW5kZXIgb2NjdXJzLlxuICovXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGNvbXBvbmVudCkge1xuICBlbnN1cmVJbmplY3RlZCgpO1xuXG4gIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoVGhpcyBpcyBjYWxsZWQgYnkgZWFjaCB0b3AtbGV2ZWwgdXBkYXRlXG4gIC8vIGZ1bmN0aW9uLCBsaWtlIHNldFN0YXRlLCBmb3JjZVVwZGF0ZSwgZXRjLjsgY3JlYXRpb24gYW5kXG4gIC8vIGRlc3RydWN0aW9uIG9mIHRvcC1sZXZlbCBjb21wb25lbnRzIGlzIGd1YXJkZWQgaW4gUmVhY3RNb3VudC4pXG5cbiAgaWYgKCFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyhlbnF1ZXVlVXBkYXRlLCBjb21wb25lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRpcnR5Q29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gIGlmIChjb21wb25lbnQuX3VwZGF0ZUJhdGNoTnVtYmVyID09IG51bGwpIHtcbiAgICBjb21wb25lbnQuX3VwZGF0ZUJhdGNoTnVtYmVyID0gdXBkYXRlQmF0Y2hOdW1iZXIgKyAxO1xuICB9XG59XG5cbi8qKlxuICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRvIGJlIHJ1biBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJhdGNoaW5nIGN5Y2xlLiBUaHJvd3NcbiAqIGlmIG5vIHVwZGF0ZXMgYXJlIGN1cnJlbnRseSBiZWluZyBwZXJmb3JtZWQuXG4gKi9cbmZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgIWJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzLmFzYXA6IENhblxcJ3QgZW5xdWV1ZSBhbiBhc2FwIGNhbGxiYWNrIGluIGEgY29udGV4dCB3aGVyZXVwZGF0ZXMgYXJlIG5vdCBiZWluZyBiYXRjaGVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzEyNScpIDogdm9pZCAwO1xuICBhc2FwQ2FsbGJhY2tRdWV1ZS5lbnF1ZXVlKGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgYXNhcEVucXVldWVkID0gdHJ1ZTtcbn1cblxudmFyIFJlYWN0VXBkYXRlc0luamVjdGlvbiA9IHtcbiAgaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IGZ1bmN0aW9uIChSZWNvbmNpbGVUcmFuc2FjdGlvbikge1xuICAgICFSZWNvbmNpbGVUcmFuc2FjdGlvbiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIHJlY29uY2lsZSB0cmFuc2FjdGlvbiBjbGFzcycpIDogX3Byb2RJbnZhcmlhbnQoJzEyNicpIDogdm9pZCAwO1xuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVjb25jaWxlVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgaW5qZWN0QmF0Y2hpbmdTdHJhdGVneTogZnVuY3Rpb24gKF9iYXRjaGluZ1N0cmF0ZWd5KSB7XG4gICAgIV9iYXRjaGluZ1N0cmF0ZWd5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgYmF0Y2hpbmcgc3RyYXRlZ3knKSA6IF9wcm9kSW52YXJpYW50KCcxMjcnKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGVkVXBkYXRlcygpIGZ1bmN0aW9uJykgOiBfcHJvZEludmFyaWFudCgnMTI4JykgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPT09ICdib29sZWFuJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYW4gaXNCYXRjaGluZ1VwZGF0ZXMgYm9vbGVhbiBhdHRyaWJ1dGUnKSA6IF9wcm9kSW52YXJpYW50KCcxMjknKSA6IHZvaWQgMDtcbiAgICBiYXRjaGluZ1N0cmF0ZWd5ID0gX2JhdGNoaW5nU3RyYXRlZ3k7XG4gIH1cbn07XG5cbnZhciBSZWFjdFVwZGF0ZXMgPSB7XG4gIC8qKlxuICAgKiBSZWFjdCByZWZlcmVuY2VzIGBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uYCB1c2luZyB0aGlzIHByb3BlcnR5IGluIG9yZGVyXG4gICAqIHRvIGFsbG93IGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IG51bGwsXG5cbiAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuICBlbnF1ZXVlVXBkYXRlOiBlbnF1ZXVlVXBkYXRlLFxuICBmbHVzaEJhdGNoZWRVcGRhdGVzOiBmbHVzaEJhdGNoZWRVcGRhdGVzLFxuICBpbmplY3Rpb246IFJlYWN0VXBkYXRlc0luamVjdGlvbixcbiAgYXNhcDogYXNhcFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFVwZGF0ZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0VXBkYXRlcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCBwc2V1ZG8tZXZlbnQgbW9kdWxlIHRvIGhlbHAga2VlcCB0cmFjayBvZiBjb21wb25lbnRzIHdhaXRpbmcgdG9cbiAqIGJlIG5vdGlmaWVkIHdoZW4gdGhlaXIgRE9NIHJlcHJlc2VudGF0aW9ucyBhcmUgYXZhaWxhYmxlIGZvciB1c2UuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRzIGBQb29sZWRDbGFzc2AsIHNvIHlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzLlxuICogSW5zdGVhZCwgdXNlIGBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpYC5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNb3VudFJlYWR5XG4gKiBAaW1wbGVtZW50cyBQb29sZWRDbGFzc1xuICogQGludGVybmFsXG4gKi9cblxudmFyIENhbGxiYWNrUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENhbGxiYWNrUXVldWUoYXJnKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbGxiYWNrUXVldWUpO1xuXG4gICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gICAgdGhpcy5fYXJnID0gYXJnO1xuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGBub3RpZnlBbGxgIGlzIGludm9rZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIEludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHQgQ29udGV4dCB0byBjYWxsIGBjYWxsYmFja2Agd2l0aC5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uIGVucXVldWUoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwgW107XG4gICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIHRoaXMuX2NvbnRleHRzID0gdGhpcy5fY29udGV4dHMgfHwgW107XG4gICAgdGhpcy5fY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfTtcblxuICAvKipcbiAgICogSW52b2tlcyBhbGwgZW5xdWV1ZWQgY2FsbGJhY2tzIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLiBUaGlzIGlzIGludm9rZWQgYWZ0ZXJcbiAgICogdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbXBvbmVudCBoYXMgYmVlbiBjcmVhdGVkIG9yIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLm5vdGlmeUFsbCA9IGZ1bmN0aW9uIG5vdGlmeUFsbCgpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICAgIHZhciBjb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzO1xuICAgIHZhciBhcmcgPSB0aGlzLl9hcmc7XG4gICAgaWYgKGNhbGxiYWNrcyAmJiBjb250ZXh0cykge1xuICAgICAgIShjYWxsYmFja3MubGVuZ3RoID09PSBjb250ZXh0cy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc21hdGNoZWQgbGlzdCBvZiBjb250ZXh0cyBpbiBjYWxsYmFjayBxdWV1ZScpIDogX3Byb2RJbnZhcmlhbnQoJzI0JykgOiB2b2lkIDA7XG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwoY29udGV4dHNbaV0sIGFyZyk7XG4gICAgICB9XG4gICAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgIGNvbnRleHRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9O1xuXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLmNoZWNrcG9pbnQgPSBmdW5jdGlvbiBjaGVja3BvaW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxsYmFja3MgPyB0aGlzLl9jYWxsYmFja3MubGVuZ3RoIDogMDtcbiAgfTtcblxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5yb2xsYmFjayA9IGZ1bmN0aW9uIHJvbGxiYWNrKGxlbikge1xuICAgIGlmICh0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY29udGV4dHMpIHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggPSBsZW47XG4gICAgICB0aGlzLl9jb250ZXh0cy5sZW5ndGggPSBsZW47XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGludGVybmFsIHF1ZXVlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLlxuICAgKi9cblxuXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfTtcblxuICByZXR1cm4gQ2FsbGJhY2tRdWV1ZTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sZWRDbGFzcy5hZGRQb29saW5nVG8oQ2FsbGJhY2tRdWV1ZSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL0NhbGxiYWNrUXVldWUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHtcbiAgLy8gV2hlbiB0cnVlLCBjYWxsIGNvbnNvbGUudGltZSgpIGJlZm9yZSBhbmQgLnRpbWVFbmQoKSBhZnRlciBlYWNoIHRvcC1sZXZlbFxuICAvLyByZW5kZXIgKGJvdGggaW5pdGlhbCByZW5kZXJzIGFuZCB1cGRhdGVzKS4gVXNlZnVsIHdoZW4gbG9va2luZyBhdCBwcm9kLW1vZGVcbiAgLy8gdGltZWxpbmUgcHJvZmlsZXMgaW4gQ2hyb21lLCBmb3IgZXhhbXBsZS5cbiAgbG9nVG9wTGV2ZWxSZW5kZXJzOiBmYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEZlYXR1cmVGbGFncztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RGZWF0dXJlRmxhZ3MuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWYgPSByZXF1aXJlKCcuL1JlYWN0UmVmJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEhlbHBlciB0byBjYWxsIFJlYWN0UmVmLmF0dGFjaFJlZnMgd2l0aCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQsIHNwbGl0IG91dFxuICogdG8gYXZvaWQgYWxsb2NhdGlvbnMgaW4gdGhlIHRyYW5zYWN0aW9uIG1vdW50LXJlYWR5IHF1ZXVlLlxuICovXG5mdW5jdGlvbiBhdHRhY2hSZWZzKCkge1xuICBSZWFjdFJlZi5hdHRhY2hSZWZzKHRoaXMsIHRoaXMuX2N1cnJlbnRFbGVtZW50KTtcbn1cblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IHRoZSBjb250YWluaW5nIGhvc3QgY29tcG9uZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gaW5mbyBhYm91dCB0aGUgaG9zdCBjb250YWluZXJcbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHBhcmVudERlYnVnSUQgLy8gMCBpbiBwcm9kdWN0aW9uIGFuZCBmb3Igcm9vdHNcbiAgKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZU1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LCBwYXJlbnREZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1hcmt1cCA9IGludGVybmFsSW5zdGFuY2UubW91bnRDb21wb25lbnQodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBwYXJlbnREZWJ1Z0lEKTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Nb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZhbHVlIHRoYXQgY2FuIGJlIHBhc3NlZCB0b1xuICAgKiBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cC5cbiAgICovXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnRlcm5hbEluc3RhbmNlLmdldEhvc3ROb2RlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBzYWZlbHkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlVW5tb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCk7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS51bm1vdW50Q29tcG9uZW50KHNhZmVseSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVubW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSBjb21wb25lbnQgdXNpbmcgYSBuZXcgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcblxuICAgIGlmIChuZXh0RWxlbWVudCA9PT0gcHJldkVsZW1lbnQgJiYgY29udGV4dCA9PT0gaW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCkge1xuICAgICAgLy8gU2luY2UgZWxlbWVudHMgYXJlIGltbXV0YWJsZSBhZnRlciB0aGUgb3duZXIgaXMgcmVuZGVyZWQsXG4gICAgICAvLyB3ZSBjYW4gZG8gYSBjaGVhcCBpZGVudGl0eSBjb21wYXJlIGhlcmUgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYVxuICAgICAgLy8gc3VwZXJmbHVvdXMgcmVjb25jaWxlLiBJdCdzIHBvc3NpYmxlIGZvciBzdGF0ZSB0byBiZSBtdXRhYmxlIGJ1dCBzdWNoXG4gICAgICAvLyBjaGFuZ2Ugc2hvdWxkIHRyaWdnZXIgYW4gdXBkYXRlIG9mIHRoZSBvd25lciB3aGljaCB3b3VsZCByZWNyZWF0ZVxuICAgICAgLy8gdGhlIGVsZW1lbnQuIFdlIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gb3duZXIgc2luY2VcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIGFuIGVsZW1lbnQgY3JlYXRlZCBvdXRzaWRlIGEgY29tcG9zaXRlIHRvIGJlXG4gICAgICAvLyBkZWVwbHkgbXV0YXRlZCBhbmQgcmV1c2VkLlxuXG4gICAgICAvLyBUT0RPOiBCYWlsaW5nIG91dCBlYXJseSBpcyBqdXN0IGEgcGVyZiBvcHRpbWl6YXRpb24gcmlnaHQ/XG4gICAgICAvLyBUT0RPOiBSZW1vdmluZyB0aGUgcmV0dXJuIHN0YXRlbWVudCBzaG91bGQgYWZmZWN0IGNvcnJlY3RuZXNzP1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgbmV4dEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWZzQ2hhbmdlZCA9IFJlYWN0UmVmLnNob3VsZFVwZGF0ZVJlZnMocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCkge1xuICAgICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBwcmV2RWxlbWVudCk7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50KG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICBpZiAocmVmc0NoYW5nZWQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZsdXNoIGFueSBkaXJ0eSBjaGFuZ2VzIGluIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgdXBkYXRlQmF0Y2hOdW1iZXIpIHtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIgIT09IHVwZGF0ZUJhdGNoTnVtYmVyKSB7XG4gICAgICAvLyBUaGUgY29tcG9uZW50J3MgZW5xdWV1ZWQgYmF0Y2ggbnVtYmVyIHNob3VsZCBhbHdheXMgYmUgdGhlIGN1cnJlbnRcbiAgICAgIC8vIGJhdGNoIG9yIHRoZSBmb2xsb3dpbmcgb25lLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIgPT0gbnVsbCB8fCBpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciA9PT0gdXBkYXRlQmF0Y2hOdW1iZXIgKyAxLCAncGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBVbmV4cGVjdGVkIGJhdGNoIG51bWJlciAoY3VycmVudCAlcywgJyArICdwZW5kaW5nICVzKScsIHVwZGF0ZUJhdGNoTnVtYmVyLCBpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlcikgOiB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnRlcm5hbEluc3RhbmNlLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSh0cmFuc2FjdGlvbik7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0UmVjb25jaWxlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0T3duZXInKTtcblxudmFyIFJlYWN0UmVmID0ge307XG5cbmZ1bmN0aW9uIGF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYoY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpO1xuICB9IGVsc2Uge1xuICAgIC8vIExlZ2FjeSByZWZcbiAgICBSZWFjdE93bmVyLmFkZENvbXBvbmVudEFzUmVmVG8oY29tcG9uZW50LCByZWYsIG93bmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRhY2hSZWYocmVmLCBjb21wb25lbnQsIG93bmVyKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVmKG51bGwpO1xuICB9IGVsc2Uge1xuICAgIC8vIExlZ2FjeSByZWZcbiAgICBSZWFjdE93bmVyLnJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbShjb21wb25lbnQsIHJlZiwgb3duZXIpO1xuICB9XG59XG5cblJlYWN0UmVmLmF0dGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgdHlwZW9mIGVsZW1lbnQgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgYXR0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcbiAgfVxufTtcblxuUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyA9IGZ1bmN0aW9uIChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgLy8gSWYgZWl0aGVyIHRoZSBvd25lciBvciBhIGByZWZgIGhhcyBjaGFuZ2VkLCBtYWtlIHN1cmUgdGhlIG5ld2VzdCBvd25lclxuICAvLyBoYXMgc3RvcmVkIGEgcmVmZXJlbmNlIHRvIGB0aGlzYCwgYW5kIHRoZSBwcmV2aW91cyBvd25lciAoaWYgZGlmZmVyZW50KVxuICAvLyBoYXMgZm9yZ290dGVuIHRoZSByZWZlcmVuY2UgdG8gYHRoaXNgLiBXZSB1c2UgdGhlIGVsZW1lbnQgaW5zdGVhZFxuICAvLyBvZiB0aGUgcHVibGljIHRoaXMucHJvcHMgYmVjYXVzZSB0aGUgcG9zdCBwcm9jZXNzaW5nIGNhbm5vdCBkZXRlcm1pbmVcbiAgLy8gYSByZWYuIFRoZSByZWYgY29uY2VwdHVhbGx5IGxpdmVzIG9uIHRoZSBlbGVtZW50LlxuXG4gIC8vIFRPRE86IFNob3VsZCB0aGlzIGV2ZW4gYmUgcG9zc2libGU/IFRoZSBvd25lciBjYW5ub3QgY2hhbmdlIGJlY2F1c2VcbiAgLy8gaXQncyBmb3JiaWRkZW4gYnkgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuIFRoZSByZWYgY2FuIGNoYW5nZVxuICAvLyBpZiB5b3Ugc3dhcCB0aGUga2V5cyBvZiBidXQgbm90IHRoZSByZWZzLiBSZWNvbnNpZGVyIHdoZXJlIHRoaXMgY2hlY2tcbiAgLy8gaXMgbWFkZS4gSXQgcHJvYmFibHkgYmVsb25ncyB3aGVyZSB0aGUga2V5IGNoZWNraW5nIGFuZFxuICAvLyBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50IGlzIGRvbmUuXG5cbiAgdmFyIHByZXZSZWYgPSBudWxsO1xuICB2YXIgcHJldk93bmVyID0gbnVsbDtcbiAgaWYgKHByZXZFbGVtZW50ICE9PSBudWxsICYmIHR5cGVvZiBwcmV2RWxlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICBwcmV2UmVmID0gcHJldkVsZW1lbnQucmVmO1xuICAgIHByZXZPd25lciA9IHByZXZFbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHZhciBuZXh0UmVmID0gbnVsbDtcbiAgdmFyIG5leHRPd25lciA9IG51bGw7XG4gIGlmIChuZXh0RWxlbWVudCAhPT0gbnVsbCAmJiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgbmV4dFJlZiA9IG5leHRFbGVtZW50LnJlZjtcbiAgICBuZXh0T3duZXIgPSBuZXh0RWxlbWVudC5fb3duZXI7XG4gIH1cblxuICByZXR1cm4gcHJldlJlZiAhPT0gbmV4dFJlZiB8fFxuICAvLyBJZiBvd25lciBjaGFuZ2VzIGJ1dCB3ZSBoYXZlIGFuIHVuY2hhbmdlZCBmdW5jdGlvbiByZWYsIGRvbid0IHVwZGF0ZSByZWZzXG4gIHR5cGVvZiBuZXh0UmVmID09PSAnc3RyaW5nJyAmJiBuZXh0T3duZXIgIT09IHByZXZPd25lcjtcbn07XG5cblJlYWN0UmVmLmRldGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgdHlwZW9mIGVsZW1lbnQgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgZGV0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlZjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RSZWYuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIG93bmVyLlxuICogQGZpbmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRPd25lcihvYmplY3QpIHtcbiAgcmV0dXJuICEhKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0LmF0dGFjaFJlZiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqZWN0LmRldGFjaFJlZiA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogUmVhY3RPd25lcnMgYXJlIGNhcGFibGUgb2Ygc3RvcmluZyByZWZlcmVuY2VzIHRvIG93bmVkIGNvbXBvbmVudHMuXG4gKlxuICogQWxsIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9iZWluZy8vIHJlZmVyZW5jZWQgYnkgb3duZXIgY29tcG9uZW50cywgYnV0XG4gKiBvbmx5IFJlYWN0T3duZXIgY29tcG9uZW50cyBhcmUgY2FwYWJsZSBvZiAvL3JlZmVyZW5jaW5nLy8gb3duZWQgY29tcG9uZW50cy5cbiAqIFRoZSBuYW1lZCByZWZlcmVuY2UgaXMga25vd24gYXMgYSBcInJlZlwiLlxuICpcbiAqIFJlZnMgYXJlIGF2YWlsYWJsZSB3aGVuIG1vdW50ZWQgYW5kIHVwZGF0ZWQgZHVyaW5nIHJlY29uY2lsaWF0aW9uLlxuICpcbiAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gKFxuICogICAgICAgICA8ZGl2IG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9PlxuICogICAgICAgICAgIDxDdXN0b21Db21wb25lbnQgcmVmPVwiY3VzdG9tXCIgLz5cbiAqICAgICAgICAgPC9kaXY+XG4gKiAgICAgICApO1xuICogICAgIH0sXG4gKiAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICogICAgICAgdGhpcy5yZWZzLmN1c3RvbS5oYW5kbGVDbGljaygpO1xuICogICAgIH0sXG4gKiAgICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICogICAgICAgdGhpcy5yZWZzLmN1c3RvbS5pbml0aWFsaXplKCk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBSZWZzIHNob3VsZCByYXJlbHkgYmUgdXNlZC4gV2hlbiByZWZzIGFyZSB1c2VkLCB0aGV5IHNob3VsZCBvbmx5IGJlIGRvbmUgdG9cbiAqIGNvbnRyb2wgZGF0YSB0aGF0IGlzIG5vdCBoYW5kbGVkIGJ5IFJlYWN0J3MgZGF0YSBmbG93LlxuICpcbiAqIEBjbGFzcyBSZWFjdE93bmVyXG4gKi9cbnZhciBSZWFjdE93bmVyID0ge1xuICAvKipcbiAgICogQWRkcyBhIGNvbXBvbmVudCBieSByZWYgdG8gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIHJlZmVyZW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIGJ5IHdoaWNoIHRvIHJlZmVyIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRvIHJlY29yZCB0aGUgcmVmLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhZGRDb21wb25lbnRBc1JlZlRvOiBmdW5jdGlvbiAoY29tcG9uZW50LCByZWYsIG93bmVyKSB7XG4gICAgIWlzVmFsaWRPd25lcihvd25lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYWRkQ29tcG9uZW50QXNSZWZUbyguLi4pOiBPbmx5IGEgUmVhY3RPd25lciBjYW4gaGF2ZSByZWZzLiBZb3UgbWlnaHQgYmUgYWRkaW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgYHJlbmRlcmAgbWV0aG9kLCBvciB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkIChkZXRhaWxzOiBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTknKSA6IHZvaWQgMDtcbiAgICBvd25lci5hdHRhY2hSZWYocmVmLCBjb21wb25lbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY29tcG9uZW50IGJ5IHJlZiBmcm9tIGFuIG93bmVyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byBkZXJlZmVyZW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIG9mIHRoZSByZWYgdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0ge1JlYWN0T3duZXJ9IG93bmVyIENvbXBvbmVudCBvbiB3aGljaCB0aGUgcmVmIGlzIHJlY29yZGVkLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZW1vdmVDb21wb25lbnRBc1JlZkZyb206IGZ1bmN0aW9uIChjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAhaXNWYWxpZE93bmVyKG93bmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW1vdmVDb21wb25lbnRBc1JlZkZyb20oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0IGJlIHJlbW92aW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgYHJlbmRlcmAgbWV0aG9kLCBvciB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkIChkZXRhaWxzOiBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxMjAnKSA6IHZvaWQgMDtcbiAgICB2YXIgb3duZXJQdWJsaWNJbnN0YW5jZSA9IG93bmVyLmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgLy8gQ2hlY2sgdGhhdCBgY29tcG9uZW50YCdzIG93bmVyIGlzIHN0aWxsIGFsaXZlIGFuZCB0aGF0IGBjb21wb25lbnRgIGlzIHN0aWxsIHRoZSBjdXJyZW50IHJlZlxuICAgIC8vIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG8gZGV0YWNoIHRoZSByZWYgaWYgYW5vdGhlciBjb21wb25lbnQgc3RvbGUgaXQuXG4gICAgaWYgKG93bmVyUHVibGljSW5zdGFuY2UgJiYgb3duZXJQdWJsaWNJbnN0YW5jZS5yZWZzW3JlZl0gPT09IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKSB7XG4gICAgICBvd25lci5kZXRhY2hSZWYocmVmKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE93bmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdE93bmVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUcnVzdCB0aGUgZGV2ZWxvcGVyIHRvIG9ubHkgdXNlIFJlYWN0SW5zdHJ1bWVudGF0aW9uIHdpdGggYSBfX0RFVl9fIGNoZWNrXG5cbnZhciBkZWJ1Z1Rvb2wgPSBudWxsO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3REZWJ1Z1Rvb2wgPSByZXF1aXJlKCcuL1JlYWN0RGVidWdUb29sJyk7XG4gIGRlYnVnVG9vbCA9IFJlYWN0RGVidWdUb29sO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVidWdUb29sOiBkZWJ1Z1Rvb2wgfTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RJbnN0cnVtZW50YXRpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rID0gcmVxdWlyZSgnLi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rJyk7XG52YXIgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rJyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgcGVyZm9ybWFuY2VOb3cgPSByZXF1aXJlKCdmYmpzL2xpYi9wZXJmb3JtYW5jZU5vdycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBob29rcyA9IFtdO1xudmFyIGRpZEhvb2tUaHJvd0ZvckV2ZW50ID0ge307XG5cbmZ1bmN0aW9uIGNhbGxIb29rKGV2ZW50LCBmbiwgY29udGV4dCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuICB0cnkge1xuICAgIGZuLmNhbGwoY29udGV4dCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRIb29rVGhyb3dGb3JFdmVudFtldmVudF0sICdFeGNlcHRpb24gdGhyb3duIGJ5IGhvb2sgd2hpbGUgaGFuZGxpbmcgJXM6ICVzJywgZXZlbnQsIGUgKyAnXFxuJyArIGUuc3RhY2spIDogdm9pZCAwO1xuICAgIGRpZEhvb2tUaHJvd0ZvckV2ZW50W2V2ZW50XSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEV2ZW50KGV2ZW50LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaG9vayA9IGhvb2tzW2ldO1xuICAgIHZhciBmbiA9IGhvb2tbZXZlbnRdO1xuICAgIGlmIChmbikge1xuICAgICAgY2FsbEhvb2soZXZlbnQsIGZuLCBob29rLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGlzUHJvZmlsaW5nID0gZmFsc2U7XG52YXIgZmx1c2hIaXN0b3J5ID0gW107XG52YXIgbGlmZUN5Y2xlVGltZXJTdGFjayA9IFtdO1xudmFyIGN1cnJlbnRGbHVzaE5lc3RpbmcgPSAwO1xudmFyIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IFtdO1xudmFyIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IDA7XG52YXIgY3VycmVudFRpbWVyRGVidWdJRCA9IG51bGw7XG52YXIgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gMDtcbnZhciBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gMDtcbnZhciBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcblxudmFyIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNsZWFySGlzdG9yeSgpIHtcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vay5wdXJnZVVubW91bnRlZENvbXBvbmVudHMoKTtcbiAgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suY2xlYXJIaXN0b3J5KCk7XG59XG5cbmZ1bmN0aW9uIGdldFRyZWVTbmFwc2hvdChyZWdpc3RlcmVkSURzKSB7XG4gIHJldHVybiByZWdpc3RlcmVkSURzLnJlZHVjZShmdW5jdGlvbiAodHJlZSwgaWQpIHtcbiAgICB2YXIgb3duZXJJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChpZCk7XG4gICAgdmFyIHBhcmVudElEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRQYXJlbnRJRChpZCk7XG4gICAgdHJlZVtpZF0gPSB7XG4gICAgICBkaXNwbGF5TmFtZTogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShpZCksXG4gICAgICB0ZXh0OiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFRleHQoaWQpLFxuICAgICAgdXBkYXRlQ291bnQ6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0VXBkYXRlQ291bnQoaWQpLFxuICAgICAgY2hpbGRJRHM6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q2hpbGRJRHMoaWQpLFxuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIG93bmVycyBidXQgdGhpcyBpcyBjbG9zZSBlbm91Z2guXG4gICAgICBvd25lcklEOiBvd25lcklEIHx8IHBhcmVudElEICYmIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChwYXJlbnRJRCkgfHwgMCxcbiAgICAgIHBhcmVudElEOiBwYXJlbnRJRFxuICAgIH07XG4gICAgcmV0dXJuIHRyZWU7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRNZWFzdXJlbWVudHMoKSB7XG4gIHZhciBwcmV2aW91c1N0YXJ0VGltZSA9IGN1cnJlbnRGbHVzaFN0YXJ0VGltZTtcbiAgdmFyIHByZXZpb3VzTWVhc3VyZW1lbnRzID0gY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzO1xuICB2YXIgcHJldmlvdXNPcGVyYXRpb25zID0gUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suZ2V0SGlzdG9yeSgpO1xuXG4gIGlmIChjdXJyZW50Rmx1c2hOZXN0aW5nID09PSAwKSB7XG4gICAgY3VycmVudEZsdXNoU3RhcnRUaW1lID0gMDtcbiAgICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMgPSBbXTtcbiAgICBjbGVhckhpc3RvcnkoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJldmlvdXNNZWFzdXJlbWVudHMubGVuZ3RoIHx8IHByZXZpb3VzT3BlcmF0aW9ucy5sZW5ndGgpIHtcbiAgICB2YXIgcmVnaXN0ZXJlZElEcyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0UmVnaXN0ZXJlZElEcygpO1xuICAgIGZsdXNoSGlzdG9yeS5wdXNoKHtcbiAgICAgIGR1cmF0aW9uOiBwZXJmb3JtYW5jZU5vdygpIC0gcHJldmlvdXNTdGFydFRpbWUsXG4gICAgICBtZWFzdXJlbWVudHM6IHByZXZpb3VzTWVhc3VyZW1lbnRzIHx8IFtdLFxuICAgICAgb3BlcmF0aW9uczogcHJldmlvdXNPcGVyYXRpb25zIHx8IFtdLFxuICAgICAgdHJlZVNuYXBzaG90OiBnZXRUcmVlU25hcHNob3QocmVnaXN0ZXJlZElEcylcbiAgICB9KTtcbiAgfVxuXG4gIGNsZWFySGlzdG9yeSgpO1xuICBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMgPSBbXTtcbn1cblxuZnVuY3Rpb24gY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpIHtcbiAgdmFyIGFsbG93Um9vdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgaWYgKGFsbG93Um9vdCAmJiBkZWJ1Z0lEID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghZGVidWdJRCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3REZWJ1Z1Rvb2w6IGRlYnVnSUQgbWF5IG5vdCBiZSBlbXB0eS4nKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBiZWdpbkxpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xuICBpZiAoY3VycmVudEZsdXNoTmVzdGluZyA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY3VycmVudFRpbWVyVHlwZSAmJiAhbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZXJlIGlzIGFuIGludGVybmFsIGVycm9yIGluIHRoZSBSZWFjdCBwZXJmb3JtYW5jZSBtZWFzdXJlbWVudCBjb2RlLiAnICsgJ0RpZCBub3QgZXhwZWN0ICVzIHRpbWVyIHRvIHN0YXJ0IHdoaWxlICVzIHRpbWVyIGlzIHN0aWxsIGluICcgKyAncHJvZ3Jlc3MgZm9yICVzIGluc3RhbmNlLicsIHRpbWVyVHlwZSwgY3VycmVudFRpbWVyVHlwZSB8fCAnbm8nLCBkZWJ1Z0lEID09PSBjdXJyZW50VGltZXJEZWJ1Z0lEID8gJ3RoZSBzYW1lJyA6ICdhbm90aGVyJykgOiB2b2lkIDA7XG4gICAgbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQgPSB0cnVlO1xuICB9XG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSAwO1xuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gZGVidWdJRDtcbiAgY3VycmVudFRpbWVyVHlwZSA9IHRpbWVyVHlwZTtcbn1cblxuZnVuY3Rpb24gZW5kTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gIGlmIChjdXJyZW50Rmx1c2hOZXN0aW5nID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChjdXJyZW50VGltZXJUeXBlICE9PSB0aW1lclR5cGUgJiYgIWxpZmVDeWNsZVRpbWVySGFzV2FybmVkKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGVyZSBpcyBhbiBpbnRlcm5hbCBlcnJvciBpbiB0aGUgUmVhY3QgcGVyZm9ybWFuY2UgbWVhc3VyZW1lbnQgY29kZS4gJyArICdXZSBkaWQgbm90IGV4cGVjdCAlcyB0aW1lciB0byBzdG9wIHdoaWxlICVzIHRpbWVyIGlzIHN0aWxsIGluICcgKyAncHJvZ3Jlc3MgZm9yICVzIGluc3RhbmNlLiBQbGVhc2UgcmVwb3J0IHRoaXMgYXMgYSBidWcgaW4gUmVhY3QuJywgdGltZXJUeXBlLCBjdXJyZW50VGltZXJUeXBlIHx8ICdubycsIGRlYnVnSUQgPT09IGN1cnJlbnRUaW1lckRlYnVnSUQgPyAndGhlIHNhbWUnIDogJ2Fub3RoZXInKSA6IHZvaWQgMDtcbiAgICBsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCA9IHRydWU7XG4gIH1cbiAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzLnB1c2goe1xuICAgICAgdGltZXJUeXBlOiB0aW1lclR5cGUsXG4gICAgICBpbnN0YW5jZUlEOiBkZWJ1Z0lELFxuICAgICAgZHVyYXRpb246IHBlcmZvcm1hbmNlTm93KCkgLSBjdXJyZW50VGltZXJTdGFydFRpbWUgLSBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uXG4gICAgfSk7XG4gIH1cbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gMDtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBudWxsO1xuICBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGF1c2VDdXJyZW50TGlmZUN5Y2xlVGltZXIoKSB7XG4gIHZhciBjdXJyZW50VGltZXIgPSB7XG4gICAgc3RhcnRUaW1lOiBjdXJyZW50VGltZXJTdGFydFRpbWUsXG4gICAgbmVzdGVkRmx1c2hTdGFydFRpbWU6IHBlcmZvcm1hbmNlTm93KCksXG4gICAgZGVidWdJRDogY3VycmVudFRpbWVyRGVidWdJRCxcbiAgICB0aW1lclR5cGU6IGN1cnJlbnRUaW1lclR5cGVcbiAgfTtcbiAgbGlmZUN5Y2xlVGltZXJTdGFjay5wdXNoKGN1cnJlbnRUaW1lcik7XG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IDA7XG4gIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSAwO1xuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gbnVsbDtcbiAgY3VycmVudFRpbWVyVHlwZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlc3VtZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpIHtcbiAgdmFyIF9saWZlQ3ljbGVUaW1lclN0YWNrJCA9IGxpZmVDeWNsZVRpbWVyU3RhY2sucG9wKCksXG4gICAgICBzdGFydFRpbWUgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQuc3RhcnRUaW1lLFxuICAgICAgbmVzdGVkRmx1c2hTdGFydFRpbWUgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQubmVzdGVkRmx1c2hTdGFydFRpbWUsXG4gICAgICBkZWJ1Z0lEID0gX2xpZmVDeWNsZVRpbWVyU3RhY2skLmRlYnVnSUQsXG4gICAgICB0aW1lclR5cGUgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQudGltZXJUeXBlO1xuXG4gIHZhciBuZXN0ZWRGbHVzaER1cmF0aW9uID0gcGVyZm9ybWFuY2VOb3coKSAtIG5lc3RlZEZsdXNoU3RhcnRUaW1lO1xuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gKz0gbmVzdGVkRmx1c2hEdXJhdGlvbjtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IGRlYnVnSUQ7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSB0aW1lclR5cGU7XG59XG5cbnZhciBsYXN0TWFya1RpbWVTdGFtcCA9IDA7XG52YXIgY2FuVXNlUGVyZm9ybWFuY2VNZWFzdXJlID1cbi8vICRGbG93Rml4TWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzIzNDVcbnR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMgPT09ICdmdW5jdGlvbic7XG5cbmZ1bmN0aW9uIHNob3VsZE1hcmsoZGVidWdJRCkge1xuICBpZiAoIWlzUHJvZmlsaW5nIHx8ICFjYW5Vc2VQZXJmb3JtYW5jZU1lYXN1cmUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoZGVidWdJRCk7XG4gIGlmIChlbGVtZW50ID09IG51bGwgfHwgdHlwZW9mIGVsZW1lbnQgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpc0hvc3RFbGVtZW50ID0gdHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZyc7XG4gIGlmIChpc0hvc3RFbGVtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtYXJrQmVnaW4oZGVidWdJRCwgbWFya1R5cGUpIHtcbiAgaWYgKCFzaG91bGRNYXJrKGRlYnVnSUQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1hcmtOYW1lID0gZGVidWdJRCArICc6OicgKyBtYXJrVHlwZTtcbiAgbGFzdE1hcmtUaW1lU3RhbXAgPSBwZXJmb3JtYW5jZU5vdygpO1xuICBwZXJmb3JtYW5jZS5tYXJrKG1hcmtOYW1lKTtcbn1cblxuZnVuY3Rpb24gbWFya0VuZChkZWJ1Z0lELCBtYXJrVHlwZSkge1xuICBpZiAoIXNob3VsZE1hcmsoZGVidWdJRCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbWFya05hbWUgPSBkZWJ1Z0lEICsgJzo6JyArIG1hcmtUeXBlO1xuICB2YXIgZGlzcGxheU5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGRlYnVnSUQpIHx8ICdVbmtub3duJztcblxuICAvLyBDaHJvbWUgaGFzIGFuIGlzc3VlIG9mIGRyb3BwaW5nIG1hcmtlcnMgcmVjb3JkZWQgdG9vIGZhc3Q6XG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTY0MDY1MlxuICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzLCB3ZSB3aWxsIG5vdCByZXBvcnQgdmVyeSBzbWFsbCBtZWFzdXJlbWVudHMuXG4gIC8vIEkgZGV0ZXJtaW5lZCB0aGUgbWFnaWMgbnVtYmVyIGJ5IHR3ZWFraW5nIGl0IGJhY2sgYW5kIGZvcnRoLlxuICAvLyAwLjA1bXMgd2FzIGVub3VnaCB0byBwcmV2ZW50IHRoZSBpc3N1ZSwgYnV0IEkgc2V0IGl0IHRvIDAuMW1zIHRvIGJlIHNhZmUuXG4gIC8vIFdoZW4gdGhlIGJ1ZyBpcyBmaXhlZCwgd2UgY2FuIGBtZWFzdXJlKClgIHVuY29uZGl0aW9uYWxseSBpZiB3ZSB3YW50IHRvLlxuICB2YXIgdGltZVN0YW1wID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgaWYgKHRpbWVTdGFtcCAtIGxhc3RNYXJrVGltZVN0YW1wID4gMC4xKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50TmFtZSA9IGRpc3BsYXlOYW1lICsgJyBbJyArIG1hcmtUeXBlICsgJ10nO1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUobWVhc3VyZW1lbnROYW1lLCBtYXJrTmFtZSk7XG4gIH1cblxuICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKG1hcmtOYW1lKTtcbiAgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhtZWFzdXJlbWVudE5hbWUpO1xufVxuXG52YXIgUmVhY3REZWJ1Z1Rvb2wgPSB7XG4gIGFkZEhvb2s6IGZ1bmN0aW9uIChob29rKSB7XG4gICAgaG9va3MucHVzaChob29rKTtcbiAgfSxcbiAgcmVtb3ZlSG9vazogZnVuY3Rpb24gKGhvb2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaG9va3NbaV0gPT09IGhvb2spIHtcbiAgICAgICAgaG9va3Muc3BsaWNlKGksIDEpO1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBpc1Byb2ZpbGluZzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc1Byb2ZpbGluZztcbiAgfSxcbiAgYmVnaW5Qcm9maWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpc1Byb2ZpbGluZyA9IHRydWU7XG4gICAgZmx1c2hIaXN0b3J5Lmxlbmd0aCA9IDA7XG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICBSZWFjdERlYnVnVG9vbC5hZGRIb29rKFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rKTtcbiAgfSxcbiAgZW5kUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpc1Byb2ZpbGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlzUHJvZmlsaW5nID0gZmFsc2U7XG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICBSZWFjdERlYnVnVG9vbC5yZW1vdmVIb29rKFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rKTtcbiAgfSxcbiAgZ2V0Rmx1c2hIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZsdXNoSGlzdG9yeTtcbiAgfSxcbiAgb25CZWdpbkZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgY3VycmVudEZsdXNoTmVzdGluZysrO1xuICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgcGF1c2VDdXJyZW50TGlmZUN5Y2xlVGltZXIoKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5GbHVzaCcpO1xuICB9LFxuICBvbkVuZEZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICBjdXJyZW50Rmx1c2hOZXN0aW5nLS07XG4gICAgcmVzdW1lQ3VycmVudExpZmVDeWNsZVRpbWVyKCk7XG4gICAgZW1pdEV2ZW50KCdvbkVuZEZsdXNoJyk7XG4gIH0sXG4gIG9uQmVnaW5MaWZlQ3ljbGVUaW1lcjogZnVuY3Rpb24gKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5MaWZlQ3ljbGVUaW1lcicsIGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gICAgbWFya0JlZ2luKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gICAgYmVnaW5MaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICB9LFxuICBvbkVuZExpZmVDeWNsZVRpbWVyOiBmdW5jdGlvbiAoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVuZExpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gICAgbWFya0VuZChkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICAgIGVtaXRFdmVudCgnb25FbmRMaWZlQ3ljbGVUaW1lcicsIGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gIH0sXG4gIG9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgZW1pdEV2ZW50KCdvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCcpO1xuICB9LFxuICBvbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCcpO1xuICB9LFxuICBvbkhvc3RPcGVyYXRpb246IGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICBjaGVja0RlYnVnSUQob3BlcmF0aW9uLmluc3RhbmNlSUQpO1xuICAgIGVtaXRFdmVudCgnb25Ib3N0T3BlcmF0aW9uJywgb3BlcmF0aW9uKTtcbiAgfSxcbiAgb25TZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25TZXRTdGF0ZScpO1xuICB9LFxuICBvblNldENoaWxkcmVuOiBmdW5jdGlvbiAoZGVidWdJRCwgY2hpbGREZWJ1Z0lEcykge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBjaGlsZERlYnVnSURzLmZvckVhY2goY2hlY2tEZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uU2V0Q2hpbGRyZW4nLCBkZWJ1Z0lELCBjaGlsZERlYnVnSURzKTtcbiAgfSxcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQsIHBhcmVudERlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgY2hlY2tEZWJ1Z0lEKHBhcmVudERlYnVnSUQsIHRydWUpO1xuICAgIGVtaXRFdmVudCgnb25CZWZvcmVNb3VudENvbXBvbmVudCcsIGRlYnVnSUQsIGVsZW1lbnQsIHBhcmVudERlYnVnSUQpO1xuICAgIG1hcmtCZWdpbihkZWJ1Z0lELCAnbW91bnQnKTtcbiAgfSxcbiAgb25Nb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgbWFya0VuZChkZWJ1Z0lELCAnbW91bnQnKTtcbiAgICBlbWl0RXZlbnQoJ29uTW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25CZWZvcmVVcGRhdGVDb21wb25lbnQnLCBkZWJ1Z0lELCBlbGVtZW50KTtcbiAgICBtYXJrQmVnaW4oZGVidWdJRCwgJ3VwZGF0ZScpO1xuICB9LFxuICBvblVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgbWFya0VuZChkZWJ1Z0lELCAndXBkYXRlJyk7XG4gICAgZW1pdEV2ZW50KCdvblVwZGF0ZUNvbXBvbmVudCcsIGRlYnVnSUQpO1xuICB9LFxuICBvbkJlZm9yZVVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25CZWZvcmVVbm1vdW50Q29tcG9uZW50JywgZGVidWdJRCk7XG4gICAgbWFya0JlZ2luKGRlYnVnSUQsICd1bm1vdW50Jyk7XG4gIH0sXG4gIG9uVW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgbWFya0VuZChkZWJ1Z0lELCAndW5tb3VudCcpO1xuICAgIGVtaXRFdmVudCgnb25Vbm1vdW50Q29tcG9uZW50JywgZGVidWdJRCk7XG4gIH0sXG4gIG9uVGVzdEV2ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgZW1pdEV2ZW50KCdvblRlc3RFdmVudCcpO1xuICB9XG59O1xuXG4vLyBUT0RPIHJlbW92ZSB0aGVzZSB3aGVuIFJOL3d3dyBnZXRzIHVwZGF0ZWRcblJlYWN0RGVidWdUb29sLmFkZERldnRvb2wgPSBSZWFjdERlYnVnVG9vbC5hZGRIb29rO1xuUmVhY3REZWJ1Z1Rvb2wucmVtb3ZlRGV2dG9vbCA9IFJlYWN0RGVidWdUb29sLnJlbW92ZUhvb2s7XG5cblJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vayk7XG5SZWFjdERlYnVnVG9vbC5hZGRIb29rKFJlYWN0Q29tcG9uZW50VHJlZUhvb2spO1xudmFyIHVybCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cubG9jYXRpb24uaHJlZiB8fCAnJztcbmlmICgvWz8mXXJlYWN0X3BlcmZcXGIvLnRlc3QodXJsKSkge1xuICBSZWFjdERlYnVnVG9vbC5iZWdpblByb2ZpbGluZygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVidWdUb29sO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdERlYnVnVG9vbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5JbnZhbGlkU2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIXByb2Nlc3NpbmdDaGlsZENvbnRleHQsICdzZXRTdGF0ZSguLi4pOiBDYW5ub3QgY2FsbCBzZXRTdGF0ZSgpIGluc2lkZSBnZXRDaGlsZENvbnRleHQoKScpIDogdm9pZCAwO1xuICB9O1xufVxuXG52YXIgUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vayA9IHtcbiAgb25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcbiAgfSxcbiAgb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCA9IGZhbHNlO1xuICB9LFxuICBvblNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgd2FybkludmFsaWRTZXRTdGF0ZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2s7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2suanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoaXN0b3J5ID0gW107XG5cbnZhciBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayA9IHtcbiAgb25Ib3N0T3BlcmF0aW9uOiBmdW5jdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgaGlzdG9yeS5wdXNoKG9wZXJhdGlvbik7XG4gIH0sXG4gIGNsZWFySGlzdG9yeTogZnVuY3Rpb24gKCkge1xuICAgIGlmIChSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5fcHJldmVudENsZWFyaW5nKSB7XG4gICAgICAvLyBTaG91bGQgb25seSBiZSB1c2VkIGZvciB0ZXN0cy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoaXN0b3J5ID0gW107XG4gIH0sXG4gIGdldEhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaGlzdG9yeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vaztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBwZXJmb3JtYW5jZSA9IHJlcXVpcmUoJy4vcGVyZm9ybWFuY2UnKTtcblxudmFyIHBlcmZvcm1hbmNlTm93O1xuXG4vKipcbiAqIERldGVjdCBpZiB3ZSBjYW4gdXNlIGB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClgIGFuZCBncmFjZWZ1bGx5IGZhbGxiYWNrIHRvXG4gKiBgRGF0ZS5ub3coKWAgaWYgaXQgZG9lc24ndCBleGlzdC4gV2UgbmVlZCB0byBzdXBwb3J0IEZpcmVmb3ggPCAxNSBmb3Igbm93XG4gKiBiZWNhdXNlIG9mIEZhY2Vib29rJ3MgdGVzdGluZyBpbmZyYXN0cnVjdHVyZS5cbiAqL1xuaWYgKHBlcmZvcm1hbmNlLm5vdykge1xuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uIHBlcmZvcm1hbmNlTm93KCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gcGVyZm9ybWFuY2VOb3coKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2VOb3c7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9mYmpzL2xpYi9wZXJmb3JtYW5jZU5vdy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgcGVyZm9ybWFuY2U7XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2UgfHwgd2luZG93Lm1zUGVyZm9ybWFuY2UgfHwgd2luZG93LndlYmtpdFBlcmZvcm1hbmNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlIHx8IHt9O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZmJqcy9saWIvcGVyZm9ybWFuY2UuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIE9CU0VSVkVEX0VSUk9SID0ge307XG5cbi8qKlxuICogYFRyYW5zYWN0aW9uYCBjcmVhdGVzIGEgYmxhY2sgYm94IHRoYXQgaXMgYWJsZSB0byB3cmFwIGFueSBtZXRob2Qgc3VjaCB0aGF0XG4gKiBjZXJ0YWluIGludmFyaWFudHMgYXJlIG1haW50YWluZWQgYmVmb3JlIGFuZCBhZnRlciB0aGUgbWV0aG9kIGlzIGludm9rZWRcbiAqIChFdmVuIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gd2hpbGUgaW52b2tpbmcgdGhlIHdyYXBwZWQgbWV0aG9kKS4gV2hvZXZlclxuICogaW5zdGFudGlhdGVzIGEgdHJhbnNhY3Rpb24gY2FuIHByb3ZpZGUgZW5mb3JjZXJzIG9mIHRoZSBpbnZhcmlhbnRzIGF0XG4gKiBjcmVhdGlvbiB0aW1lLiBUaGUgYFRyYW5zYWN0aW9uYCBjbGFzcyBpdHNlbGYgd2lsbCBzdXBwbHkgb25lIGFkZGl0aW9uYWxcbiAqIGF1dG9tYXRpYyBpbnZhcmlhbnQgZm9yIHlvdSAtIHRoZSBpbnZhcmlhbnQgdGhhdCBhbnkgdHJhbnNhY3Rpb24gaW5zdGFuY2VcbiAqIHNob3VsZCBub3QgYmUgcnVuIHdoaWxlIGl0IGlzIGFscmVhZHkgYmVpbmcgcnVuLiBZb3Ugd291bGQgdHlwaWNhbGx5IGNyZWF0ZSBhXG4gKiBzaW5nbGUgaW5zdGFuY2Ugb2YgYSBgVHJhbnNhY3Rpb25gIGZvciByZXVzZSBtdWx0aXBsZSB0aW1lcywgdGhhdCBwb3RlbnRpYWxseVxuICogaXMgdXNlZCB0byB3cmFwIHNldmVyYWwgZGlmZmVyZW50IG1ldGhvZHMuIFdyYXBwZXJzIGFyZSBleHRyZW1lbHkgc2ltcGxlIC1cbiAqIHRoZXkgb25seSByZXF1aXJlIGltcGxlbWVudGluZyB0d28gbWV0aG9kcy5cbiAqXG4gKiA8cHJlPlxuICogICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXJzIChpbmplY3RlZCBhdCBjcmVhdGlvbiB0aW1lKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgICAgICAgICtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHYgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgKy0tLS0tLS0tLS0tLS0tLSsgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICstLXwgICAgd3JhcHBlcjEgICB8LS0tfC0tLS0rICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICArLS0tLS0tLS0tLS0tLS0tKyAgIHYgICAgfCAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgICAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICstLS0tfCAgIHdyYXBwZXIyICB8LS0tLS0tLS0rICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgfCAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHYgICAgIHYgICAgICAgICAgICAgICAgICAgICB2ICAgICB2ICAgfCB3cmFwcGVyXG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfCBpbnZhcmlhbnRzXG4gKiBwZXJmb3JtKGFueU1ldGhvZCkgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfCBtYWludGFpbmVkXG4gKiArLS0tLS0tLS0tLS0tLS0tLS0+fC18LS0tfC18LS0tfC0tPnxhbnlNZXRob2R8LS0tfC0tLXwtfC0tLXwtfC0tLS0tLS0tPlxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICBpbml0aWFsaXplICAgICAgICAgICAgICAgICAgICBjbG9zZSAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogPC9wcmU+XG4gKlxuICogVXNlIGNhc2VzOlxuICogLSBQcmVzZXJ2aW5nIHRoZSBpbnB1dCBzZWxlY3Rpb24gcmFuZ2VzIGJlZm9yZS9hZnRlciByZWNvbmNpbGlhdGlvbi5cbiAqICAgUmVzdG9yaW5nIHNlbGVjdGlvbiBldmVuIGluIHRoZSBldmVudCBvZiBhbiB1bmV4cGVjdGVkIGVycm9yLlxuICogLSBEZWFjdGl2YXRpbmcgZXZlbnRzIHdoaWxlIHJlYXJyYW5naW5nIHRoZSBET00sIHByZXZlbnRpbmcgYmx1cnMvZm9jdXNlcyxcbiAqICAgd2hpbGUgZ3VhcmFudGVlaW5nIHRoYXQgYWZ0ZXJ3YXJkcywgdGhlIGV2ZW50IHN5c3RlbSBpcyByZWFjdGl2YXRlZC5cbiAqIC0gRmx1c2hpbmcgYSBxdWV1ZSBvZiBjb2xsZWN0ZWQgRE9NIG11dGF0aW9ucyB0byB0aGUgbWFpbiBVSSB0aHJlYWQgYWZ0ZXIgYVxuICogICByZWNvbmNpbGlhdGlvbiB0YWtlcyBwbGFjZSBpbiBhIHdvcmtlciB0aHJlYWQuXG4gKiAtIEludm9raW5nIGFueSBjb2xsZWN0ZWQgYGNvbXBvbmVudERpZFVwZGF0ZWAgY2FsbGJhY2tzIGFmdGVyIHJlbmRlcmluZyBuZXdcbiAqICAgY29udGVudC5cbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IFdyYXBwaW5nIHBhcnRpY3VsYXIgZmx1c2hlcyBvZiB0aGUgYFJlYWN0V29ya2VyYCBxdWV1ZVxuICogICB0byBwcmVzZXJ2ZSB0aGUgYHNjcm9sbFRvcGAgKGFuIGF1dG9tYXRpYyBzY3JvbGwgYXdhcmUgRE9NKS5cbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IExheW91dCBjYWxjdWxhdGlvbnMgYmVmb3JlIGFuZCBhZnRlciBET00gdXBkYXRlcy5cbiAqXG4gKiBUcmFuc2FjdGlvbmFsIHBsdWdpbiBBUEk6XG4gKiAtIEEgbW9kdWxlIHRoYXQgaGFzIGFuIGBpbml0aWFsaXplYCBtZXRob2QgdGhhdCByZXR1cm5zIGFueSBwcmVjb21wdXRhdGlvbi5cbiAqIC0gYW5kIGEgYGNsb3NlYCBtZXRob2QgdGhhdCBhY2NlcHRzIHRoZSBwcmVjb21wdXRhdGlvbi4gYGNsb3NlYCBpcyBpbnZva2VkXG4gKiAgIHdoZW4gdGhlIHdyYXBwZWQgcHJvY2VzcyBpcyBjb21wbGV0ZWQsIG9yIGhhcyBmYWlsZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxUcmFuc2FjdGlvbmFsV3JhcHBlcj59IHRyYW5zYWN0aW9uV3JhcHBlciBXcmFwcGVyIG1vZHVsZXNcbiAqIHRoYXQgaW1wbGVtZW50IGBpbml0aWFsaXplYCBhbmQgYGNsb3NlYC5cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSBTaW5nbGUgdHJhbnNhY3Rpb24gZm9yIHJldXNlIGluIHRocmVhZC5cbiAqXG4gKiBAY2xhc3MgVHJhbnNhY3Rpb25cbiAqL1xudmFyIFRyYW5zYWN0aW9uSW1wbCA9IHtcbiAgLyoqXG4gICAqIFNldHMgdXAgdGhpcyBpbnN0YW5jZSBzbyB0aGF0IGl0IGlzIHByZXBhcmVkIGZvciBjb2xsZWN0aW5nIG1ldHJpY3MuIERvZXNcbiAgICogc28gc3VjaCB0aGF0IHRoaXMgc2V0dXAgbWV0aG9kIG1heSBiZSB1c2VkIG9uIGFuIGluc3RhbmNlIHRoYXQgaXMgYWxyZWFkeVxuICAgKiBpbml0aWFsaXplZCwgaW4gYSB3YXkgdGhhdCBkb2VzIG5vdCBjb25zdW1lIGFkZGl0aW9uYWwgbWVtb3J5IHVwb24gcmV1c2UuXG4gICAqIFRoYXQgY2FuIGJlIHVzZWZ1bCBpZiB5b3UgZGVjaWRlIHRvIG1ha2UgeW91ciBzdWJjbGFzcyBvZiB0aGlzIG1peGluIGFcbiAgICogXCJQb29sZWRDbGFzc1wiLlxuICAgKi9cbiAgcmVpbml0aWFsaXplVHJhbnNhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLmdldFRyYW5zYWN0aW9uV3JhcHBlcnMoKTtcbiAgICBpZiAodGhpcy53cmFwcGVySW5pdERhdGEpIHtcbiAgICAgIHRoaXMud3JhcHBlckluaXREYXRhLmxlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud3JhcHBlckluaXREYXRhID0gW107XG4gICAgfVxuICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IGZhbHNlO1xuICB9LFxuXG4gIF9pc0luVHJhbnNhY3Rpb246IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7QXJyYXk8VHJhbnNhY3Rpb25XcmFwcGVyPn0gQXJyYXkgb2YgdHJhbnNhY3Rpb24gd3JhcHBlcnMuXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBudWxsLFxuXG4gIGlzSW5UcmFuc2FjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2lzSW5UcmFuc2FjdGlvbjtcbiAgfSxcblxuICAvKipcbiAgICogRXhlY3V0ZXMgdGhlIGZ1bmN0aW9uIHdpdGhpbiBhIHNhZmV0eSB3aW5kb3cuIFVzZSB0aGlzIGZvciB0aGUgdG9wIGxldmVsXG4gICAqIG1ldGhvZHMgdGhhdCByZXN1bHQgaW4gbGFyZ2UgYW1vdW50cyBvZiBjb21wdXRhdGlvbi9tdXRhdGlvbnMgdGhhdCB3b3VsZFxuICAgKiBuZWVkIHRvIGJlIHNhZmV0eSBjaGVja2VkLiBUaGUgb3B0aW9uYWwgYXJndW1lbnRzIGhlbHBzIHByZXZlbnQgdGhlIG5lZWRcbiAgICogdG8gYmluZCBpbiBtYW55IGNhc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgTWVtYmVyIG9mIHNjb3BlIHRvIGNhbGwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBTY29wZSB0byBpbnZva2UgZnJvbS5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYSBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGIgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBjIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZCBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGUgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBmIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICpcbiAgICogQHJldHVybiB7Kn0gUmV0dXJuIHZhbHVlIGZyb20gYG1ldGhvZGAuXG4gICAqL1xuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgICEhdGhpcy5pc0luVHJhbnNhY3Rpb24oKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcmFuc2FjdGlvbi5wZXJmb3JtKC4uLik6IENhbm5vdCBpbml0aWFsaXplIGEgdHJhbnNhY3Rpb24gd2hlbiB0aGVyZSBpcyBhbHJlYWR5IGFuIG91dHN0YW5kaW5nIHRyYW5zYWN0aW9uLicpIDogX3Byb2RJbnZhcmlhbnQoJzI3JykgOiB2b2lkIDA7XG4gICAgdmFyIGVycm9yVGhyb3duO1xuICAgIHZhciByZXQ7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgLy8gb25lIG9mIHRoZXNlIGNhbGxzIHRocmV3LlxuICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdGhpcy5pbml0aWFsaXplQWxsKDApO1xuICAgICAgcmV0ID0gbWV0aG9kLmNhbGwoc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gSWYgYG1ldGhvZGAgdGhyb3dzLCBwcmVmZXIgdG8gc2hvdyB0aGF0IHN0YWNrIHRyYWNlIG92ZXIgYW55IHRocm93blxuICAgICAgICAgIC8vIGJ5IGludm9raW5nIGBjbG9zZUFsbGAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNpbmNlIGBtZXRob2RgIGRpZG4ndCB0aHJvdywgd2UgZG9uJ3Qgd2FudCB0byBzaWxlbmNlIHRoZSBleGNlcHRpb25cbiAgICAgICAgICAvLyBoZXJlLlxuICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIGluaXRpYWxpemVBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoIHRoZVxuICAgICAgICAvLyBPQlNFUlZFRF9FUlJPUiBzdGF0ZSBiZWZvcmUgb3ZlcndyaXRpbmcgaXQgd2l0aCB0aGUgcmVhbCByZXR1cm4gdmFsdWVcbiAgICAgICAgLy8gb2YgaW5pdGlhbGl6ZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byBPQlNFUlZFRF9FUlJPUiBpbiB0aGUgZmluYWxseVxuICAgICAgICAvLyBibG9jaywgaXQgbWVhbnMgd3JhcHBlci5pbml0aWFsaXplIHRocmV3LlxuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IE9CU0VSVkVEX0VSUk9SO1xuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IHdyYXBwZXIuaW5pdGlhbGl6ZSA/IHdyYXBwZXIuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpIDogbnVsbDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9PT0gT0JTRVJWRURfRVJST1IpIHtcbiAgICAgICAgICAvLyBUaGUgaW5pdGlhbGl6ZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgaW5pdGlhbGl6ZSB0aGVcbiAgICAgICAgICAvLyByZW1haW5pbmcgd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZVxuICAgICAgICAgIC8vIHRoYXQgdGhlIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlcyBlYWNoIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuY2xvc2VbaV1gIGZ1bmN0aW9ucywgcGFzc2luZyBpbnRvXG4gICAqIHRoZW0gdGhlIHJlc3BlY3RpdmUgcmV0dXJuIHZhbHVlcyBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmluaXRbaV1gXG4gICAqIChgY2xvc2VgcnMgdGhhdCBjb3JyZXNwb25kIHRvIGluaXRpYWxpemVycyB0aGF0IGZhaWxlZCB3aWxsIG5vdCBiZVxuICAgKiBpbnZva2VkKS5cbiAgICovXG4gIGNsb3NlQWxsOiBmdW5jdGlvbiAoc3RhcnRJbmRleCkge1xuICAgICF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLmNsb3NlQWxsKCk6IENhbm5vdCBjbG9zZSB0cmFuc2FjdGlvbiB3aGVuIG5vbmUgYXJlIG9wZW4uJykgOiBfcHJvZEludmFyaWFudCgnMjgnKSA6IHZvaWQgMDtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHZhciBpbml0RGF0YSA9IHRoaXMud3JhcHBlckluaXREYXRhW2ldO1xuICAgICAgdmFyIGVycm9yVGhyb3duO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aFxuICAgICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAgIC8vIHdyYXBwZXIuY2xvc2UgdGhyZXcuXG4gICAgICAgIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluaXREYXRhICE9PSBPQlNFUlZFRF9FUlJPUiAmJiB3cmFwcGVyLmNsb3NlKSB7XG4gICAgICAgICAgd3JhcHBlci5jbG9zZS5jYWxsKHRoaXMsIGluaXREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gVGhlIGNsb3NlciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBjbG9zZSB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgLy8gd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZSB0aGF0IHRoZVxuICAgICAgICAgIC8vIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKGkgKyAxKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMud3JhcHBlckluaXREYXRhLmxlbmd0aCA9IDA7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb25JbXBsO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9UcmFuc2FjdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgdGFyZ2V0IG5vZGUgZnJvbSBhIG5hdGl2ZSBicm93c2VyIGV2ZW50IGJ5IGFjY291bnRpbmcgZm9yXG4gKiBpbmNvbnNpc3RlbmNpZXMgaW4gYnJvd3NlciBET00gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gVGFyZ2V0IG5vZGUuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcblxuICAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH1cblxuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSAzID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRUYXJnZXQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2dldEV2ZW50VGFyZ2V0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHVzZUhhc0ZlYXR1cmU7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gIC8vIGFsd2F5cyByZXR1cm5zIHRydWUgaW4gbmV3ZXIgYnJvd3NlcnMgYXMgcGVyIHRoZSBzdGFuZGFyZC5cbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFdmVudFN1cHBvcnRlZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvaXNFdmVudFN1cHBvcnRlZC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1pbnB1dC1lbGVtZW50Lmh0bWwjaW5wdXQtdHlwZS1hdHRyLXN1bW1hcnlcbiAqL1xuXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgJ2NvbG9yJzogdHJ1ZSxcbiAgJ2RhdGUnOiB0cnVlLFxuICAnZGF0ZXRpbWUnOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICAnZW1haWwnOiB0cnVlLFxuICAnbW9udGgnOiB0cnVlLFxuICAnbnVtYmVyJzogdHJ1ZSxcbiAgJ3Bhc3N3b3JkJzogdHJ1ZSxcbiAgJ3JhbmdlJzogdHJ1ZSxcbiAgJ3NlYXJjaCc6IHRydWUsXG4gICd0ZWwnOiB0cnVlLFxuICAndGV4dCc6IHRydWUsXG4gICd0aW1lJzogdHJ1ZSxcbiAgJ3VybCc6IHRydWUsXG4gICd3ZWVrJzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gaXNUZXh0SW5wdXRFbGVtZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdpbnB1dCcpIHtcbiAgICByZXR1cm4gISFzdXBwb3J0ZWRJbnB1dFR5cGVzW2VsZW0udHlwZV07XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICd0ZXh0YXJlYScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHRJbnB1dEVsZW1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2lzVGV4dElucHV0RWxlbWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cblxudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gWydSZXNwb25kZXJFdmVudFBsdWdpbicsICdTaW1wbGVFdmVudFBsdWdpbicsICdUYXBFdmVudFBsdWdpbicsICdFbnRlckxlYXZlRXZlbnRQbHVnaW4nLCAnQ2hhbmdlRXZlbnRQbHVnaW4nLCAnU2VsZWN0RXZlbnRQbHVnaW4nLCAnQmVmb3JlSW5wdXRFdmVudFBsdWdpbiddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRFdmVudFBsdWdpbk9yZGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBtb3VzZUVudGVyOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VFbnRlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH0sXG4gIG1vdXNlTGVhdmU6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Nb3VzZUxlYXZlJyxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wTW91c2VPdXQnLCAndG9wTW91c2VPdmVyJ11cbiAgfVxufTtcblxudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxuICAgKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXG4gICAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdmVyJyAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxUeXBlICE9PSAndG9wTW91c2VPdXQnICYmIHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3ZlcicpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2UgaW4gb3IgbW91c2Ugb3V0IC0gaWdub3JpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2luO1xuICAgIGlmIChuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICAgIHdpbiA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZU91dCcpIHtcbiAgICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgICAgdmFyIHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcbiAgICAgIHRvID0gcmVsYXRlZCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgICBmcm9tID0gbnVsbDtcbiAgICAgIHRvID0gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmcm9tTm9kZSA9IGZyb20gPT0gbnVsbCA/IHdpbiA6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGZyb20pO1xuICAgIHZhciB0b05vZGUgPSB0byA9PSBudWxsID8gd2luIDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodG8pO1xuXG4gICAgdmFyIGxlYXZlID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5tb3VzZUxlYXZlLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGxlYXZlLnR5cGUgPSAnbW91c2VsZWF2ZSc7XG4gICAgbGVhdmUudGFyZ2V0ID0gZnJvbU5vZGU7XG4gICAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvTm9kZTtcblxuICAgIHZhciBlbnRlciA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VFbnRlciwgdG8sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0b05vZGU7XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG5cbiAgICByZXR1cm4gW2xlYXZlLCBlbnRlcl07XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbnRlckxlYXZlRXZlbnRQbHVnaW47XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL0VudGVyTGVhdmVFdmVudFBsdWdpbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG52YXIgVmlld3BvcnRNZXRyaWNzID0gcmVxdWlyZSgnLi9WaWV3cG9ydE1ldHJpY3MnKTtcblxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIE1vdXNlRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHNjcmVlblg6IG51bGwsXG4gIHNjcmVlblk6IG51bGwsXG4gIGNsaWVudFg6IG51bGwsXG4gIGNsaWVudFk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBXZWJraXQsIEZpcmVmb3gsIElFOStcbiAgICAvLyB3aGljaDogIDEgMiAzXG4gICAgLy8gYnV0dG9uOiAwIDEgMiAoc3RhbmRhcmQpXG4gICAgdmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcbiAgICBpZiAoJ3doaWNoJyBpbiBldmVudCkge1xuICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG4gICAgLy8gSUU8OVxuICAgIC8vIHdoaWNoOiAgdW5kZWZpbmVkXG4gICAgLy8gYnV0dG9uOiAwIDAgMFxuICAgIC8vIGJ1dHRvbjogMSA0IDIgKG9ubW91c2V1cClcbiAgICByZXR1cm4gYnV0dG9uID09PSAyID8gMiA6IGJ1dHRvbiA9PT0gNCA/IDEgOiAwO1xuICB9LFxuICBidXR0b25zOiBudWxsLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCAoZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudCk7XG4gIH0sXG4gIC8vIFwiUHJvcHJpZXRhcnlcIiBJbnRlcmZhY2UuXG4gIHBhZ2VYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ3BhZ2VYJyBpbiBldmVudCA/IGV2ZW50LnBhZ2VYIDogZXZlbnQuY2xpZW50WCArIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdDtcbiAgfSxcbiAgcGFnZVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAncGFnZVknIGluIGV2ZW50ID8gZXZlbnQucGFnZVkgOiBldmVudC5jbGllbnRZICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3A7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY01vdXNlRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY01vdXNlRXZlbnQsIE1vdXNlRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY01vdXNlRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFVJRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgVUlFdmVudEludGVyZmFjZSA9IHtcbiAgdmlldzogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnZpZXcpIHtcbiAgICAgIHJldHVybiBldmVudC52aWV3O1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgaWYgKHRhcmdldC53aW5kb3cgPT09IHRhcmdldCkge1xuICAgICAgLy8gdGFyZ2V0IGlzIGEgd2luZG93IG9iamVjdFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICB2YXIgZG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgIGlmIChkb2MpIHtcbiAgICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gIH0sXG4gIGRldGFpbDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmRldGFpbCB8fCAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVUlFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNVSUV2ZW50LCBVSUV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNVSUV2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFZpZXdwb3J0TWV0cmljcyA9IHtcblxuICBjdXJyZW50U2Nyb2xsTGVmdDogMCxcblxuICBjdXJyZW50U2Nyb2xsVG9wOiAwLFxuXG4gIHJlZnJlc2hTY3JvbGxWYWx1ZXM6IGZ1bmN0aW9uIChzY3JvbGxQb3NpdGlvbikge1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdCA9IHNjcm9sbFBvc2l0aW9uLng7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3AgPSBzY3JvbGxQb3NpdGlvbi55O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnRNZXRyaWNzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9WaWV3cG9ydE1ldHJpY3MuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xuICovXG5cbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgJ0FsdCc6ICdhbHRLZXknLFxuICAnQ29udHJvbCc6ICdjdHJsS2V5JyxcbiAgJ01ldGEnOiAnbWV0YUtleScsXG4gICdTaGlmdCc6ICdzaGlmdEtleSdcbn07XG5cbi8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgZ2V0TW9kaWZpZXJTdGF0ZSBzbyB3ZSBzaW1wbHkgbWFwIGl0IHRvIHRoZSBvbmx5XG4vLyBtb2RpZmllciBrZXlzIGV4cG9zZWQgYnkgdGhlIGV2ZW50IGl0c2VsZiwgZG9lcyBub3Qgc3VwcG9ydCBMb2NrLWtleXMuXG4vLyBDdXJyZW50bHksIGFsbCBtYWpvciBicm93c2VycyBleGNlcHQgQ2hyb21lIHNlZW1zIHRvIHN1cHBvcnQgTG9jay1rZXlzLlxuZnVuY3Rpb24gbW9kaWZpZXJTdGF0ZUdldHRlcihrZXlBcmcpIHtcbiAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gdGhpcztcbiAgdmFyIG5hdGl2ZUV2ZW50ID0gc3ludGhldGljRXZlbnQubmF0aXZlRXZlbnQ7XG4gIGlmIChuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKTtcbiAgfVxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRNb2RpZmllclN0YXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9nZXRFdmVudE1vZGlmaWVyU3RhdGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG5cbnZhciBNVVNUX1VTRV9QUk9QRVJUWSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWTtcbnZhciBIQVNfQk9PTEVBTl9WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG5cbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIGlzQ3VzdG9tQXR0cmlidXRlOiBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZChuZXcgUmVnRXhwKCdeKGRhdGF8YXJpYSktWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpKSxcbiAgUHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFN0YW5kYXJkIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBhY2NlcHQ6IDAsXG4gICAgYWNjZXB0Q2hhcnNldDogMCxcbiAgICBhY2Nlc3NLZXk6IDAsXG4gICAgYWN0aW9uOiAwLFxuICAgIGFsbG93RnVsbFNjcmVlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYWxsb3dUcmFuc3BhcmVuY3k6IDAsXG4gICAgYWx0OiAwLFxuICAgIC8vIHNwZWNpZmllcyB0YXJnZXQgY29udGV4dCBmb3IgbGlua3Mgd2l0aCBgcHJlbG9hZGAgdHlwZVxuICAgIGFzOiAwLFxuICAgIGFzeW5jOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvQ29tcGxldGU6IDAsXG4gICAgLy8gYXV0b0ZvY3VzIGlzIHBvbHlmaWxsZWQvbm9ybWFsaXplZCBieSBBdXRvRm9jdXNVdGlsc1xuICAgIC8vIGF1dG9Gb2N1czogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b1BsYXk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNhcHR1cmU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNlbGxQYWRkaW5nOiAwLFxuICAgIGNlbGxTcGFjaW5nOiAwLFxuICAgIGNoYXJTZXQ6IDAsXG4gICAgY2hhbGxlbmdlOiAwLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2l0ZTogMCxcbiAgICBjbGFzc0lEOiAwLFxuICAgIGNsYXNzTmFtZTogMCxcbiAgICBjb2xzOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBjb2xTcGFuOiAwLFxuICAgIGNvbnRlbnQ6IDAsXG4gICAgY29udGVudEVkaXRhYmxlOiAwLFxuICAgIGNvbnRleHRNZW51OiAwLFxuICAgIGNvbnRyb2xzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjb29yZHM6IDAsXG4gICAgY3Jvc3NPcmlnaW46IDAsXG4gICAgZGF0YTogMCwgLy8gRm9yIGA8b2JqZWN0IC8+YCBhY3RzIGFzIGBzcmNgLlxuICAgIGRhdGVUaW1lOiAwLFxuICAgICdkZWZhdWx0JzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpcjogMCxcbiAgICBkaXNhYmxlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZG93bmxvYWQ6IEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsXG4gICAgZHJhZ2dhYmxlOiAwLFxuICAgIGVuY1R5cGU6IDAsXG4gICAgZm9ybTogMCxcbiAgICBmb3JtQWN0aW9uOiAwLFxuICAgIGZvcm1FbmNUeXBlOiAwLFxuICAgIGZvcm1NZXRob2Q6IDAsXG4gICAgZm9ybU5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGZvcm1UYXJnZXQ6IDAsXG4gICAgZnJhbWVCb3JkZXI6IDAsXG4gICAgaGVhZGVyczogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgaGlkZGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBoaWdoOiAwLFxuICAgIGhyZWY6IDAsXG4gICAgaHJlZkxhbmc6IDAsXG4gICAgaHRtbEZvcjogMCxcbiAgICBodHRwRXF1aXY6IDAsXG4gICAgaWNvbjogMCxcbiAgICBpZDogMCxcbiAgICBpbnB1dE1vZGU6IDAsXG4gICAgaW50ZWdyaXR5OiAwLFxuICAgIGlzOiAwLFxuICAgIGtleVBhcmFtczogMCxcbiAgICBrZXlUeXBlOiAwLFxuICAgIGtpbmQ6IDAsXG4gICAgbGFiZWw6IDAsXG4gICAgbGFuZzogMCxcbiAgICBsaXN0OiAwLFxuICAgIGxvb3A6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGxvdzogMCxcbiAgICBtYW5pZmVzdDogMCxcbiAgICBtYXJnaW5IZWlnaHQ6IDAsXG4gICAgbWFyZ2luV2lkdGg6IDAsXG4gICAgbWF4OiAwLFxuICAgIG1heExlbmd0aDogMCxcbiAgICBtZWRpYTogMCxcbiAgICBtZWRpYUdyb3VwOiAwLFxuICAgIG1ldGhvZDogMCxcbiAgICBtaW46IDAsXG4gICAgbWluTGVuZ3RoOiAwLFxuICAgIC8vIENhdXRpb247IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4gICAgLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC5cbiAgICBtdWx0aXBsZTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBtdXRlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBuYW1lOiAwLFxuICAgIG5vbmNlOiAwLFxuICAgIG5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wdGltdW06IDAsXG4gICAgcGF0dGVybjogMCxcbiAgICBwbGFjZWhvbGRlcjogMCxcbiAgICBwbGF5c0lubGluZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcG9zdGVyOiAwLFxuICAgIHByZWxvYWQ6IDAsXG4gICAgcHJvZmlsZTogMCxcbiAgICByYWRpb0dyb3VwOiAwLFxuICAgIHJlYWRPbmx5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZWZlcnJlclBvbGljeTogMCxcbiAgICByZWw6IDAsXG4gICAgcmVxdWlyZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJldmVyc2VkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByb2xlOiAwLFxuICAgIHJvd3M6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHNhbmRib3g6IDAsXG4gICAgc2NvcGU6IDAsXG4gICAgc2NvcGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzY3JvbGxpbmc6IDAsXG4gICAgc2VhbWxlc3M6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNoYXBlOiAwLFxuICAgIHNpemU6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNpemVzOiAwLFxuICAgIHNwYW46IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNwZWxsQ2hlY2s6IDAsXG4gICAgc3JjOiAwLFxuICAgIHNyY0RvYzogMCxcbiAgICBzcmNMYW5nOiAwLFxuICAgIHNyY1NldDogMCxcbiAgICBzdGFydDogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc3RlcDogMCxcbiAgICBzdHlsZTogMCxcbiAgICBzdW1tYXJ5OiAwLFxuICAgIHRhYkluZGV4OiAwLFxuICAgIHRhcmdldDogMCxcbiAgICB0aXRsZTogMCxcbiAgICAvLyBTZXR0aW5nIC50eXBlIHRocm93cyBvbiBub24tPGlucHV0PiB0YWdzXG4gICAgdHlwZTogMCxcbiAgICB1c2VNYXA6IDAsXG4gICAgdmFsdWU6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgd21vZGU6IDAsXG4gICAgd3JhcDogMCxcblxuICAgIC8qKlxuICAgICAqIFJERmEgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFib3V0OiAwLFxuICAgIGRhdGF0eXBlOiAwLFxuICAgIGlubGlzdDogMCxcbiAgICBwcmVmaXg6IDAsXG4gICAgLy8gcHJvcGVydHkgaXMgYWxzbyBzdXBwb3J0ZWQgZm9yIE9wZW5HcmFwaCBpbiBtZXRhIHRhZ3MuXG4gICAgcHJvcGVydHk6IDAsXG4gICAgcmVzb3VyY2U6IDAsXG4gICAgJ3R5cGVvZic6IDAsXG4gICAgdm9jYWI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBOb24tc3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIC8vIGF1dG9DYXBpdGFsaXplIGFuZCBhdXRvQ29ycmVjdCBhcmUgc3VwcG9ydGVkIGluIE1vYmlsZSBTYWZhcmkgZm9yXG4gICAgLy8ga2V5Ym9hcmQgaGludHMuXG4gICAgYXV0b0NhcGl0YWxpemU6IDAsXG4gICAgYXV0b0NvcnJlY3Q6IDAsXG4gICAgLy8gYXV0b1NhdmUgYWxsb3dzIFdlYktpdC9CbGluayB0byBwZXJzaXN0IHZhbHVlcyBvZiBpbnB1dCBmaWVsZHMgb24gcGFnZSByZWxvYWRzXG4gICAgYXV0b1NhdmU6IDAsXG4gICAgLy8gY29sb3IgaXMgZm9yIFNhZmFyaSBtYXNrLWljb24gbGlua1xuICAgIGNvbG9yOiAwLFxuICAgIC8vIGl0ZW1Qcm9wLCBpdGVtU2NvcGUsIGl0ZW1UeXBlIGFyZSBmb3JcbiAgICAvLyBNaWNyb2RhdGEgc3VwcG9ydC4gU2VlIGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1Qcm9wOiAwLFxuICAgIGl0ZW1TY29wZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaXRlbVR5cGU6IDAsXG4gICAgLy8gaXRlbUlEIGFuZCBpdGVtUmVmIGFyZSBmb3IgTWljcm9kYXRhIHN1cHBvcnQgYXMgd2VsbCBidXRcbiAgICAvLyBvbmx5IHNwZWNpZmllZCBpbiB0aGUgV0hBVFdHIHNwZWMgZG9jdW1lbnQuIFNlZVxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL21pY3JvZGF0YS5odG1sI21pY3JvZGF0YS1kb20tYXBpXG4gICAgaXRlbUlEOiAwLFxuICAgIGl0ZW1SZWY6IDAsXG4gICAgLy8gcmVzdWx0cyBzaG93IGxvb2tpbmcgZ2xhc3MgaWNvbiBhbmQgcmVjZW50IHNlYXJjaGVzIG9uIGlucHV0XG4gICAgLy8gc2VhcmNoIGZpZWxkcyBpbiBXZWJLaXQvQmxpbmtcbiAgICByZXN1bHRzOiAwLFxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgc3BlY2lmaWVzIHNlY3VyaXR5IHJlc3RyaWN0aW9ucyBvbiBhbiBpZnJhbWVcbiAgICAvLyBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgc2FuZGJveCBhdHRyaWJ1dGUgb24gSUU8MTBcbiAgICBzZWN1cml0eTogMCxcbiAgICAvLyBJRS1vbmx5IGF0dHJpYnV0ZSB0aGF0IGNvbnRyb2xzIGZvY3VzIGJlaGF2aW9yXG4gICAgdW5zZWxlY3RhYmxlOiAwXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NUHJvcGVydHlOYW1lczoge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSFRNTERPTVByb3BlcnR5Q29uZmlnO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RET01JRE9wZXJhdGlvbnMnKTtcblxuLyoqXG4gKiBBYnN0cmFjdHMgYXdheSBhbGwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgcmVjb25jaWxlciB0aGF0IHJlcXVpcmVzIGtub3dsZWRnZSBvZlxuICogdGhlIGJyb3dzZXIgY29udGV4dC4gVE9ETzogVGhlc2UgY2FsbGVycyBzaG91bGQgYmUgcmVmYWN0b3JlZCB0byBhdm9pZCB0aGVcbiAqIG5lZWQgZm9yIHRoaXMgaW5qZWN0aW9uLlxuICovXG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSB7XG5cbiAgcHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogUmVhY3RET01JRE9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzLFxuXG4gIHJlcGxhY2VOb2RlV2l0aE1hcmt1cDogRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIERhbmdlciA9IHJlcXVpcmUoJy4vRGFuZ2VyJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xuXG5mdW5jdGlvbiBnZXROb2RlQWZ0ZXIocGFyZW50Tm9kZSwgbm9kZSkge1xuICAvLyBTcGVjaWFsIGNhc2UgZm9yIHRleHQgY29tcG9uZW50cywgd2hpY2ggcmV0dXJuIFtvcGVuLCBjbG9zZV0gY29tbWVudHNcbiAgLy8gZnJvbSBnZXRIb3N0Tm9kZS5cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBub2RlID0gbm9kZVsxXTtcbiAgfVxuICByZXR1cm4gbm9kZSA/IG5vZGUubmV4dFNpYmxpbmcgOiBwYXJlbnROb2RlLmZpcnN0Q2hpbGQ7XG59XG5cbi8qKlxuICogSW5zZXJ0cyBgY2hpbGROb2RlYCBhcyBhIGNoaWxkIG9mIGBwYXJlbnROb2RlYCBhdCB0aGUgYGluZGV4YC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHBhcmVudE5vZGUgUGFyZW50IG5vZGUgaW4gd2hpY2ggdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjaGlsZE5vZGUgQ2hpbGQgbm9kZSB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cbiAqIEBpbnRlcm5hbFxuICovXG52YXIgaW5zZXJ0Q2hpbGRBdCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAvLyBXZSByZWx5IGV4Y2x1c2l2ZWx5IG9uIGBpbnNlcnRCZWZvcmUobm9kZSwgbnVsbClgIGluc3RlYWQgb2YgYWxzbyB1c2luZ1xuICAvLyBgYXBwZW5kQ2hpbGQobm9kZSlgLiAoVXNpbmcgYHVuZGVmaW5lZGAgaXMgbm90IGFsbG93ZWQgYnkgYWxsIGJyb3dzZXJzIHNvXG4gIC8vIHdlIGFyZSBjYXJlZnVsIHRvIHVzZSBgbnVsbGAuKVxuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xufSk7XG5cbmZ1bmN0aW9uIGluc2VydExhenlUcmVlQ2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZFRyZWUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZShwYXJlbnROb2RlLCBjaGlsZFRyZWUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiBtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkTm9kZSkpIHtcbiAgICBtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBjaGlsZE5vZGVbMF0sIGNoaWxkTm9kZVsxXSwgcmVmZXJlbmNlTm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudE5vZGUsIGNoaWxkTm9kZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZE5vZGUpKSB7XG4gICAgdmFyIGNsb3NpbmdDb21tZW50ID0gY2hpbGROb2RlWzFdO1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZVswXTtcbiAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvc2luZ0NvbW1lbnQpO1xuICB9XG4gIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGROb2RlKTtcbn1cblxuZnVuY3Rpb24gbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgb3BlbmluZ0NvbW1lbnQsIGNsb3NpbmdDb21tZW50LCByZWZlcmVuY2VOb2RlKSB7XG4gIHZhciBub2RlID0gb3BlbmluZ0NvbW1lbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIG5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICAgIGlmIChub2RlID09PSBjbG9zaW5nQ29tbWVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIHN0YXJ0Tm9kZSwgY2xvc2luZ0NvbW1lbnQpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZS5uZXh0U2libGluZztcbiAgICBpZiAobm9kZSA9PT0gY2xvc2luZ0NvbW1lbnQpIHtcbiAgICAgIC8vIFRoZSBjbG9zaW5nIGNvbW1lbnQgaXMgcmVtb3ZlZCBieSBSZWFjdE11bHRpQ2hpbGQuXG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZURlbGltaXRlZFRleHQob3BlbmluZ0NvbW1lbnQsIGNsb3NpbmdDb21tZW50LCBzdHJpbmdUZXh0KSB7XG4gIHZhciBwYXJlbnROb2RlID0gb3BlbmluZ0NvbW1lbnQucGFyZW50Tm9kZTtcbiAgdmFyIG5vZGVBZnRlckNvbW1lbnQgPSBvcGVuaW5nQ29tbWVudC5uZXh0U2libGluZztcbiAgaWYgKG5vZGVBZnRlckNvbW1lbnQgPT09IGNsb3NpbmdDb21tZW50KSB7XG4gICAgLy8gVGhlcmUgYXJlIG5vIHRleHQgbm9kZXMgYmV0d2VlbiB0aGUgb3BlbmluZyBhbmQgY2xvc2luZyBjb21tZW50czsgaW5zZXJ0XG4gICAgLy8gYSBuZXcgb25lIGlmIHN0cmluZ1RleHQgaXNuJ3QgZW1wdHkuXG4gICAgaWYgKHN0cmluZ1RleHQpIHtcbiAgICAgIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3RyaW5nVGV4dCksIG5vZGVBZnRlckNvbW1lbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RyaW5nVGV4dCkge1xuICAgICAgLy8gU2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIGZpcnN0IG5vZGUgYWZ0ZXIgdGhlIG9wZW5pbmcgY29tbWVudCwgYW5kXG4gICAgICAvLyByZW1vdmUgYWxsIGZvbGxvd2luZyBub2RlcyB1cCB1bnRpbCB0aGUgY2xvc2luZyBjb21tZW50LlxuICAgICAgc2V0VGV4dENvbnRlbnQobm9kZUFmdGVyQ29tbWVudCwgc3RyaW5nVGV4dCk7XG4gICAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIG5vZGVBZnRlckNvbW1lbnQsIGNsb3NpbmdDb21tZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShvcGVuaW5nQ29tbWVudCkuX2RlYnVnSUQsXG4gICAgICB0eXBlOiAncmVwbGFjZSB0ZXh0JyxcbiAgICAgIHBheWxvYWQ6IHN0cmluZ1RleHRcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAgPSBEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IGZ1bmN0aW9uIChvbGRDaGlsZCwgbWFya3VwLCBwcmV2SW5zdGFuY2UpIHtcbiAgICBEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkQ2hpbGQsIG1hcmt1cCk7XG4gICAgaWYgKHByZXZJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgIGluc3RhbmNlSUQ6IHByZXZJbnN0YW5jZS5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3JlcGxhY2Ugd2l0aCcsXG4gICAgICAgIHBheWxvYWQ6IG1hcmt1cC50b1N0cmluZygpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRJbnN0YW5jZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG1hcmt1cC5ub2RlKTtcbiAgICAgIGlmIChuZXh0SW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgaW5zdGFuY2VJRDogbmV4dEluc3RhbmNlLl9kZWJ1Z0lELFxuICAgICAgICAgIHR5cGU6ICdtb3VudCcsXG4gICAgICAgICAgcGF5bG9hZDogbWFya3VwLnRvU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIHVwZGF0aW5nIHdpdGggRE9NIGNoaWxkcmVuLlxuICovXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0ge1xuXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCxcblxuICByZXBsYWNlRGVsaW1pdGVkVGV4dDogcmVwbGFjZURlbGltaXRlZFRleHQsXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBjb21wb25lbnQncyBjaGlsZHJlbiBieSBwcm9jZXNzaW5nIGEgc2VyaWVzIG9mIHVwZGF0ZXMuIFRoZVxuICAgKiB1cGRhdGUgY29uZmlndXJhdGlvbnMgYXJlIGVhY2ggZXhwZWN0ZWQgdG8gaGF2ZSBhIGBwYXJlbnROb2RlYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb2Nlc3NVcGRhdGVzOiBmdW5jdGlvbiAocGFyZW50Tm9kZSwgdXBkYXRlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGFyZW50Tm9kZURlYnVnSUQgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShwYXJlbnROb2RlKS5fZGVidWdJRDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHVwZGF0ZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciB1cGRhdGUgPSB1cGRhdGVzW2tdO1xuICAgICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xuICAgICAgICBjYXNlICdJTlNFUlRfTUFSS1VQJzpcbiAgICAgICAgICBpbnNlcnRMYXp5VHJlZUNoaWxkQXQocGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQsIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCB1cGRhdGUuYWZ0ZXJOb2RlKSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBwYXJlbnROb2RlRGVidWdJRCxcbiAgICAgICAgICAgICAgdHlwZTogJ2luc2VydCBjaGlsZCcsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHsgdG9JbmRleDogdXBkYXRlLnRvSW5kZXgsIGNvbnRlbnQ6IHVwZGF0ZS5jb250ZW50LnRvU3RyaW5nKCkgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNT1ZFX0VYSVNUSU5HJzpcbiAgICAgICAgICBtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgdXBkYXRlLmZyb21Ob2RlLCBnZXROb2RlQWZ0ZXIocGFyZW50Tm9kZSwgdXBkYXRlLmFmdGVyTm9kZSkpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgaW5zdGFuY2VJRDogcGFyZW50Tm9kZURlYnVnSUQsXG4gICAgICAgICAgICAgIHR5cGU6ICdtb3ZlIGNoaWxkJyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogeyBmcm9tSW5kZXg6IHVwZGF0ZS5mcm9tSW5kZXgsIHRvSW5kZXg6IHVwZGF0ZS50b0luZGV4IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnU0VUX01BUktVUCc6XG4gICAgICAgICAgc2V0SW5uZXJIVE1MKHBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50KTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgICAgIGluc3RhbmNlSUQ6IHBhcmVudE5vZGVEZWJ1Z0lELFxuICAgICAgICAgICAgICB0eXBlOiAncmVwbGFjZSBjaGlsZHJlbicsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5jb250ZW50LnRvU3RyaW5nKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVEVYVF9DT05URU5UJzpcbiAgICAgICAgICBzZXRUZXh0Q29udGVudChwYXJlbnROb2RlLCB1cGRhdGUuY29udGVudCk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBwYXJlbnROb2RlRGVidWdJRCxcbiAgICAgICAgICAgICAgdHlwZTogJ3JlcGxhY2UgdGV4dCcsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5jb250ZW50LnRvU3RyaW5nKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUkVNT1ZFX05PREUnOlxuICAgICAgICAgIHJlbW92ZUNoaWxkKHBhcmVudE5vZGUsIHVwZGF0ZS5mcm9tTm9kZSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBwYXJlbnROb2RlRGVidWdJRCxcbiAgICAgICAgICAgICAgdHlwZTogJ3JlbW92ZSBjaGlsZCcsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHsgZnJvbUluZGV4OiB1cGRhdGUuZnJvbUluZGV4IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01DaGlsZHJlbk9wZXJhdGlvbnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL0RPTUNoaWxkcmVuT3BlcmF0aW9ucy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcbnZhciBzZXRUZXh0Q29udGVudCA9IHJlcXVpcmUoJy4vc2V0VGV4dENvbnRlbnQnKTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxuLyoqXG4gKiBJbiBJRSAoOC0xMSkgYW5kIEVkZ2UsIGFwcGVuZGluZyBub2RlcyB3aXRoIG5vIGNoaWxkcmVuIGlzIGRyYW1hdGljYWxseVxuICogZmFzdGVyIHRoYW4gYXBwZW5kaW5nIGEgZnVsbCBzdWJ0cmVlLCBzbyB3ZSBlc3NlbnRpYWxseSBxdWV1ZSB1cCB0aGVcbiAqIC5hcHBlbmRDaGlsZCBjYWxscyBoZXJlIGFuZCBhcHBseSB0aGVtIHNvIGVhY2ggbm9kZSBpcyBhZGRlZCB0byBpdHMgcGFyZW50XG4gKiBiZWZvcmUgYW55IGNoaWxkcmVuIGFyZSBhZGRlZC5cbiAqXG4gKiBJbiBvdGhlciBicm93c2VycywgZG9pbmcgc28gaXMgc2xvd2VyIG9yIG5ldXRyYWwgY29tcGFyZWQgdG8gdGhlIG90aGVyIG9yZGVyXG4gKiAoaW4gRmlyZWZveCwgdHdpY2UgYXMgc2xvdykgc28gd2Ugb25seSBkbyB0aGlzIGludmVyc2lvbiBpbiBJRS5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NwaWN5ai9pbm5lcmh0bWwtdnMtY3JlYXRlZWxlbWVudC12cy1jbG9uZW5vZGUuXG4gKi9cbnZhciBlbmFibGVMYXp5ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudCA9PT0gJ3N0cmluZycgJiYgL1xcYkVkZ2VcXC9cXGQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbmZ1bmN0aW9uIGluc2VydFRyZWVDaGlsZHJlbih0cmVlKSB7XG4gIGlmICghZW5hYmxlTGF6eSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbm9kZSA9IHRyZWUubm9kZTtcbiAgdmFyIGNoaWxkcmVuID0gdHJlZS5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGluc2VydFRyZWVCZWZvcmUobm9kZSwgY2hpbGRyZW5baV0sIG51bGwpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0cmVlLmh0bWwgIT0gbnVsbCkge1xuICAgIHNldElubmVySFRNTChub2RlLCB0cmVlLmh0bWwpO1xuICB9IGVsc2UgaWYgKHRyZWUudGV4dCAhPSBudWxsKSB7XG4gICAgc2V0VGV4dENvbnRlbnQobm9kZSwgdHJlZS50ZXh0KTtcbiAgfVxufVxuXG52YXIgaW5zZXJ0VHJlZUJlZm9yZSA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKHBhcmVudE5vZGUsIHRyZWUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgLy8gRG9jdW1lbnRGcmFnbWVudHMgYXJlbid0IGFjdHVhbGx5IHBhcnQgb2YgdGhlIERPTSBhZnRlciBpbnNlcnRpb24gc29cbiAgLy8gYXBwZW5kaW5nIGNoaWxkcmVuIHdvbid0IHVwZGF0ZSB0aGUgRE9NLiBXZSBuZWVkIHRvIGVuc3VyZSB0aGUgZnJhZ21lbnRcbiAgLy8gaXMgcHJvcGVybHkgcG9wdWxhdGVkIGZpcnN0LCBicmVha2luZyBvdXQgb2Ygb3VyIGxhenkgYXBwcm9hY2ggZm9yIGp1c3RcbiAgLy8gdGhpcyBsZXZlbC4gQWxzbywgc29tZSA8b2JqZWN0PiBwbHVnaW5zIChsaWtlIEZsYXNoIFBsYXllcikgd2lsbCByZWFkXG4gIC8vIDxwYXJhbT4gbm9kZXMgaW1tZWRpYXRlbHkgdXBvbiBpbnNlcnRpb24gaW50byB0aGUgRE9NLCBzbyA8b2JqZWN0PlxuICAvLyBtdXN0IGFsc28gYmUgcG9wdWxhdGVkIHByaW9yIHRvIGluc2VydGlvbiBpbnRvIHRoZSBET00uXG4gIGlmICh0cmVlLm5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSB8fCB0cmVlLm5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFICYmIHRyZWUubm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb2JqZWN0JyAmJiAodHJlZS5ub2RlLm5hbWVzcGFjZVVSSSA9PSBudWxsIHx8IHRyZWUubm9kZS5uYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuaHRtbCkpIHtcbiAgICBpbnNlcnRUcmVlQ2hpbGRyZW4odHJlZSk7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodHJlZS5ub2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0cmVlLm5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICAgIGluc2VydFRyZWVDaGlsZHJlbih0cmVlKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHJlcGxhY2VDaGlsZFdpdGhUcmVlKG9sZE5vZGUsIG5ld1RyZWUpIHtcbiAgb2xkTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdUcmVlLm5vZGUsIG9sZE5vZGUpO1xuICBpbnNlcnRUcmVlQ2hpbGRyZW4obmV3VHJlZSk7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlQ2hpbGQocGFyZW50VHJlZSwgY2hpbGRUcmVlKSB7XG4gIGlmIChlbmFibGVMYXp5KSB7XG4gICAgcGFyZW50VHJlZS5jaGlsZHJlbi5wdXNoKGNoaWxkVHJlZSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50VHJlZS5ub2RlLmFwcGVuZENoaWxkKGNoaWxkVHJlZS5ub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBxdWV1ZUhUTUwodHJlZSwgaHRtbCkge1xuICBpZiAoZW5hYmxlTGF6eSkge1xuICAgIHRyZWUuaHRtbCA9IGh0bWw7XG4gIH0gZWxzZSB7XG4gICAgc2V0SW5uZXJIVE1MKHRyZWUubm9kZSwgaHRtbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVldWVUZXh0KHRyZWUsIHRleHQpIHtcbiAgaWYgKGVuYWJsZUxhenkpIHtcbiAgICB0cmVlLnRleHQgPSB0ZXh0O1xuICB9IGVsc2Uge1xuICAgIHNldFRleHRDb250ZW50KHRyZWUubm9kZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLm5vZGUubm9kZU5hbWU7XG59XG5cbmZ1bmN0aW9uIERPTUxhenlUcmVlKG5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiBub2RlLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBodG1sOiBudWxsLFxuICAgIHRleHQ6IG51bGwsXG4gICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gIH07XG59XG5cbkRPTUxhenlUcmVlLmluc2VydFRyZWVCZWZvcmUgPSBpbnNlcnRUcmVlQmVmb3JlO1xuRE9NTGF6eVRyZWUucmVwbGFjZUNoaWxkV2l0aFRyZWUgPSByZXBsYWNlQ2hpbGRXaXRoVHJlZTtcbkRPTUxhenlUcmVlLnF1ZXVlQ2hpbGQgPSBxdWV1ZUNoaWxkO1xuRE9NTGF6eVRyZWUucXVldWVIVE1MID0gcXVldWVIVE1MO1xuRE9NTGF6eVRyZWUucXVldWVUZXh0ID0gcXVldWVUZXh0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUxhenlUcmVlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9ET01MYXp5VHJlZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01OYW1lc3BhY2VzID0ge1xuICBodG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsXG4gIG1hdGhtbDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnLFxuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zydcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NTmFtZXNwYWNlcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvRE9NTmFtZXNwYWNlcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgRE9NTmFtZXNwYWNlcyA9IHJlcXVpcmUoJy4vRE9NTmFtZXNwYWNlcycpO1xuXG52YXIgV0hJVEVTUEFDRV9URVNUID0gL15bIFxcclxcblxcdFxcZl0vO1xudmFyIE5PTlZJU0lCTEVfVEVTVCA9IC88KCEtLXxsaW5rfG5vc2NyaXB0fG1ldGF8c2NyaXB0fHN0eWxlKVsgXFxyXFxuXFx0XFxmXFwvPl0vO1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xuXG4vLyBTVkcgdGVtcCBjb250YWluZXIgZm9yIElFIGxhY2tpbmcgaW5uZXJIVE1MXG52YXIgcmV1c2FibGVTVkdDb250YWluZXI7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldElubmVySFRNTCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgLy8gSUUgZG9lcyBub3QgaGF2ZSBpbm5lckhUTUwgZm9yIFNWRyBub2Rlcywgc28gaW5zdGVhZCB3ZSBpbmplY3QgdGhlXG4gIC8vIG5ldyBtYXJrdXAgaW4gYSB0ZW1wIG5vZGUgYW5kIHRoZW4gbW92ZSB0aGUgY2hpbGQgbm9kZXMgYWNyb3NzIGludG9cbiAgLy8gdGhlIHRhcmdldCBub2RlXG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5zdmcgJiYgISgnaW5uZXJIVE1MJyBpbiBub2RlKSkge1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKHN2Z05vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdmdOb2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gIH1cbn0pO1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFODogV2hlbiB1cGRhdGluZyBhIGp1c3QgY3JlYXRlZCBub2RlIHdpdGggaW5uZXJIVE1MIG9ubHkgbGVhZGluZ1xuICAvLyB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQuIFdoZW4gdXBkYXRpbmcgYW4gZXhpc3Rpbmcgbm9kZSB3aXRoIGlubmVySFRNTFxuICAvLyB3aGl0ZXNwYWNlIGluIHJvb3QgVGV4dE5vZGVzIGlzIGFsc28gY29sbGFwc2VkLlxuICAvLyBAc2VlIHF1aXJrc21vZGUub3JnL2J1Z3JlcG9ydHMvYXJjaGl2ZXMvMjAwNC8xMS9pbm5lcmh0bWxfYW5kX3QuaHRtbFxuXG4gIC8vIEZlYXR1cmUgZGV0ZWN0aW9uOyBvbmx5IElFOCBpcyBrbm93biB0byBiZWhhdmUgaW1wcm9wZXJseSBsaWtlIHRoaXMuXG4gIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSAnICc7XG4gIGlmICh0ZXN0RWxlbWVudC5pbm5lckhUTUwgPT09ICcnKSB7XG4gICAgc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgICAgIC8vIE1hZ2ljIHRoZW9yeTogSUU4IHN1cHBvc2VkbHkgZGlmZmVyZW50aWF0ZXMgYmV0d2VlbiBhZGRlZCBhbmQgdXBkYXRlZFxuICAgICAgLy8gbm9kZXMgd2hlbiBwcm9jZXNzaW5nIGlubmVySFRNTCwgaW5uZXJIVE1MIG9uIHVwZGF0ZWQgbm9kZXMgc3VmZmVyc1xuICAgICAgLy8gZnJvbSB3b3JzZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLiBSZS1hZGRpbmcgYSBub2RlIGxpa2UgdGhpcyB0cmlnZ2Vyc1xuICAgICAgLy8gdGhlIGluaXRpYWwgYW5kIG1vcmUgZmF2b3JhYmxlIHdoaXRlc3BhY2UgYmVoYXZpb3IuXG4gICAgICAvLyBUT0RPOiBXaGF0IHRvIGRvIG9uIGEgZGV0YWNoZWQgbm9kZT9cbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChub2RlLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgYWxzbyBpbXBsZW1lbnQgYSB3b3JrYXJvdW5kIGZvciBub24tdmlzaWJsZSB0YWdzIGRpc2FwcGVhcmluZyBpbnRvXG4gICAgICAvLyB0aGluIGFpciBvbiBJRTgsIHRoaXMgb25seSBoYXBwZW5zIGlmIHRoZXJlIGlzIG5vIHZpc2libGUgdGV4dFxuICAgICAgLy8gaW4tZnJvbnQgb2YgdGhlIG5vbi12aXNpYmxlIHRhZ3MuIFBpZ2d5YmFjayBvbiB0aGUgd2hpdGVzcGFjZSBmaXhcbiAgICAgIC8vIGFuZCBzaW1wbHkgY2hlY2sgaWYgYW55IG5vbi12aXNpYmxlIHRhZ3MgYXBwZWFyIGluIHRoZSBzb3VyY2UuXG4gICAgICBpZiAoV0hJVEVTUEFDRV9URVNULnRlc3QoaHRtbCkgfHwgaHRtbFswXSA9PT0gJzwnICYmIE5PTlZJU0lCTEVfVEVTVC50ZXN0KGh0bWwpKSB7XG4gICAgICAgIC8vIFJlY292ZXIgbGVhZGluZyB3aGl0ZXNwYWNlIGJ5IHRlbXBvcmFyaWx5IHByZXBlbmRpbmcgYW55IGNoYXJhY3Rlci5cbiAgICAgICAgLy8gXFx1RkVGRiBoYXMgdGhlIHBvdGVudGlhbCBhZHZhbnRhZ2Ugb2YgYmVpbmcgemVyby13aWR0aC9pbnZpc2libGUuXG4gICAgICAgIC8vIFVnbGlmeUpTIGRyb3BzIFUrRkVGRiBjaGFycyB3aGVuIHBhcnNpbmcsIHNvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICAgICAgIC8vIGluIGhvcGVzIHRoYXQgdGhpcyBpcyBwcmVzZXJ2ZWQgZXZlbiBpZiBcIlxcdUZFRkZcIiBpcyB0cmFuc2Zvcm1lZCB0b1xuICAgICAgICAvLyB0aGUgYWN0dWFsIFVuaWNvZGUgY2hhcmFjdGVyIChieSBCYWJlbCwgZm9yIGV4YW1wbGUpLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9ibG9iL3YyLjQuMjAvbGliL3BhcnNlLmpzI0wyMTZcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkVGRikgKyBodG1sO1xuXG4gICAgICAgIC8vIGRlbGV0ZURhdGEgbGVhdmVzIGFuIGVtcHR5IGBUZXh0Tm9kZWAgd2hpY2ggb2Zmc2V0cyB0aGUgaW5kZXggb2YgYWxsXG4gICAgICAgIC8vIGNoaWxkcmVuLiBEZWZpbml0ZWx5IHdhbnQgdG8gYXZvaWQgdGhpcy5cbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUuZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKHRleHROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZS5kZWxldGVEYXRhKDAsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0ZXN0RWxlbWVudCA9IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0SW5uZXJIVE1MO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9zZXRJbm5lckhUTUwuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyogZ2xvYmFscyBNU0FwcCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYykge1xuICBpZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuYyhhcmcwLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xuXG4vKipcbiAqIFNldCB0aGUgdGV4dENvbnRlbnQgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC4gaW5uZXJUZXh0IGlzIGEgcG9vciBzdWJzdGl0dXRlIGZvciB0ZXh0Q29udGVudCBhbmQsIGFtb25nIG1hbnlcbiAqIGlzc3VlcywgaW5zZXJ0cyA8YnI+IGluc3RlYWQgb2YgdGhlIGxpdGVyYWwgbmV3bGluZSBjaGFycy4gaW5uZXJIVE1MIGJlaGF2ZXNcbiAqIGFzIGl0IHNob3VsZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgaWYgKHRleHQpIHtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcblxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIGlmICghKCd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSkge1xuICAgIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgIG5vZGUubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0SW5uZXJIVE1MKG5vZGUsIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0ZXh0KSk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRleHRDb250ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9zZXRUZXh0Q29udGVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEJhc2VkIG9uIHRoZSBlc2NhcGUtaHRtbCBsaWJyYXJ5LCB3aGljaCBpcyB1c2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSBiZWxvdzpcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxMyBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0IChjKSAyMDE1IEFuZHJlYXMgTHViYmVcbiAqIENvcHlyaWdodCAoYykgMjAxNSBUaWFuY2hlbmcgXCJUaW1vdGh5XCIgR3VcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogJ1NvZnR3YXJlJyksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG4gKiBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULFxuICogVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcbiAqIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xuXG4vKipcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZXNjYXBlIGZvciBpbnNlcnRpbmcgaW50byBIVE1MXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RJbmRleCA9IDA7XG5cbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgLy8gXCJcbiAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgLy8gJlxuICAgICAgICBlc2NhcGUgPSAnJmFtcDsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgLy8gPFxuICAgICAgICBlc2NhcGUgPSAnJmx0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGU7XG4gIH1cblxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn1cbi8vIGVuZCBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuICByZXR1cm4gZXNjYXBlSHRtbCh0ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgPSByZXF1aXJlKCdmYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAnKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgRGFuZ2VyID0ge1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhIG5vZGUgd2l0aCBhIHN0cmluZyBvZiBtYXJrdXAgYXQgaXRzIGN1cnJlbnQgcG9zaXRpb24gd2l0aGluIGl0c1xuICAgKiBwYXJlbnQuIFRoZSBtYXJrdXAgbXVzdCByZW5kZXIgaW50byBhIHNpbmdsZSByb290IG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb2xkQ2hpbGQgQ2hpbGQgbm9kZSB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0byByZW5kZXIgaW4gcGxhY2Ugb2YgdGhlIGNoaWxkIG5vZGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGZ1bmN0aW9uIChvbGRDaGlsZCwgbWFya3VwKSB7XG4gICAgIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBDYW5ub3QgcmVuZGVyIG1hcmt1cCBpbiBhIHdvcmtlciB0aHJlYWQuIE1ha2Ugc3VyZSBgd2luZG93YCBhbmQgYGRvY3VtZW50YCBhcmUgYXZhaWxhYmxlIGdsb2JhbGx5IGJlZm9yZSByZXF1aXJpbmcgUmVhY3Qgd2hlbiB1bml0IHRlc3Rpbmcgb3IgdXNlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkgZm9yIHNlcnZlciByZW5kZXJpbmcuJykgOiBfcHJvZEludmFyaWFudCgnNTYnKSA6IHZvaWQgMDtcbiAgICAhbWFya3VwID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IE1pc3NpbmcgbWFya3VwLicpIDogX3Byb2RJbnZhcmlhbnQoJzU3JykgOiB2b2lkIDA7XG4gICAgIShvbGRDaGlsZC5ub2RlTmFtZSAhPT0gJ0hUTUwnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBDYW5ub3QgcmVwbGFjZSBtYXJrdXAgb2YgdGhlIDxodG1sPiBub2RlLiBUaGlzIGlzIGJlY2F1c2UgYnJvd3NlciBxdWlya3MgbWFrZSB0aGlzIHVucmVsaWFibGUgYW5kL29yIHNsb3cuIElmIHlvdSB3YW50IHRvIHJlbmRlciB0byB0aGUgcm9vdCB5b3UgbXVzdCB1c2Ugc2VydmVyIHJlbmRlcmluZy4gU2VlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkuJykgOiBfcHJvZEludmFyaWFudCgnNTgnKSA6IHZvaWQgMDtcblxuICAgIGlmICh0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIG5ld0NoaWxkID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgZW1wdHlGdW5jdGlvbilbMF07XG4gICAgICBvbGRDaGlsZC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdDaGlsZCwgb2xkQ2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBET01MYXp5VHJlZS5yZXBsYWNlQ2hpbGRXaXRoVHJlZShvbGRDaGlsZCwgbWFya3VwKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYW5nZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL0Rhbmdlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwqL1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJy4vY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcbnZhciBnZXRNYXJrdXBXcmFwID0gcmVxdWlyZSgnLi9nZXRNYXJrdXBXcmFwJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byByZW5kZXIgYWxsIG1hcmt1cC5cbiAqL1xudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBQYXR0ZXJuIHVzZWQgYnkgYGdldE5vZGVOYW1lYC5cbiAqL1xudmFyIG5vZGVOYW1lUGF0dGVybiA9IC9eXFxzKjwoXFx3KykvO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBgbm9kZU5hbWVgIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBOb2RlIG5hbWUgb2YgdGhlIHN1cHBsaWVkIG1hcmt1cC5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobWFya3VwKSB7XG4gIHZhciBub2RlTmFtZU1hdGNoID0gbWFya3VwLm1hdGNoKG5vZGVOYW1lUGF0dGVybik7XG4gIHJldHVybiBub2RlTmFtZU1hdGNoICYmIG5vZGVOYW1lTWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG5vZGVzIHJlbmRlcmVkIGZyb20gdGhlIHN1cHBsaWVkIG1hcmt1cC4gVGhlXG4gKiBvcHRpb25hbGx5IHN1cHBsaWVkIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbmNlIGZvciBlYWNoXG4gKiA8c2NyaXB0PiBlbGVtZW50IHRoYXQgaXMgcmVuZGVyZWQuIElmIG5vIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIGlzIHN1cHBsaWVkLFxuICogYW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiBhbnkgPHNjcmlwdD4gZWxlbWVudHMgYXJlIHJlbmRlcmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgQSBzdHJpbmcgb2YgdmFsaWQgSFRNTCBtYXJrdXAuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gaGFuZGxlU2NyaXB0IEludm9rZWQgb25jZSBmb3IgZWFjaCByZW5kZXJlZCA8c2NyaXB0Pi5cbiAqIEByZXR1cm4ge2FycmF5PERPTUVsZW1lbnR8RE9NVGV4dE5vZGU+fSBBbiBhcnJheSBvZiByZW5kZXJlZCBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgaGFuZGxlU2NyaXB0KSB7XG4gIHZhciBub2RlID0gZHVtbXlOb2RlO1xuICAhISFkdW1teU5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlTm9kZXNGcm9tTWFya3VwIGR1bW15IG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIG5vZGVOYW1lID0gZ2V0Tm9kZU5hbWUobWFya3VwKTtcblxuICB2YXIgd3JhcCA9IG5vZGVOYW1lICYmIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpO1xuICBpZiAod3JhcCkge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gd3JhcFsxXSArIG1hcmt1cCArIHdyYXBbMl07XG5cbiAgICB2YXIgd3JhcERlcHRoID0gd3JhcFswXTtcbiAgICB3aGlsZSAod3JhcERlcHRoLS0pIHtcbiAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBtYXJrdXA7XG4gIH1cblxuICB2YXIgc2NyaXB0cyA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICBpZiAoc2NyaXB0cy5sZW5ndGgpIHtcbiAgICAhaGFuZGxlU2NyaXB0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCguLi4pOiBVbmV4cGVjdGVkIDxzY3JpcHQ+IGVsZW1lbnQgcmVuZGVyZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNyZWF0ZUFycmF5RnJvbU1peGVkKHNjcmlwdHMpLmZvckVhY2goaGFuZGxlU2NyaXB0KTtcbiAgfVxuXG4gIHZhciBub2RlcyA9IEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKTtcbiAgd2hpbGUgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQ29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gYXJyYXlzLlxuICpcbiAqIFRoaXMgQVBJIGFzc3VtZXMgdGhlIGNhbGxlciBrbm93cyB0aGUgY29udGVudHMgb2YgdGhlIGRhdGEgdHlwZS4gRm9yIGxlc3NcbiAqIHdlbGwgZGVmaW5lZCBpbnB1dHMgdXNlIGNyZWF0ZUFycmF5RnJvbU1peGVkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufGZpbGVsaXN0fSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcblxuICAvLyBTb21lIGJyb3dzZXJzIGJ1aWx0aW4gb2JqZWN0cyBjYW4gcmVwb3J0IHR5cGVvZiAnZnVuY3Rpb24nIChlLmcuIE5vZGVMaXN0XG4gIC8vIGluIG9sZCB2ZXJzaW9ucyBvZiBTYWZhcmkpLlxuICAhKCFBcnJheS5pc0FycmF5KG9iaikgJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBBcnJheS1saWtlIG9iamVjdCBleHBlY3RlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAhKHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3QgbmVlZHMgYSBsZW5ndGggcHJvcGVydHknKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgIShsZW5ndGggPT09IDAgfHwgbGVuZ3RoIC0gMSBpbiBvYmopID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBzaG91bGQgaGF2ZSBrZXlzIGZvciBpbmRpY2VzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICEodHlwZW9mIG9iai5jYWxsZWUgIT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBjYW5cXCd0IGJlIGBhcmd1bWVudHNgLiBVc2UgcmVzdCBwYXJhbXMgJyArICcoZnVuY3Rpb24oLi4uYXJncykge30pIG9yIEFycmF5LmZyb20oKSBpbnN0ZWFkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAvLyBPbGQgSUUgZG9lc24ndCBnaXZlIGNvbGxlY3Rpb25zIGFjY2VzcyB0byBoYXNPd25Qcm9wZXJ0eS4gQXNzdW1lIGlucHV0c1xuICAvLyB3aXRob3V0IG1ldGhvZCB3aWxsIHRocm93IGR1cmluZyB0aGUgc2xpY2UgY2FsbCBhbmQgc2tpcCBzdHJhaWdodCB0byB0aGVcbiAgLy8gZmFsbGJhY2suXG4gIGlmIChvYmouaGFzT3duUHJvcGVydHkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSUUgPCA5IGRvZXMgbm90IHN1cHBvcnQgQXJyYXkjc2xpY2Ugb24gY29sbGVjdGlvbnMgb2JqZWN0c1xuICAgIH1cbiAgfVxuXG4gIC8vIEZhbGwgYmFjayB0byBjb3B5aW5nIGtleSBieSBrZXkuIFRoaXMgYXNzdW1lcyBhbGwga2V5cyBoYXZlIGEgdmFsdWUsXG4gIC8vIHNvIHdpbGwgbm90IHByZXNlcnZlIHNwYXJzZWx5IHBvcHVsYXRlZCBpbnB1dHMuXG4gIHZhciByZXQgPSBBcnJheShsZW5ndGgpO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGVuZ3RoOyBpaSsrKSB7XG4gICAgcmV0W2lpXSA9IG9ialtpaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtIGEgaGV1cmlzdGljIHRlc3QgdG8gZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBcImFycmF5LWxpa2VcIi5cbiAqXG4gKiAgIEEgbW9uayBhc2tlZCBKb3NodSwgYSBaZW4gbWFzdGVyLCBcIkhhcyBhIGRvZyBCdWRkaGEgbmF0dXJlP1wiXG4gKiAgIEpvc2h1IHJlcGxpZWQ6IFwiTXUuXCJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgaWYgaXRzIGFyZ3VtZW50IGhhcyBcImFycmF5IG5hdHVyZVwiOiBpdCByZXR1cm5zXG4gKiB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhY3R1YWwgYXJyYXksIGFuIGBhcmd1bWVudHMnIG9iamVjdCwgb3IgYW5cbiAqIEhUTUxDb2xsZWN0aW9uIChlLmcuIG5vZGUuY2hpbGROb2RlcyBvciBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCkpLlxuICpcbiAqIEl0IHdpbGwgcmV0dXJuIGZhbHNlIGZvciBvdGhlciBhcnJheS1saWtlIG9iamVjdHMgbGlrZSBGaWxlbGlzdC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzQXJyYXlOYXR1cmUob2JqKSB7XG4gIHJldHVybiAoXG4gICAgLy8gbm90IG51bGwvZmFsc2VcbiAgICAhIW9iaiAmJiAoXG4gICAgLy8gYXJyYXlzIGFyZSBvYmplY3RzLCBOb2RlTGlzdHMgYXJlIGZ1bmN0aW9ucyBpbiBTYWZhcmlcbiAgICB0eXBlb2Ygb2JqID09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAvLyBxdWFja3MgbGlrZSBhbiBhcnJheVxuICAgICdsZW5ndGgnIGluIG9iaiAmJlxuICAgIC8vIG5vdCB3aW5kb3dcbiAgICAhKCdzZXRJbnRlcnZhbCcgaW4gb2JqKSAmJlxuICAgIC8vIG5vIERPTSBub2RlIHNob3VsZCBiZSBjb25zaWRlcmVkIGFuIGFycmF5LWxpa2VcbiAgICAvLyBhICdzZWxlY3QnIGVsZW1lbnQgaGFzICdsZW5ndGgnIGFuZCAnaXRlbScgcHJvcGVydGllcyBvbiBJRThcbiAgICB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9ICdudW1iZXInICYmIChcbiAgICAvLyBhIHJlYWwgYXJyYXlcbiAgICBBcnJheS5pc0FycmF5KG9iaikgfHxcbiAgICAvLyBhcmd1bWVudHNcbiAgICAnY2FsbGVlJyBpbiBvYmogfHxcbiAgICAvLyBIVE1MQ29sbGVjdGlvbi9Ob2RlTGlzdFxuICAgICdpdGVtJyBpbiBvYmopXG4gICk7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5IGJ5IHdyYXBwaW5nIGl0IGluIGFuIGFycmF5IGlmIGl0IGlzIG5vdC5cbiAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBhcmd1bWVudCBpZiBpdCBpcyBhbHJlYWR5IGFuIGFycmF5LlxuICpcbiAqIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5OlxuICpcbiAqICAgdmFyIGNyZWF0ZUFycmF5RnJvbU1peGVkID0gcmVxdWlyZSgnY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcbiAqXG4gKiAgIGZ1bmN0aW9uIHRha2VzT25lT3JNb3JlVGhpbmdzKHRoaW5ncykge1xuICogICAgIHRoaW5ncyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkKHRoaW5ncyk7XG4gKiAgICAgLi4uXG4gKiAgIH1cbiAqXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gdHJlYXQgYHRoaW5ncycgYXMgYW4gYXJyYXksIGJ1dCBhY2NlcHQgc2NhbGFycyBpbiB0aGUgQVBJLlxuICpcbiAqIElmIHlvdSBuZWVkIHRvIGNvbnZlcnQgYW4gYXJyYXktbGlrZSBvYmplY3QsIGxpa2UgYGFyZ3VtZW50c2AsIGludG8gYW4gYXJyYXlcbiAqIHVzZSB0b0FycmF5IGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NaXhlZChvYmopIHtcbiAgaWYgKCFoYXNBcnJheU5hdHVyZShvYmopKSB7XG4gICAgcmV0dXJuIFtvYmpdO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdG9BcnJheShvYmopO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9mYmpzL2xpYi9jcmVhdGVBcnJheUZyb21NaXhlZC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIGZiLXd3dy91bnNhZmUtaHRtbCAqL1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIER1bW15IGNvbnRhaW5lciB1c2VkIHRvIGRldGVjdCB3aGljaCB3cmFwcyBhcmUgbmVjZXNzYXJ5LlxuICovXG52YXIgZHVtbXlOb2RlID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBudWxsO1xuXG4vKipcbiAqIFNvbWUgYnJvd3NlcnMgY2Fubm90IHVzZSBgaW5uZXJIVE1MYCB0byByZW5kZXIgY2VydGFpbiBlbGVtZW50cyBzdGFuZGFsb25lLFxuICogc28gd2Ugd3JhcCB0aGVtLCByZW5kZXIgdGhlIHdyYXBwZWQgbm9kZXMsIHRoZW4gZXh0cmFjdCB0aGUgZGVzaXJlZCBub2RlLlxuICpcbiAqIEluIElFOCwgY2VydGFpbiBlbGVtZW50cyBjYW5ub3QgcmVuZGVyIGFsb25lLCBzbyB3cmFwIGFsbCBlbGVtZW50cyAoJyonKS5cbiAqL1xuXG52YXIgc2hvdWxkV3JhcCA9IHt9O1xuXG52YXIgc2VsZWN0V3JhcCA9IFsxLCAnPHNlbGVjdCBtdWx0aXBsZT1cInRydWVcIj4nLCAnPC9zZWxlY3Q+J107XG52YXIgdGFibGVXcmFwID0gWzEsICc8dGFibGU+JywgJzwvdGFibGU+J107XG52YXIgdHJXcmFwID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XG5cbnZhciBzdmdXcmFwID0gWzEsICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj4nLCAnPC9zdmc+J107XG5cbnZhciBtYXJrdXBXcmFwID0ge1xuICAnKic6IFsxLCAnPzxkaXY+JywgJzwvZGl2PiddLFxuXG4gICdhcmVhJzogWzEsICc8bWFwPicsICc8L21hcD4nXSxcbiAgJ2NvbCc6IFsyLCAnPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD4nLCAnPC9jb2xncm91cD48L3RhYmxlPiddLFxuICAnbGVnZW5kJzogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXG4gICdwYXJhbSc6IFsxLCAnPG9iamVjdD4nLCAnPC9vYmplY3Q+J10sXG4gICd0cic6IFsyLCAnPHRhYmxlPjx0Ym9keT4nLCAnPC90Ym9keT48L3RhYmxlPiddLFxuXG4gICdvcHRncm91cCc6IHNlbGVjdFdyYXAsXG4gICdvcHRpb24nOiBzZWxlY3RXcmFwLFxuXG4gICdjYXB0aW9uJzogdGFibGVXcmFwLFxuICAnY29sZ3JvdXAnOiB0YWJsZVdyYXAsXG4gICd0Ym9keSc6IHRhYmxlV3JhcCxcbiAgJ3Rmb290JzogdGFibGVXcmFwLFxuICAndGhlYWQnOiB0YWJsZVdyYXAsXG5cbiAgJ3RkJzogdHJXcmFwLFxuICAndGgnOiB0cldyYXBcbn07XG5cbi8vIEluaXRpYWxpemUgdGhlIFNWRyBlbGVtZW50cyBzaW5jZSB3ZSBrbm93IHRoZXknbGwgYWx3YXlzIG5lZWQgdG8gYmUgd3JhcHBlZFxuLy8gY29uc2lzdGVudGx5LiBJZiB0aGV5IGFyZSBjcmVhdGVkIGluc2lkZSBhIDxkaXY+IHRoZXkgd2lsbCBiZSBpbml0aWFsaXplZCBpblxuLy8gdGhlIHdyb25nIG5hbWVzcGFjZSAoYW5kIHdpbGwgbm90IGRpc3BsYXkpLlxudmFyIHN2Z0VsZW1lbnRzID0gWydjaXJjbGUnLCAnY2xpcFBhdGgnLCAnZGVmcycsICdlbGxpcHNlJywgJ2cnLCAnaW1hZ2UnLCAnbGluZScsICdsaW5lYXJHcmFkaWVudCcsICdtYXNrJywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbEdyYWRpZW50JywgJ3JlY3QnLCAnc3RvcCcsICd0ZXh0JywgJ3RzcGFuJ107XG5zdmdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlTmFtZSkge1xuICBtYXJrdXBXcmFwW25vZGVOYW1lXSA9IHN2Z1dyYXA7XG4gIHNob3VsZFdyYXBbbm9kZU5hbWVdID0gdHJ1ZTtcbn0pO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBzdXBwbGllZCBgbm9kZU5hbWVgLlxuICpcbiAqIE5PVEU6IFRoaXMgbGF6aWx5IGRldGVjdHMgd2hpY2ggd3JhcHMgYXJlIG5lY2Vzc2FyeSBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgTG93ZXJjYXNlIGBub2RlTmFtZWAuXG4gKiBAcmV0dXJuIHs/YXJyYXl9IE1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24sIGlmIGFwcGxpY2FibGUuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpIHtcbiAgISEhZHVtbXlOb2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01hcmt1cCB3cmFwcGluZyBub2RlIG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgaWYgKCFtYXJrdXBXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIG5vZGVOYW1lID0gJyonO1xuICB9XG4gIGlmICghc2hvdWxkV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICBpZiAobm9kZU5hbWUgPT09ICcqJykge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8bGluayAvPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPCcgKyBub2RlTmFtZSArICc+PC8nICsgbm9kZU5hbWUgKyAnPic7XG4gICAgfVxuICAgIHNob3VsZFdyYXBbbm9kZU5hbWVdID0gIWR1bW15Tm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBzaG91bGRXcmFwW25vZGVOYW1lXSA/IG1hcmt1cFdyYXBbbm9kZU5hbWVdIDogbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXJrdXBXcmFwO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZmJqcy9saWIvZ2V0TWFya3VwV3JhcC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG5cbi8qKlxuICogT3BlcmF0aW9ucyB1c2VkIHRvIHByb2Nlc3MgdXBkYXRlcyB0byBET00gbm9kZXMuXG4gKi9cbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogZnVuY3Rpb24gKHBhcmVudEluc3QsIHVwZGF0ZXMpIHtcbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHBhcmVudEluc3QpO1xuICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5wcm9jZXNzVXBkYXRlcyhub2RlLCB1cGRhdGVzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlET3BlcmF0aW9ucztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01JRE9wZXJhdGlvbnMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyogZ2xvYmFsIGhhc093blByb3BlcnR5OnRydWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBBdXRvRm9jdXNVdGlscyA9IHJlcXVpcmUoJy4vQXV0b0ZvY3VzVXRpbHMnKTtcbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIERPTU5hbWVzcGFjZXMgPSByZXF1aXJlKCcuL0RPTU5hbWVzcGFjZXMnKTtcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50RmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NSW5wdXQgPSByZXF1aXJlKCcuL1JlYWN0RE9NSW5wdXQnKTtcbnZhciBSZWFjdERPTU9wdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RET01PcHRpb24nKTtcbnZhciBSZWFjdERPTVNlbGVjdCA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3QnKTtcbnZhciBSZWFjdERPTVRleHRhcmVhID0gcmVxdWlyZSgnLi9SZWFjdERPTVRleHRhcmVhJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RNdWx0aUNoaWxkID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGQnKTtcbnZhciBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIEZsYWdzID0gUmVhY3RET01Db21wb25lbnRGbGFncztcbnZhciBkZWxldGVMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViLmRlbGV0ZUxpc3RlbmVyO1xudmFyIGdldE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZTtcbnZhciBsaXN0ZW5UbyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5saXN0ZW5UbztcbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM7XG5cbi8vIEZvciBxdWlja2x5IG1hdGNoaW5nIGNoaWxkcmVuIHR5cGUsIHRvIHRlc3QgaWYgY2FuIGJlIHRyZWF0ZWQgYXMgY29udGVudC5cbnZhciBDT05URU5UX1RZUEVTID0geyAnc3RyaW5nJzogdHJ1ZSwgJ251bWJlcic6IHRydWUgfTtcblxudmFyIFNUWUxFID0gJ3N0eWxlJztcbnZhciBIVE1MID0gJ19faHRtbCc7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBkYW5nZXJvdXNseVNldElubmVySFRNTDogbnVsbCxcbiAgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiBudWxsXG59O1xuXG4vLyBOb2RlIHR5cGUgZm9yIGRvY3VtZW50IGZyYWdtZW50cyAoTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKS5cbnZhciBET0NfRlJBR01FTlRfVFlQRSA9IDExO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oaW50ZXJuYWxJbnN0YW5jZSkge1xuICBpZiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIHZhciBvd25lciA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lciB8fCBudWxsO1xuICAgIGlmIChvd25lcikge1xuICAgICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJyBUaGlzIERPTSBub2RlIHdhcyByZW5kZXJlZCBieSBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGZyaWVuZGx5U3RyaW5naWZ5KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICByZXR1cm4gJ1snICsgb2JqLm1hcChmcmllbmRseVN0cmluZ2lmeSkuam9pbignLCAnKSArICddJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhaXJzID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGtleUVzY2FwZWQgPSAvXlthLXokX11bXFx3JF9dKiQvaS50ZXN0KGtleSkgPyBrZXkgOiBKU09OLnN0cmluZ2lmeShrZXkpO1xuICAgICAgICAgIHBhaXJzLnB1c2goa2V5RXNjYXBlZCArICc6ICcgKyBmcmllbmRseVN0cmluZ2lmeShvYmpba2V5XSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJ3snICsgcGFpcnMuam9pbignLCAnKSArICd9JztcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuICdbZnVuY3Rpb24gb2JqZWN0XSc7XG4gIH1cbiAgLy8gRGlmZmVycyBmcm9tIEpTT04uc3RyaW5naWZ5IGluIHRoYXQgdW5kZWZpbmVkIGJlY2F1c2UgdW5kZWZpbmVkIGFuZCB0aGF0XG4gIC8vIGluZiBhbmQgbmFuIGRvbid0IGJlY29tZSBudWxsXG4gIHJldHVybiBTdHJpbmcob2JqKTtcbn1cblxudmFyIHN0eWxlTXV0YXRpb25XYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZShzdHlsZTEsIHN0eWxlMiwgY29tcG9uZW50KSB7XG4gIGlmIChzdHlsZTEgPT0gbnVsbCB8fCBzdHlsZTIgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2hhbGxvd0VxdWFsKHN0eWxlMSwgc3R5bGUyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50Ll90YWc7XG4gIHZhciBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICB2YXIgb3duZXJOYW1lO1xuICBpZiAob3duZXIpIHtcbiAgICBvd25lck5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gIH1cblxuICB2YXIgaGFzaCA9IG93bmVyTmFtZSArICd8JyArIGNvbXBvbmVudE5hbWU7XG5cbiAgaWYgKHN0eWxlTXV0YXRpb25XYXJuaW5nLmhhc093blByb3BlcnR5KGhhc2gpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3R5bGVNdXRhdGlvbldhcm5pbmdbaGFzaF0gPSB0cnVlO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYCVzYCB3YXMgcGFzc2VkIGEgc3R5bGUgb2JqZWN0IHRoYXQgaGFzIHByZXZpb3VzbHkgYmVlbiBtdXRhdGVkLiAnICsgJ011dGF0aW5nIGBzdHlsZWAgaXMgZGVwcmVjYXRlZC4gQ29uc2lkZXIgY2xvbmluZyBpdCBiZWZvcmVoYW5kLiBDaGVjayAnICsgJ3RoZSBgcmVuZGVyYCAlcy4gUHJldmlvdXMgc3R5bGU6ICVzLiBNdXRhdGVkIHN0eWxlOiAlcy4nLCBjb21wb25lbnROYW1lLCBvd25lciA/ICdvZiBgJyArIG93bmVyTmFtZSArICdgJyA6ICd1c2luZyA8JyArIGNvbXBvbmVudE5hbWUgKyAnPicsIGZyaWVuZGx5U3RyaW5naWZ5KHN0eWxlMSksIGZyaWVuZGx5U3RyaW5naWZ5KHN0eWxlMikpIDogdm9pZCAwO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyhjb21wb25lbnQsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKHZvaWRFbGVtZW50VGFnc1tjb21wb25lbnQuX3RhZ10pIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4lcycsIGNvbXBvbmVudC5fdGFnLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJyArIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJyA6ICcnKSA6IF9wcm9kSW52YXJpYW50KCcxMzcnLCBjb21wb25lbnQuX3RhZywgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIgPyAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICcgKyBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLicgOiAnJykgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogX3Byb2RJbnZhcmlhbnQoJzYwJykgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIEhUTUwgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWludmFyaWFudC1kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IF9wcm9kSW52YXJpYW50KCc2MScpIDogdm9pZCAwO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuaW5uZXJIVE1MID09IG51bGwsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHx8ICFwcm9wcy5jb250ZW50RWRpdGFibGUgfHwgcHJvcHMuY2hpbGRyZW4gPT0gbnVsbCwgJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICsgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICsgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4nKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5vbkZvY3VzSW4gPT0gbnVsbCAmJiBwcm9wcy5vbkZvY3VzT3V0ID09IG51bGwsICdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpIDogdm9pZCAwO1xuICB9XG4gICEocHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyBcXCdlbVxcJ319IHdoZW4gdXNpbmcgSlNYLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogX3Byb2RJbnZhcmlhbnQoJzYyJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBlbnF1ZXVlUHV0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIsIHRyYW5zYWN0aW9uKSB7XG4gIGlmICh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBJRTggaGFzIG5vIEFQSSBmb3IgZXZlbnQgY2FwdHVyaW5nIGFuZCB0aGUgYG9uU2Nyb2xsYCBldmVudCBkb2Vzbid0XG4gICAgLy8gYnViYmxlLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHJlZ2lzdHJhdGlvbk5hbWUgIT09ICdvblNjcm9sbCcgfHwgaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSksICdUaGlzIGJyb3dzZXIgZG9lc25cXCd0IHN1cHBvcnQgdGhlIGBvblNjcm9sbGAgZXZlbnQnKSA6IHZvaWQgMDtcbiAgfVxuICB2YXIgY29udGFpbmVySW5mbyA9IGluc3QuX2hvc3RDb250YWluZXJJbmZvO1xuICB2YXIgaXNEb2N1bWVudEZyYWdtZW50ID0gY29udGFpbmVySW5mby5fbm9kZSAmJiBjb250YWluZXJJbmZvLl9ub2RlLm5vZGVUeXBlID09PSBET0NfRlJBR01FTlRfVFlQRTtcbiAgdmFyIGRvYyA9IGlzRG9jdW1lbnRGcmFnbWVudCA/IGNvbnRhaW5lckluZm8uX25vZGUgOiBjb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xuICBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBkb2MpO1xuICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHB1dExpc3RlbmVyLCB7XG4gICAgaW5zdDogaW5zdCxcbiAgICByZWdpc3RyYXRpb25OYW1lOiByZWdpc3RyYXRpb25OYW1lLFxuICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICB9KTtcbn1cblxuZnVuY3Rpb24gcHV0TGlzdGVuZXIoKSB7XG4gIHZhciBsaXN0ZW5lclRvUHV0ID0gdGhpcztcbiAgRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXIobGlzdGVuZXJUb1B1dC5pbnN0LCBsaXN0ZW5lclRvUHV0LnJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyVG9QdXQubGlzdGVuZXIpO1xufVxuXG5mdW5jdGlvbiBpbnB1dFBvc3RNb3VudCgpIHtcbiAgdmFyIGluc3QgPSB0aGlzO1xuICBSZWFjdERPTUlucHV0LnBvc3RNb3VudFdyYXBwZXIoaW5zdCk7XG59XG5cbmZ1bmN0aW9uIHRleHRhcmVhUG9zdE1vdW50KCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIFJlYWN0RE9NVGV4dGFyZWEucG9zdE1vdW50V3JhcHBlcihpbnN0KTtcbn1cblxuZnVuY3Rpb24gb3B0aW9uUG9zdE1vdW50KCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIFJlYWN0RE9NT3B0aW9uLnBvc3RNb3VudFdyYXBwZXIoaW5zdCk7XG59XG5cbnZhciBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldiA9IGVtcHR5RnVuY3Rpb247XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldiA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgdmFyIGhhc0V4aXN0aW5nQ29udGVudCA9IHRoaXMuX2NvbnRlbnREZWJ1Z0lEICE9IG51bGw7XG4gICAgdmFyIGRlYnVnSUQgPSB0aGlzLl9kZWJ1Z0lEO1xuICAgIC8vIFRoaXMgSUQgcmVwcmVzZW50cyB0aGUgaW5saW5lZCBjaGlsZCB0aGF0IGhhcyBubyBiYWNraW5nIGluc3RhbmNlOlxuICAgIHZhciBjb250ZW50RGVidWdJRCA9IC1kZWJ1Z0lEO1xuXG4gICAgaWYgKGNvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgaWYgKGhhc0V4aXN0aW5nQ29udGVudCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Vbm1vdW50Q29tcG9uZW50KHRoaXMuX2NvbnRlbnREZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbnRlbnREZWJ1Z0lEID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgU3RyaW5nKGNvbnRlbnQpLCB0aGlzLCB0aGlzLl9hbmNlc3RvckluZm8pO1xuICAgIHRoaXMuX2NvbnRlbnREZWJ1Z0lEID0gY29udGVudERlYnVnSUQ7XG4gICAgaWYgKGhhc0V4aXN0aW5nQ29udGVudCkge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlVXBkYXRlQ29tcG9uZW50KGNvbnRlbnREZWJ1Z0lELCBjb250ZW50KTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChjb250ZW50RGVidWdJRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZU1vdW50Q29tcG9uZW50KGNvbnRlbnREZWJ1Z0lELCBjb250ZW50LCBkZWJ1Z0lEKTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbk1vdW50Q29tcG9uZW50KGNvbnRlbnREZWJ1Z0lEKTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKGRlYnVnSUQsIFtjb250ZW50RGVidWdJRF0pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gVGhlcmUgYXJlIHNvIG1hbnkgbWVkaWEgZXZlbnRzLCBpdCBtYWtlcyBzZW5zZSB0byBqdXN0XG4vLyBtYWludGFpbiBhIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRlIGEgYHRyYXBCdWJibGVkRXZlbnRgIGZvciBlYWNoXG52YXIgbWVkaWFFdmVudHMgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZydcbn07XG5cbmZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnRzTG9jYWwoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgLy8gSWYgYSBjb21wb25lbnQgcmVuZGVycyB0byBudWxsIG9yIGlmIGFub3RoZXIgY29tcG9uZW50IGZhdGFscyBhbmQgY2F1c2VzXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgdHJlZSB0byBiZSBjb3JydXB0ZWQsIGBub2RlYCBoZXJlIGNhbiBiZSBudWxsLlxuICAhaW5zdC5fcm9vdE5vZGVJRCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNdXN0IGJlIG1vdW50ZWQgdG8gdHJhcCBldmVudHMnKSA6IF9wcm9kSW52YXJpYW50KCc2MycpIDogdm9pZCAwO1xuICB2YXIgbm9kZSA9IGdldE5vZGUoaW5zdCk7XG4gICFub2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RyYXBCdWJibGVkRXZlbnQoLi4uKTogUmVxdWlyZXMgbm9kZSB0byBiZSByZW5kZXJlZC4nKSA6IF9wcm9kSW52YXJpYW50KCc2NCcpIDogdm9pZCAwO1xuXG4gIHN3aXRjaCAoaW5zdC5fdGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcblxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtdO1xuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycy5wdXNoKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KGV2ZW50LCBtZWRpYUV2ZW50c1tldmVudF0sIG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW1nJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgbm9kZSksIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmb3JtJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFJlc2V0JywgJ3Jlc2V0Jywgbm9kZSksIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BTdWJtaXQnLCAnc3VibWl0Jywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdFVwZGF0ZVNlbGVjdFdyYXBwZXIoKSB7XG4gIFJlYWN0RE9NU2VsZWN0LnBvc3RVcGRhdGVXcmFwcGVyKHRoaXMpO1xufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBmb3Jcbi8vIHRob3NlIHNwZWNpYWwtY2FzZSB0YWdzLlxuXG52YXIgb21pdHRlZENsb3NlVGFncyA9IHtcbiAgJ2FyZWEnOiB0cnVlLFxuICAnYmFzZSc6IHRydWUsXG4gICdicic6IHRydWUsXG4gICdjb2wnOiB0cnVlLFxuICAnZW1iZWQnOiB0cnVlLFxuICAnaHInOiB0cnVlLFxuICAnaW1nJzogdHJ1ZSxcbiAgJ2lucHV0JzogdHJ1ZSxcbiAgJ2tleWdlbic6IHRydWUsXG4gICdsaW5rJzogdHJ1ZSxcbiAgJ21ldGEnOiB0cnVlLFxuICAncGFyYW0nOiB0cnVlLFxuICAnc291cmNlJzogdHJ1ZSxcbiAgJ3RyYWNrJzogdHJ1ZSxcbiAgJ3dicic6IHRydWVcbn07XG5cbnZhciBuZXdsaW5lRWF0aW5nVGFncyA9IHtcbiAgJ2xpc3RpbmcnOiB0cnVlLFxuICAncHJlJzogdHJ1ZSxcbiAgJ3RleHRhcmVhJzogdHJ1ZVxufTtcblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBjYW5ub3QgaGF2ZSBjaGlsZHJlbi4gVGhpcyBoYXMgdGhlIHNhbWUgcHVycG9zZSBhc1xuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gX2Fzc2lnbih7XG4gICdtZW51aXRlbSc6IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG4vLyBXZSBhY2NlcHQgYW55IHRhZyB0byBiZSByZW5kZXJlZCBidXQgc2luY2UgdGhpcyBnZXRzIGluamVjdGVkIGludG8gYXJiaXRyYXJ5XG4vLyBIVE1MLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3MgYSBzYWZlIHRhZy5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVcblxudmFyIFZBTElEX1RBR19SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aOl9cXC5cXC1cXGRdKiQvOyAvLyBTaW1wbGlmaWVkIHN1YnNldFxudmFyIHZhbGlkYXRlZFRhZ0NhY2hlID0ge307XG52YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKSB7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh2YWxpZGF0ZWRUYWdDYWNoZSwgdGFnKSkge1xuICAgICFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdGFnOiAlcycsIHRhZykgOiBfcHJvZEludmFyaWFudCgnNjUnLCB0YWcpIDogdm9pZCAwO1xuICAgIHZhbGlkYXRlZFRhZ0NhY2hlW3RhZ10gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIHJldHVybiB0YWdOYW1lLmluZGV4T2YoJy0nKSA+PSAwIHx8IHByb3BzLmlzICE9IG51bGw7XG59XG5cbnZhciBnbG9iYWxJZENvdW50ZXIgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUmVhY3QgY2xhc3MgdGhhdCBpcyBpZGVtcG90ZW50IGFuZCBjYXBhYmxlIG9mIGNvbnRhaW5pbmcgb3RoZXJcbiAqIFJlYWN0IGNvbXBvbmVudHMuIEl0IGFjY2VwdHMgZXZlbnQgbGlzdGVuZXJzIGFuZCBET00gcHJvcGVydGllcyB0aGF0IGFyZVxuICogdmFsaWQgYWNjb3JkaW5nIHRvIGBET01Qcm9wZXJ0eWAuXG4gKlxuICogIC0gRXZlbnQgbGlzdGVuZXJzOiBgb25DbGlja2AsIGBvbk1vdXNlRG93bmAsIGV0Yy5cbiAqICAtIERPTSBwcm9wZXJ0aWVzOiBgY2xhc3NOYW1lYCwgYG5hbWVgLCBgdGl0bGVgLCBldGMuXG4gKlxuICogVGhlIGBzdHlsZWAgcHJvcGVydHkgZnVuY3Rpb25zIGRpZmZlcmVudGx5IGZyb20gdGhlIERPTSBBUEkuIEl0IGFjY2VwdHMgYW5cbiAqIG9iamVjdCBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBSZWFjdERPTUNvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RNdWx0aUNoaWxkXG4gKi9cbmZ1bmN0aW9uIFJlYWN0RE9NQ29tcG9uZW50KGVsZW1lbnQpIHtcbiAgdmFyIHRhZyA9IGVsZW1lbnQudHlwZTtcbiAgdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKTtcbiAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLl90YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgdGhpcy5fbmFtZXNwYWNlVVJJID0gbnVsbDtcbiAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcbiAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG4gIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xuICB0aGlzLl9kb21JRCA9IDA7XG4gIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gbnVsbDtcbiAgdGhpcy5fd3JhcHBlclN0YXRlID0gbnVsbDtcbiAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcbiAgdGhpcy5fZmxhZ3MgPSAwO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHRoaXMuX2FuY2VzdG9ySW5mbyA9IG51bGw7XG4gICAgc2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYuY2FsbCh0aGlzLCBudWxsKTtcbiAgfVxufVxuXG5SZWFjdERPTUNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdSZWFjdERPTUNvbXBvbmVudCc7XG5cblJlYWN0RE9NQ29tcG9uZW50Lk1peGluID0ge1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcm9vdCB0YWcgbWFya3VwIHRoZW4gcmVjdXJzZXMuIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYW5kXG4gICAqIGlzIG5vdCBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P1JlYWN0RE9NQ29tcG9uZW50fSB0aGUgcGFyZW50IGNvbXBvbmVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IGluZm8gYWJvdXQgdGhlIGhvc3QgY29udGFpbmVyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbXB1dGVkIG1hcmt1cC5cbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IGdsb2JhbElkQ291bnRlcisrO1xuICAgIHRoaXMuX2RvbUlEID0gaG9zdENvbnRhaW5lckluZm8uX2lkQ291bnRlcisrO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gaG9zdENvbnRhaW5lckluZm87XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnbGluayc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgdGhpcy5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgICAgIGxpc3RlbmVyczogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgUmVhY3RET01JbnB1dC5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICBSZWFjdERPTU9wdGlvbi5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgUmVhY3RET01TZWxlY3QubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBob3N0UGFyZW50KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgUmVhY3RET01UZXh0YXJlYS5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBwcm9wcyk7XG5cbiAgICAvLyBXZSBjcmVhdGUgdGFncyBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoZWlyIHBhcmVudCBjb250YWluZXIsIGV4Y2VwdCBIVE1MXG4gICAgLy8gdGFncyBnZXQgbm8gbmFtZXNwYWNlLlxuICAgIHZhciBuYW1lc3BhY2VVUkk7XG4gICAgdmFyIHBhcmVudFRhZztcbiAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XG4gICAgICBuYW1lc3BhY2VVUkkgPSBob3N0UGFyZW50Ll9uYW1lc3BhY2VVUkk7XG4gICAgICBwYXJlbnRUYWcgPSBob3N0UGFyZW50Ll90YWc7XG4gICAgfSBlbHNlIGlmIChob3N0Q29udGFpbmVySW5mby5fdGFnKSB7XG4gICAgICBuYW1lc3BhY2VVUkkgPSBob3N0Q29udGFpbmVySW5mby5fbmFtZXNwYWNlVVJJO1xuICAgICAgcGFyZW50VGFnID0gaG9zdENvbnRhaW5lckluZm8uX3RhZztcbiAgICB9XG4gICAgaWYgKG5hbWVzcGFjZVVSSSA9PSBudWxsIHx8IG5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5zdmcgJiYgcGFyZW50VGFnID09PSAnZm9yZWlnbm9iamVjdCcpIHtcbiAgICAgIG5hbWVzcGFjZVVSSSA9IERPTU5hbWVzcGFjZXMuaHRtbDtcbiAgICB9XG4gICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5odG1sKSB7XG4gICAgICBpZiAodGhpcy5fdGFnID09PSAnc3ZnJykge1xuICAgICAgICBuYW1lc3BhY2VVUkkgPSBET01OYW1lc3BhY2VzLnN2ZztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fdGFnID09PSAnbWF0aCcpIHtcbiAgICAgICAgbmFtZXNwYWNlVVJJID0gRE9NTmFtZXNwYWNlcy5tYXRobWw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX25hbWVzcGFjZVVSSSA9IG5hbWVzcGFjZVVSSTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGFyZW50SW5mbztcbiAgICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgcGFyZW50SW5mbyA9IGhvc3RQYXJlbnQuX2FuY2VzdG9ySW5mbztcbiAgICAgIH0gZWxzZSBpZiAoaG9zdENvbnRhaW5lckluZm8uX3RhZykge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdENvbnRhaW5lckluZm8uX2FuY2VzdG9ySW5mbztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRJbmZvKSB7XG4gICAgICAgIC8vIHBhcmVudEluZm8gc2hvdWxkIGFsd2F5cyBiZSBwcmVzZW50IGV4Y2VwdCBmb3IgdGhlIHRvcC1sZXZlbFxuICAgICAgICAvLyBjb21wb25lbnQgd2hlbiBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyh0aGlzLl90YWcsIG51bGwsIHRoaXMsIHBhcmVudEluZm8pO1xuICAgICAgfVxuICAgICAgdGhpcy5fYW5jZXN0b3JJbmZvID0gdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8ocGFyZW50SW5mbywgdGhpcy5fdGFnLCB0aGlzKTtcbiAgICB9XG5cbiAgICB2YXIgbW91bnRJbWFnZTtcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBob3N0Q29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgICAgIHZhciBlbDtcbiAgICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuaHRtbCkge1xuICAgICAgICBpZiAodGhpcy5fdGFnID09PSAnc2NyaXB0Jykge1xuICAgICAgICAgIC8vIENyZWF0ZSB0aGUgc2NyaXB0IHZpYSAuaW5uZXJIVE1MIHNvIGl0cyBcInBhcnNlci1pbnNlcnRlZFwiIGZsYWcgaXNcbiAgICAgICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgICAgIHZhciBkaXYgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gJzwnICsgdHlwZSArICc+PC8nICsgdHlwZSArICc+JztcbiAgICAgICAgICBlbCA9IGRpdi5yZW1vdmVDaGlsZChkaXYuZmlyc3RDaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcHMuaXMpIHtcbiAgICAgICAgICBlbCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlLCBwcm9wcy5pcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2VwYXJhdGUgZWxzZSBicmFuY2ggaW5zdGVhZCBvZiB1c2luZyBgcHJvcHMuaXMgfHwgdW5kZWZpbmVkYCBhYm92ZSBiZWN1YXNlIG9mIGEgRmlyZWZveCBidWcuXG4gICAgICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNjg5NlxuICAgICAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbiAgICAgICAgICBlbCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUpO1xuICAgICAgfVxuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBlbCk7XG4gICAgICB0aGlzLl9mbGFncyB8PSBGbGFncy5oYXNDYWNoZWRDaGlsZE5vZGVzO1xuICAgICAgaWYgKCF0aGlzLl9ob3N0UGFyZW50KSB7XG4gICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRBdHRyaWJ1dGVGb3JSb290KGVsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMobnVsbCwgcHJvcHMsIHRyYW5zYWN0aW9uKTtcbiAgICAgIHZhciBsYXp5VHJlZSA9IERPTUxhenlUcmVlKGVsKTtcbiAgICAgIHRoaXMuX2NyZWF0ZUluaXRpYWxDaGlsZHJlbih0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQsIGxhenlUcmVlKTtcbiAgICAgIG1vdW50SW1hZ2UgPSBsYXp5VHJlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhZ09wZW4gPSB0aGlzLl9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzKHRyYW5zYWN0aW9uLCBwcm9wcyk7XG4gICAgICB2YXIgdGFnQ29udGVudCA9IHRoaXMuX2NyZWF0ZUNvbnRlbnRNYXJrdXAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KTtcbiAgICAgIGlmICghdGFnQ29udGVudCAmJiBvbWl0dGVkQ2xvc2VUYWdzW3RoaXMuX3RhZ10pIHtcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnLz4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnPicgKyB0YWdDb250ZW50ICsgJzwvJyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUgKyAnPic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnB1dFBvc3RNb3VudCwgdGhpcyk7XG4gICAgICAgIGlmIChwcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKEF1dG9Gb2N1c1V0aWxzLmZvY3VzRE9NQ29tcG9uZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0ZXh0YXJlYVBvc3RNb3VudCwgdGhpcyk7XG4gICAgICAgIGlmIChwcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKEF1dG9Gb2N1c1V0aWxzLmZvY3VzRE9NQ29tcG9uZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIGlmIChwcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKEF1dG9Gb2N1c1V0aWxzLmZvY3VzRE9NQ29tcG9uZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIGlmIChwcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKEF1dG9Gb2N1c1V0aWxzLmZvY3VzRE9NQ29tcG9uZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUob3B0aW9uUG9zdE1vdW50LCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vdW50SW1hZ2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgb3BlbiB0YWcgYW5kIGFsbCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGJlY2F1c2UgZXZlbnRzIGdldCByZWdpc3RlcmVkLlxuICAgKlxuICAgKiBJdGVyYXRpbmcgb3ZlciBvYmplY3QgcHJvcGVydGllcyBpcyBmYXN0ZXIgdGhhbiBpdGVyYXRpbmcgb3ZlciBhcnJheXMuXG4gICAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vb2JqLXZzLWFyci1pdGVyYXRpb25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBvZiBvcGVuaW5nIHRhZy5cbiAgICovXG4gIF9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzKSB7XG4gICAgdmFyIHJldCA9ICc8JyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICBlbnF1ZXVlUHV0TGlzdGVuZXIodGhpcywgcHJvcEtleSwgcHJvcFZhbHVlLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIC8vIFNlZSBgX3VwZGF0ZURPTVByb3BlcnRpZXNgLiBzdHlsZSBibG9ja1xuICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcFZhbHVlID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBfYXNzaWduKHt9LCBwcm9wcy5zdHlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb3BWYWx1ZSA9IENTU1Byb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JTdHlsZXMocHJvcFZhbHVlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFya3VwID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3RhZyAhPSBudWxsICYmIGlzQ3VzdG9tQ29tcG9uZW50KHRoaXMuX3RhZywgcHJvcHMpKSB7XG4gICAgICAgICAgaWYgKCFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXJrdXAgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yUHJvcGVydHkocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya3VwKSB7XG4gICAgICAgICAgcmV0ICs9ICcgJyArIG1hcmt1cDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvciBzdGF0aWMgcGFnZXMsIG5vIG5lZWQgdG8gcHV0IFJlYWN0IElEIGFuZCBjaGVja3N1bS4gU2F2ZXMgbG90cyBvZlxuICAgIC8vIGJ5dGVzLlxuICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2hvc3RQYXJlbnQpIHtcbiAgICAgIHJldCArPSAnICcgKyBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yUm9vdCgpO1xuICAgIH1cbiAgICByZXQgKz0gJyAnICsgRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvcklEKHRoaXMuX2RvbUlEKTtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGUgdGFncy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbnRlbnQgbWFya3VwLlxuICAgKi9cbiAgX2NyZWF0ZUNvbnRlbnRNYXJrdXA6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgcmV0ID0gJyc7XG5cbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cbiAgICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHJldCA9IGlubmVySFRNTC5fX2h0bWw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBwcm9wcy5jaGlsZHJlbl0gPyBwcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgICB2YXIgY2hpbGRyZW5Ub1VzZSA9IGNvbnRlbnRUb1VzZSAhPSBudWxsID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNvbnRlbnRUb1VzZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoYXQgdGV4dCBpcyBhbGxvd2VkIGFzIGEgY2hpbGQgb2YgdGhpcyBub2RlXG4gICAgICAgIHJldCA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcihjb250ZW50VG9Vc2UpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgY29udGVudFRvVXNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgcmV0ID0gbW91bnRJbWFnZXMuam9pbignJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdsaW5lRWF0aW5nVGFnc1t0aGlzLl90YWddICYmIHJldC5jaGFyQXQoMCkgPT09ICdcXG4nKSB7XG4gICAgICAvLyB0ZXh0L2h0bWwgaWdub3JlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZXNlIHRhZ3MgaWYgaXQncyBhIG5ld2xpbmVcbiAgICAgIC8vIFByZWZlciB0byBicmVhayBhcHBsaWNhdGlvbi94bWwgb3ZlciB0ZXh0L2h0bWwgKGZvciBub3cpIGJ5IGFkZGluZ1xuICAgICAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAgICAgLy8gdGV4dGFyZWFzLCByZXBsYWNpbmcgXCJeXFxuXCIgd2l0aCBcIlxcclxcblwiIGRvZXNuJ3QgZ2V0IGVhdGVuLCBhbmQgdGhlIGZpcnN0XG4gICAgICAvLyBcXHIgaXMgbm9ybWFsaXplZCBvdXQgYnkgSFRNTFRleHRBcmVhRWxlbWVudCN2YWx1ZS4pXG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudC1yZXN0cmljdGlvbnM+XG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNuZXdsaW5lcz5cbiAgICAgIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgICAgIC8vICBmcm9tIDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5PlxuICAgICAgcmV0dXJuICdcXG4nICsgcmV0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSxcblxuICBfY3JlYXRlSW5pdGlhbENoaWxkcmVuOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0LCBsYXp5VHJlZSkge1xuICAgIC8vIEludGVudGlvbmFsIHVzZSBvZiAhPSB0byBhdm9pZCBjYXRjaGluZyB6ZXJvL2ZhbHNlLlxuICAgIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVIVE1MKGxhenlUcmVlLCBpbm5lckhUTUwuX19odG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIHByb3BzLmNoaWxkcmVuXSA/IHByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY29udGVudFRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIGNvbnRlbnRUb1VzZSk7XG4gICAgICAgIH1cbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVUZXh0KGxhenlUcmVlLCBjb250ZW50VG9Vc2UpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3VudEltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIERPTUxhenlUcmVlLnF1ZXVlQ2hpbGQobGF6eVRyZWUsIG1vdW50SW1hZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjZWl2ZXMgYSBuZXh0IGVsZW1lbnQgYW5kIHVwZGF0ZXMgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgRE9NIGNvbXBvbmVudCBhZnRlciBpdCBoYXMgYWxyZWFkeSBiZWVuIGFsbG9jYXRlZCBhbmRcbiAgICogYXR0YWNoZWQgdG8gdGhlIERPTS4gUmVjb25jaWxlcyB0aGUgcm9vdCBET00gbm9kZSwgdGhlbiByZWN1cnNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gcHJldkVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICB2YXIgbGFzdFByb3BzID0gcHJldkVsZW1lbnQucHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01JbnB1dC5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01JbnB1dC5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0SG9zdFByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLl91cGRhdGVET01DaGlsZHJlbihsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVyIGFyb3VuZCBpbnB1dHMgKmFmdGVyKiB1cGRhdGluZyBwcm9wcy4gVGhpcyBoYXMgdG9cbiAgICAgICAgLy8gaGFwcGVuIGFmdGVyIGBfdXBkYXRlRE9NUHJvcGVydGllc2AuIE90aGVyd2lzZSBIVE1MNSBpbnB1dCB2YWxpZGF0aW9uc1xuICAgICAgICAvLyByYWlzZSB3YXJuaW5ncyBhbmQgcHJldmVudCB0aGUgbmV3IHZhbHVlIGZyb20gYmVpbmcgYXNzaWduZWQuXG4gICAgICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIFJlYWN0RE9NVGV4dGFyZWEudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwb3N0VXBkYXRlU2VsZWN0V3JhcHBlciwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjb25jaWxlcyB0aGUgcHJvcGVydGllcyBieSBkZXRlY3RpbmcgZGlmZmVyZW5jZXMgaW4gcHJvcGVydHkgdmFsdWVzIGFuZFxuICAgKiB1cGRhdGluZyB0aGUgRE9NIGFzIG5lY2Vzc2FyeS4gVGhpcyBmdW5jdGlvbiBpcyBwcm9iYWJseSB0aGUgc2luZ2xlIG1vc3RcbiAgICogY3JpdGljYWwgcGF0aCBmb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxuICAgKlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgd2hldGhlciBjaGVja2luZyBmb3IgY2hhbmdlZCB2YWx1ZXMgaW4gbWVtb3J5IGFjdHVhbGx5XG4gICAqICAgICAgIGltcHJvdmVzIHBlcmZvcm1hbmNlIChlc3BlY2lhbGx5IHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50cykuXG4gICAqIFRPRE86IEJlbmNobWFyayB0aGUgZWZmZWN0cyBvZiBwdXR0aW5nIHRoaXMgYXQgdGhlIHRvcCBzaW5jZSA5OSUgb2YgcHJvcHNcbiAgICogICAgICAgZG8gbm90IGNoYW5nZSBmb3IgYSBnaXZlbiByZWNvbmNpbGlhdGlvbi5cbiAgICogVE9ETzogQmVuY2htYXJrIGFyZWFzIHRoYXQgY2FuIGJlIGltcHJvdmVkIHdpdGggY2FjaGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIF91cGRhdGVET01Qcm9wZXJ0aWVzOiBmdW5jdGlvbiAobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uKSB7XG4gICAgdmFyIHByb3BLZXk7XG4gICAgdmFyIHN0eWxlTmFtZTtcbiAgICB2YXIgc3R5bGVVcGRhdGVzO1xuICAgIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBsYXN0UHJvcHNbcHJvcEtleV0gPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICB2YXIgbGFzdFN0eWxlID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHk7XG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICAgIGlmIChsYXN0U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAobGFzdFByb3BzW3Byb3BLZXldKSB7XG4gICAgICAgICAgLy8gT25seSBjYWxsIGRlbGV0ZUxpc3RlbmVyIGlmIHRoZXJlIHdhcyBhIGxpc3RlbmVyIHByZXZpb3VzbHkgb3JcbiAgICAgICAgICAvLyBlbHNlIHdpbGxEZWxldGVMaXN0ZW5lciBnZXRzIGNhbGxlZCB3aGVuIHRoZXJlIHdhc24ndCBhY3R1YWxseSBhXG4gICAgICAgICAgLy8gbGlzdGVuZXIgKGUuZy4sIG9uQ2xpY2s9e251bGx9KVxuICAgICAgICAgIGRlbGV0ZUxpc3RlbmVyKHRoaXMsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHRoaXMuX3RhZywgbGFzdFByb3BzKSkge1xuICAgICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlKGdldE5vZGUodGhpcyksIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICAgIHZhciBsYXN0UHJvcCA9IHByb3BLZXkgPT09IFNUWUxFID8gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgOiBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IG5leHRQcm9wID09PSBsYXN0UHJvcCB8fCBuZXh0UHJvcCA9PSBudWxsICYmIGxhc3RQcm9wID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZSh0aGlzLl9wcmV2aW91c1N0eWxlQ29weSwgdGhpcy5fcHJldmlvdXNTdHlsZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gbmV4dFByb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRQcm9wID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBfYXNzaWduKHt9LCBuZXh0UHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0UHJvcCkge1xuICAgICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIG5leHRQcm9wKSB7XG4gICAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICBlbnF1ZXVlUHV0TGlzdGVuZXIodGhpcywgcHJvcEtleSwgbmV4dFByb3AsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAgIGRlbGV0ZUxpc3RlbmVyKHRoaXMsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHRoaXMuX3RhZywgbmV4dFByb3BzKSkge1xuICAgICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKGdldE5vZGUodGhpcyksIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BLZXldIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIHZhciBub2RlID0gZ2V0Tm9kZSh0aGlzKTtcbiAgICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAgIC8vIGZyb20gdGhlIERPTSBub2RlIGluc3RlYWQgb2YgaW5hZHZlcnRlbnRseSBzZXR0aW5nIHRvIGEgc3RyaW5nLiBUaGlzXG4gICAgICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0eWxlVXBkYXRlcykge1xuICAgICAgQ1NTUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yU3R5bGVzKGdldE5vZGUodGhpcyksIHN0eWxlVXBkYXRlcywgdGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgdGhhdCBhZmZlY3QgdGhlXG4gICAqIGNoaWxkcmVuIGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXN0UHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICBfdXBkYXRlRE9NQ2hpbGRyZW46IGZ1bmN0aW9uIChsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgbGFzdENvbnRlbnQgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBsYXN0UHJvcHMuY2hpbGRyZW5dID8gbGFzdFByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICB2YXIgbmV4dENvbnRlbnQgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBuZXh0UHJvcHMuY2hpbGRyZW5dID8gbmV4dFByb3BzLmNoaWxkcmVuIDogbnVsbDtcblxuICAgIHZhciBsYXN0SHRtbCA9IGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJiBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJiBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuXG4gICAgLy8gTm90ZSB0aGUgdXNlIG9mIGAhPWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICB2YXIgbGFzdENoaWxkcmVuID0gbGFzdENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBsYXN0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRDb250ZW50ICE9IG51bGwgPyBudWxsIDogbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gY2hpbGRyZW4gdG8gY29udGVudC9odG1sIG9yIHZpY2UgdmVyc2EsIHJlbW92ZVxuICAgIC8vIHRoZSBvbGQgY29udGVudFxuICAgIHZhciBsYXN0SGFzQ29udGVudE9ySHRtbCA9IGxhc3RDb250ZW50ICE9IG51bGwgfHwgbGFzdEh0bWwgIT0gbnVsbDtcbiAgICB2YXIgbmV4dEhhc0NvbnRlbnRPckh0bWwgPSBuZXh0Q29udGVudCAhPSBudWxsIHx8IG5leHRIdG1sICE9IG51bGw7XG4gICAgaWYgKGxhc3RDaGlsZHJlbiAhPSBudWxsICYmIG5leHRDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG51bGwsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGxhc3RIYXNDb250ZW50T3JIdG1sICYmICFuZXh0SGFzQ29udGVudE9ySHRtbCkge1xuICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbih0aGlzLl9kZWJ1Z0lELCBbXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5leHRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIGlmIChsYXN0Q29udGVudCAhPT0gbmV4dENvbnRlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyArIG5leHRDb250ZW50KTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIG5leHRDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICB0aGlzLnVwZGF0ZU1hcmt1cCgnJyArIG5leHRIdG1sKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIFtdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG5leHRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXROb2RlKHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS4gRG9lcyBub3QgcmVtb3ZlIGZyb21cbiAgICogdGhlIERPTS4gVGhhdCBtdXN0IGJlIGRvbmUgYnkgdGhlIHBhcmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoc2FmZWx5KSB7XG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgY2FzZSAnaWZyYW1lJzpcbiAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICBjYXNlICdsaW5rJzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fd3JhcHBlclN0YXRlLmxpc3RlbmVycztcbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0ucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50cyBsaWtlIDxodG1sPiA8aGVhZD4gYW5kIDxib2R5PiBjYW4ndCBiZSByZW1vdmVkIG9yIGFkZGVkXG4gICAgICAgICAqIGVhc2lseSBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LCBob3dldmVyIGl0J3MgdmFsdWFibGUgdG8gYmUgYWJsZSB0b1xuICAgICAgICAgKiB0YWtlIGFkdmFudGFnZSBvZiBSZWFjdCdzIHJlY29uY2lsaWF0aW9uIGZvciBzdHlsaW5nIGFuZCA8dGl0bGU+XG4gICAgICAgICAqIG1hbmFnZW1lbnQuIFNvIHdlIGp1c3QgZG9jdW1lbnQgaXQgYW5kIHRocm93IGluIGRhbmdlcm91cyBjYXNlcy5cbiAgICAgICAgICovXG4gICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8JXM+IHRyaWVkIHRvIHVubW91bnQuIEJlY2F1c2Ugb2YgY3Jvc3MtYnJvd3NlciBxdWlya3MgaXQgaXMgaW1wb3NzaWJsZSB0byB1bm1vdW50IHNvbWUgdG9wLWxldmVsIGNvbXBvbmVudHMgKGVnIDxodG1sPiwgPGhlYWQ+LCBhbmQgPGJvZHk+KSByZWxpYWJseSBhbmQgZWZmaWNpZW50bHkuIFRvIGZpeCB0aGlzLCBoYXZlIGEgc2luZ2xlIHRvcC1sZXZlbCBjb21wb25lbnQgdGhhdCBuZXZlciB1bm1vdW50cyByZW5kZXIgdGhlc2UgZWxlbWVudHMuJywgdGhpcy5fdGFnKSA6IF9wcm9kSW52YXJpYW50KCc2NicsIHRoaXMuX3RhZykgOiB2b2lkIDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMudW5tb3VudENoaWxkcmVuKHNhZmVseSk7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICAgIEV2ZW50UGx1Z2luSHViLmRlbGV0ZUFsbExpc3RlbmVycyh0aGlzKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgICB0aGlzLl9kb21JRCA9IDA7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlID0gbnVsbDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIG51bGwpO1xuICAgIH1cbiAgfSxcblxuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXROb2RlKHRoaXMpO1xuICB9XG5cbn07XG5cbl9hc3NpZ24oUmVhY3RET01Db21wb25lbnQucHJvdG90eXBlLCBSZWFjdERPTUNvbXBvbmVudC5NaXhpbiwgUmVhY3RNdWx0aUNoaWxkLk1peGluKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01Db21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSB7XG4gIGZvY3VzRE9NQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgZm9jdXNOb2RlKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdXRvRm9jdXNVdGlscztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvQXV0b0ZvY3VzVXRpbHMuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICAvLyBJRTggY2FuIHRocm93IFwiQ2FuJ3QgbW92ZSBmb2N1cyB0byB0aGUgY29udHJvbCBiZWNhdXNlIGl0IGlzIGludmlzaWJsZSxcbiAgLy8gbm90IGVuYWJsZWQsIG9yIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFjY2VwdCB0aGUgZm9jdXMuXCIgZm9yIGFsbCBraW5kcyBvZlxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cbiAgdHJ5IHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZmJqcy9saWIvZm9jdXNOb2RlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eScpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIGNhbWVsaXplU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUnKTtcbnZhciBkYW5nZXJvdXNTdHlsZVZhbHVlID0gcmVxdWlyZSgnLi9kYW5nZXJvdXNTdHlsZVZhbHVlJyk7XG52YXIgaHlwaGVuYXRlU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lJyk7XG52YXIgbWVtb2l6ZVN0cmluZ09ubHkgPSByZXF1aXJlKCdmYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seScpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBwcm9jZXNzU3R5bGVOYW1lID0gbWVtb2l6ZVN0cmluZ09ubHkoZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuICByZXR1cm4gaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSk7XG59KTtcblxudmFyIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gZmFsc2U7XG52YXIgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ2Nzc0Zsb2F0JztcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdmFyIHRlbXBTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICB0cnkge1xuICAgIC8vIElFOCB0aHJvd3MgXCJJbnZhbGlkIGFyZ3VtZW50LlwiIGlmIHJlc2V0dGluZyBzaG9ydGhhbmQgc3R5bGUgcHJvcGVydGllcy5cbiAgICB0ZW1wU3R5bGUuZm9udCA9ICcnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgPSB0cnVlO1xuICB9XG4gIC8vIElFOCBvbmx5IHN1cHBvcnRzIGFjY2Vzc2luZyBjc3NGbG9hdCAoc3RhbmRhcmQpIGFzIHN0eWxlRmxvYXRcbiAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jc3NGbG9hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ3N0eWxlRmxvYXQnO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcblxuICAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuXG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuICB2YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSksIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpIDogdm9pZCAwO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1N0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuXFwndCBjb250YWluIGEgc2VtaWNvbG9uLiVzICcgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkRm9yTmFOVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgY2hlY2tSZW5kZXJNZXNzYWdlID0gZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG4gIHZhciB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgY29tcG9uZW50KSB7XG4gICAgdmFyIG93bmVyO1xuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgfVxuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lLCBvd25lcik7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUsIG93bmVyKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlLCBvd25lcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlLCBvd25lcik7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogU2VyaWFsaXplcyBhIG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyBmb3IgdXNlIGFzIGlubGluZSBzdHlsZXM6XG4gICAqXG4gICAqICAgPiBjcmVhdGVNYXJrdXBGb3JTdHlsZXMoe3dpZHRoOiAnMjAwcHgnLCBoZWlnaHQ6IDB9KVxuICAgKiAgIFwid2lkdGg6MjAwcHg7aGVpZ2h0OjA7XCJcbiAgICpcbiAgICogVW5kZWZpbmVkIHZhbHVlcyBhcmUgaWdub3JlZCBzbyB0aGF0IGRlY2xhcmF0aXZlIHByb2dyYW1taW5nIGlzIGVhc2llci5cbiAgICogVGhlIHJlc3VsdCBzaG91bGQgYmUgSFRNTC1lc2NhcGVkIGJlZm9yZSBpbnNlcnRpb24gaW50byB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yU3R5bGVzOiBmdW5jdGlvbiAoc3R5bGVzLCBjb21wb25lbnQpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBjb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXJpYWxpemVkICs9IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgY29tcG9uZW50KSArICc7JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICAgKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqL1xuICBzZXRWYWx1ZUZvclN0eWxlczogZnVuY3Rpb24gKG5vZGUsIHN0eWxlcywgY29tcG9uZW50KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBjb21wb25lbnQuX2RlYnVnSUQsXG4gICAgICAgIHR5cGU6ICd1cGRhdGUgc3R5bGVzJyxcbiAgICAgICAgcGF5bG9hZDogc3R5bGVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBjb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGNvbXBvbmVudCk7XG4gICAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnIHx8IHN0eWxlTmFtZSA9PT0gJ2Nzc0Zsb2F0Jykge1xuICAgICAgICBzdHlsZU5hbWUgPSBzdHlsZUZsb2F0QWNjZXNzb3I7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBhbnNpb24gPSBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyAmJiBDU1NQcm9wZXJ0eS5zaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNbc3R5bGVOYW1lXTtcbiAgICAgICAgaWYgKGV4cGFuc2lvbikge1xuICAgICAgICAgIC8vIFNob3J0aGFuZCBwcm9wZXJ0eSB0aGF0IElFOCB3b24ndCBsaWtlIHVuc2V0dGluZywgc28gdW5zZXQgZWFjaFxuICAgICAgICAgIC8vIGNvbXBvbmVudCB0byBwbGFjYXRlIGl0XG4gICAgICAgICAgZm9yICh2YXIgaW5kaXZpZHVhbFN0eWxlTmFtZSBpbiBleHBhbnNpb24pIHtcbiAgICAgICAgICAgIHN0eWxlW2luZGl2aWR1YWxTdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5T3BlcmF0aW9ucztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZFJvdzogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTtcblxuLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBNb3N0IHN0eWxlIHByb3BlcnRpZXMgY2FuIGJlIHVuc2V0IGJ5IGRvaW5nIC5zdHlsZVtwcm9wXSA9ICcnIGJ1dCBJRThcbiAqIGRvZXNuJ3QgbGlrZSBkb2luZyB0aGF0IHdpdGggc2hvcnRoYW5kIHByb3BlcnRpZXMgc28gZm9yIHRoZSBwcm9wZXJ0aWVzIHRoYXRcbiAqIElFOCBicmVha3Mgb24sIHdoaWNoIGFyZSBsaXN0ZWQgaGVyZSwgd2UgaW5zdGVhZCB1bnNldCBlYWNoIG9mIHRoZVxuICogaW5kaXZpZHVhbCBwcm9wZXJ0aWVzLiBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzODUuXG4gKiBUaGUgNC12YWx1ZSAnY2xvY2snIHByb3BlcnRpZXMgbGlrZSBtYXJnaW4sIHBhZGRpbmcsIGJvcmRlci13aWR0aCBzZWVtIHRvXG4gKiBiZWhhdmUgd2l0aG91dCBhbnkgcHJvYmxlbXMuIEN1cmlvdXNseSwgbGlzdC1zdHlsZSB3b3JrcyB0b28gd2l0aG91dCBhbnlcbiAqIHNwZWNpYWwgcHJvZGRpbmcuXG4gKi9cbnZhciBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnMgPSB7XG4gIGJhY2tncm91bmQ6IHtcbiAgICBiYWNrZ3JvdW5kQXR0YWNobWVudDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRydWUsXG4gICAgYmFja2dyb3VuZEltYWdlOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUmVwZWF0OiB0cnVlXG4gIH0sXG4gIGJhY2tncm91bmRQb3NpdGlvbjoge1xuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZVxuICB9LFxuICBib3JkZXI6IHtcbiAgICBib3JkZXJXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJCb3R0b206IHtcbiAgICBib3JkZXJCb3R0b21XaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21TdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21Db2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJMZWZ0OiB7XG4gICAgYm9yZGVyTGVmdFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckxlZnRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyUmlnaHQ6IHtcbiAgICBib3JkZXJSaWdodFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJUb3A6IHtcbiAgICBib3JkZXJUb3BXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJUb3BTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJUb3BDb2xvcjogdHJ1ZVxuICB9LFxuICBmb250OiB7XG4gICAgZm9udFN0eWxlOiB0cnVlLFxuICAgIGZvbnRWYXJpYW50OiB0cnVlLFxuICAgIGZvbnRXZWlnaHQ6IHRydWUsXG4gICAgZm9udFNpemU6IHRydWUsXG4gICAgbGluZUhlaWdodDogdHJ1ZSxcbiAgICBmb250RmFtaWx5OiB0cnVlXG4gIH0sXG4gIG91dGxpbmU6IHtcbiAgICBvdXRsaW5lV2lkdGg6IHRydWUsXG4gICAgb3V0bGluZVN0eWxlOiB0cnVlLFxuICAgIG91dGxpbmVDb2xvcjogdHJ1ZVxuICB9XG59O1xuXG52YXIgQ1NTUHJvcGVydHkgPSB7XG4gIGlzVW5pdGxlc3NOdW1iZXI6IGlzVW5pdGxlc3NOdW1iZXIsXG4gIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uczogc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9DU1NQcm9wZXJ0eS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX2h5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZmJqcy9saWIvY2FtZWxpemUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyO1xudmFyIHN0eWxlV2FybmluZ3MgPSB7fTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlLCBjb21wb25lbnQpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBpc05vbk51bWVyaWMgPSBpc05hTih2YWx1ZSk7XG4gIGlmIChpc05vbk51bWVyaWMgfHwgdmFsdWUgPT09IDAgfHwgaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSB7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7IC8vIGNhc3QgdG8gc3RyaW5nXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBBbGxvdyAnMCcgdG8gcGFzcyB0aHJvdWdoIHdpdGhvdXQgd2FybmluZy4gMCBpcyBhbHJlYWR5IHNwZWNpYWwgYW5kXG4gICAgICAvLyBkb2Vzbid0IHJlcXVpcmUgdW5pdHMsIHNvIHdlIGRvbid0IG5lZWQgdG8gd2FybiBhYm91dCBpdC5cbiAgICAgIGlmIChjb21wb25lbnQgJiYgdmFsdWUgIT09ICcwJykge1xuICAgICAgICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gb3duZXIuZ2V0TmFtZSgpIDogbnVsbDtcbiAgICAgICAgaWYgKG93bmVyTmFtZSAmJiAhc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdKSB7XG4gICAgICAgICAgc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgdmFyIHdhcm5pbmdzID0gc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdO1xuICAgICAgICAgIHdhcm5lZCA9IHdhcm5pbmdzW25hbWVdO1xuICAgICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgICB3YXJuaW5nc1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdhIGAlc2AgdGFnIChvd25lcjogYCVzYCkgd2FzIHBhc3NlZCBhIG51bWVyaWMgc3RyaW5nIHZhbHVlICcgKyAnZm9yIENTUyBwcm9wZXJ0eSBgJXNgICh2YWx1ZTogYCVzYCkgd2hpY2ggd2lsbCBiZSB0cmVhdGVkICcgKyAnYXMgYSB1bml0bGVzcyBudW1iZXIgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdC4nLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50LnR5cGUsIG93bmVyTmFtZSB8fCAndW5rbm93bicsIG5hbWUsIHZhbHVlKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgKyAncHgnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhbmdlcm91c1N0eWxlVmFsdWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKCcuL2h5cGhlbmF0ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNZW1vaXplcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBzdHJpbmcgYXJndW1lbnQuXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZVN0cmluZ09ubHkoY2FsbGJhY2spIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgaWYgKCFjYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHJpbmcpKSB7XG4gICAgICBjYWNoZVtzdHJpbmddID0gY2FsbGJhY2suY2FsbCh0aGlzLCBzdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbc3RyaW5nXTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplU3RyaW5nT25seTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL21lbW9pemVTdHJpbmdPbmx5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXInKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKCdeWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSkgOiB2b2lkIDA7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICYmICF2YWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICYmIGlzTmFOKHZhbHVlKSB8fCBwcm9wZXJ0eUluZm8uaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUgJiYgdmFsdWUgPCAxIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSBmYWxzZTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggRE9NIHByb3BlcnRpZXMuXG4gKi9cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgSUQgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbmVzY2FwZWQgSUQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZy5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcihpZCk7XG4gIH0sXG5cbiAgc2V0QXR0cmlidXRlRm9ySUQ6IGZ1bmN0aW9uIChub2RlLCBpZCkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FLCBpZCk7XG4gIH0sXG5cbiAgY3JlYXRlTWFya3VwRm9yUm9vdDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FICsgJz1cIlwiJztcbiAgfSxcblxuICBzZXRBdHRyaWJ1dGVGb3JSb290OiBmdW5jdGlvbiAobm9kZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LlJPT1RfQVRUUklCVVRFX05BTUUsICcnKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7P3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgbnVsbCBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz1cIlwiJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgY3VzdG9tIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgZW1wdHkgc3RyaW5nIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICAgIG5vZGVbcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuICAgICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBheWxvYWQgPSB7fTtcbiAgICAgIHBheWxvYWRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKS5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3VwZGF0ZSBhdHRyaWJ1dGUnLFxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgc2V0VmFsdWVGb3JBdHRyaWJ1dGU6IGZ1bmN0aW9uIChub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnICsgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGF5bG9hZCA9IHt9O1xuICAgICAgcGF5bG9hZFtuYW1lXSA9IHZhbHVlO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgIGluc3RhbmNlSUQ6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELFxuICAgICAgICB0eXBlOiAndXBkYXRlIGF0dHJpYnV0ZScsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBhdHRyaWJ1dGVzIGZyb20gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgaW5zdGFuY2VJRDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsXG4gICAgICAgIHR5cGU6ICdyZW1vdmUgYXR0cmlidXRlJyxcbiAgICAgICAgcGF5bG9hZDogbmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKS5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3JlbW92ZSBhdHRyaWJ1dGUnLFxuICAgICAgICBwYXlsb2FkOiBuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL0RPTVByb3BlcnR5T3BlcmF0aW9ucy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xuXG4vKipcbiAqIEVzY2FwZXMgYXR0cmlidXRlIHZhbHVlIHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSkge1xuICByZXR1cm4gJ1wiJyArIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih2YWx1ZSkgKyAnXCInO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4nKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xuXG52YXIgZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUgPSByZXF1aXJlKCcuL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lJyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RFdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0IHBsdWdnYWJsZVxuICogICAgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGhhc0V2ZW50UGFnZVhZO1xudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gZmFsc2U7XG52YXIgcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyID0gMDtcblxuLy8gRm9yIGV2ZW50cyBsaWtlICdzdWJtaXQnIHdoaWNoIGRvbid0IGNvbnNpc3RlbnRseSBidWJibGUgKHdoaWNoIHdlIHRyYXAgYXQgYVxuLy8gbG93ZXIgbm9kZSB0aGFuIGBkb2N1bWVudGApLCBiaW5kaW5nIGF0IGBkb2N1bWVudGAgd291bGQgY2F1c2UgZHVwbGljYXRlXG4vLyBldmVudHMgc28gd2UgZG9uJ3QgaW5jbHVkZSB0aGVtIGhlcmVcbnZhciB0b3BFdmVudE1hcHBpbmcgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BBbmltYXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25lbmQnKSB8fCAnYW5pbWF0aW9uZW5kJyxcbiAgdG9wQW5pbWF0aW9uSXRlcmF0aW9uOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJykgfHwgJ2FuaW1hdGlvbml0ZXJhdGlvbicsXG4gIHRvcEFuaW1hdGlvblN0YXJ0OiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uc3RhcnQnKSB8fCAnYW5pbWF0aW9uc3RhcnQnLFxuICB0b3BCbHVyOiAnYmx1cicsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcENoYW5nZTogJ2NoYW5nZScsXG4gIHRvcENsaWNrOiAnY2xpY2snLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BNb3VzZURvd246ICdtb3VzZWRvd24nLFxuICB0b3BNb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3BNb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgdG9wTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgdG9wTW91c2VVcDogJ21vdXNldXAnLFxuICB0b3BQYXN0ZTogJ3Bhc3RlJyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTY3JvbGw6ICdzY3JvbGwnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogJ3NlbGVjdGlvbmNoYW5nZScsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUZXh0SW5wdXQ6ICd0ZXh0SW5wdXQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFRvdWNoQ2FuY2VsOiAndG91Y2hjYW5jZWwnLFxuICB0b3BUb3VjaEVuZDogJ3RvdWNoZW5kJyxcbiAgdG9wVG91Y2hNb3ZlOiAndG91Y2htb3ZlJyxcbiAgdG9wVG91Y2hTdGFydDogJ3RvdWNoc3RhcnQnLFxuICB0b3BUcmFuc2l0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgndHJhbnNpdGlvbmVuZCcpIHx8ICd0cmFuc2l0aW9uZW5kJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnLFxuICB0b3BXaGVlbDogJ3doZWVsJ1xufTtcblxuLyoqXG4gKiBUbyBlbnN1cmUgbm8gY29uZmxpY3RzIHdpdGggb3RoZXIgcG90ZW50aWFsIFJlYWN0IGluc3RhbmNlcyBvbiB0aGUgcGFnZVxuICovXG52YXIgdG9wTGlzdGVuZXJzSURLZXkgPSAnX3JlYWN0TGlzdGVuZXJzSUQnICsgU3RyaW5nKE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBpcyB1c2VkIHRvIGF0dGFjaCB0b3AtbGV2ZWwgZXZlbnQgbGlzdGVuZXJzLiBGb3JcbiAqIGV4YW1wbGU6XG4gKlxuICogICBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcignbXlJRCcsICdvbkNsaWNrJywgbXlGdW5jdGlvbik7XG4gKlxuICogVGhpcyB3b3VsZCBhbGxvY2F0ZSBhIFwicmVnaXN0cmF0aW9uXCIgb2YgYCgnb25DbGljaycsIG15RnVuY3Rpb24pYCBvbiAnbXlJRCcuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSBfYXNzaWduKHt9LCBSZWFjdEV2ZW50RW1pdHRlck1peGluLCB7XG5cbiAgLyoqXG4gICAqIEluamVjdGFibGUgZXZlbnQgYmFja2VuZFxuICAgKi9cbiAgUmVhY3RFdmVudExpc3RlbmVyOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAgICAgKi9cbiAgICBpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChSZWFjdEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5zZXRIYW5kbGVUb3BMZXZlbChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaGFuZGxlVG9wTGV2ZWwpO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciBvciBub3QgYW55IGNyZWF0ZWQgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBpZiBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIGlmIChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnNldEVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGNhbGxiYWNrcyBhcmUgZW5hYmxlZC5cbiAgICovXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIShSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyICYmIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuaXNFbmFibGVkKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gICAqXG4gICAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAgICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAgICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcbiAgICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAgICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcbiAgICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gICAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAgKlxuICAgKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gICAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gICAqL1xuICBsaXN0ZW5UbzogZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICAgIHZhciBtb3VudEF0ID0gY29udGVudERvY3VtZW50SGFuZGxlO1xuICAgIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BXaGVlbCcpIHtcbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnd2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BXaGVlbCcsICd3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnbW91c2V3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ21vdXNld2hlZWwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBuZWVkcyB0byBjYXB0dXJlIGEgZGlmZmVyZW50IG1vdXNlIHNjcm9sbCBldmVudC5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Rlc3RzL3Njcm9sbC5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BTY3JvbGwnKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQoJ3RvcFNjcm9sbCcsICdzY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BTY3JvbGwnLCAnc2Nyb2xsJywgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5XSU5ET1dfSEFORExFKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcEZvY3VzJyB8fCBkZXBlbmRlbmN5ID09PSAndG9wQmx1cicpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1cycsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCgndG9wQmx1cicsICdibHVyJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1c2luJykpIHtcbiAgICAgICAgICAgIC8vIElFIGhhcyBgZm9jdXNpbmAgYW5kIGBmb2N1c291dGAgZXZlbnRzIHdoaWNoIGJ1YmJsZS5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMDgvMDQvZGVsZWdhdGluZ190aGUuaHRtbFxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1c2luJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEJsdXInLCAnZm9jdXNvdXQnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0byBtYWtlIHN1cmUgYmx1ciBhbmQgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGF0dGFjaGVkIG9uY2VcbiAgICAgICAgICBpc0xpc3RlbmluZy50b3BCbHVyID0gdHJ1ZTtcbiAgICAgICAgICBpc0xpc3RlbmluZy50b3BGb2N1cyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodG9wRXZlbnRNYXBwaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcEV2ZW50TWFwcGluZ1tkZXBlbmRlbmN5XSwgbW91bnRBdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICB0cmFwQ2FwdHVyZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICAvKipcbiAgICogUHJvdGVjdCBhZ2FpbnN0IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkgcmV0dXJuaW5nIG51bGxcbiAgICogU29tZSBwb3B1cCBibG9ja2VyIGV4dGVuc2lvbnMgYXBwZWFyIHRvIGRvIHRoaXM6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjg4N1xuICAgKi9cbiAgc3VwcG9ydHNFdmVudFBhZ2VYWTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnQnKTtcbiAgICByZXR1cm4gZXYgIT0gbnVsbCAmJiAncGFnZVgnIGluIGV2O1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIHdpbmRvdyBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMuIFdlIGNhY2hlIHNjcm9sbCB2YWx1ZXMgc28gdGhhdFxuICAgKiBhcHBsaWNhdGlvbiBjb2RlIGNhbiBhY2Nlc3MgdGhlbSB3aXRob3V0IHRyaWdnZXJpbmcgcmVmbG93cy5cbiAgICpcbiAgICogVmlld3BvcnRNZXRyaWNzIGlzIG9ubHkgdXNlZCBieSBTeW50aGV0aWNNb3VzZS9Ub3VjaEV2ZW50IGFuZCBvbmx5IHdoZW5cbiAgICogcGFnZVgvcGFnZVkgaXNuJ3Qgc3VwcG9ydGVkIChsZWdhY3kgYnJvd3NlcnMpLlxuICAgKlxuICAgKiBOT1RFOiBTY3JvbGwgZXZlbnRzIGRvIG5vdCBidWJibGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Njcm9sbC5odG1sXG4gICAqL1xuICBlbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3Jpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGFzRXZlbnRQYWdlWFkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaGFzRXZlbnRQYWdlWFkgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc3VwcG9ydHNFdmVudFBhZ2VYWSgpO1xuICAgIH1cbiAgICBpZiAoIWhhc0V2ZW50UGFnZVhZICYmICFpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSkge1xuICAgICAgdmFyIHJlZnJlc2ggPSBWaWV3cG9ydE1ldHJpY3MucmVmcmVzaFNjcm9sbFZhbHVlcztcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIubW9uaXRvclNjcm9sbFZhbHVlKHJlZnJlc2gpO1xuICAgICAgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcblxuZnVuY3Rpb24gcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHtcblxuICAvKipcbiAgICogU3RyZWFtcyBhIGZpcmVkIHRvcC1sZXZlbCBldmVudCB0byBgRXZlbnRQbHVnaW5IdWJgIHdoZXJlIHBsdWdpbnMgaGF2ZSB0aGVcbiAgICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAgICovXG4gIGhhbmRsZVRvcExldmVsOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZXZlbnRzID0gRXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50RW1pdHRlck1peGluO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1ha2VQcmVmaXhNYXAoc3R5bGVQcm9wLCBldmVudE5hbWUpIHtcbiAgdmFyIHByZWZpeGVzID0ge307XG5cbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ21zJyArIHN0eWxlUHJvcF0gPSAnTVMnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTycgKyBzdHlsZVByb3BdID0gJ28nICsgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHZlbmRvclByZWZpeGVzID0ge1xuICBhbmltYXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25FbmQnKSxcbiAgYW5pbWF0aW9uaXRlcmF0aW9uOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uSXRlcmF0aW9uJyksXG4gIGFuaW1hdGlvbnN0YXJ0OiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uU3RhcnQnKSxcbiAgdHJhbnNpdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnVHJhbnNpdGlvbicsICdUcmFuc2l0aW9uRW5kJylcbn07XG5cbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG52YXIgcHJlZml4ZWRFdmVudE5hbWVzID0ge307XG5cbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cbnZhciBzdHlsZSA9IHt9O1xuXG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25zdGFydC5hbmltYXRpb247XG4gIH1cblxuICAvLyBTYW1lIGFzIGFib3ZlXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZlbmRvciBwcmVmaXhlZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG52YXIgUmVhY3RET01JbnB1dCA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICB2YXIgY2hlY2tlZCA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0Q2hlY2tlZChwcm9wcyk7XG5cbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7XG4gICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC50eXBlIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcyAoc2V0dGluZyAudmFsdWVcbiAgICAgIC8vIGJlZm9yZSAudHlwZSBtZWFucyAudmFsdWUgaXMgbG9zdCBpbiBJRTExIGFuZCBiZWxvdylcbiAgICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnN0ZXAgYmVmb3JlIC52YWx1ZSAoc2V0dGluZyAudmFsdWUgYmVmb3JlIC5zdGVwXG4gICAgICAvLyBtZWFucyAudmFsdWUgaXMgcm91bmRlZCBvbiBtb3VudCwgYmFzZWQgdXBvbiBzdGVwIHByZWNpc2lvbilcbiAgICAgIHN0ZXA6IHVuZGVmaW5lZCxcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLm1pbiAmIC5tYXggYmVmb3JlIC52YWx1ZSAodG8gZW5zdXJlIHByb3BlciBvcmRlclxuICAgICAgLy8gaW4gY29ybmVyIGNhc2VzIHN1Y2ggYXMgbWluIG9yIG1heCBkZXJpdmluZyBmcm9tIHZhbHVlLCBlLmcuIElzc3VlICM3MTcwKVxuICAgICAgbWluOiB1bmRlZmluZWQsXG4gICAgICBtYXg6IHVuZGVmaW5lZFxuICAgIH0sIHByb3BzLCB7XG4gICAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB2YWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQsXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaG9zdFByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG5cbiAgICAgIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgaWYgKHByb3BzLnZhbHVlTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVMaW5rKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmNoZWNrZWRMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkTGluaykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2BjaGVja2VkTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5DaGVja2VkTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgICBpbml0aWFsVmFsdWU6IHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IGRlZmF1bHRWYWx1ZSxcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdClcbiAgICB9O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY29udHJvbGxlZCA9IGlzQ29udHJvbGxlZChwcm9wcyk7XG4gICAgICB2YXIgb3duZXIgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG5cbiAgICAgIGlmICghaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnN0Ll93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiAhY29udHJvbGxlZCAmJiAhZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGNoYW5naW5nIGEgY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIHVuY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFNob3VsZG4ndCB0aGlzIGJlIGdldENoZWNrZWQocHJvcHMpP1xuICAgIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgICBpZiAoY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSwgJ2NoZWNrZWQnLCBjaGVja2VkIHx8IGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgICAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BzLnZhbHVlID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5jaGVja2VkID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcG9zdE1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuXG4gICAgLy8gRGV0YWNoIHZhbHVlIGZyb20gZGVmYXVsdFZhbHVlLiBXZSB3b24ndCBkbyBhbnl0aGluZyBpZiB3ZSdyZSB3b3JraW5nIG9uXG4gICAgLy8gc3VibWl0IG9yIHJlc2V0IGlucHV0cyBhcyB0aG9zZSB2YWx1ZXMgJiBkZWZhdWx0VmFsdWVzIGFyZSBsaW5rZWQuIFRoZXlcbiAgICAvLyBhcmUgbm90IHJlc2V0YWJsZSBub2RlcyBzbyB0aGlzIG9wZXJhdGlvbiBkb2Vzbid0IG1hdHRlciBhbmQgYWN0dWFsbHlcbiAgICAvLyByZW1vdmVzIGJyb3dzZXItZGVmYXVsdCB2YWx1ZXMgKGVnIFwiU3VibWl0IFF1ZXJ5XCIpIHdoZW4gbm8gdmFsdWUgaXNcbiAgICAvLyBwcm92aWRlZC5cblxuICAgIHN3aXRjaCAocHJvcHMudHlwZSkge1xuICAgICAgY2FzZSAnc3VibWl0JzpcbiAgICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjb2xvcic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ2RhdGV0aW1lJzpcbiAgICAgIGNhc2UgJ2RhdGV0aW1lLWxvY2FsJzpcbiAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIC8vIFRoaXMgZml4ZXMgdGhlIG5vLXNob3cgaXNzdWUgb24gaU9TIFNhZmFyaSBhbmQgQW5kcm9pZCBDaHJvbWU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzIzM1xuICAgICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICAgIG5vZGUudmFsdWUgPSBub2RlLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBub2RlLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcbiAgICAvLyB0aGlzIGlzIG5lZWRlZCB0byB3b3JrIGFyb3VuZCBhIGNocm9tZSBidWcgd2hlcmUgc2V0dGluZyBkZWZhdWx0Q2hlY2tlZFxuICAgIC8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbiAgICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxuICAgIC8vIFdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgdW5zZXQgbmFtZSB0byBhdm9pZCBkaXNydXB0aW5nIHJhZGlvIGJ1dHRvbiBncm91cHMuXG4gICAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgICBub2RlLm5hbWUgPSAnJztcbiAgICB9XG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG5cbiAgLy8gSGVyZSB3ZSB1c2UgYXNhcCB0byB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2hcbiAgLy8gaXMgaW1wb3J0YW50IHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG5cbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcm9vdE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0sIGxldCdzIGp1c3QgdXNlIHRoZSBnbG9iYWxcbiAgICAvLyBgcXVlcnlTZWxlY3RvckFsbGAgdG8gZW5zdXJlIHdlIGRvbid0IG1pc3MgYW55dGhpbmcuXG4gICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlck5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG4gICAgICB2YXIgb3RoZXJJbnN0YW5jZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG90aGVyTm9kZSk7XG4gICAgICAhb3RoZXJJbnN0YW5jZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKSA6IF9wcm9kSW52YXJpYW50KCc5MCcpIDogdm9pZCAwO1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgb3RoZXJJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSW5wdXQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NSW5wdXQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3QnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICAnYnV0dG9uJzogdHJ1ZSxcbiAgJ2NoZWNrYm94JzogdHJ1ZSxcbiAgJ2ltYWdlJzogdHJ1ZSxcbiAgJ2hpZGRlbic6IHRydWUsXG4gICdyYWRpbyc6IHRydWUsXG4gICdyZXNldCc6IHRydWUsXG4gICdzdWJtaXQnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKSB7XG4gICEoaW5wdXRQcm9wcy5jaGVja2VkTGluayA9PSBudWxsIHx8IGlucHV0UHJvcHMudmFsdWVMaW5rID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgY2hlY2tlZExpbmsgYW5kIGEgdmFsdWVMaW5rLiBJZiB5b3Ugd2FudCB0byB1c2UgY2hlY2tlZExpbmssIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gdXNlIHZhbHVlTGluayBhbmQgdmljZSB2ZXJzYS4nKSA6IF9wcm9kSW52YXJpYW50KCc4NycpIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xuICAhKGlucHV0UHJvcHMudmFsdWUgPT0gbnVsbCAmJiBpbnB1dFByb3BzLm9uQ2hhbmdlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgdmFsdWVMaW5rIGFuZCBhIHZhbHVlIG9yIG9uQ2hhbmdlIGV2ZW50LiBJZiB5b3Ugd2FudCB0byB1c2UgdmFsdWUgb3Igb25DaGFuZ2UsIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gdXNlIHZhbHVlTGluay4nKSA6IF9wcm9kSW52YXJpYW50KCc4OCcpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcykge1xuICBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKTtcbiAgIShpbnB1dFByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBpbnB1dFByb3BzLm9uQ2hhbmdlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgY2hlY2tlZExpbmsgYW5kIGEgY2hlY2tlZCBwcm9wZXJ0eSBvciBvbkNoYW5nZSBldmVudC4gSWYgeW91IHdhbnQgdG8gdXNlIGNoZWNrZWQgb3Igb25DaGFuZ2UsIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gdXNlIGNoZWNrZWRMaW5rJykgOiBfcHJvZEludmFyaWFudCgnODknKSA6IHZvaWQgMDtcbn1cblxudmFyIHByb3BUeXBlcyA9IHtcbiAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgfSxcbiAgY2hlY2tlZDogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gIH0sXG4gIG9uQ2hhbmdlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuY1xufTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICovXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHtcbiAgY2hlY2tQcm9wVHlwZXM6IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcywgb3duZXIpIHtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHByb3BUeXBlc1twcm9wTmFtZV0ocHJvcHMsIHByb3BOYW1lLCB0YWdOYW1lLCAncHJvcCcsIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcik7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIGZvcm0gcHJvcFR5cGU6ICVzJXMnLCBlcnJvci5tZXNzYWdlLCBhZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gdmFsdWUgcHJvcCBvciBsaW5rLlxuICAgKi9cbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChpbnB1dFByb3BzKSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEByZXR1cm4geyp9IGN1cnJlbnQgY2hlY2tlZCBzdGF0dXMgb2YgdGhlIGlucHV0IGVpdGhlciBmcm9tIGNoZWNrZWQgcHJvcFxuICAgKiAgICAgICAgICAgICBvciBsaW5rLlxuICAgKi9cbiAgZ2V0Q2hlY2tlZDogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy5jaGVja2VkTGluaykge1xuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZExpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBjaGFuZ2UgZXZlbnQgdG8gaGFuZGxlXG4gICAqL1xuICBleGVjdXRlT25DaGFuZ2U6IGZ1bmN0aW9uIChpbnB1dFByb3BzLCBldmVudCkge1xuICAgIGlmIChpbnB1dFByb3BzLnZhbHVlTGluaykge1xuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMub25DaGFuZ2UpIHtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLm9uQ2hhbmdlLmNhbGwodW5kZWZpbmVkLCBldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtlZFZhbHVlVXRpbHM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL0xpbmtlZFZhbHVlVXRpbHMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSBmYWxzZTtcblxuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgfSBlbHNlIGlmICghZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbikge1xuICAgICAgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpIDogdm9pZCAwO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cbnZhciBSZWFjdERPTU9wdGlvbiA9IHtcbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGhvc3RQYXJlbnQpIHtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgd2hldGhlciB0aGlzIG9wdGlvbiBpcyAnc2VsZWN0ZWQnXG4gICAgdmFyIHNlbGVjdFZhbHVlID0gbnVsbDtcbiAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XG4gICAgICB2YXIgc2VsZWN0UGFyZW50ID0gaG9zdFBhcmVudDtcblxuICAgICAgaWYgKHNlbGVjdFBhcmVudC5fdGFnID09PSAnb3B0Z3JvdXAnKSB7XG4gICAgICAgIHNlbGVjdFBhcmVudCA9IHNlbGVjdFBhcmVudC5faG9zdFBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdFBhcmVudCAhPSBudWxsICYmIHNlbGVjdFBhcmVudC5fdGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgICBzZWxlY3RWYWx1ZSA9IFJlYWN0RE9NU2VsZWN0LmdldFNlbGVjdFZhbHVlQ29udGV4dChzZWxlY3RQYXJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBudWxsIChlLmcuLCBubyBzcGVjaWZpZWQgdmFsdWUgb3IgYWZ0ZXIgaW5pdGlhbCBtb3VudClcbiAgICAvLyBvciBtaXNzaW5nIChlLmcuLCBmb3IgPGRhdGFsaXN0PiksIHdlIGRvbid0IGNoYW5nZSBwcm9wcy5zZWxlY3RlZFxuICAgIHZhciBzZWxlY3RlZCA9IG51bGw7XG4gICAgaWYgKHNlbGVjdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0gcHJvcHMudmFsdWUgKyAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RWYWx1ZSkpIHtcbiAgICAgICAgLy8gbXVsdGlwbGVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICgnJyArIHNlbGVjdFZhbHVlW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZCA9ICcnICsgc2VsZWN0VmFsdWUgPT09IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHsgc2VsZWN0ZWQ6IHNlbGVjdGVkIH07XG4gIH0sXG5cbiAgcG9zdE1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHByb3BzLnZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7IHNlbGVjdGVkOiB1bmRlZmluZWQsIGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuXG4gICAgLy8gUmVhZCBzdGF0ZSBvbmx5IGZyb20gaW5pdGlhbCBtb3VudCBiZWNhdXNlIDxzZWxlY3Q+IHVwZGF0ZXMgdmFsdWVcbiAgICAvLyBtYW51YWxseTsgd2UgbmVlZCB0aGUgaW5pdGlhbCBzdGF0ZSBvbmx5IGZvciBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgaWYgKGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICBob3N0UHJvcHMuc2VsZWN0ZWQgPSBpbnN0Ll93cmFwcGVyU3RhdGUuc2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIGhvc3RQcm9wcy5jaGlsZHJlbiA9IGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NT3B0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTU9wdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuVmFsdWVMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCAmJiB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSkge1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKHRoaXMsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wVHlwZXMoaW5zdCwgcHJvcHMpIHtcbiAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCdzZWxlY3QnLCBwcm9wcywgb3duZXIpO1xuXG4gIGlmIChwcm9wcy52YWx1ZUxpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlTGluaykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgc2VsZWN0YCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSkgOiB2b2lkIDA7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGluc3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbGVcbiAqIEBwYXJhbSB7Kn0gcHJvcFZhbHVlIEEgc3RyaW5nYWJsZSAod2l0aCBgbXVsdGlwbGVgLCBhIGxpc3Qgb2Ygc3RyaW5nYWJsZXMpLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhpbnN0LCBtdWx0aXBsZSwgcHJvcFZhbHVlKSB7XG4gIHZhciBzZWxlY3RlZFZhbHVlLCBpO1xuICB2YXIgb3B0aW9ucyA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpLm9wdGlvbnM7XG5cbiAgaWYgKG11bHRpcGxlKSB7XG4gICAgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGVjdGVkVmFsdWVbJycgKyBwcm9wVmFsdWVbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkob3B0aW9uc1tpXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tpXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgc2V0IGBzZWxlY3QudmFsdWVgIGFzIGV4YWN0IGJlaGF2aW9yIGlzbid0IGNvbnNpc3RlbnQgYWNyb3NzIGFsbFxuICAgIC8vIGJyb3dzZXJzIGZvciBhbGwgY2FzZXMuXG4gICAgc2VsZWN0ZWRWYWx1ZSA9ICcnICsgcHJvcFZhbHVlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob3B0aW9uc1tpXS52YWx1ZSA9PT0gc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xudmFyIFJlYWN0RE9NU2VsZWN0ID0ge1xuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIHJldHVybiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZSxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja1NlbGVjdFByb3BUeXBlcyhpbnN0LCBwcm9wcyk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgcGVuZGluZ1VwZGF0ZTogZmFsc2UsXG4gICAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdCksXG4gICAgICB3YXNNdWx0aXBsZTogQm9vbGVhbihwcm9wcy5tdWx0aXBsZSlcbiAgICB9O1xuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpIDogdm9pZCAwO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0U2VsZWN0VmFsdWVDb250ZXh0OiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIFJlYWN0RE9NT3B0aW9uIGxvb2tzIGF0IHRoaXMgaW5pdGlhbCB2YWx1ZSBzbyB0aGUgaW5pdGlhbCBnZW5lcmF0ZWRcbiAgICAvLyBtYXJrdXAgaGFzIGNvcnJlY3QgYHNlbGVjdGVkYCBhdHRyaWJ1dGVzXG4gICAgcmV0dXJuIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU7XG4gIH0sXG5cbiAgcG9zdFVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBBZnRlciB0aGUgaW5pdGlhbCBtb3VudCwgd2UgY29udHJvbCBzZWxlY3RlZC1uZXNzIG1hbnVhbGx5IHNvIGRvbid0IHBhc3NcbiAgICAvLyB0aGlzIHZhbHVlIGRvd25cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIHdhc011bHRpcGxlID0gaW5zdC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpO1xuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG4gICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh3YXNNdWx0aXBsZSAhPT0gQm9vbGVhbihwcm9wcy5tdWx0aXBsZSkpIHtcbiAgICAgIC8vIEZvciBzaW1wbGljaXR5LCByZWFwcGx5IGBkZWZhdWx0VmFsdWVgIGlmIGBtdWx0aXBsZWAgaXMgdG9nZ2xlZC5cbiAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCBwcm9wcy5kZWZhdWx0VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV2ZXJ0IHRoZSBzZWxlY3QgYmFjayB0byBpdHMgZGVmYXVsdCB1bnNlbGVjdGVkIHN0YXRlLlxuICAgICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCBwcm9wcy5tdWx0aXBsZSA/IFtdIDogJycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcblxuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICBSZWFjdFVwZGF0ZXMuYXNhcCh1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01TZWxlY3QuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZUxpbmsgPSBmYWxzZTtcbnZhciBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NVGV4dGFyZWEudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSB7XG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IF9wcm9kSW52YXJpYW50KCc5MScpIDogdm9pZCAwO1xuXG4gICAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgICAvLyB0byBvbmx5IHNldCB0aGUgdmFsdWUgaWYvd2hlbiB0aGUgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBub2RlIHZhbHVlICh3aGljaCB3b3VsZFxuICAgIC8vIGNvbXBsZXRlbHkgc29sdmUgdGhpcyBJRTkgYnVnKSwgYnV0IFNlYmFzdGlhbitCZW4gc2VlbWVkIHRvIGxpa2UgdGhpcyBzb2x1dGlvbi5cbiAgICAvLyBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZCB0byBiZSBhIHN0cmluZy5cbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGNoaWxkcmVuOiAnJyArIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaG9zdFByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ3RleHRhcmVhJywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgICBpZiAocHJvcHMudmFsdWVMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZUxpbmspIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVMaW5rYCBwcm9wIG9uIGB0ZXh0YXJlYWAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbHVlTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbERlZmF1bHRWYWwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICB2YXIgaW5pdGlhbFZhbHVlID0gdmFsdWU7XG5cbiAgICAvLyBPbmx5IGJvdGhlciBmZXRjaGluZyBkZWZhdWx0IHZhbHVlIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSBpdFxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgICEoZGVmYXVsdFZhbHVlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IF9wcm9kSW52YXJpYW50KCc5MicpIDogdm9pZCAwO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJykgOiBfcHJvZEludmFyaWFudCgnOTMnKSA6IHZvaWQgMDtcbiAgICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBpbml0aWFsVmFsdWU6ICcnICsgaW5pdGlhbFZhbHVlLFxuICAgICAgbGlzdGVuZXJzOiBudWxsLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgICAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgfSxcblxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuXG4gICAgLy8gV2FybmluZzogbm9kZS52YWx1ZSBtYXkgYmUgdGhlIGVtcHR5IHN0cmluZyBhdCB0aGlzIHBvaW50IChJRTExKSBpZiBwbGFjZWhvbGRlciBpcyBzZXQuXG4gICAgbm9kZS52YWx1ZSA9IG5vZGUudGV4dENvbnRlbnQ7IC8vIERldGFjaCB2YWx1ZSBmcm9tIGRlZmF1bHRWYWx1ZVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRhcmVhO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTVRleHRhcmVhLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RDaGlsZFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRSZWNvbmNpbGVyJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGZsYXR0ZW5DaGlsZHJlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbkNoaWxkcmVuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIG1hcmt1cCB0byBiZSByZW5kZXJlZCBhbmQgaW5zZXJ0ZWQgYXQgYSBzdXBwbGllZCBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXguXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlSW5zZXJ0TWFya3VwKG1hcmt1cCwgYWZ0ZXJOb2RlLCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnSU5TRVJUX01BUktVUCcsXG4gICAgY29udGVudDogbWFya3VwLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiB0b0luZGV4LFxuICAgIGFmdGVyTm9kZTogYWZ0ZXJOb2RlXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIG1vdmluZyBhbiBleGlzdGluZyBlbGVtZW50IHRvIGFub3RoZXIgaW5kZXguXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBTb3VyY2UgaW5kZXggb2YgdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VNb3ZlKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdNT1ZFX0VYSVNUSU5HJyxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogY2hpbGQuX21vdW50SW5kZXgsXG4gICAgZnJvbU5vZGU6IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShjaGlsZCksXG4gICAgdG9JbmRleDogdG9JbmRleCxcbiAgICBhZnRlck5vZGU6IGFmdGVyTm9kZVxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciByZW1vdmluZyBhbiBlbGVtZW50IGF0IGFuIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggSW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZVJlbW92ZShjaGlsZCwgbm9kZSkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1JFTU9WRV9OT0RFJyxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogY2hpbGQuX21vdW50SW5kZXgsXG4gICAgZnJvbU5vZGU6IG5vZGUsXG4gICAgdG9JbmRleDogbnVsbCxcbiAgICBhZnRlck5vZGU6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3Igc2V0dGluZyB0aGUgbWFya3VwIG9mIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZVNldE1hcmt1cChtYXJrdXApIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdTRVRfTUFSS1VQJyxcbiAgICBjb250ZW50OiBtYXJrdXAsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJOb2RlOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIHNldHRpbmcgdGhlIHRleHQgY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dENvbnRlbnQgVGV4dCBjb250ZW50IHRvIHNldC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VUZXh0Q29udGVudCh0ZXh0Q29udGVudCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1RFWFRfQ09OVEVOVCcsXG4gICAgY29udGVudDogdGV4dENvbnRlbnQsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJOb2RlOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogUHVzaCBhbiB1cGRhdGUsIGlmIGFueSwgb250byB0aGUgcXVldWUuIENyZWF0ZXMgYSBuZXcgcXVldWUgaWYgbm9uZSBpc1xuICogcGFzc2VkIGFuZCBhbHdheXMgcmV0dXJucyB0aGUgcXVldWUuIE11dGF0aXZlLlxuICovXG5mdW5jdGlvbiBlbnF1ZXVlKHF1ZXVlLCB1cGRhdGUpIHtcbiAgaWYgKHVwZGF0ZSkge1xuICAgIHF1ZXVlID0gcXVldWUgfHwgW107XG4gICAgcXVldWUucHVzaCh1cGRhdGUpO1xuICB9XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzZXMgYW55IGVucXVldWVkIHVwZGF0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKGluc3QsIHVwZGF0ZVF1ZXVlKSB7XG4gIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyhpbnN0LCB1cGRhdGVRdWV1ZSk7XG59XG5cbnZhciBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbiA9IGVtcHR5RnVuY3Rpb247XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgZ2V0RGVidWdJRCA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgaWYgKCFpbnN0Ll9kZWJ1Z0lEKSB7XG4gICAgICAvLyBDaGVjayBmb3IgQVJULWxpa2UgaW5zdGFuY2VzLiBUT0RPOiBUaGlzIGlzIHNpbGx5L2dyb3NzLlxuICAgICAgdmFyIGludGVybmFsO1xuICAgICAgaWYgKGludGVybmFsID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoaW5zdCkpIHtcbiAgICAgICAgaW5zdCA9IGludGVybmFsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zdC5fZGVidWdJRDtcbiAgfTtcbiAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24gPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgICB2YXIgZGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgLy8gVE9ETzogUmVhY3QgTmF0aXZlIGVtcHR5IGNvbXBvbmVudHMgYXJlIGFsc28gbXVsdGljaGlsZC5cbiAgICAvLyBUaGlzIG1lYW5zIHRoZXkgc3RpbGwgZ2V0IGludG8gdGhpcyBtZXRob2QgYnV0IGRvbid0IGhhdmUgX2RlYnVnSUQuXG4gICAgaWYgKGRlYnVnSUQgIT09IDApIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKGRlYnVnSUQsIGNoaWxkcmVuID8gT2JqZWN0LmtleXMoY2hpbGRyZW4pLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbltrZXldLl9kZWJ1Z0lEO1xuICAgICAgfSkgOiBbXSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFJlYWN0TXVsdGlDaGlsZCBhcmUgY2FwYWJsZSBvZiByZWNvbmNpbGluZyBtdWx0aXBsZSBjaGlsZHJlbi5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNdWx0aUNoaWxkXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHtcblxuICAvKipcbiAgICogUHJvdmlkZXMgY29tbW9uIGZ1bmN0aW9uYWxpdHkgZm9yIGNvbXBvbmVudHMgdGhhdCBtdXN0IHJlY29uY2lsZSBtdWx0aXBsZVxuICAgKiBjaGlsZHJlbi4gVGhpcyBpcyB1c2VkIGJ5IGBSZWFjdERPTUNvbXBvbmVudGAgdG8gbW91bnQsIHVwZGF0ZSwgYW5kXG4gICAqIHVubW91bnQgY2hpbGQgY29tcG9uZW50cy5cbiAgICpcbiAgICogQGxlbmRzIHtSZWFjdE11bHRpQ2hpbGQucHJvdG90eXBlfVxuICAgKi9cbiAgTWl4aW46IHtcblxuICAgIF9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHNlbGZEZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIuaW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIuaW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBfcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW47XG4gICAgICB2YXIgc2VsZkRlYnVnSUQgPSAwO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2VsZkRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgc2VsZkRlYnVnSUQpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCB0aGlzLCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICAgIHJldHVybiBuZXh0Q2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgc2VsZkRlYnVnSUQpO1xuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCB0aGlzLCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgcmV0dXJuIG5leHRDaGlsZHJlbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICAgKiBvZiBgUmVhY3RET01Db21wb25lbnRgLCBhIG1vdW50IGltYWdlIGlzIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGRyZW4gTmVzdGVkIGNoaWxkIG1hcHMuXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIG1vdW50ZWQgcmVwcmVzZW50YXRpb25zLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAgIHZhciBtb3VudEltYWdlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bbmFtZV07XG4gICAgICAgICAgdmFyIHNlbGZEZWJ1Z0lEID0gMDtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgc2VsZkRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgdHJhbnNhY3Rpb24sIHRoaXMsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBpbmRleCsrO1xuICAgICAgICAgIG1vdW50SW1hZ2VzLnB1c2gobW91bnRJbWFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBjaGlsZHJlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtb3VudEltYWdlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW55IHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSB0ZXh0IGNvbnRlbnQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRDb250ZW50IFN0cmluZyBvZiBjb250ZW50LlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZVRleHRDb250ZW50OiBmdW5jdGlvbiAobmV4dENvbnRlbnQpIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIGZhbHNlKTtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlVGV4dENvbnRlbnQgY2FsbGVkIG9uIG5vbi1lbXB0eSBjb21wb25lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMTE4JykgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBuZXcgdGV4dCBjb250ZW50LlxuICAgICAgdmFyIHVwZGF0ZXMgPSBbbWFrZVRleHRDb250ZW50KG5leHRDb250ZW50KV07XG4gICAgICBwcm9jZXNzUXVldWUodGhpcywgdXBkYXRlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbWFya3VwIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0TWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlTWFya3VwOiBmdW5jdGlvbiAobmV4dE1hcmt1cCkge1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICAvLyBSZW1vdmUgYW55IHJlbmRlcmVkIGNoaWxkcmVuLlxuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbiwgZmFsc2UpO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGVUZXh0Q29udGVudCBjYWxsZWQgb24gbm9uLWVtcHR5IGNvbXBvbmVudC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTgnKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHVwZGF0ZXMgPSBbbWFrZVNldE1hcmt1cChuZXh0TWFya3VwKV07XG4gICAgICBwcm9jZXNzUXVldWUodGhpcywgdXBkYXRlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggbmV3IGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyBOZXN0ZWQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgLy8gSG9vayB1c2VkIGJ5IFJlYWN0IEFSVFxuICAgICAgdGhpcy5fdXBkYXRlQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyBOZXN0ZWQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3VwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIHZhciByZW1vdmVkTm9kZXMgPSB7fTtcbiAgICAgIHZhciBtb3VudEltYWdlcyA9IFtdO1xuICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IHRoaXMuX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB1cGRhdGVzID0gbnVsbDtcbiAgICAgIHZhciBuYW1lO1xuICAgICAgLy8gYG5leHRJbmRleGAgd2lsbCBpbmNyZW1lbnQgZm9yIGVhY2ggY2hpbGQgaW4gYG5leHRDaGlsZHJlbmAsIGJ1dFxuICAgICAgLy8gYGxhc3RJbmRleGAgd2lsbCBiZSB0aGUgbGFzdCBpbmRleCB2aXNpdGVkIGluIGBwcmV2Q2hpbGRyZW5gLlxuICAgICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgICB2YXIgbGFzdEluZGV4ID0gMDtcbiAgICAgIC8vIGBuZXh0TW91bnRJbmRleGAgd2lsbCBpbmNyZW1lbnQgZm9yIGVhY2ggbmV3bHkgbW91bnRlZCBjaGlsZC5cbiAgICAgIHZhciBuZXh0TW91bnRJbmRleCA9IDA7XG4gICAgICB2YXIgbGFzdFBsYWNlZE5vZGUgPSBudWxsO1xuICAgICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xuICAgICAgICBpZiAoIW5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgICB2YXIgbmV4dENoaWxkID0gbmV4dENoaWxkcmVuW25hbWVdO1xuICAgICAgICBpZiAocHJldkNoaWxkID09PSBuZXh0Q2hpbGQpIHtcbiAgICAgICAgICB1cGRhdGVzID0gZW5xdWV1ZSh1cGRhdGVzLCB0aGlzLm1vdmVDaGlsZChwcmV2Q2hpbGQsIGxhc3RQbGFjZWROb2RlLCBuZXh0SW5kZXgsIGxhc3RJbmRleCkpO1xuICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICBwcmV2Q2hpbGQuX21vdW50SW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHByZXZDaGlsZCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGBsYXN0SW5kZXhgIGJlZm9yZSBgX21vdW50SW5kZXhgIGdldHMgdW5zZXQgYnkgdW5tb3VudGluZy5cbiAgICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgIC8vIFRoZSBgcmVtb3ZlZE5vZGVzYCBsb29wIGJlbG93IHdpbGwgYWN0dWFsbHkgcmVtb3ZlIHRoZSBjaGlsZC5cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVGhlIGNoaWxkIG11c3QgYmUgaW5zdGFudGlhdGVkIGJlZm9yZSBpdCdzIG1vdW50ZWQuXG4gICAgICAgICAgdXBkYXRlcyA9IGVucXVldWUodXBkYXRlcywgdGhpcy5fbW91bnRDaGlsZEF0SW5kZXgobmV4dENoaWxkLCBtb3VudEltYWdlc1tuZXh0TW91bnRJbmRleF0sIGxhc3RQbGFjZWROb2RlLCBuZXh0SW5kZXgsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSk7XG4gICAgICAgICAgbmV4dE1vdW50SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgICAgbGFzdFBsYWNlZE5vZGUgPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUobmV4dENoaWxkKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBjaGlsZHJlbiB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudC5cbiAgICAgIGZvciAobmFtZSBpbiByZW1vdmVkTm9kZXMpIHtcbiAgICAgICAgaWYgKHJlbW92ZWROb2Rlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHVwZGF0ZXMgPSBlbnF1ZXVlKHVwZGF0ZXMsIHRoaXMuX3VubW91bnRDaGlsZChwcmV2Q2hpbGRyZW5bbmFtZV0sIHJlbW92ZWROb2Rlc1tuYW1lXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodXBkYXRlcykge1xuICAgICAgICBwcm9jZXNzUXVldWUodGhpcywgdXBkYXRlcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbmV4dENoaWxkcmVuO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIG5leHRDaGlsZHJlbik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgICAqIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkLiBJdCBkb2VzIG5vdCBhY3R1YWxseSBwZXJmb3JtIGFueVxuICAgICAqIGJhY2tlbmQgb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKHNhZmVseSkge1xuICAgICAgdmFyIHJlbmRlcmVkQ2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHJlbmRlcmVkQ2hpbGRyZW4sIHNhZmVseSk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYSBjaGlsZCBjb21wb25lbnQgdG8gdGhlIHN1cHBsaWVkIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhc3RJbmRleCBMYXN0IGluZGV4IHZpc2l0ZWQgb2YgdGhlIHNpYmxpbmdzIG9mIGBjaGlsZGAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgsIGxhc3RJbmRleCkge1xuICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIGBjaGlsZGAgaXMgbGVzcyB0aGFuIGBsYXN0SW5kZXhgLCB0aGVuIGl0IG5lZWRzIHRvXG4gICAgICAvLyBiZSBtb3ZlZC4gT3RoZXJ3aXNlLCB3ZSBkbyBub3QgbmVlZCB0byBtb3ZlIGl0IGJlY2F1c2UgYSBjaGlsZCB3aWxsIGJlXG4gICAgICAvLyBpbnNlcnRlZCBvciBtb3ZlZCBiZWZvcmUgYGNoaWxkYC5cbiAgICAgIGlmIChjaGlsZC5fbW91bnRJbmRleCA8IGxhc3RJbmRleCkge1xuICAgICAgICByZXR1cm4gbWFrZU1vdmUoY2hpbGQsIGFmdGVyTm9kZSwgdG9JbmRleCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gY3JlYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb3VudEltYWdlIE1hcmt1cCB0byBpbnNlcnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIGFmdGVyTm9kZSwgbW91bnRJbWFnZSkge1xuICAgICAgcmV0dXJuIG1ha2VJbnNlcnRNYXJrdXAobW91bnRJbWFnZSwgYWZ0ZXJOb2RlLCBjaGlsZC5fbW91bnRJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDaGlsZCB0byByZW1vdmUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIG5vZGUpIHtcbiAgICAgIHJldHVybiBtYWtlUmVtb3ZlKGNoaWxkLCBub2RlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW91bnRzIGEgY2hpbGQgd2l0aCB0aGUgc3VwcGxpZWQgbmFtZS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgcGFydCBvZiBgdXBkYXRlQ2hpbGRyZW5gIGFuZCBpcyBoZXJlIGZvciByZWFkYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbW91bnRDaGlsZEF0SW5kZXg6IGZ1bmN0aW9uIChjaGlsZCwgbW91bnRJbWFnZSwgYWZ0ZXJOb2RlLCBpbmRleCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gaW5kZXg7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVDaGlsZChjaGlsZCwgYWZ0ZXJOb2RlLCBtb3VudEltYWdlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5tb3VudHMgYSByZW5kZXJlZCBjaGlsZC5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgcGFydCBvZiBgdXBkYXRlQ2hpbGRyZW5gIGFuZCBpcyBoZXJlIGZvciByZWFkYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byB1bm1vdW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VubW91bnRDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBub2RlKSB7XG4gICAgICB2YXIgdXBkYXRlID0gdGhpcy5yZW1vdmVDaGlsZChjaGlsZCwgbm9kZSk7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IG51bGw7XG4gICAgICByZXR1cm4gdXBkYXRlO1xuICAgIH1cblxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNdWx0aUNoaWxkO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdE11bHRpQ2hpbGQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGluamVjdGVkID0gZmFsc2U7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0ge1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgaG9vayBmb3Igc3dhcHBpbmcgb3V0IG1vdW50IGltYWdlcyBpbiB0aGUgbWlkZGxlIG9mXG4gICAqIHRoZSB0cmVlLlxuICAgKi9cbiAgcmVwbGFjZU5vZGVXaXRoTWFya3VwOiBudWxsLFxuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgaG9vayBmb3IgcHJvY2Vzc2luZyBhIHF1ZXVlIG9mIGNoaWxkIHVwZGF0ZXMuIFdpbGxcbiAgICogbGF0ZXIgbW92ZSBpbnRvIE11bHRpQ2hpbGRDb21wb25lbnRzLlxuICAgKi9cbiAgcHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogbnVsbCxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RFbnZpcm9ubWVudDogZnVuY3Rpb24gKGVudmlyb25tZW50KSB7XG4gICAgICAhIWluamVjdGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50OiBpbmplY3RFbnZpcm9ubWVudCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLicpIDogX3Byb2RJbnZhcmlhbnQoJzEwNCcpIDogdm9pZCAwO1xuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXAgPSBlbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXA7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXMgPSBlbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzO1xuICAgICAgaW5qZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICovXG5cbi8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIEVTNjogdmFyIFJlYWN0SW5zdGFuY2VNYXAgPSBuZXcgTWFwKCk7XG5cbnZhciBSZWFjdEluc3RhbmNlTWFwID0ge1xuXG4gIC8qKlxuICAgKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICAgKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICAgKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB2YWx1ZTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VNYXA7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0SW5zdGFuY2VNYXAuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xufVxuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdGFuY2VzLCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpIHtcbiAgLy8gV2UgZm91bmQgYSBjb21wb25lbnQgaW5zdGFuY2UuXG4gIHZhciBrZXlVbmlxdWUgPSBjaGlsZEluc3RhbmNlc1tuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xuICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgfVxuICAgIGlmICgha2V5VW5pcXVlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLiVzJywgS2V5RXNjYXBlVXRpbHMudW5lc2NhcGUobmFtZSksIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoc2VsZkRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKGNoaWxkICE9IG51bGwgJiYga2V5VW5pcXVlKSB7XG4gICAgY2hpbGRJbnN0YW5jZXNbbmFtZV0gPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGNoaWxkLCB0cnVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlYWN0Q2hpbGRSZWNvbmNpbGVyIHByb3ZpZGVzIGhlbHBlcnMgZm9yIGluaXRpYWxpemluZyBvciB1cGRhdGluZyBhIHNldCBvZlxuICogY2hpbGRyZW4uIEl0cyBvdXRwdXQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgaXQgb250byBSZWFjdE11bHRpQ2hpbGQgd2hpY2hcbiAqIGRvZXMgZGlmZmVkIHJlb3JkZXJpbmcgYW5kIGluc2VydGlvbi5cbiAqL1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0ge1xuICAvKipcbiAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGROb2RlcyBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICogQHJldHVybiB7P29iamVjdH0gQSBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCwgc2VsZkRlYnVnSUQgLy8gMCBpbiBwcm9kdWN0aW9uIGFuZCBmb3Igcm9vdHNcbiAgKSB7XG4gICAgaWYgKG5lc3RlZENoaWxkTm9kZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBjaGlsZEluc3RhbmNlcyA9IHt9O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4obmVzdGVkQ2hpbGROb2RlcywgZnVuY3Rpb24gKGNoaWxkSW5zdHMsIGNoaWxkLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdHMsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCk7XG4gICAgICB9LCBjaGlsZEluc3RhbmNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4obmVzdGVkQ2hpbGROb2RlcywgaW5zdGFudGlhdGVDaGlsZCwgY2hpbGRJbnN0YW5jZXMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRJbnN0YW5jZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIGFuZCByZXR1cm5zIGEgbmV3IHNldCBvZiBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q2hpbGRyZW4gUHJldmlvdXNseSBpbml0aWFsaXplZCBzZXQgb2YgY2hpbGRyZW4uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENoaWxkcmVuIEZsYXQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9IEEgbmV3IHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xuICApIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgZG9uJ3QgaGF2ZSBhIHdheSB0byB0cmFjayBtb3ZlcyBoZXJlIGJ1dCBpZiB3ZSB1c2UgaXRlcmF0b3JzXG4gICAgLy8gaW5zdGVhZCBvZiBmb3IuLmluIHdlIGNhbiB6aXAgdGhlIGl0ZXJhdG9ycyBhbmQgY2hlY2sgaWYgYW4gaXRlbSBoYXNcbiAgICAvLyBtb3ZlZC5cbiAgICAvLyBUT0RPOiBJZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCByZXR1cm4gdGhlIHByZXZDaGlsZHJlbiBvYmplY3Qgc28gdGhhdCB3ZVxuICAgIC8vIGNhbiBxdWlja2x5IGJhaWxvdXQgaWYgbm90aGluZyBoYXMgY2hhbmdlZC5cbiAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuYW1lO1xuICAgIHZhciBwcmV2Q2hpbGQ7XG4gICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldkNoaWxkICYmIHByZXZDaGlsZC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICBpZiAocHJldkNoaWxkICE9IG51bGwgJiYgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q2hpbGQsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IHByZXZDaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICByZW1vdmVkTm9kZXNbbmFtZV0gPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUocHJldkNoaWxkKTtcbiAgICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgdmFyIG5leHRDaGlsZEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IG5leHRDaGlsZEluc3RhbmNlO1xuICAgICAgICAvLyBDcmVhdGluZyBtb3VudCBpbWFnZSBub3cgZW5zdXJlcyByZWZzIGFyZSByZXNvbHZlZCBpbiByaWdodCBvcmRlclxuICAgICAgICAvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxMDEgZm9yIGV4cGxhbmF0aW9uKS5cbiAgICAgICAgdmFyIG5leHRDaGlsZE1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQobmV4dENoaWxkSW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICBtb3VudEltYWdlcy5wdXNoKG5leHRDaGlsZE1vdW50SW1hZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBVbm1vdW50IGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgIGZvciAobmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIShuZXh0Q2hpbGRyZW4gJiYgbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSkge1xuICAgICAgICBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIHJlbW92ZWROb2Rlc1tuYW1lXSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShwcmV2Q2hpbGQpO1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSByZW5kZXJlZENoaWxkcmVuIFByZXZpb3VzbHkgaW5pdGlhbGl6ZWQgc2V0IG9mIGNoaWxkcmVuLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKHJlbmRlcmVkQ2hpbGRyZW4sIHNhZmVseSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gcmVuZGVyZWRDaGlsZHJlbikge1xuICAgICAgaWYgKHJlbmRlcmVkQ2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkQ2hpbGQgPSByZW5kZXJlZENoaWxkcmVuW25hbWVdO1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChyZW5kZXJlZENoaWxkLCBzYWZlbHkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRSZWNvbmNpbGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdENoaWxkUmVjb25jaWxlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0SG9zdENvbXBvbmVudCcpO1xuXG52YXIgZ2V0TmV4dERlYnVnSUQgPSByZXF1aXJlKCcuL2dldE5leHREZWJ1Z0lEJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLy8gVG8gYXZvaWQgYSBjeWNsaWMgZGVwZW5kZW5jeSwgd2UgY3JlYXRlIHRoZSBmaW5hbCBjbGFzcyBpbiB0aGlzIG1vZHVsZVxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHRoaXMuY29uc3RydWN0KGVsZW1lbnQpO1xufTtcbl9hc3NpZ24oUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyLnByb3RvdHlwZSwgUmVhY3RDb21wb3NpdGVDb21wb25lbnQsIHtcbiAgX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ6IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcbn0pO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdHlwZSByZWZlcmVuY2UgaXMgYSBrbm93biBpbnRlcm5hbCB0eXBlLiBJLmUuIG5vdCBhIHVzZXJcbiAqIHByb3ZpZGVkIGNvbXBvc2l0ZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGlzIGlzIGEgdmFsaWQgaW50ZXJuYWwgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNJbnRlcm5hbENvbXBvbmVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdE5vZGUsIGNyZWF0ZSBhbiBpbnN0YW5jZSB0aGF0IHdpbGwgYWN0dWFsbHkgYmUgbW91bnRlZC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRIYXZlRGVidWdJRFxuICogQHJldHVybiB7b2JqZWN0fSBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgZWxlbWVudCdzIGNvbnN0cnVjdG9yLlxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5vZGUsIHNob3VsZEhhdmVEZWJ1Z0lEKSB7XG4gIHZhciBpbnN0YW5jZTtcblxuICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSBmYWxzZSkge1xuICAgIGluc3RhbmNlID0gUmVhY3RFbXB0eUNvbXBvbmVudC5jcmVhdGUoaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuICAgICEoZWxlbWVudCAmJiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCBlbGVtZW50LnR5cGUgPT0gbnVsbCA/IGVsZW1lbnQudHlwZSA6IHR5cGVvZiBlbGVtZW50LnR5cGUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShlbGVtZW50Ll9vd25lcikpIDogX3Byb2RJbnZhcmlhbnQoJzEzMCcsIGVsZW1lbnQudHlwZSA9PSBudWxsID8gZWxlbWVudC50eXBlIDogdHlwZW9mIGVsZW1lbnQudHlwZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGVsZW1lbnQuX293bmVyKSkgOiB2b2lkIDA7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2Ugc3RyaW5nIHZhbHVlc1xuICAgIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgaW5zdGFuY2UgPSBSZWFjdEhvc3RDb21wb25lbnQuY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmIChpc0ludGVybmFsQ29tcG9uZW50VHlwZShlbGVtZW50LnR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIHRlbXBvcmFyaWx5IGF2YWlsYWJsZSBmb3IgY3VzdG9tIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb25zLiBJLmUuIEFSVC4gT25jZSB0aG9zZSBhcmUgdXBkYXRlZCB0byB1c2UgdGhlIHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb24sIHdlIGNhbiBkcm9wIHRoaXMgY29kZSBwYXRoLlxuICAgICAgaW5zdGFuY2UgPSBuZXcgZWxlbWVudC50eXBlKGVsZW1lbnQpO1xuXG4gICAgICAvLyBXZSByZW5hbWVkIHRoaXMuIEFsbG93IHRoZSBvbGQgbmFtZSBmb3IgY29tcGF0LiA6KFxuICAgICAgaWYgKCFpbnN0YW5jZS5nZXRIb3N0Tm9kZSkge1xuICAgICAgICBpbnN0YW5jZS5nZXRIb3N0Tm9kZSA9IGluc3RhbmNlLmdldE5hdGl2ZU5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlID0gbmV3IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlcihlbGVtZW50KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykge1xuICAgIGluc3RhbmNlID0gUmVhY3RIb3N0Q29tcG9uZW50LmNyZWF0ZUluc3RhbmNlRm9yVGV4dChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRW5jb3VudGVyZWQgaW52YWxpZCBSZWFjdCBub2RlIG9mIHR5cGUgJXMnLCB0eXBlb2Ygbm9kZSkgOiBfcHJvZEludmFyaWFudCgnMTMxJywgdHlwZW9mIG5vZGUpIDogdm9pZCAwO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdGFuY2UubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldEhvc3ROb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS51bm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nLCAnT25seSBSZWFjdCBDb21wb25lbnRzIGNhbiBiZSBtb3VudGVkLicpIDogdm9pZCAwO1xuICB9XG5cbiAgLy8gVGhlc2UgdHdvIGZpZWxkcyBhcmUgdXNlZCBieSB0aGUgRE9NIGFuZCBBUlQgZGlmZmluZyBhbGdvcml0aG1zXG4gIC8vIHJlc3BlY3RpdmVseS4gSW5zdGVhZCBvZiB1c2luZyBleHBhbmRvcyBvbiBjb21wb25lbnRzLCB3ZSBzaG91bGQgYmVcbiAgLy8gc3RvcmluZyB0aGUgc3RhdGUgbmVlZGVkIGJ5IHRoZSBkaWZmaW5nIGFsZ29yaXRobXMgZWxzZXdoZXJlLlxuICBpbnN0YW5jZS5fbW91bnRJbmRleCA9IDA7XG4gIGluc3RhbmNlLl9tb3VudEltYWdlID0gbnVsbDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGluc3RhbmNlLl9kZWJ1Z0lEID0gc2hvdWxkSGF2ZURlYnVnSUQgPyBnZXROZXh0RGVidWdJRCgpIDogMDtcbiAgfVxuXG4gIC8vIEludGVybmFsIGluc3RhbmNlcyBzaG91bGQgZnVsbHkgY29uc3RydWN0ZWQgYXQgdGhpcyBwb2ludCwgc28gdGhleSBzaG91bGRcbiAgLy8gbm90IGdldCBhbnkgbmV3IGZpZWxkcyBhZGRlZCB0byB0aGVtIGF0IHRoaXMgcG9pbnQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3ROb2RlVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0Tm9kZVR5cGVzJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGNoZWNrUmVhY3RUeXBlU3BlYyA9IHJlcXVpcmUoJy4vY2hlY2tSZWFjdFR5cGVTcGVjJyk7XG59XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIENvbXBvc2l0ZVR5cGVzID0ge1xuICBJbXB1cmVDbGFzczogMCxcbiAgUHVyZUNsYXNzOiAxLFxuICBTdGF0ZWxlc3NGdW5jdGlvbmFsOiAyXG59O1xuXG5mdW5jdGlvbiBTdGF0ZWxlc3NDb21wb25lbnQoQ29tcG9uZW50KSB7fVxuU3RhdGVsZXNzQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBDb21wb25lbnQgPSBSZWFjdEluc3RhbmNlTWFwLmdldCh0aGlzKS5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgdmFyIGVsZW1lbnQgPSBDb21wb25lbnQodGhpcy5wcm9wcywgdGhpcy5jb250ZXh0LCB0aGlzLnVwZGF0ZXIpO1xuICB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIGVsZW1lbnQpO1xuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbmZ1bmN0aW9uIHdhcm5JZkludmFsaWRFbGVtZW50KENvbXBvbmVudCwgZWxlbWVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UgfHwgUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCksICclcyguLi4pOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSAnICsgJ3JldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsICclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBpc1B1cmVDb21wb25lbnQoQ29tcG9uZW50KSB7XG4gIHJldHVybiAhIShDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQpO1xufVxuXG4vLyBTZXBhcmF0ZWQgaW50byBhIGZ1bmN0aW9uIHRvIGNvbnRhaW4gZGVvcHRpbWl6YXRpb25zIGNhdXNlZCBieSB0cnkvZmluYWxseS5cbmZ1bmN0aW9uIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZuLCBkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgaWYgKGRlYnVnSUQgPT09IDApIHtcbiAgICAvLyBUb3AtbGV2ZWwgd3JhcHBlcnMgKHNlZSBSZWFjdE1vdW50KSBhbmQgZW1wdHkgY29tcG9uZW50cyAoc2VlXG4gICAgLy8gUmVhY3RET01FbXB0eUNvbXBvbmVudCkgYXJlIGludmlzaWJsZSB0byBob29rcyBhbmQgZGV2dG9vbHMuXG4gICAgLy8gQm90aCBhcmUgaW1wbGVtZW50YXRpb24gZGV0YWlscyB0aGF0IHNob3VsZCBnbyBhd2F5IGluIHRoZSBmdXR1cmUuXG4gICAgcmV0dXJuIGZuKCk7XG4gIH1cblxuICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKCk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLSBUaGUgTGlmZS1DeWNsZSBvZiBhIENvbXBvc2l0ZSBDb21wb25lbnQgLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogLSBjb25zdHJ1Y3RvcjogSW5pdGlhbGl6YXRpb24gb2Ygc3RhdGUuIFRoZSBpbnN0YW5jZSBpcyBub3cgcmV0YWluZWQuXG4gKiAgIC0gY29tcG9uZW50V2lsbE1vdW50XG4gKiAgIC0gcmVuZGVyXG4gKiAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbE1vdW50IGFuZCByZW5kZXJdXG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnREaWRNb3VudF1cbiAqICAgICAtIGNvbXBvbmVudERpZE1vdW50XG4gKlxuICogICAgICAgVXBkYXRlIFBoYXNlczpcbiAqICAgICAgIC0gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAob25seSBjYWxsZWQgaWYgcGFyZW50IHVwZGF0ZWQpXG4gKiAgICAgICAtIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICogICAgICAgICAtIGNvbXBvbmVudFdpbGxVcGRhdGVcbiAqICAgICAgICAgICAtIHJlbmRlclxuICogICAgICAgICAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzIG9yIHJlY2VpdmUgcHJvcHMgcGhhc2VzXVxuICogICAgICAgICAtIGNvbXBvbmVudERpZFVwZGF0ZVxuICpcbiAqICAgICAtIGNvbXBvbmVudFdpbGxVbm1vdW50XG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnRXaWxsVW5tb3VudF1cbiAqICAgLSBbY2hpbGRyZW4gZGVzdHJveWVkXVxuICogLSAoZGVzdHJveWVkKTogVGhlIGluc3RhbmNlIGlzIG5vdyBibGFuaywgcmVsZWFzZWQgYnkgUmVhY3QgYW5kIHJlYWR5IGZvciBHQy5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbi8qKlxuICogQW4gaW5jcmVtZW50aW5nIElEIGFzc2lnbmVkIHRvIGVhY2ggY29tcG9uZW50IHdoZW4gaXQgaXMgbW91bnRlZC4gVGhpcyBpc1xuICogdXNlZCB0byBlbmZvcmNlIHRoZSBvcmRlciBpbiB3aGljaCBgUmVhY3RVcGRhdGVzYCB1cGRhdGVzIGRpcnR5IGNvbXBvbmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIG5leHRNb3VudElEID0gMTtcblxuLyoqXG4gKiBAbGVuZHMge1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LnByb3RvdHlwZX1cbiAqL1xudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0ge1xuXG4gIC8qKlxuICAgKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgY29tcG9zaXRlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gbnVsbDtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xuXG4gICAgLy8gU2VlIFJlYWN0VXBkYXRlUXVldWVcbiAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IDA7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZXMgYW5kIFJlYWN0VXBkYXRlUXVldWUuXG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG5cbiAgICAvLyBDb21wb25lbnRXaWxsVW5tb3VudCBzaGFsbCBvbmx5IGJlIGNhbGxlZCBvbmNlXG4gICAgdGhpcy5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQgPSBmYWxzZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aGlzLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBob3N0UGFyZW50XG4gICAqIEBwYXJhbSB7P29iamVjdH0gaG9zdENvbnRhaW5lckluZm9cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuX21vdW50T3JkZXIgPSBuZXh0TW91bnRJRCsrO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gaG9zdENvbnRhaW5lckluZm87XG5cbiAgICB2YXIgcHVibGljUHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgcHVibGljQ29udGV4dCA9IHRoaXMuX3Byb2Nlc3NDb250ZXh0KGNvbnRleHQpO1xuXG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICB2YXIgdXBkYXRlUXVldWUgPSB0cmFuc2FjdGlvbi5nZXRVcGRhdGVRdWV1ZSgpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcHVibGljIGNsYXNzXG4gICAgdmFyIGRvQ29uc3RydWN0ID0gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCk7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnQoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcblxuICAgIC8vIFN1cHBvcnQgZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gICAgaWYgKCFkb0NvbnN0cnVjdCAmJiAoaW5zdCA9PSBudWxsIHx8IGluc3QucmVuZGVyID09IG51bGwpKSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSBpbnN0O1xuICAgICAgd2FybklmSW52YWxpZEVsZW1lbnQoQ29tcG9uZW50LCByZW5kZXJlZEVsZW1lbnQpO1xuICAgICAgIShpbnN0ID09PSBudWxsIHx8IGluc3QgPT09IGZhbHNlIHx8IFJlYWN0LmlzVmFsaWRFbGVtZW50KGluc3QpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDUnLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgaW5zdCA9IG5ldyBTdGF0ZWxlc3NDb21wb25lbnQoQ29tcG9uZW50KTtcbiAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNQdXJlQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IENvbXBvc2l0ZVR5cGVzLlB1cmVDbGFzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5JbXB1cmVDbGFzcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGxhdGVyIGluIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQsIGJ1dCBhZGQgYW4gZWFybHlcbiAgICAgIC8vIHdhcm5pbmcgbm93IHRvIGhlbHAgZGVidWdnaW5nXG4gICAgICBpZiAoaW5zdC5yZW5kZXIgPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wc011dGF0ZWQgPSBpbnN0LnByb3BzICE9PSBwdWJsaWNQcm9wcztcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0LnByb3BzID09PSB1bmRlZmluZWQgfHwgIXByb3BzTXV0YXRlZCwgJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyAndXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudFxcJ3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBUaGVzZSBzaG91bGQgYmUgc2V0IHVwIGluIHRoZSBjb25zdHJ1Y3RvciwgYnV0IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgLy8gc2ltcGxlciBjbGFzcyBhYnN0cmFjdGlvbnMsIHdlIHNldCB0aGVtIHVwIGFmdGVyIHRoZSBmYWN0LlxuICAgIGluc3QucHJvcHMgPSBwdWJsaWNQcm9wcztcbiAgICBpbnN0LmNvbnRleHQgPSBwdWJsaWNDb250ZXh0O1xuICAgIGluc3QucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgIGluc3QudXBkYXRlciA9IHVwZGF0ZVF1ZXVlO1xuXG4gICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0O1xuXG4gICAgLy8gU3RvcmUgYSByZWZlcmVuY2UgZnJvbSB0aGUgaW5zdGFuY2UgYmFjayB0byB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICBSZWFjdEluc3RhbmNlTWFwLnNldChpbnN0LCB0aGlzKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBTaW5jZSBwbGFpbiBKUyBjbGFzc2VzIGFyZSBkZWZpbmVkIHdpdGhvdXQgYW55IHNwZWNpYWwgaW5pdGlhbGl6YXRpb25cbiAgICAgIC8vIGxvZ2ljLCB3ZSBjYW4gbm90IGNhdGNoIGNvbW1vbiBlcnJvcnMgZWFybHkuIFRoZXJlZm9yZSwgd2UgaGF2ZSB0b1xuICAgICAgLy8gY2F0Y2ggdGhlbSBoZXJlLCBhdCBpbml0aWFsaXphdGlvbiB0aW1lLCBpbnN0ZWFkLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3QuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0RGVmYXVsdFByb3BzIHx8IGluc3QuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5wcm9wVHlwZXMsICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmNvbnRleHRUeXBlcywgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgJyArICdzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50U2hvdWxkVXBkYXRlICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnREaWRVbm1vdW50ICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsU3RhdGUgPSBpbnN0LnN0YXRlO1xuICAgIGlmIChpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5zdC5zdGF0ZSA9IGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgICEodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA2JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIG1hcmt1cDtcbiAgICBpZiAoaW5zdC51bnN0YWJsZV9oYW5kbGVFcnJvcikge1xuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50V2l0aEVycm9ySGFuZGxpbmcocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnQocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChpbnN0LmNvbXBvbmVudERpZE1vdW50KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdC5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgIH0sIF90aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50RGlkTW91bnQnKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGluc3QuY29tcG9uZW50RGlkTW91bnQsIGluc3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgX2NvbnN0cnVjdENvbXBvbmVudDogZnVuY3Rpb24gKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0Q29tcG9uZW50V2l0aG91dE93bmVyKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnRXaXRob3V0T3duZXIoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgfVxuICB9LFxuXG4gIF9jb25zdHJ1Y3RDb21wb25lbnRXaXRob3V0T3duZXI6IGZ1bmN0aW9uIChkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICBpZiAoZG9Db25zdHJ1Y3QpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ2N0b3InKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBjYW4gc3RpbGwgYmUgYW4gaW5zdGFuY2UgaW4gY2FzZSBvZiBmYWN0b3J5IGNvbXBvbmVudHNcbiAgICAvLyBidXQgd2UnbGwgY291bnQgdGhpcyBhcyB0aW1lIHNwZW50IHJlbmRlcmluZyBhcyB0aGUgbW9yZSBjb21tb24gY2FzZS5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmV0dXJuIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ3JlbmRlcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgfVxuICB9LFxuXG4gIHBlcmZvcm1Jbml0aWFsTW91bnRXaXRoRXJyb3JIYW5kbGluZzogZnVuY3Rpb24gKHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIG1hcmt1cDtcbiAgICB2YXIgY2hlY2twb2ludCA9IHRyYW5zYWN0aW9uLmNoZWNrcG9pbnQoKTtcbiAgICB0cnkge1xuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50KHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBSb2xsIGJhY2sgdG8gY2hlY2twb2ludCwgaGFuZGxlIGVycm9yICh3aGljaCBtYXkgYWRkIGl0ZW1zIHRvIHRoZSB0cmFuc2FjdGlvbiksIGFuZCB0YWtlIGEgbmV3IGNoZWNrcG9pbnRcbiAgICAgIHRyYW5zYWN0aW9uLnJvbGxiYWNrKGNoZWNrcG9pbnQpO1xuICAgICAgdGhpcy5faW5zdGFuY2UudW5zdGFibGVfaGFuZGxlRXJyb3IoZSk7XG4gICAgICBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUpIHtcbiAgICAgICAgdGhpcy5faW5zdGFuY2Uuc3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKHRoaXMuX2luc3RhbmNlLnByb3BzLCB0aGlzLl9pbnN0YW5jZS5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGNoZWNrcG9pbnQgPSB0cmFuc2FjdGlvbi5jaGVja3BvaW50KCk7XG5cbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50LnVubW91bnRDb21wb25lbnQodHJ1ZSk7XG4gICAgICB0cmFuc2FjdGlvbi5yb2xsYmFjayhjaGVja3BvaW50KTtcblxuICAgICAgLy8gVHJ5IGFnYWluIC0gd2UndmUgaW5mb3JtZWQgdGhlIGNvbXBvbmVudCBhYm91dCB0aGUgZXJyb3IsIHNvIHRoZXkgY2FuIHJlbmRlciBhbiBlcnJvciBtZXNzYWdlIHRoaXMgdGltZS5cbiAgICAgIC8vIElmIHRoaXMgdGhyb3dzIGFnYWluLCB0aGUgZXJyb3Igd2lsbCBidWJibGUgdXAgKGFuZCBjYW4gYmUgY2F1Z2h0IGJ5IGEgaGlnaGVyIGVycm9yIGJvdW5kYXJ5KS5cbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgcGVyZm9ybUluaXRpYWxNb3VudDogZnVuY3Rpb24gKHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIHZhciBkZWJ1Z0lEID0gMDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XG4gICAgfVxuXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbE1vdW50KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGluc3QuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAgIH0sIGRlYnVnSUQsICdjb21wb25lbnRXaWxsTW91bnQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3QuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICB9XG4gICAgICAvLyBXaGVuIG1vdW50aW5nLCBjYWxscyB0byBgc2V0U3RhdGVgIGJ5IGBjb21wb25lbnRXaWxsTW91bnRgIHdpbGwgc2V0XG4gICAgICAvLyBgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWVgIHdpdGhvdXQgdHJpZ2dlcmluZyBhIHJlLXJlbmRlci5cbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSkge1xuICAgICAgICBpbnN0LnN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShpbnN0LnByb3BzLCBpbnN0LmNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vdCBhIHN0YXRlbGVzcyBjb21wb25lbnQsIHdlIG5vdyByZW5kZXJcbiAgICBpZiAocmVuZGVyZWRFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xuICAgIH1cblxuICAgIHZhciBub2RlVHlwZSA9IFJlYWN0Tm9kZVR5cGVzLmdldFR5cGUocmVuZGVyZWRFbGVtZW50KTtcbiAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbm9kZVR5cGU7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5faW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChyZW5kZXJlZEVsZW1lbnQsIG5vZGVUeXBlICE9PSBSZWFjdE5vZGVUeXBlcy5FTVBUWSAvKiBzaG91bGRIYXZlRGVidWdJRCAqL1xuICAgICk7XG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBjaGlsZDtcblxuICAgIHZhciBtYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSwgZGVidWdJRCk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGRlYnVnSUQgIT09IDApIHtcbiAgICAgICAgdmFyIGNoaWxkRGVidWdJRHMgPSBjaGlsZC5fZGVidWdJRCAhPT0gMCA/IFtjaGlsZC5fZGVidWdJRF0gOiBbXTtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4oZGVidWdJRCwgY2hpbGREZWJ1Z0lEcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUodGhpcy5fcmVuZGVyZWRDb21wb25lbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSBgbW91bnRDb21wb25lbnRgLlxuICAgKlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoc2FmZWx5KSB7XG4gICAgaWYgKCF0aGlzLl9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCAmJiAhaW5zdC5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQpIHtcbiAgICAgIGluc3QuX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50ID0gdHJ1ZTtcblxuICAgICAgaWYgKHNhZmVseSkge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZ2V0TmFtZSgpICsgJy5jb21wb25lbnRXaWxsVW5tb3VudCgpJztcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50LmJpbmQoaW5zdCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgICAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsVW5tb3VudCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc3QuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHNhZmVseSk7XG4gICAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbnVsbDtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBwZW5kaW5nIGZpZWxkc1xuICAgIC8vIEV2ZW4gaWYgdGhpcyBjb21wb25lbnQgaXMgc2NoZWR1bGVkIGZvciBhbm90aGVyIHVwZGF0ZSBpbiBSZWFjdFVwZGF0ZXMsXG4gICAgLy8gaXQgd291bGQgc3RpbGwgYmUgaWdub3JlZCBiZWNhdXNlIHRoZXNlIGZpZWxkcyBhcmUgcmVzZXQuXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICAvLyBUaGVzZSBmaWVsZHMgZG8gbm90IHJlYWxseSBuZWVkIHRvIGJlIHJlc2V0IHNpbmNlIHRoaXMgb2JqZWN0IGlzIG5vXG4gICAgLy8gbG9uZ2VyIGFjY2Vzc2libGUuXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIERlbGV0ZSB0aGUgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIHRvIHRoaXMgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICAvLyB3aGljaCBhbGxvdyB0aGUgaW50ZXJuYWxzIHRvIGJlIHByb3Blcmx5IGNsZWFuZWQgdXAgZXZlbiBpZiB0aGUgdXNlclxuICAgIC8vIGxlYWtzIGEgcmVmZXJlbmNlIHRvIHRoZSBwdWJsaWMgaW5zdGFuY2UuXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5yZW1vdmUoaW5zdCk7XG5cbiAgICAvLyBTb21lIGV4aXN0aW5nIGNvbXBvbmVudHMgcmVseSBvbiBpbnN0LnByb3BzIGV2ZW4gYWZ0ZXIgdGhleSd2ZSBiZWVuXG4gICAgLy8gZGVzdHJveWVkIChpbiBldmVudCBoYW5kbGVycykuXG4gICAgLy8gVE9ETzogaW5zdC5wcm9wcyA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5zdGF0ZSA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5jb250ZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFza0NvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGNvbnRleHRUeXBlcyA9IENvbXBvbmVudC5jb250ZXh0VHlwZXM7XG4gICAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgICB9XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSB7fTtcbiAgICBmb3IgKHZhciBjb250ZXh0TmFtZSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICAgIG1hc2tlZENvbnRleHRbY29udGV4dE5hbWVdID0gY29udGV4dFtjb250ZXh0TmFtZV07XG4gICAgfVxuICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIHRoZSBjb250ZXh0IG9iamVjdCB0byBvbmx5IGNvbnRhaW4ga2V5cyBzcGVjaWZpZWQgaW5cbiAgICogYGNvbnRleHRUeXBlc2AsIGFuZCBhc3NlcnRzIHRoYXQgdGhleSBhcmUgdmFsaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSB0aGlzLl9tYXNrQ29udGV4dChjb250ZXh0KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICBpZiAoQ29tcG9uZW50LmNvbnRleHRUeXBlcykge1xuICAgICAgICB0aGlzLl9jaGVja0NvbnRleHRUeXBlcyhDb21wb25lbnQuY29udGV4dFR5cGVzLCBtYXNrZWRDb250ZXh0LCAnY29udGV4dCcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRDb250ZXh0XG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoY3VycmVudENvbnRleHQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciBjaGlsZENvbnRleHQ7XG5cbiAgICBpZiAoaW5zdC5nZXRDaGlsZENvbnRleHQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNoaWxkQ29udGV4dCA9IGluc3QuZ2V0Q2hpbGRDb250ZXh0KCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZENvbnRleHQgPSBpbnN0LmdldENoaWxkQ29udGV4dCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGlsZENvbnRleHQpIHtcbiAgICAgICEodHlwZW9mIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gdXNlIGdldENoaWxkQ29udGV4dCgpLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwNycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tDb250ZXh0VHlwZXMoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZENvbnRleHQnKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgICAgICEobmFtZSBpbiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzEwOCcsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9hc3NpZ24oe30sIGN1cnJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFzc2VydCB0aGF0IHRoZSBjb250ZXh0IHR5cGVzIGFyZSB2YWxpZFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBjb250ZXh0IGZpZWxkIHRvIGEgUmVhY3RQcm9wVHlwZVxuICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrQ29udGV4dFR5cGVzOiBmdW5jdGlvbiAodHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrUmVhY3RUeXBlU3BlYyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIHRoaXMuZ2V0TmFtZSgpLCBudWxsLCB0aGlzLl9kZWJ1Z0lEKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgbmV4dENvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgcHJldkNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuXG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgcHJldkNvbnRleHQsIG5leHRDb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgYW55IG9mIGBfcGVuZGluZ0VsZW1lbnRgLCBgX3BlbmRpbmdTdGF0ZVF1ZXVlYCwgb3IgYF9wZW5kaW5nRm9yY2VVcGRhdGVgXG4gICAqIGlzIHNldCwgdXBkYXRlIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudCh0aGlzLCB0aGlzLl9wZW5kaW5nRWxlbWVudCwgdHJhbnNhY3Rpb24sIHRoaXMuX2NvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgIT09IG51bGwgfHwgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0aGlzLl9jb250ZXh0LCB0aGlzLl9jb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlQmF0Y2hOdW1iZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUGVyZm9ybSBhbiB1cGRhdGUgdG8gYSBtb3VudGVkIGNvbXBvbmVudC4gVGhlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgYW5kXG4gICAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSBtZXRob2RzIGFyZSBjYWxsZWQsIHRoZW4gKGFzc3VtaW5nIHRoZSB1cGRhdGUgaXNuJ3RcbiAgICogc2tpcHBlZCkgdGhlIHJlbWFpbmluZyB1cGRhdGUgbGlmZWN5Y2xlIG1ldGhvZHMgYXJlIGNhbGxlZCBhbmQgdGhlIERPTVxuICAgKiByZXByZXNlbnRhdGlvbiBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZQYXJlbnRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0UGFyZW50RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldlBhcmVudEVsZW1lbnQsIG5leHRQYXJlbnRFbGVtZW50LCBwcmV2VW5tYXNrZWRDb250ZXh0LCBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAhKGluc3QgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQXR0ZW1wdGVkIHRvIHVwZGF0ZSBjb21wb25lbnQgYCVzYCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gdW5tb3VudGVkIChvciBmYWlsZWQgdG8gbW91bnQpLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEzNicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgdmFyIHdpbGxSZWNlaXZlID0gZmFsc2U7XG4gICAgdmFyIG5leHRDb250ZXh0O1xuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBjb250ZXh0IGhhcyBjaGFuZ2VkIG9yIG5vdFxuICAgIGlmICh0aGlzLl9jb250ZXh0ID09PSBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XG4gICAgICBuZXh0Q29udGV4dCA9IGluc3QuY29udGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dENvbnRleHQgPSB0aGlzLl9wcm9jZXNzQ29udGV4dChuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgICAgIHdpbGxSZWNlaXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJldlByb3BzID0gcHJldlBhcmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IG5leHRQYXJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gTm90IGEgc2ltcGxlIHN0YXRlIHVwZGF0ZSBidXQgYSBwcm9wcyB1cGRhdGVcbiAgICBpZiAocHJldlBhcmVudEVsZW1lbnQgIT09IG5leHRQYXJlbnRFbGVtZW50KSB7XG4gICAgICB3aWxsUmVjZWl2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQW4gdXBkYXRlIGhlcmUgd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgYnV0IGltbWVkaWF0ZWx5IHNldFxuICAgIC8vIF9wZW5kaW5nU3RhdGVRdWV1ZSB3aGljaCB3aWxsIGVuc3VyZSB0aGF0IGFueSBzdGF0ZSB1cGRhdGVzIGdldHNcbiAgICAvLyBpbW1lZGlhdGVseSByZWNvbmNpbGVkIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIG5leHQgYmF0Y2guXG4gICAgaWYgKHdpbGxSZWNlaXZlICYmIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBpbnN0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUobmV4dFByb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IHRydWU7XG5cbiAgICBpZiAoIXRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSkge1xuICAgICAgaWYgKGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgc2hvdWxkVXBkYXRlID0gbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNob3VsZFVwZGF0ZSA9IGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9jb21wb3NpdGVUeXBlID09PSBDb21wb3NpdGVUeXBlcy5QdXJlQ2xhc3MpIHtcbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSAhc2hhbGxvd0VxdWFsKHByZXZQcm9wcywgbmV4dFByb3BzKSB8fCAhc2hhbGxvd0VxdWFsKGluc3Quc3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XG4gICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG4gICAgICAvLyBXaWxsIHNldCBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAuXG4gICAgICB0aGlzLl9wZXJmb3JtQ29tcG9uZW50VXBkYXRlKG5leHRQYXJlbnRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCBuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgaXQncyBkZXRlcm1pbmVkIHRoYXQgYSBjb21wb25lbnQgc2hvdWxkIG5vdCB1cGRhdGUsIHdlIHN0aWxsIHdhbnRcbiAgICAgIC8vIHRvIHNldCBwcm9wcyBhbmQgc3RhdGUgYnV0IHdlIHNob3J0Y3V0IHRoZSByZXN0IG9mIHRoZSB1cGRhdGUuXG4gICAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRQYXJlbnRFbGVtZW50O1xuICAgICAgdGhpcy5fY29udGV4dCA9IG5leHRVbm1hc2tlZENvbnRleHQ7XG4gICAgICBpbnN0LnByb3BzID0gbmV4dFByb3BzO1xuICAgICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICAgIH1cbiAgfSxcblxuICBfcHJvY2Vzc1BlbmRpbmdTdGF0ZTogZnVuY3Rpb24gKHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgcXVldWUgPSB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZTtcbiAgICB2YXIgcmVwbGFjZSA9IHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGU7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgIGlmICghcXVldWUpIHtcbiAgICAgIHJldHVybiBpbnN0LnN0YXRlO1xuICAgIH1cblxuICAgIGlmIChyZXBsYWNlICYmIHF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHF1ZXVlWzBdO1xuICAgIH1cblxuICAgIHZhciBuZXh0U3RhdGUgPSBfYXNzaWduKHt9LCByZXBsYWNlID8gcXVldWVbMF0gOiBpbnN0LnN0YXRlKTtcbiAgICBmb3IgKHZhciBpID0gcmVwbGFjZSA/IDEgOiAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0aWFsID0gcXVldWVbaV07XG4gICAgICBfYXNzaWduKG5leHRTdGF0ZSwgdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgPyBwYXJ0aWFsLmNhbGwoaW5zdCwgbmV4dFN0YXRlLCBwcm9wcywgY29udGV4dCkgOiBwYXJ0aWFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNZXJnZXMgbmV3IHByb3BzIGFuZCBzdGF0ZSwgbm90aWZpZXMgZGVsZWdhdGUgbWV0aG9kcyBvZiB1cGRhdGUgYW5kXG4gICAqIHBlcmZvcm1zIHVwZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IE5leHQgZWxlbWVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzIE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGUgTmV4dCBvYmplY3QgdG8gc2V0IGFzIHN0YXRlLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0IE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgY29udGV4dC5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IHVubWFza2VkQ29udGV4dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BlcmZvcm1Db21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0LCB0cmFuc2FjdGlvbiwgdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgdmFyIGhhc0NvbXBvbmVudERpZFVwZGF0ZSA9IEJvb2xlYW4oaW5zdC5jb21wb25lbnREaWRVcGRhdGUpO1xuICAgIHZhciBwcmV2UHJvcHM7XG4gICAgdmFyIHByZXZTdGF0ZTtcbiAgICB2YXIgcHJldkNvbnRleHQ7XG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgcHJldlByb3BzID0gaW5zdC5wcm9wcztcbiAgICAgIHByZXZTdGF0ZSA9IGluc3Quc3RhdGU7XG4gICAgICBwcmV2Q29udGV4dCA9IGluc3QuY29udGV4dDtcbiAgICB9XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGluc3QuY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICB0aGlzLl9jb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBpbnN0LmNvbnRleHQgPSBuZXh0Q29udGV4dDtcblxuICAgIHRoaXMuX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoaW5zdC5jb21wb25lbnREaWRVcGRhdGUuYmluZChpbnN0LCBwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpLCBfdGhpczIuX2RlYnVnSUQsICdjb21wb25lbnREaWRVcGRhdGUnKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGluc3QuY29tcG9uZW50RGlkVXBkYXRlLmJpbmQoaW5zdCwgcHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KSwgaW5zdCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBjb21wb25lbnQncyBgcmVuZGVyYCBtZXRob2QgYW5kIHVwZGF0ZSB0aGUgRE9NIGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkNvbXBvbmVudEluc3RhbmNlID0gdGhpcy5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgdmFyIHByZXZSZW5kZXJlZEVsZW1lbnQgPSBwcmV2Q29tcG9uZW50SW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBuZXh0UmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XG5cbiAgICB2YXIgZGVidWdJRCA9IDA7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGRlYnVnSUQgPSB0aGlzLl9kZWJ1Z0lEO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2UmVuZGVyZWRFbGVtZW50LCBuZXh0UmVuZGVyZWRFbGVtZW50KSkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBuZXh0UmVuZGVyZWRFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbGRIb3N0Tm9kZSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShwcmV2Q29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBmYWxzZSk7XG5cbiAgICAgIHZhciBub2RlVHlwZSA9IFJlYWN0Tm9kZVR5cGVzLmdldFR5cGUobmV4dFJlbmRlcmVkRWxlbWVudCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbm9kZVR5cGU7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRSZW5kZXJlZEVsZW1lbnQsIG5vZGVUeXBlICE9PSBSZWFjdE5vZGVUeXBlcy5FTVBUWSAvKiBzaG91bGRIYXZlRGVidWdJRCAqL1xuICAgICAgKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gY2hpbGQ7XG5cbiAgICAgIHZhciBuZXh0TWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCB0cmFuc2FjdGlvbiwgdGhpcy5faG9zdFBhcmVudCwgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCksIGRlYnVnSUQpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIHZhciBjaGlsZERlYnVnSURzID0gY2hpbGQuX2RlYnVnSUQgIT09IDAgPyBbY2hpbGQuX2RlYnVnSURdIDogW107XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4oZGVidWdJRCwgY2hpbGREZWJ1Z0lEcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVwbGFjZU5vZGVXaXRoTWFya3VwKG9sZEhvc3ROb2RlLCBuZXh0TWFya3VwLCBwcmV2Q29tcG9uZW50SW5zdGFuY2UpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogT3ZlcnJpZGRlbiBpbiBzaGFsbG93IHJlbmRlcmluZy5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlcGxhY2VOb2RlV2l0aE1hcmt1cDogZnVuY3Rpb24gKG9sZEhvc3ROb2RlLCBuZXh0TWFya3VwLCBwcmV2SW5zdGFuY2UpIHtcbiAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGRIb3N0Tm9kZSwgbmV4dE1hcmt1cCwgcHJldkluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnN0LnJlbmRlcigpO1xuICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ3JlbmRlcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSBpbnN0LnJlbmRlcigpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgIGlmIChyZW5kZXJlZEVsZW1lbnQgPT09IHVuZGVmaW5lZCAmJiBpbnN0LnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgcmVuZGVyZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVuZGVyZWRFbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciByZW5kZXJlZEVsZW1lbnQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgfHwgdGhpcy5fY29tcG9zaXRlVHlwZSAhPT0gQ29tcG9zaXRlVHlwZXMuU3RhdGVsZXNzRnVuY3Rpb25hbCkge1xuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XG4gICAgICB0cnkge1xuICAgICAgICByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQoKTtcbiAgICB9XG4gICAgIShcbiAgICAvLyBUT0RPOiBBbiBgaXNWYWxpZE5vZGVgIGZ1bmN0aW9uIHdvdWxkIHByb2JhYmx5IGJlIG1vcmUgYXBwcm9wcmlhdGVcbiAgICByZW5kZXJlZEVsZW1lbnQgPT09IG51bGwgfHwgcmVuZGVyZWRFbGVtZW50ID09PSBmYWxzZSB8fCBSZWFjdC5pc1ZhbGlkRWxlbWVudChyZW5kZXJlZEVsZW1lbnQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5yZW5kZXIoKTogQSB2YWxpZCBSZWFjdCBlbGVtZW50IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwOScsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgcmV0dXJuIHJlbmRlcmVkRWxlbWVudDtcbiAgfSxcblxuICAvKipcbiAgICogTGF6aWx5IGFsbG9jYXRlcyB0aGUgcmVmcyBvYmplY3QgYW5kIHN0b3JlcyBgY29tcG9uZW50YCBhcyBgcmVmYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBSZWZlcmVuY2UgbmFtZS5cbiAgICogQHBhcmFtIHtjb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gc3RvcmUgYXMgYHJlZmAuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXR0YWNoUmVmOiBmdW5jdGlvbiAocmVmLCBjb21wb25lbnQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAhKGluc3QgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgcmVmcy4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTAnKSA6IHZvaWQgMDtcbiAgICB2YXIgcHVibGljQ29tcG9uZW50SW5zdGFuY2UgPSBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQgJiYgY29tcG9uZW50LmdldE5hbWUgPyBjb21wb25lbnQuZ2V0TmFtZSgpIDogJ2EgY29tcG9uZW50JztcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHB1YmxpY0NvbXBvbmVudEluc3RhbmNlICE9IG51bGwgfHwgY29tcG9uZW50Ll9jb21wb3NpdGVUeXBlICE9PSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMgJyArICcoU2VlIHJlZiBcIiVzXCIgaW4gJXMgY3JlYXRlZCBieSAlcykuICcgKyAnQXR0ZW1wdHMgdG8gYWNjZXNzIHRoaXMgcmVmIHdpbGwgZmFpbC4nLCByZWYsIGNvbXBvbmVudE5hbWUsIHRoaXMuZ2V0TmFtZSgpKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIHJlZnMgPSBpbnN0LnJlZnMgPT09IGVtcHR5T2JqZWN0ID8gaW5zdC5yZWZzID0ge30gOiBpbnN0LnJlZnM7XG4gICAgcmVmc1tyZWZdID0gcHVibGljQ29tcG9uZW50SW5zdGFuY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGFjaGVzIGEgcmVmZXJlbmNlIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSB0byBkZXJlZmVyZW5jZS5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXRhY2hSZWY6IGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIgcmVmcyA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKS5yZWZzO1xuICAgIGRlbGV0ZSByZWZzW3JlZl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGNvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IGl0XG4gICAqIGluIGVycm9yIG1lc3NhZ2VzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuYW1lIG9yIG51bGwuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0TmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0eXBlID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgY29uc3RydWN0b3IgPSB0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9pbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IubmFtZSB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1YmxpY2x5IGFjY2Vzc2libGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQgLSBpLmUuIHdoYXRcbiAgICogaXMgZXhwb3NlZCBieSByZWZzIGFuZCByZXR1cm5lZCBieSByZW5kZXIuIENhbiBiZSBudWxsIGZvciBzdGF0ZWxlc3NcbiAgICogY29tcG9uZW50cy5cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IHRoZSBwdWJsaWMgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICBpZiAodGhpcy5fY29tcG9zaXRlVHlwZSA9PT0gQ29tcG9zaXRlVHlwZXMuU3RhdGVsZXNzRnVuY3Rpb25hbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpbnN0O1xuICB9LFxuXG4gIC8vIFN0dWJcbiAgX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ6IG51bGxcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RDb21wb3NpdGVDb21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdE5vZGVUeXBlcyA9IHtcbiAgSE9TVDogMCxcbiAgQ09NUE9TSVRFOiAxLFxuICBFTVBUWTogMixcblxuICBnZXRUeXBlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gUmVhY3ROb2RlVHlwZXMuRU1QVFk7XG4gICAgfSBlbHNlIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgaWYgKHR5cGVvZiBub2RlLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0Tm9kZVR5cGVzLkNPTVBPU0lURTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBSZWFjdE5vZGVUeXBlcy5IT1NUO1xuICAgICAgfVxuICAgIH1cbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBub2RlOiAlcycsIG5vZGUpIDogX3Byb2RJbnZhcmlhbnQoJzI2Jywgbm9kZSkgOiB2b2lkIDA7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3ROb2RlVHlwZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0Tm9kZVR5cGVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P29iamVjdH0gZWxlbWVudCBUaGUgUmVhY3QgZWxlbWVudCB0aGF0IGlzIGJlaW5nIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHs/bnVtYmVyfSBkZWJ1Z0lEIFRoZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUmVhY3RUeXBlU3BlYyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQsIGRlYnVnSUQpIHtcbiAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgdmFyIGVycm9yO1xuICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICEodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIFJlYWN0LlByb3BUeXBlcy4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc4NCcsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUpIDogdm9pZCAwO1xuICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKSA6IHZvaWQgMDtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBjb21wb25lbnRTdGFja0luZm8gPSAnJztcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xuICAgICAgICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWJ1Z0lEICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0luZm8gPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDdXJyZW50U3RhY2tBZGRlbmR1bShlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCAlcyB0eXBlOiAlcyVzJywgbG9jYXRpb24sIGVycm9yLm1lc3NhZ2UsIGNvbXBvbmVudFN0YWNrSW5mbykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tSZWFjdFR5cGVTcGVjO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcbiAgICBwcm9wOiAncHJvcCcsXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKiBcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgLy8gQWRkZWQgdGhlIG5vbnplcm8geSBjaGVjayB0byBtYWtlIEZsb3cgaGFwcHksIGJ1dCBpdCBpcyByZWR1bmRhbnRcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFcXVhbDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2l2ZW4gYSBgcHJldkVsZW1lbnRgIGFuZCBgbmV4dEVsZW1lbnRgLCBkZXRlcm1pbmVzIGlmIHRoZSBleGlzdGluZ1xuICogaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQgYXMgb3Bwb3NlZCB0byBiZWluZyBkZXN0cm95ZWQgb3IgcmVwbGFjZWQgYnkgYSBuZXdcbiAqIGluc3RhbmNlLiBCb3RoIGFyZ3VtZW50cyBhcmUgZWxlbWVudHMuIFRoaXMgZW5zdXJlcyB0aGF0IHRoaXMgbG9naWMgY2FuXG4gKiBvcGVyYXRlIG9uIHN0YXRlbGVzcyB0cmVlcyB3aXRob3V0IGFueSBiYWNraW5nIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJldkVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gbmV4dEVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV4aXN0aW5nIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkLlxuICogQHByb3RlY3RlZFxuICovXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICB2YXIgcHJldkVtcHR5ID0gcHJldkVsZW1lbnQgPT09IG51bGwgfHwgcHJldkVsZW1lbnQgPT09IGZhbHNlO1xuICB2YXIgbmV4dEVtcHR5ID0gbmV4dEVsZW1lbnQgPT09IG51bGwgfHwgbmV4dEVsZW1lbnQgPT09IGZhbHNlO1xuICBpZiAocHJldkVtcHR5IHx8IG5leHRFbXB0eSkge1xuICAgIHJldHVybiBwcmV2RW1wdHkgPT09IG5leHRFbXB0eTtcbiAgfVxuXG4gIHZhciBwcmV2VHlwZSA9IHR5cGVvZiBwcmV2RWxlbWVudDtcbiAgdmFyIG5leHRUeXBlID0gdHlwZW9mIG5leHRFbGVtZW50O1xuICBpZiAocHJldlR5cGUgPT09ICdzdHJpbmcnIHx8IHByZXZUeXBlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ3N0cmluZycgfHwgbmV4dFR5cGUgPT09ICdudW1iZXInO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgcHJldkVsZW1lbnQudHlwZSA9PT0gbmV4dEVsZW1lbnQudHlwZSAmJiBwcmV2RWxlbWVudC5rZXkgPT09IG5leHRFbGVtZW50LmtleTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUNvbXBvbmVudEZhY3Rvcnk7XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uID0ge1xuICBpbmplY3RFbXB0eUNvbXBvbmVudEZhY3Rvcnk6IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgZW1wdHlDb21wb25lbnRGYWN0b3J5ID0gZmFjdG9yeTtcbiAgfVxufTtcblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gKGluc3RhbnRpYXRlKSB7XG4gICAgcmV0dXJuIGVtcHR5Q29tcG9uZW50RmFjdG9yeShpbnN0YW50aWF0ZSk7XG4gIH1cbn07XG5cblJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uID0gUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVtcHR5Q29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBudWxsO1xuLy8gVGhpcyByZWdpc3RyeSBrZWVwcyB0cmFjayBvZiB3cmFwcGVyIGNsYXNzZXMgYXJvdW5kIGhvc3QgdGFncy5cbnZhciB0YWdUb0NvbXBvbmVudENsYXNzID0ge307XG52YXIgdGV4dENvbXBvbmVudENsYXNzID0gbnVsbDtcblxudmFyIFJlYWN0SG9zdENvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgLy8gVGhpcyBhY2NlcHRzIGEgY2xhc3MgdGhhdCByZWNlaXZlcyB0aGUgdGFnIHN0cmluZy4gVGhpcyBpcyBhIGNhdGNoIGFsbFxuICAvLyB0aGF0IGNhbiByZW5kZXIgYW55IGtpbmQgb2YgdGFnLlxuICBpbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3M6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgIGdlbmVyaWNDb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudENsYXNzO1xuICB9LFxuICAvLyBUaGlzIGFjY2VwdHMgYSB0ZXh0IGNvbXBvbmVudCBjbGFzcyB0aGF0IHRha2VzIHRoZSB0ZXh0IHN0cmluZyB0byBiZVxuICAvLyByZW5kZXJlZCBhcyBwcm9wcy5cbiAgaW5qZWN0VGV4dENvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICB0ZXh0Q29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfSxcbiAgLy8gVGhpcyBhY2NlcHRzIGEga2V5ZWQgb2JqZWN0IHdpdGggY2xhc3NlcyBhcyB2YWx1ZXMuIEVhY2gga2V5IHJlcHJlc2VudHMgYVxuICAvLyB0YWcuIFRoYXQgcGFydGljdWxhciB0YWcgd2lsbCB1c2UgdGhpcyBjbGFzcyBpbnN0ZWFkIG9mIHRoZSBnZW5lcmljIG9uZS5cbiAgaW5qZWN0Q29tcG9uZW50Q2xhc3NlczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzZXMpIHtcbiAgICBfYXNzaWduKHRhZ1RvQ29tcG9uZW50Q2xhc3MsIGNvbXBvbmVudENsYXNzZXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBhIGhvc3QgaW50ZXJuYWwgY29tcG9uZW50IGNsYXNzIGZvciBhIHNwZWNpZmljIHRhZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBjcmVhdGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGludGVybmFsIGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnRlcm5hbENvbXBvbmVudChlbGVtZW50KSB7XG4gICFnZW5lcmljQ29tcG9uZW50Q2xhc3MgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVGhlcmUgaXMgbm8gcmVnaXN0ZXJlZCBjb21wb25lbnQgZm9yIHRoZSB0YWcgJXMnLCBlbGVtZW50LnR5cGUpIDogX3Byb2RJbnZhcmlhbnQoJzExMScsIGVsZW1lbnQudHlwZSkgOiB2b2lkIDA7XG4gIHJldHVybiBuZXcgZ2VuZXJpY0NvbXBvbmVudENsYXNzKGVsZW1lbnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RUZXh0fSB0ZXh0XG4gKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VGb3JUZXh0KHRleHQpIHtcbiAgcmV0dXJuIG5ldyB0ZXh0Q29tcG9uZW50Q2xhc3ModGV4dCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1RleHRDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBjb21wb25lbnQgaW5zdGFuY2VvZiB0ZXh0Q29tcG9uZW50Q2xhc3M7XG59XG5cbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSB7XG4gIGNyZWF0ZUludGVybmFsQ29tcG9uZW50OiBjcmVhdGVJbnRlcm5hbENvbXBvbmVudCxcbiAgY3JlYXRlSW5zdGFuY2VGb3JUZXh0OiBjcmVhdGVJbnN0YW5jZUZvclRleHQsXG4gIGlzVGV4dENvbXBvbmVudDogaXNUZXh0Q29tcG9uZW50LFxuICBpbmplY3Rpb246IFJlYWN0SG9zdENvbXBvbmVudEluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEhvc3RDb21wb25lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0SG9zdENvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5leHREZWJ1Z0lEID0gMTtcblxuZnVuY3Rpb24gZ2V0TmV4dERlYnVnSUQoKSB7XG4gIHJldHVybiBuZXh0RGVidWdJRCsrO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5leHREZWJ1Z0lEO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9nZXROZXh0RGVidWdJRC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBVbmVzY2FwZSBhbmQgdW53cmFwIGtleSBmb3IgaHVtYW4tcmVhZGFibGUgZGlzcGxheVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gdW5lc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSB1bmVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiB1bmVzY2FwZShrZXkpIHtcbiAgdmFyIHVuZXNjYXBlUmVnZXggPSAvKD0wfD0yKS9nO1xuICB2YXIgdW5lc2NhcGVyTG9va3VwID0ge1xuICAgICc9MCc6ICc9JyxcbiAgICAnPTInOiAnOidcbiAgfTtcbiAgdmFyIGtleVN1YnN0cmluZyA9IGtleVswXSA9PT0gJy4nICYmIGtleVsxXSA9PT0gJyQnID8ga2V5LnN1YnN0cmluZygyKSA6IGtleS5zdWJzdHJpbmcoMSk7XG5cbiAgcmV0dXJuICgnJyArIGtleVN1YnN0cmluZykucmVwbGFjZSh1bmVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG59XG5cbnZhciBLZXlFc2NhcGVVdGlscyA9IHtcbiAgZXNjYXBlOiBlc2NhcGUsXG4gIHVuZXNjYXBlOiB1bmVzY2FwZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlFc2NhcGVVdGlscztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvS2V5RXNjYXBlVXRpbHMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFN5bWJvbCcpO1xuXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIFRoaXMgaXMgaW5saW5lZCBmcm9tIFJlYWN0RWxlbWVudCBzaW5jZSB0aGlzIGZpbGUgaXMgc2hhcmVkIGJldHdlZW5cbiAqIGlzb21vcnBoaWMgYW5kIHJlbmRlcmVycy4gV2UgY291bGQgZXh0cmFjdCB0aGlzIHRvIGFcbiAqXG4gKi9cblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgY29tcG9uZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGNvbXBvbmVudC5rZXkpO1xuICB9XG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fFxuICAvLyBUaGUgZm9sbG93aW5nIGlzIGlubGluZWQgZnJvbSBSZWFjdEVsZW1lbnQuIFRoaXMgbWVhbnMgd2UgY2FuIG9wdGltaXplXG4gIC8vIHNvbWUgY2hlY2tzLiBSZWFjdCBGaWJlciBhbHNvIGlubGluZXMgdGhpcyBsb2dpYyBmb3Igc2ltaWxhciBwdXJwb3Nlcy5cbiAgdHlwZSA9PT0gJ29iamVjdCcgJiYgY2hpbGRyZW4uJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGlpID0gMDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcnO1xuICAgICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICAgIGlmIChtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSkge1xuICAgICAgICAgICAgICBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtID0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHlldCBmdWxseSBzdXBwb3J0ZWQuIEl0IGlzIGFuICcgKyAnZXhwZXJpbWVudGFsIGZlYXR1cmUgdGhhdCBtaWdodCBiZSByZW1vdmVkLiBDb252ZXJ0IGl0IHRvIGEgJyArICdzZXF1ZW5jZSAvIGl0ZXJhYmxlIG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0pIDogdm9pZCAwO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIGNoaWxkID0gZW50cnlbMV07XG4gICAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGVudHJ5WzBdKSArIFNVQlNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZCwgMCk7XG4gICAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZCBvciB3cmFwIHRoZSBvYmplY3QgdXNpbmcgY3JlYXRlRnJhZ21lbnQob2JqZWN0KSBmcm9tIHRoZSAnICsgJ1JlYWN0IGFkZC1vbnMuJztcbiAgICAgICAgaWYgKGNoaWxkcmVuLl9pc1JlYWN0RWxlbWVudCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGFuIGVsZW1lbnQgY3JlYXRlZCBieSBhIGRpZmZlcmVudCAnICsgJ3ZlcnNpb24gb2YgUmVhY3QuIE1ha2Ugc3VyZSB0byB1c2Ugb25seSBvbmUgY29weSBvZiBSZWFjdC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgYWRkZW5kdW0gKz0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogX3Byb2RJbnZhcmlhbnQoJzMxJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcbiAqXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXG4gKlxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sICcnLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmF2ZXJzZUFsbENoaWxkcmVuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQgdHlwZS4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddICYmIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSB8fCAweGVhYzc7XG5cbm1vZHVsZS5leHBvcnRzID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdEVsZW1lbnRTeW1ib2wuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBTeW1ib2wgKi9cblxudmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICpcbiAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICpcbiAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAqICAgICAgIC4uLlxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpdGVyYXRvckZuO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SXRlcmF0b3JGbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gIC8vIFRlbXBvcmFyeSBoYWNrLlxuICAvLyBJbmxpbmUgcmVxdWlyZXMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggSmVzdDpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjQwXG4gIC8vIFJlbW92ZSB0aGUgaW5saW5lIHJlcXVpcmVzIHdoZW4gd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxNzhcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgcGFzc2VkIHRocm91Z2ggdHJhdmVyc2FsLlxuICogQHBhcmFtIHs/UmVhY3RDb21wb25lbnR9IGNoaWxkIFJlYWN0IGNoaWxkIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZSBTdHJpbmcgbmFtZSBvZiBrZXkgcGF0aCB0byBjaGlsZC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gc2VsZkRlYnVnSUQgT3B0aW9uYWwgZGVidWdJRCBvZiB0aGUgY3VycmVudCBpbnRlcm5hbCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpIHtcbiAgLy8gV2UgZm91bmQgYSBjb21wb25lbnQgaW5zdGFuY2UuXG4gIGlmICh0cmF2ZXJzZUNvbnRleHQgJiYgdHlwZW9mIHRyYXZlcnNlQ29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJhdmVyc2VDb250ZXh0O1xuICAgIHZhciBrZXlVbmlxdWUgPSByZXN1bHRbbmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XG4gICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuICAgICAgfVxuICAgICAgaWYgKCFrZXlVbmlxdWUpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdmbGF0dGVuQ2hpbGRyZW4oLi4uKTogRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCAnICsgJ2Alc2AuIENoaWxkIGtleXMgbXVzdCBiZSB1bmlxdWU7IHdoZW4gdHdvIGNoaWxkcmVuIHNoYXJlIGEga2V5LCBvbmx5ICcgKyAndGhlIGZpcnN0IGNoaWxkIHdpbGwgYmUgdXNlZC4lcycsIEtleUVzY2FwZVV0aWxzLnVuZXNjYXBlKG5hbWUpLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKHNlbGZEZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlVbmlxdWUgJiYgY2hpbGQgIT0gbnVsbCkge1xuICAgICAgcmVzdWx0W25hbWVdID0gY2hpbGQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRmxhdHRlbnMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLiBBbnkgbnVsbFxuICogY2hpbGRyZW4gd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKiBAcmV0dXJuIHshb2JqZWN0fSBmbGF0dGVuZWQgY2hpbGRyZW4ga2V5ZWQgYnkgbmFtZS5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuLCBzZWxmRGVidWdJRCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICAgICAgcmV0dXJuIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKTtcbiAgICB9LCByZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0LCByZXN1bHQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbkNoaWxkcmVuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9mbGF0dGVuQ2hpbGRyZW4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0U2VydmVyVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyVXBkYXRlUXVldWUnKTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW107XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRSQU5TQUNUSU9OX1dSQVBQRVJTLnB1c2goe1xuICAgIGluaXRpYWxpemU6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2gsXG4gICAgY2xvc2U6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoXG4gIH0pO1xufVxuXG52YXIgbm9vcENhbGxiYWNrUXVldWUgPSB7XG4gIGVucXVldWU6IGZ1bmN0aW9uICgpIHt9XG59O1xuXG4vKipcbiAqIEBjbGFzcyBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlbmRlclRvU3RhdGljTWFya3VwXG4gKi9cbmZ1bmN0aW9uIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ocmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gcmVuZGVyVG9TdGF0aWNNYXJrdXA7XG4gIHRoaXMudXNlQ3JlYXRlRWxlbWVudCA9IGZhbHNlO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbmV3IFJlYWN0U2VydmVyVXBkYXRlUXVldWUodGhpcyk7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheX0gRW1wdHkgbGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWR1cmVzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbm9vcENhbGxiYWNrUXVldWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgUmVhY3QgYXN5bmMgZXZlbnRzLlxuICAgKi9cbiAgZ2V0VXBkYXRlUXVldWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge30sXG5cbiAgY2hlY2twb2ludDogZnVuY3Rpb24gKCkge30sXG5cbiAgcm9sbGJhY2s6IGZ1bmN0aW9uICgpIHt9XG59O1xuXG5fYXNzaWduKFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvdXRzaWRlIGNvbXBvbmVudFdpbGxNb3VudCgpIG9uIHRoZSBzZXJ2ZXIuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB1cGRhdGUgcXVldWUgdXNlZCBmb3Igc2VydmVyIHJlbmRlcmluZy5cbiAqIEl0IGRlbGVnYXRlcyB0byBSZWFjdFVwZGF0ZVF1ZXVlIHdoaWxlIHNlcnZlciByZW5kZXJpbmcgaXMgaW4gcHJvZ3Jlc3MgYW5kXG4gKiBzd2l0Y2hlcyB0byBSZWFjdE5vb3BVcGRhdGVRdWV1ZSBhZnRlciB0aGUgdHJhbnNhY3Rpb24gaGFzIGNvbXBsZXRlZC5cbiAqIEBjbGFzcyBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICovXG5cbnZhciBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlKHRyYW5zYWN0aW9uKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlYWN0U2VydmVyVXBkYXRlUXVldWUpO1xuXG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5pc01vdW50ZWQgPSBmdW5jdGlvbiBpc01vdW50ZWQocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlQ2FsbGJhY2sgPSBmdW5jdGlvbiBlbnF1ZXVlQ2FsbGJhY2socHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaXNJblRyYW5zYWN0aW9uKCkpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlRm9yY2VVcGRhdGUgPSBmdW5jdGlvbiBlbnF1ZXVlRm9yY2VVcGRhdGUocHVibGljSW5zdGFuY2UpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlRm9yY2VVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVSZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiBlbnF1ZXVlUmVwbGFjZVN0YXRlKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaXNJblRyYW5zYWN0aW9uKCkpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVJlcGxhY2VTdGF0ZShwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVTZXRTdGF0ZSA9IGZ1bmN0aW9uIGVucXVldWVTZXRTdGF0ZShwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaXNJblRyYW5zYWN0aW9uKCkpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVNldFN0YXRlKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0U2VydmVyVXBkYXRlUXVldWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0U2VydmVyVXBkYXRlUXVldWUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSkge1xuICBSZWFjdFVwZGF0ZXMuZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VW5leHBlY3RlZEFyZ3VtZW50KGFyZykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBhcmc7XG4gIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHZhciBkaXNwbGF5TmFtZSA9IGFyZy5jb25zdHJ1Y3RvciAmJiBhcmcuY29uc3RydWN0b3IubmFtZSB8fCB0eXBlO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFyZyk7XG4gIGlmIChrZXlzLmxlbmd0aCA+IDAgJiYga2V5cy5sZW5ndGggPCAyMCkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZSArICcgKGtleXM6ICcgKyBrZXlzLmpvaW4oJywgJykgKyAnKSc7XG4gIH1cbiAgcmV0dXJuIGRpc3BsYXlOYW1lO1xufVxuXG5mdW5jdGlvbiBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgICAgLy8gT25seSB3YXJuIHdoZW4gd2UgaGF2ZSBhIGNhbGxlck5hbWUuIE90aGVyd2lzZSB3ZSBzaG91bGQgYmUgc2lsZW50LlxuICAgICAgLy8gV2UncmUgcHJvYmFibHkgY2FsbGluZyBmcm9tIGVucXVldWVDYWxsYmFjay4gV2UgZG9uJ3Qgd2FudCB0byB3YXJuXG4gICAgICAvLyB0aGVyZSBiZWNhdXNlIHdlIGFscmVhZHkgd2FybmVkIGZvciB0aGUgY29ycmVzcG9uZGluZyBsaWZlY3ljbGUgbWV0aG9kLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNhbGxlck5hbWUsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY3RvciAmJiAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICclcyguLi4pOiBDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzICcgKyAnd2l0aGluIGByZW5kZXJgIG9yIGFub3RoZXIgY29tcG9uZW50XFwncyBjb25zdHJ1Y3RvcikuIFJlbmRlciBtZXRob2RzICcgKyAnc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IGNvbnN0cnVjdG9yICcgKyAnc2lkZS1lZmZlY3RzIGFyZSBhbiBhbnRpLXBhdHRlcm4sIGJ1dCBjYW4gYmUgbW92ZWQgdG8gJyArICdgY29tcG9uZW50V2lsbE1vdW50YC4nLCBjYWxsZXJOYW1lKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBpbnRlcm5hbEluc3RhbmNlO1xufVxuXG4vKipcbiAqIFJlYWN0VXBkYXRlUXVldWUgYWxsb3dzIGZvciBzdGF0ZSB1cGRhdGVzIHRvIGJlIHNjaGVkdWxlZCBpbnRvIGEgbGF0ZXJcbiAqIHJlY29uY2lsaWF0aW9uIHN0ZXAuXG4gKi9cbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgICAgb3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIC8vIER1cmluZyBjb21wb25lbnRXaWxsTW91bnQgYW5kIHJlbmRlciB0aGlzIHdpbGwgc3RpbGwgYmUgbnVsbCBidXQgYWZ0ZXJcbiAgICAgIC8vIHRoYXQgd2lsbCBhbHdheXMgcmVuZGVyIHRvIHNvbWV0aGluZy4gQXQgbGVhc3QgZm9yIG5vdy4gU28gd2UgY2FuIHVzZVxuICAgICAgLy8gdGhpcyBoYWNrLlxuICAgICAgcmV0dXJuICEhaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FsbGVyTmFtZSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIFJlYWN0VXBkYXRlUXVldWUudmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjaywgY2FsbGVyTmFtZSk7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuXG4gICAgLy8gUHJldmlvdXNseSB3ZSB3b3VsZCB0aHJvdyBhbiBlcnJvciBpZiB3ZSBkaWRuJ3QgaGF2ZSBhbiBpbnRlcm5hbFxuICAgIC8vIGluc3RhbmNlLiBTaW5jZSB3ZSB3YW50IHRvIG1ha2UgaXQgYSBuby1vcCBpbnN0ZWFkLCB3ZSBtaXJyb3IgdGhlIHNhbWVcbiAgICAvLyBiZWhhdmlvciB3ZSBoYXZlIGluIG90aGVyIGVucXVldWUqIG1ldGhvZHMuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIGlnbm9yZSBjYWxsYmFja3MgaW4gY29tcG9uZW50V2lsbE1vdW50LiBTZWVcbiAgICAvLyBlbnF1ZXVlVXBkYXRlcy5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgLy8gVE9ETzogVGhlIGNhbGxiYWNrIGhlcmUgaXMgaWdub3JlZCB3aGVuIHNldFN0YXRlIGlzIGNhbGxlZCBmcm9tXG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50LiBFaXRoZXIgZml4IGl0IG9yIGRpc2FsbG93IGRvaW5nIHNvIGNvbXBsZXRlbHkgaW5cbiAgICAvLyBmYXZvciBvZiBnZXRJbml0aWFsU3RhdGUuIEFsdGVybmF0aXZlbHksIHdlIGNhbiBkaXNhbGxvd1xuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBkdXJpbmcgc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IHRydWU7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW2NvbXBsZXRlU3RhdGVdO1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSB0cnVlO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0U3RhdGUoKTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHBhcnRpYWxTdGF0ZSAhPSBudWxsLCAnc2V0U3RhdGUoLi4uKTogWW91IHBhc3NlZCBhbiB1bmRlZmluZWQgb3IgbnVsbCBzdGF0ZSBvYmplY3Q7ICcgKyAnaW5zdGVhZCwgdXNlIGZvcmNlVXBkYXRlKCkuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHF1ZXVlID0gaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgfHwgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW10pO1xuICAgIHF1ZXVlLnB1c2gocGFydGlhbFN0YXRlKTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCkge1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgLy8gVE9ETzogaW50cm9kdWNlIF9wZW5kaW5nQ29udGV4dCBpbnN0ZWFkIG9mIHNldHRpbmcgaXQgZGlyZWN0bHkuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCA9IG5leHRDb250ZXh0O1xuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgdmFsaWRhdGVDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgISghY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChjYWxsYmFjaykpIDogX3Byb2RJbnZhcmlhbnQoJzEyMicsIGNhbGxlck5hbWUsIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChjYWxsYmFjaykpIDogdm9pZCAwO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RVcGRhdGVRdWV1ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RVcGRhdGVRdWV1ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZywgaW5zdGFuY2UpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gX2Fzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndHInIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluaGVhZFxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdiYXNlJyB8fCB0YWcgPT09ICdiYXNlZm9udCcgfHwgdGFnID09PSAnYmdzb3VuZCcgfHwgdGFnID09PSAnbGluaycgfHwgdGFnID09PSAnbWV0YScgfHwgdGFnID09PSAndGl0bGUnIHx8IHRhZyA9PT0gJ25vc2NyaXB0JyB8fCB0YWcgPT09ICdub2ZyYW1lcycgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknO1xuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH1cblxuICAgIC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuXG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG5cbiAgICAgIGNhc2UgJ3RhYmxlJzpcblxuICAgICAgY2FzZSAnaHInOlxuXG4gICAgICBjYXNlICd4bXAnOlxuXG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdsaSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgY2FzZSAnZHQnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdub2JyJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCBpbnN0YW5jZSwgcmV0dXJuIGEgbGlzdCBvZiBpdHMgcmVjdXJzaXZlXG4gICAqIG93bmVycywgc3RhcnRpbmcgYXQgdGhlIHJvb3QgYW5kIGVuZGluZyB3aXRoIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICB2YXIgZmluZE93bmVyU3RhY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgZG8ge1xuICAgICAgc3RhY2sucHVzaChpbnN0YW5jZSk7XG4gICAgfSB3aGlsZSAoaW5zdGFuY2UgPSBpbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICBzdGFjay5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZFRleHQsIGNoaWxkSW5zdGFuY2UsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgaWYgKGNoaWxkVGV4dCAhPSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhjaGlsZFRhZyA9PSBudWxsLCAndmFsaWRhdGVET01OZXN0aW5nOiB3aGVuIGNoaWxkVGV4dCBpcyBwYXNzZWQsIGNoaWxkVGFnIHNob3VsZCBiZSBudWxsJykgOiB2b2lkIDA7XG4gICAgICBjaGlsZFRhZyA9ICcjdGV4dCc7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIHByb2JsZW1hdGljID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG5cbiAgICBpZiAocHJvYmxlbWF0aWMpIHtcbiAgICAgIHZhciBhbmNlc3RvclRhZyA9IHByb2JsZW1hdGljLnRhZztcbiAgICAgIHZhciBhbmNlc3Rvckluc3RhbmNlID0gcHJvYmxlbWF0aWMuaW5zdGFuY2U7XG5cbiAgICAgIHZhciBjaGlsZE93bmVyID0gY2hpbGRJbnN0YW5jZSAmJiBjaGlsZEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lciA9IGFuY2VzdG9ySW5zdGFuY2UgJiYgYW5jZXN0b3JJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICB2YXIgY2hpbGRPd25lcnMgPSBmaW5kT3duZXJTdGFjayhjaGlsZE93bmVyKTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVycyA9IGZpbmRPd25lclN0YWNrKGFuY2VzdG9yT3duZXIpO1xuXG4gICAgICB2YXIgbWluU3RhY2tMZW4gPSBNYXRoLm1pbihjaGlsZE93bmVycy5sZW5ndGgsIGFuY2VzdG9yT3duZXJzLmxlbmd0aCk7XG4gICAgICB2YXIgaTtcblxuICAgICAgdmFyIGRlZXBlc3RDb21tb24gPSAtMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5TdGFja0xlbjsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZE93bmVyc1tpXSA9PT0gYW5jZXN0b3JPd25lcnNbaV0pIHtcbiAgICAgICAgICBkZWVwZXN0Q29tbW9uID0gaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgVU5LTk9XTiA9ICcodW5rbm93biknO1xuICAgICAgdmFyIGNoaWxkT3duZXJOYW1lcyA9IGNoaWxkT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XG4gICAgICB9KTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyTmFtZXMgPSBhbmNlc3Rvck93bmVycy5zbGljZShkZWVwZXN0Q29tbW9uICsgMSkubWFwKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3duZXJJbmZvID0gW10uY29uY2F0KFxuICAgICAgLy8gSWYgdGhlIHBhcmVudCBhbmQgY2hpbGQgaW5zdGFuY2VzIGhhdmUgYSBjb21tb24gb3duZXIgYW5jZXN0b3IsIHN0YXJ0XG4gICAgICAvLyB3aXRoIHRoYXQgLS0gb3RoZXJ3aXNlIHdlIGp1c3Qgc3RhcnQgd2l0aCB0aGUgcGFyZW50J3Mgb3duZXJzLlxuICAgICAgZGVlcGVzdENvbW1vbiAhPT0gLTEgPyBjaGlsZE93bmVyc1tkZWVwZXN0Q29tbW9uXS5nZXROYW1lKCkgfHwgVU5LTk9XTiA6IFtdLCBhbmNlc3Rvck93bmVyTmFtZXMsIGFuY2VzdG9yVGFnLFxuICAgICAgLy8gSWYgd2UncmUgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIChub24tcGFyZW50KSBhbmNlc3RyeSwgYWRkICcuLi4nXG4gICAgICBpbnZhbGlkQW5jZXN0b3IgPyBbJy4uLiddIDogW10sIGNoaWxkT3duZXJOYW1lcywgY2hpbGRUYWcpLmpvaW4oJyA+ICcpO1xuXG4gICAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBvd25lckluZm87XG4gICAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgICAgdmFyIHRhZ0Rpc3BsYXlOYW1lID0gY2hpbGRUYWc7XG4gICAgICB2YXIgd2hpdGVzcGFjZUluZm8gPSAnJztcbiAgICAgIGlmIChjaGlsZFRhZyA9PT0gJyN0ZXh0Jykge1xuICAgICAgICBpZiAoL1xcUy8udGVzdChjaGlsZFRleHQpKSB7XG4gICAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnVGV4dCBub2Rlcyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnV2hpdGVzcGFjZSB0ZXh0IG5vZGVzJztcbiAgICAgICAgICB3aGl0ZXNwYWNlSW5mbyA9ICcgTWFrZSBzdXJlIHlvdSBkb25cXCd0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uICcgKyAnZWFjaCBsaW5lIG9mIHlvdXIgc291cmNlIGNvZGUuJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnPCcgKyBjaGlsZFRhZyArICc+JztcbiAgICAgIH1cblxuICAgICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiVzICcgKyAnU2VlICVzLiVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgb3duZXJJbmZvLCBpbmZvKSA6IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4gU2VlICVzLicsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgb3duZXJJbmZvKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvO1xuXG4gIC8vIEZvciB0ZXN0aW5nXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5pc1RhZ1ZhbGlkSW5Db250ZXh0ID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG4gICAgcmV0dXJuIGlzVGFnVmFsaWRXaXRoUGFyZW50KHRhZywgcGFyZW50VGFnKSAmJiAhZmluZEludmFsaWRBbmNlc3RvckZvclRhZyh0YWcsIGFuY2VzdG9ySW5mbyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRhdGVET01OZXN0aW5nO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi92YWxpZGF0ZURPTU5lc3RpbmcuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG5cbnZhciBSZWFjdERPTUVtcHR5Q29tcG9uZW50ID0gZnVuY3Rpb24gKGluc3RhbnRpYXRlKSB7XG4gIC8vIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IHVzZXMgdGhpczpcbiAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICAvLyBSZWFjdERPTUNvbXBvbmVudFRyZWUgdXNlcyB0aGVzZTpcbiAgdGhpcy5faG9zdE5vZGUgPSBudWxsO1xuICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcbiAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xuICB0aGlzLl9kb21JRCA9IDA7XG59O1xuX2Fzc2lnbihSZWFjdERPTUVtcHR5Q29tcG9uZW50LnByb3RvdHlwZSwge1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIHZhciBkb21JRCA9IGhvc3RDb250YWluZXJJbmZvLl9pZENvdW50ZXIrKztcbiAgICB0aGlzLl9kb21JRCA9IGRvbUlEO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gaG9zdENvbnRhaW5lckluZm87XG5cbiAgICB2YXIgbm9kZVZhbHVlID0gJyByZWFjdC1lbXB0eTogJyArIHRoaXMuX2RvbUlEICsgJyAnO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGhvc3RDb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xuICAgICAgdmFyIG5vZGUgPSBvd25lckRvY3VtZW50LmNyZWF0ZUNvbW1lbnQobm9kZVZhbHVlKTtcbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgbm9kZSk7XG4gICAgICByZXR1cm4gRE9NTGF6eVRyZWUobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgICAvLyBOb3JtYWxseSB3ZSdkIGluc2VydCBhIGNvbW1lbnQgbm9kZSwgYnV0IHNpbmNlIHRoaXMgaXMgYSBzaXR1YXRpb25cbiAgICAgICAgLy8gd2hlcmUgUmVhY3Qgd29uJ3QgdGFrZSBvdmVyIChzdGF0aWMgcGFnZXMpLCB3ZSBjYW4gc2ltcGx5IHJldHVyblxuICAgICAgICAvLyBub3RoaW5nLlxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJzwhLS0nICsgbm9kZVZhbHVlICsgJy0tPic7XG4gICAgfVxuICB9LFxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7fSxcbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcyk7XG4gIH0sXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUudW5jYWNoZU5vZGUodGhpcyk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRW1wdHlDb21wb25lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NRW1wdHlDb21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzMnKSA6IHZvaWQgMDtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczMycpIDogdm9pZCAwO1xuXG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSB0ZW1wQS5faG9zdFBhcmVudCkge1xuICAgIGRlcHRoQSsrO1xuICB9XG4gIHZhciBkZXB0aEIgPSAwO1xuICBmb3IgKHZhciB0ZW1wQiA9IGluc3RCOyB0ZW1wQjsgdGVtcEIgPSB0ZW1wQi5faG9zdFBhcmVudCkge1xuICAgIGRlcHRoQisrO1xuICB9XG5cbiAgLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhBIC0gZGVwdGhCID4gMCkge1xuICAgIGluc3RBID0gaW5zdEEuX2hvc3RQYXJlbnQ7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBpbnN0Qi5faG9zdFBhcmVudDtcbiAgICBkZXB0aEItLTtcbiAgfVxuXG4gIC8vIFdhbGsgaW4gbG9ja3N0ZXAgdW50aWwgd2UgZmluZCBhIG1hdGNoLlxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG4gIHdoaWxlIChkZXB0aC0tKSB7XG4gICAgaWYgKGluc3RBID09PSBpbnN0Qikge1xuICAgICAgcmV0dXJuIGluc3RBO1xuICAgIH1cbiAgICBpbnN0QSA9IGluc3RBLl9ob3N0UGFyZW50O1xuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIGlmIEEgaXMgYW4gYW5jZXN0b3Igb2YgQi5cbiAqL1xuZnVuY3Rpb24gaXNBbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaXNBbmNlc3RvcjogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNScpIDogdm9pZCAwO1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3RCKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpc0FuY2VzdG9yOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM1JykgOiB2b2lkIDA7XG5cbiAgd2hpbGUgKGluc3RCKSB7XG4gICAgaWYgKGluc3RCID09PSBpbnN0QSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudEluc3RhbmNlKGluc3QpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXRQYXJlbnRJbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNicpIDogdm9pZCAwO1xuXG4gIHJldHVybiBpbnN0Ll9ob3N0UGFyZW50O1xufVxuXG4vKipcbiAqIFNpbXVsYXRlcyB0aGUgdHJhdmVyc2FsIG9mIGEgdHdvLXBoYXNlLCBjYXB0dXJlL2J1YmJsZSBldmVudCBkaXNwYXRjaC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VUd29QaGFzZShpbnN0LCBmbiwgYXJnKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHdoaWxlIChpbnN0KSB7XG4gICAgcGF0aC5wdXNoKGluc3QpO1xuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoW2ldLCAnY2FwdHVyZWQnLCBhcmcpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgJ2J1YmJsZWQnLCBhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gKlxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcbiAgdmFyIHBhdGhGcm9tID0gW107XG4gIHdoaWxlIChmcm9tICYmIGZyb20gIT09IGNvbW1vbikge1xuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XG4gICAgZnJvbSA9IGZyb20uX2hvc3RQYXJlbnQ7XG4gIH1cbiAgdmFyIHBhdGhUbyA9IFtdO1xuICB3aGlsZSAodG8gJiYgdG8gIT09IGNvbW1vbikge1xuICAgIHBhdGhUby5wdXNoKHRvKTtcbiAgICB0byA9IHRvLl9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgcGF0aEZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoRnJvbVtpXSwgJ2J1YmJsZWQnLCBhcmdGcm9tKTtcbiAgfVxuICBmb3IgKGkgPSBwYXRoVG8ubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGZuKHBhdGhUb1tpXSwgJ2NhcHR1cmVkJywgYXJnVG8pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FuY2VzdG9yOiBpc0FuY2VzdG9yLFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IsXG4gIGdldFBhcmVudEluc3RhbmNlOiBnZXRQYXJlbnRJbnN0YW5jZSxcbiAgdHJhdmVyc2VUd29QaGFzZTogdHJhdmVyc2VUd29QaGFzZSxcbiAgdHJhdmVyc2VFbnRlckxlYXZlOiB0cmF2ZXJzZUVudGVyTGVhdmVcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NVHJlZVRyYXZlcnNhbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcblxuLyoqXG4gKiBUZXh0IG5vZGVzIHZpb2xhdGUgYSBjb3VwbGUgYXNzdW1wdGlvbnMgdGhhdCBSZWFjdCBtYWtlcyBhYm91dCBjb21wb25lbnRzOlxuICpcbiAqICAtIFdoZW4gbW91bnRpbmcgdGV4dCBpbnRvIHRoZSBET00sIGFkamFjZW50IHRleHQgbm9kZXMgYXJlIG1lcmdlZC5cbiAqICAtIFRleHQgbm9kZXMgY2Fubm90IGJlIGFzc2lnbmVkIGEgUmVhY3Qgcm9vdCBJRC5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBpcyB1c2VkIHRvIHdyYXAgc3RyaW5ncyBiZXR3ZWVuIGNvbW1lbnQgbm9kZXMgc28gdGhhdCB0aGV5XG4gKiBjYW4gdW5kZXJnbyB0aGUgc2FtZSByZWNvbmNpbGlhdGlvbiB0aGF0IGlzIGFwcGxpZWQgdG8gZWxlbWVudHMuXG4gKlxuICogVE9ETzogSW52ZXN0aWdhdGUgcmVwcmVzZW50aW5nIFJlYWN0IGNvbXBvbmVudHMgaW4gdGhlIERPTSB3aXRoIHRleHQgbm9kZXMuXG4gKlxuICogQGNsYXNzIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RDb21wb25lbnRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgLy8gVE9ETzogVGhpcyBpcyByZWFsbHkgYSBSZWFjdFRleHQgKFJlYWN0Tm9kZSksIG5vdCBhIFJlYWN0RWxlbWVudFxuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IHRleHQ7XG4gIHRoaXMuX3N0cmluZ1RleHQgPSAnJyArIHRleHQ7XG4gIC8vIFJlYWN0RE9NQ29tcG9uZW50VHJlZSB1c2VzIHRoZXNlOlxuICB0aGlzLl9ob3N0Tm9kZSA9IG51bGw7XG4gIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xuXG4gIC8vIFByb3BlcnRpZXNcbiAgdGhpcy5fZG9tSUQgPSAwO1xuICB0aGlzLl9tb3VudEluZGV4ID0gMDtcbiAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBudWxsO1xuICB0aGlzLl9jb21tZW50Tm9kZXMgPSBudWxsO1xufTtcblxuX2Fzc2lnbihSZWFjdERPTVRleHRDb21wb25lbnQucHJvdG90eXBlLCB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIG1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuIFRoaXMgbm9kZSBpcyBub3QgaW50ZW5kZWQgdG8gaGF2ZVxuICAgKiBhbnkgZmVhdHVyZXMgYmVzaWRlcyBjb250YWluaW5nIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGFyZW50SW5mbztcbiAgICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgcGFyZW50SW5mbyA9IGhvc3RQYXJlbnQuX2FuY2VzdG9ySW5mbztcbiAgICAgIH0gZWxzZSBpZiAoaG9zdENvbnRhaW5lckluZm8gIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdENvbnRhaW5lckluZm8uX2FuY2VzdG9ySW5mbztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRJbmZvKSB7XG4gICAgICAgIC8vIHBhcmVudEluZm8gc2hvdWxkIGFsd2F5cyBiZSBwcmVzZW50IGV4Y2VwdCBmb3IgdGhlIHRvcC1sZXZlbFxuICAgICAgICAvLyBjb21wb25lbnQgd2hlbiBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCB0aGlzLl9zdHJpbmdUZXh0LCB0aGlzLCBwYXJlbnRJbmZvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZG9tSUQgPSBob3N0Q29udGFpbmVySW5mby5faWRDb3VudGVyKys7XG4gICAgdmFyIG9wZW5pbmdWYWx1ZSA9ICcgcmVhY3QtdGV4dDogJyArIGRvbUlEICsgJyAnO1xuICAgIHZhciBjbG9zaW5nVmFsdWUgPSAnIC9yZWFjdC10ZXh0ICc7XG4gICAgdGhpcy5fZG9tSUQgPSBkb21JRDtcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBob3N0Q29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgICAgIHZhciBvcGVuaW5nQ29tbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudChvcGVuaW5nVmFsdWUpO1xuICAgICAgdmFyIGNsb3NpbmdDb21tZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KGNsb3NpbmdWYWx1ZSk7XG4gICAgICB2YXIgbGF6eVRyZWUgPSBET01MYXp5VHJlZShvd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSk7XG4gICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShvcGVuaW5nQ29tbWVudCkpO1xuICAgICAgaWYgKHRoaXMuX3N0cmluZ1RleHQpIHtcbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUob3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLl9zdHJpbmdUZXh0KSkpO1xuICAgICAgfVxuICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUoY2xvc2luZ0NvbW1lbnQpKTtcbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgb3BlbmluZ0NvbW1lbnQpO1xuICAgICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBjbG9zaW5nQ29tbWVudDtcbiAgICAgIHJldHVybiBsYXp5VHJlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVzY2FwZWRUZXh0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRoaXMuX3N0cmluZ1RleHQpO1xuXG4gICAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgICAgLy8gTm9ybWFsbHkgd2UnZCB3cmFwIHRoaXMgYmV0d2VlbiBjb21tZW50IG5vZGVzIGZvciB0aGUgcmVhc29ucyBzdGF0ZWRcbiAgICAgICAgLy8gYWJvdmUsIGJ1dCBzaW5jZSB0aGlzIGlzIGEgc2l0dWF0aW9uIHdoZXJlIFJlYWN0IHdvbid0IHRha2Ugb3ZlclxuICAgICAgICAvLyAoc3RhdGljIHBhZ2VzKSwgd2UgY2FuIHNpbXBseSByZXR1cm4gdGhlIHRleHQgYXMgaXQgaXMuXG4gICAgICAgIHJldHVybiBlc2NhcGVkVGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8IS0tJyArIG9wZW5pbmdWYWx1ZSArICctLT4nICsgZXNjYXBlZFRleHQgKyAnPCEtLScgKyBjbG9zaW5nVmFsdWUgKyAnLS0+JztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBjb21wb25lbnQgYnkgdXBkYXRpbmcgdGhlIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFRleHR9IG5leHRUZXh0IFRoZSBuZXh0IHRleHQgY29udGVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRUZXh0LCB0cmFuc2FjdGlvbikge1xuICAgIGlmIChuZXh0VGV4dCAhPT0gdGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFRleHQ7XG4gICAgICB2YXIgbmV4dFN0cmluZ1RleHQgPSAnJyArIG5leHRUZXh0O1xuICAgICAgaWYgKG5leHRTdHJpbmdUZXh0ICE9PSB0aGlzLl9zdHJpbmdUZXh0KSB7XG4gICAgICAgIC8vIFRPRE86IFNhdmUgdGhpcyBhcyBwZW5kaW5nIHByb3BzIGFuZCB1c2UgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5XG4gICAgICAgIC8vIGFuZC9vciB1cGRhdGVDb21wb25lbnQgdG8gZG8gdGhlIGFjdHVhbCB1cGRhdGUgZm9yIGNvbnNpc3RlbmN5IHdpdGhcbiAgICAgICAgLy8gb3RoZXIgY29tcG9uZW50IHR5cGVzP1xuICAgICAgICB0aGlzLl9zdHJpbmdUZXh0ID0gbmV4dFN0cmluZ1RleHQ7XG4gICAgICAgIHZhciBjb21tZW50Tm9kZXMgPSB0aGlzLmdldEhvc3ROb2RlKCk7XG4gICAgICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5yZXBsYWNlRGVsaW1pdGVkVGV4dChjb21tZW50Tm9kZXNbMF0sIGNvbW1lbnROb2Rlc1sxXSwgbmV4dFN0cmluZ1RleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBob3N0Tm9kZSA9IHRoaXMuX2NvbW1lbnROb2RlcztcbiAgICBpZiAoaG9zdE5vZGUpIHtcbiAgICAgIHJldHVybiBob3N0Tm9kZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9jbG9zaW5nQ29tbWVudCkge1xuICAgICAgdmFyIG9wZW5pbmdDb21tZW50ID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcyk7XG4gICAgICB2YXIgbm9kZSA9IG9wZW5pbmdDb21tZW50Lm5leHRTaWJsaW5nO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgIShub2RlICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc3NpbmcgY2xvc2luZyBjb21tZW50IGZvciB0ZXh0IGNvbXBvbmVudCAlcycsIHRoaXMuX2RvbUlEKSA6IF9wcm9kSW52YXJpYW50KCc2NycsIHRoaXMuX2RvbUlEKSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgL3JlYWN0LXRleHQgJykge1xuICAgICAgICAgIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbm9kZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG4gICAgaG9zdE5vZGUgPSBbdGhpcy5faG9zdE5vZGUsIHRoaXMuX2Nsb3NpbmdDb21tZW50XTtcbiAgICB0aGlzLl9jb21tZW50Tm9kZXMgPSBob3N0Tm9kZTtcbiAgICByZXR1cm4gaG9zdE5vZGU7XG4gIH0sXG5cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbnVsbDtcbiAgICB0aGlzLl9jb21tZW50Tm9kZXMgPSBudWxsO1xuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS51bmNhY2hlTm9kZSh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRDb21wb25lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG5cbnZhciBSRVNFVF9CQVRDSEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGVtcHR5RnVuY3Rpb24sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICB9XG59O1xuXG52YXIgRkxVU0hfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogUmVhY3RVcGRhdGVzLmZsdXNoQmF0Y2hlZFVwZGF0ZXMuYmluZChSZWFjdFVwZGF0ZXMpXG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbRkxVU0hfQkFUQ0hFRF9VUERBVEVTLCBSRVNFVF9CQVRDSEVEX1VQREFURVNdO1xuXG5mdW5jdGlvbiBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbn1cblxuX2Fzc2lnbihSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbiwge1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9XG59KTtcblxudmFyIHRyYW5zYWN0aW9uID0gbmV3IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpO1xuXG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHtcbiAgaXNCYXRjaGluZ1VwZGF0ZXM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpbiBhIGNvbnRleHQgd2l0aGluIHdoaWNoIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAgICogYW5kIGZyaWVuZHMgYXJlIGJhdGNoZWQgc3VjaCB0aGF0IGNvbXBvbmVudHMgYXJlbid0IHVwZGF0ZWQgdW5uZWNlc3NhcmlseS5cbiAgICovXG4gIGJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgICB2YXIgYWxyZWFkeUJhdGNoaW5nVXBkYXRlcyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXM7XG5cbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcblxuICAgIC8vIFRoZSBjb2RlIGlzIHdyaXR0ZW4gdGhpcyB3YXkgdG8gYXZvaWQgZXh0cmEgYWxsb2NhdGlvbnNcbiAgICBpZiAoYWxyZWFkeUJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGEsIGIsIGMsIGQsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb24ucGVyZm9ybShjYWxsYmFjaywgbnVsbCwgYSwgYiwgYywgZCwgZSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3k7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xudmFyIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24nKTtcblxuLyoqXG4gKiBGaW5kIHRoZSBkZWVwZXN0IFJlYWN0IGNvbXBvbmVudCBjb21wbGV0ZWx5IGNvbnRhaW5pbmcgdGhlIHJvb3Qgb2YgdGhlXG4gKiBwYXNzZWQtaW4gaW5zdGFuY2UgKGZvciB1c2Ugd2hlbiBlbnRpcmUgUmVhY3QgdHJlZXMgYXJlIG5lc3RlZCB3aXRoaW4gZWFjaFxuICogb3RoZXIpLiBJZiBSZWFjdCB0cmVlcyBhcmUgbm90IG5lc3RlZCwgcmV0dXJucyBudWxsLlxuICovXG5mdW5jdGlvbiBmaW5kUGFyZW50KGluc3QpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgd2hpbGUgKGluc3QuX2hvc3RQYXJlbnQpIHtcbiAgICBpbnN0ID0gaW5zdC5faG9zdFBhcmVudDtcbiAgfVxuICB2YXIgcm9vdE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgdmFyIGNvbnRhaW5lciA9IHJvb3ROb2RlLnBhcmVudE5vZGU7XG4gIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUoY29udGFpbmVyKTtcbn1cblxuLy8gVXNlZCB0byBzdG9yZSBhbmNlc3RvciBoaWVyYXJjaHkgaW4gdG9wIGxldmVsIGNhbGxiYWNrXG5mdW5jdGlvbiBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICB0aGlzLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICB0aGlzLmFuY2VzdG9ycyA9IFtdO1xufVxuX2Fzc2lnbihUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcucHJvdG90eXBlLCB7XG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRvcExldmVsVHlwZSA9IG51bGw7XG4gICAgdGhpcy5uYXRpdmVFdmVudCA9IG51bGw7XG4gICAgdGhpcy5hbmNlc3RvcnMubGVuZ3RoID0gMDtcbiAgfVxufSk7XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLCBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsSW1wbChib29rS2VlcGluZykge1xuICB2YXIgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCk7XG4gIHZhciB0YXJnZXRJbnN0ID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAvLyBMb29wIHRocm91Z2ggdGhlIGhpZXJhcmNoeSwgaW4gY2FzZSB0aGVyZSdzIGFueSBuZXN0ZWQgY29tcG9uZW50cy5cbiAgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBidWlsZCB0aGUgYXJyYXkgb2YgYW5jZXN0b3JzIGJlZm9yZSBjYWxsaW5nIGFueVxuICAvLyBldmVudCBoYW5kbGVycywgYmVjYXVzZSBldmVudCBoYW5kbGVycyBjYW4gbW9kaWZ5IHRoZSBET00sIGxlYWRpbmcgdG9cbiAgLy8gaW5jb25zaXN0ZW5jaWVzIHdpdGggUmVhY3RNb3VudCdzIG5vZGUgY2FjaGUuIFNlZSAjMTEwNS5cbiAgdmFyIGFuY2VzdG9yID0gdGFyZ2V0SW5zdDtcbiAgZG8ge1xuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICBhbmNlc3RvciA9IGFuY2VzdG9yICYmIGZpbmRQYXJlbnQoYW5jZXN0b3IpO1xuICB9IHdoaWxlIChhbmNlc3Rvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29rS2VlcGluZy5hbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5faGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY3JvbGxWYWx1ZU1vbml0b3IoY2IpIHtcbiAgdmFyIHNjcm9sbFBvc2l0aW9uID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24od2luZG93KTtcbiAgY2Ioc2Nyb2xsUG9zaXRpb24pO1xufVxuXG52YXIgUmVhY3RFdmVudExpc3RlbmVyID0ge1xuICBfZW5hYmxlZDogdHJ1ZSxcbiAgX2hhbmRsZVRvcExldmVsOiBudWxsLFxuXG4gIFdJTkRPV19IQU5ETEU6IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHdpbmRvdyA6IG51bGwsXG5cbiAgc2V0SGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uIChoYW5kbGVUb3BMZXZlbCkge1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5faGFuZGxlVG9wTGV2ZWwgPSBoYW5kbGVUb3BMZXZlbDtcbiAgfSxcblxuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCA9ICEhZW5hYmxlZDtcbiAgfSxcblxuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFwcyB0b3AtbGV2ZWwgZXZlbnRzIGJ5IHVzaW5nIGV2ZW50IGJ1YmJsaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyQmFzZU5hbWUgRXZlbnQgbmFtZSAoZS5nLiBcImNsaWNrXCIpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gICAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmFwQnViYmxlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5saXN0ZW4oZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFwcyBhIHRvcC1sZXZlbCBldmVudCBieSB1c2luZyBldmVudCBjYXB0dXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5jYXB0dXJlKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgUmVhY3RFdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbiAgfSxcblxuICBtb25pdG9yU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uIChyZWZyZXNoKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gc2Nyb2xsVmFsdWVNb25pdG9yLmJpbmQobnVsbCwgcmVmcmVzaCk7XG4gICAgRXZlbnRMaXN0ZW5lci5saXN0ZW4od2luZG93LCAnc2Nyb2xsJywgY2FsbGJhY2spO1xuICB9LFxuXG4gIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCFSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYm9va0tlZXBpbmcgPSBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcuZ2V0UG9vbGVkKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICAgIHRyeSB7XG4gICAgICAvLyBFdmVudCBxdWV1ZSBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHNhbWUgY3ljbGUgYWxsb3dzXG4gICAgICAvLyBgcHJldmVudERlZmF1bHRgLlxuICAgICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKGhhbmRsZVRvcExldmVsSW1wbCwgYm9va0tlZXBpbmcpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcucmVsZWFzZShib29rS2VlcGluZyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RFdmVudExpc3RlbmVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBVcHN0cmVhbSB2ZXJzaW9uIG9mIGV2ZW50IGxpc3RlbmVyLiBEb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCBzcGVjaWZpY1xuICogbmF0dXJlIG9mIHBsYXRmb3JtLlxuICovXG52YXIgRXZlbnRMaXN0ZW5lciA9IHtcbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgYnViYmxlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XG4gICAgICB0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBjYXB0dXJlOiBmdW5jdGlvbiBjYXB0dXJlKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQXR0ZW1wdGVkIHRvIGxpc3RlbiB0byBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlIG9uIGEgJyArICdicm93c2VyIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgY2FwdHVyZSBwaGFzZS4gWW91ciBhcHBsaWNhdGlvbiAnICsgJ3dpbGwgbm90IHJlY2VpdmUgc29tZSBldmVudHMuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGVtcHR5RnVuY3Rpb25cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIHJlZ2lzdGVyRGVmYXVsdDogZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0KCkge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRMaXN0ZW5lcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBzdXBwbGllZCBlbGVtZW50IG9yIHdpbmRvdy5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlcyBhcmUgdW5ib3VuZGVkLCB1bmxpa2UgYGdldFNjcm9sbFBvc2l0aW9uYC4gVGhpcyBtZWFucyB0aGV5XG4gKiBtYXkgYmUgbmVnYXRpdmUgb3IgZXhjZWVkIHRoZSBlbGVtZW50IGJvdW5kYXJpZXMgKHdoaWNoIGlzIHBvc3NpYmxlIHVzaW5nXG4gKiBpbmVydGlhbCBzY3JvbGxpbmcpLlxuICpcbiAqIEBwYXJhbSB7RE9NV2luZG93fERPTUVsZW1lbnR9IHNjcm9sbGFibGVcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwIHdpdGggYHhgIGFuZCBgeWAga2V5cy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbihzY3JvbGxhYmxlKSB7XG4gIGlmIChzY3JvbGxhYmxlID09PSB3aW5kb3cpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0LFxuICAgIHk6IHNjcm9sbGFibGUuc2Nyb2xsVG9wXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9mYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0SG9zdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RIb3N0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIFJlYWN0SW5qZWN0aW9uID0ge1xuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuaW5qZWN0aW9uLFxuICBET01Qcm9wZXJ0eTogRE9NUHJvcGVydHkuaW5qZWN0aW9uLFxuICBFbXB0eUNvbXBvbmVudDogUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24sXG4gIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24sXG4gIEV2ZW50UGx1Z2luVXRpbHM6IEV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLFxuICBFdmVudEVtaXR0ZXI6IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pbmplY3Rpb24sXG4gIEhvc3RDb21wb25lbnQ6IFJlYWN0SG9zdENvbXBvbmVudC5pbmplY3Rpb24sXG4gIFVwZGF0ZXM6IFJlYWN0VXBkYXRlcy5pbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbmplY3Rpb247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0SW5qZWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCwgd2hlbiBwb3NzaWJsZSwgdGhlIHNlbGVjdGlvbiByYW5nZSAoY3VycmVudGx5IHNlbGVjdGVkIHRleHRcbiAqIGlucHV0KSBpcyBub3QgZGlzdHVyYmVkIGJ5IHBlcmZvcm1pbmcgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgU0VMRUNUSU9OX1JFU1RPUkFUSU9OID0ge1xuICAvKipcbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBTZWxlY3Rpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBpbml0aWFsaXplOiBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbkluZm9ybWF0aW9uLFxuICAvKipcbiAgICogQHBhcmFtIHtTZWxlY3Rpb259IHNlbCBTZWxlY3Rpb24gaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBgaW5pdGlhbGl6ZWAuXG4gICAqL1xuICBjbG9zZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5yZXN0b3JlU2VsZWN0aW9uXG59O1xuXG4vKipcbiAqIFN1cHByZXNzZXMgZXZlbnRzIChibHVyL2ZvY3VzKSB0aGF0IGNvdWxkIGJlIGluYWR2ZXJ0ZW50bHkgZGlzcGF0Y2hlZCBkdWUgdG9cbiAqIGhpZ2ggbGV2ZWwgRE9NIG1hbmlwdWxhdGlvbnMgKGxpa2UgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgYSB0ZXh0IGlucHV0IGZyb20gdGhlXG4gKiBET00pLlxuICovXG52YXIgRVZFTlRfU1VQUFJFU1NJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZW5hYmxlZCBzdGF0dXMgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlXG4gICAqIHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudGx5RW5hYmxlZCA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pc0VuYWJsZWQoKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgcmV0dXJuIGN1cnJlbnRseUVuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldmlvdXNseUVuYWJsZWQgRW5hYmxlZCBzdGF0dXMgb2ZcbiAgICogICBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmUgdGhlIHJlY29uY2lsaWF0aW9uIG9jY3VycmVkLiBgY2xvc2VgXG4gICAqICAgcmVzdG9yZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uIChwcmV2aW91c2x5RW5hYmxlZCkge1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKHByZXZpb3VzbHlFbmFibGVkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIHF1ZXVlIGZvciBjb2xsZWN0aW5nIGBjb21wb25lbnREaWRNb3VudGAgYW5kXG4gKiBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgZHVyaW5nIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIE9OX0RPTV9SRUFEWV9RVUVVRUlORyA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBgb25ET01SZWFkeWAgcXVldWUuXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucmVzZXQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQWZ0ZXIgRE9NIGlzIGZsdXNoZWQsIGludm9rZSBhbGwgcmVnaXN0ZXJlZCBgb25ET01SZWFkeWAgY2FsbGJhY2tzLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5ub3RpZnlBbGwoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW1NFTEVDVElPTl9SRVNUT1JBVElPTiwgRVZFTlRfU1VQUFJFU1NJT04sIE9OX0RPTV9SRUFEWV9RVUVVRUlOR107XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRSQU5TQUNUSU9OX1dSQVBQRVJTLnB1c2goe1xuICAgIGluaXRpYWxpemU6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2gsXG4gICAgY2xvc2U6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoXG4gIH0pO1xufVxuXG4vKipcbiAqIEN1cnJlbnRseTpcbiAqIC0gVGhlIG9yZGVyIHRoYXQgdGhlc2UgYXJlIGxpc3RlZCBpbiB0aGUgdHJhbnNhY3Rpb24gaXMgY3JpdGljYWw6XG4gKiAtIFN1cHByZXNzZXMgZXZlbnRzLlxuICogLSBSZXN0b3JlcyBzZWxlY3Rpb24gcmFuZ2UuXG4gKlxuICogRnV0dXJlOlxuICogLSBSZXN0b3JlIGRvY3VtZW50L292ZXJmbG93IHNjcm9sbCBwb3NpdGlvbnMgdGhhdCB3ZXJlIHVuaW50ZW50aW9uYWxseVxuICogICBtb2RpZmllZCB2aWEgRE9NIGluc2VydGlvbnMgYWJvdmUgdGhlIHRvcCB2aWV3cG9ydCBib3VuZGFyeS5cbiAqIC0gSW1wbGVtZW50L2ludGVncmF0ZSB3aXRoIGN1c3RvbWl6ZWQgY29uc3RyYWludCBiYXNlZCBsYXlvdXQgc3lzdGVtIGFuZCBrZWVwXG4gKiAgIHRyYWNrIG9mIHdoaWNoIGRpbWVuc2lvbnMgbXVzdCBiZSByZW1lYXN1cmVkLlxuICpcbiAqIEBjbGFzcyBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24odXNlQ3JlYXRlRWxlbWVudCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIC8vIE9ubHkgc2VydmVyLXNpZGUgcmVuZGVyaW5nIHJlYWxseSBuZWVkcyB0aGlzIG9wdGlvbiAoc2VlXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ2ApLCBidXQgc2VydmVyLXNpZGUgdXNlc1xuICAvLyBgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbmAgaW5zdGVhZC4gVGhpcyBvcHRpb24gaXMgaGVyZSBzbyB0aGF0IGl0J3NcbiAgLy8gYWNjZXNzaWJsZSBhbmQgZGVmYXVsdHMgdG8gZmFsc2Ugd2hlbiBgUmVhY3RET01Db21wb25lbnRgIGFuZFxuICAvLyBgUmVhY3RET01UZXh0Q29tcG9uZW50YCBjaGVja3MgaXQgaW4gYG1vdW50Q29tcG9uZW50YC5gXG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSBmYWxzZTtcbiAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZChudWxsKTtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gdXNlQ3JlYXRlRWxlbWVudDtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5PG9iamVjdD59IExpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VkdXJlcy5cbiAgICogICBUT0RPOiBjb252ZXJ0IHRvIGFycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IFJlYWN0IGFzeW5jIGV2ZW50cy5cbiAgICovXG4gIGdldFVwZGF0ZVF1ZXVlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0VXBkYXRlUXVldWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhdmUgY3VycmVudCB0cmFuc2FjdGlvbiBzdGF0ZSAtLSBpZiB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhpcyBtZXRob2QgaXNcbiAgICogcGFzc2VkIHRvIGByb2xsYmFja2AsIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHJlc2V0IHRvIHRoYXQgc3RhdGUuXG4gICAqL1xuICBjaGVja3BvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmVhY3RNb3VudFJlYWR5IGlzIHRoZSBvdXIgb25seSBzdGF0ZWZ1bCB3cmFwcGVyXG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5LmNoZWNrcG9pbnQoKTtcbiAgfSxcblxuICByb2xsYmFjazogZnVuY3Rpb24gKGNoZWNrcG9pbnQpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yb2xsYmFjayhjaGVja3BvaW50KTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLnJlYWN0TW91bnRSZWFkeSk7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBudWxsO1xuICB9XG59O1xuXG5fYXNzaWduKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTVNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3Rpb24nKTtcblxudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NvbnRhaW5zTm9kZScpO1xudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBjb250YWluc05vZGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0ge1xuXG4gIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllczogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBub2RlTmFtZSAmJiAobm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAndGV4dCcgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgfHwgZWxlbS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG4gIH0sXG5cbiAgZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICAgIHNlbGVjdGlvblJhbmdlOiBSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSkgPyBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbihmb2N1c2VkRWxlbSkgOiBudWxsXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQHJlc3RvcmVTZWxlY3Rpb246IElmIGFueSBzZWxlY3Rpb24gaW5mb3JtYXRpb24gd2FzIHBvdGVudGlhbGx5IGxvc3QsXG4gICAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICAgKiBub2RlcyBhbmQgcGxhY2UgdGhlbSBiYWNrIGluLCByZXN1bHRpbmcgaW4gZm9jdXMgYmVpbmcgbG9zdC5cbiAgICovXG4gIHJlc3RvcmVTZWxlY3Rpb246IGZ1bmN0aW9uIChwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSB7XG4gICAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgICB2YXIgcHJpb3JTZWxlY3Rpb25SYW5nZSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uc2VsZWN0aW9uUmFuZ2U7XG4gICAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgaWYgKFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICAgIFJlYWN0SW5wdXRTZWxlY3Rpb24uc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgfVxuICAgICAgZm9jdXNOb2RlKHByaW9yRm9jdXNlZEVsZW0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gICAqIGNvbnRlbnRFZGl0YWJsZSBub2RlLlxuICAgKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICAgKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAgICovXG4gIGdldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIHNlbGVjdGlvbjtcblxuICAgIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgICAgc2VsZWN0aW9uID0ge1xuICAgICAgICBzdGFydDogaW5wdXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGlucHV0Lm5vZGVOYW1lICYmIGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcbiAgICAgIC8vIElFOCBpbnB1dC5cbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgLy8gVGhlcmUgY2FuIG9ubHkgYmUgb25lIHNlbGVjdGlvbiBwZXIgZG9jdW1lbnQgaW4gSUUsIHNvIGl0IG11c3RcbiAgICAgIC8vIGJlIGluIG91ciBlbGVtZW50LlxuICAgICAgaWYgKHJhbmdlLnBhcmVudEVsZW1lbnQoKSA9PT0gaW5wdXQpIHtcbiAgICAgICAgc2VsZWN0aW9uID0ge1xuICAgICAgICAgIHN0YXJ0OiAtcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKSxcbiAgICAgICAgICBlbmQ6IC1yYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IFJlYWN0RE9NU2VsZWN0aW9uLmdldE9mZnNldHMoaW5wdXQpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3Rpb24gfHwgeyBzdGFydDogMCwgZW5kOiAwIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICAgKiB0aGUgaW5wdXQuXG4gICAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAgICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICAgKi9cbiAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaW5wdXQsIG9mZnNldHMpIHtcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIHZhciBlbmQgPSBvZmZzZXRzLmVuZDtcbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgIH1cblxuICAgIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGlucHV0Lm5vZGVOYW1lICYmIGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcbiAgICAgIHZhciByYW5nZSA9IGlucHV0LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcbiAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERPTVNlbGVjdGlvbi5zZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnB1dFNlbGVjdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RJbnB1dFNlbGVjdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0ID0gcmVxdWlyZSgnLi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0Jyk7XG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoJy4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcicpO1xuXG4vKipcbiAqIFdoaWxlIGBpc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG9uIHRoZSBTZWxlY3Rpb24gb2JqZWN0IGFuZCBgY29sbGFwc2VkYFxuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBSYW5nZSBvYmplY3QsIElFMTEgc29tZXRpbWVzIGdldHMgdGhlbSB3cm9uZy5cbiAqIElmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYW5kIG9mZnNldHMgYXJlIHRoZSBzYW1lLCB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLlxuICovXG5mdW5jdGlvbiBpc0NvbGxhcHNlZChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgcmV0dXJuIGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSAmJiBhbmNob3JPZmZzZXQgPT09IGZvY3VzT2Zmc2V0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgYXBwcm9wcmlhdGUgYW5jaG9yIGFuZCBmb2N1cyBub2RlL29mZnNldCBwYWlycyBmb3IgSUUuXG4gKlxuICogVGhlIGNhdGNoIGhlcmUgaXMgdGhhdCBJRSdzIHNlbGVjdGlvbiBBUEkgZG9lc24ndCBwcm92aWRlIGluZm9ybWF0aW9uXG4gKiBhYm91dCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgZm9yd2FyZCBvciBiYWNrd2FyZCwgc28gd2UgaGF2ZSB0b1xuICogYmVoYXZlIGFzIHRob3VnaCBpdCdzIGFsd2F5cyBmb3J3YXJkLlxuICpcbiAqIElFIHRleHQgZGlmZmVycyBmcm9tIG1vZGVybiBzZWxlY3Rpb24gaW4gdGhhdCBpdCBiZWhhdmVzIGFzIHRob3VnaFxuICogYmxvY2sgZWxlbWVudHMgZW5kIHdpdGggYSBuZXcgbGluZS4gVGhpcyBtZWFucyBjaGFyYWN0ZXIgb2Zmc2V0cyB3aWxsXG4gKiBkaWZmZXIgYmV0d2VlbiB0aGUgdHdvIEFQSXMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldElFT2Zmc2V0cyhub2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5zZWxlY3Rpb247XG4gIHZhciBzZWxlY3RlZFJhbmdlID0gc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gIHZhciBzZWxlY3RlZExlbmd0aCA9IHNlbGVjdGVkUmFuZ2UudGV4dC5sZW5ndGg7XG5cbiAgLy8gRHVwbGljYXRlIHNlbGVjdGlvbiBzbyB3ZSBjYW4gbW92ZSByYW5nZSB3aXRob3V0IGJyZWFraW5nIHVzZXIgc2VsZWN0aW9uLlxuICB2YXIgZnJvbVN0YXJ0ID0gc2VsZWN0ZWRSYW5nZS5kdXBsaWNhdGUoKTtcbiAgZnJvbVN0YXJ0Lm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xuICBmcm9tU3RhcnQuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCBzZWxlY3RlZFJhbmdlKTtcblxuICB2YXIgc3RhcnRPZmZzZXQgPSBmcm9tU3RhcnQudGV4dC5sZW5ndGg7XG4gIHZhciBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIHNlbGVjdGVkTGVuZ3RoO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0T2Zmc2V0LFxuICAgIGVuZDogZW5kT2Zmc2V0XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gJiYgd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICB2YXIgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgdmFyIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGU7XG4gIHZhciBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICB2YXIgY3VycmVudFJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG5cbiAgLy8gSW4gRmlyZWZveCwgcmFuZ2Uuc3RhcnRDb250YWluZXIgYW5kIHJhbmdlLmVuZENvbnRhaW5lciBjYW4gYmUgXCJhbm9ueW1vdXNcbiAgLy8gZGl2c1wiLCBlLmcuIHRoZSB1cC9kb3duIGJ1dHRvbnMgb24gYW4gPGlucHV0IHR5cGU9XCJudW1iZXJcIj4uIEFub255bW91c1xuICAvLyBkaXZzIGRvIG5vdCBzZWVtIHRvIGV4cG9zZSBwcm9wZXJ0aWVzLCB0cmlnZ2VyaW5nIGEgXCJQZXJtaXNzaW9uIGRlbmllZFxuICAvLyBlcnJvclwiIGlmIGFueSBvZiBpdHMgcHJvcGVydGllcyBhcmUgYWNjZXNzZWQuIFRoZSBvbmx5IHNlZW1pbmdseSBwb3NzaWJsZVxuICAvLyB3YXkgdG8gYXZvaWQgZXJyb3JpbmcgaXMgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhdCB0eXBpY2FsbHkgd29ya3MgZm9yXG4gIC8vIG5vbi1hbm9ueW1vdXMgZGl2cyBhbmQgY2F0Y2ggYW55IGVycm9yIHRoYXQgbWF5IG90aGVyd2lzZSBhcmlzZS4gU2VlXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTIwODQyN1xuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lci5ub2RlVHlwZTtcbiAgICBjdXJyZW50UmFuZ2UuZW5kQ29udGFpbmVyLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElmIHRoZSBub2RlIGFuZCBvZmZzZXQgdmFsdWVzIGFyZSB0aGUgc2FtZSwgdGhlIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWQuXG4gIC8vIGBTZWxlY3Rpb24uaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBuYXRpdmVseSwgYnV0IElFIHNvbWV0aW1lcyBnZXRzXG4gIC8vIHRoaXMgdmFsdWUgd3JvbmcuXG4gIHZhciBpc1NlbGVjdGlvbkNvbGxhcHNlZCA9IGlzQ29sbGFwc2VkKHNlbGVjdGlvbi5hbmNob3JOb2RlLCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LCBzZWxlY3Rpb24uZm9jdXNOb2RlLCBzZWxlY3Rpb24uZm9jdXNPZmZzZXQpO1xuXG4gIHZhciByYW5nZUxlbmd0aCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkID8gMCA6IGN1cnJlbnRSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcblxuICB2YXIgdGVtcFJhbmdlID0gY3VycmVudFJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgdGVtcFJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgdGVtcFJhbmdlLnNldEVuZChjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXIsIGN1cnJlbnRSYW5nZS5zdGFydE9mZnNldCk7XG5cbiAgdmFyIGlzVGVtcFJhbmdlQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQodGVtcFJhbmdlLnN0YXJ0Q29udGFpbmVyLCB0ZW1wUmFuZ2Uuc3RhcnRPZmZzZXQsIHRlbXBSYW5nZS5lbmRDb250YWluZXIsIHRlbXBSYW5nZS5lbmRPZmZzZXQpO1xuXG4gIHZhciBzdGFydCA9IGlzVGVtcFJhbmdlQ29sbGFwc2VkID8gMCA6IHRlbXBSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcbiAgdmFyIGVuZCA9IHN0YXJ0ICsgcmFuZ2VMZW5ndGg7XG5cbiAgLy8gRGV0ZWN0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBiYWNrd2FyZC5cbiAgdmFyIGRldGVjdGlvblJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0U3RhcnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0RW5kKGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpO1xuICB2YXIgaXNCYWNrd2FyZCA9IGRldGVjdGlvblJhbmdlLmNvbGxhcHNlZDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBpc0JhY2t3YXJkID8gZW5kIDogc3RhcnQsXG4gICAgZW5kOiBpc0JhY2t3YXJkID8gc3RhcnQgOiBlbmRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldElFT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLmR1cGxpY2F0ZSgpO1xuICB2YXIgc3RhcnQsIGVuZDtcblxuICBpZiAob2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICBlbmQgPSBzdGFydDtcbiAgfSBlbHNlIGlmIChvZmZzZXRzLnN0YXJ0ID4gb2Zmc2V0cy5lbmQpIHtcbiAgICBzdGFydCA9IG9mZnNldHMuZW5kO1xuICAgIGVuZCA9IG9mZnNldHMuc3RhcnQ7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IG9mZnNldHMuZW5kO1xuICB9XG5cbiAgcmFuZ2UubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICByYW5nZS5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHJhbmdlKTtcbiAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICByYW5nZS5zZWxlY3QoKTtcbn1cblxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldE1vZGVybk9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICBpZiAoIXdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICB2YXIgbGVuZ3RoID0gbm9kZVtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldLmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQgPyBzdGFydCA6IE1hdGgubWluKG9mZnNldHMuZW5kLCBsZW5ndGgpO1xuXG4gIC8vIElFIDExIHVzZXMgbW9kZXJuIHNlbGVjdGlvbiwgYnV0IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZXh0ZW5kIG1ldGhvZC5cbiAgLy8gRmxpcCBiYWNrd2FyZCBzZWxlY3Rpb25zLCBzbyB3ZSBjYW4gc2V0IHdpdGggYSBzaW5nbGUgcmFuZ2UuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHZhciB0ZW1wID0gZW5kO1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gdGVtcDtcbiAgfVxuXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0TWFya2VyLm5vZGUsIHN0YXJ0TWFya2VyLm9mZnNldCk7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdXNlSUVPZmZzZXRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdzZWxlY3Rpb24nIGluIGRvY3VtZW50ICYmICEoJ2dldFNlbGVjdGlvbicgaW4gd2luZG93KTtcblxudmFyIFJlYWN0RE9NU2VsZWN0aW9uID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqL1xuICBnZXRPZmZzZXRzOiB1c2VJRU9mZnNldHMgPyBnZXRJRU9mZnNldHMgOiBnZXRNb2Rlcm5PZmZzZXRzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAgICovXG4gIHNldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IHNldElFT2Zmc2V0cyA6IHNldE1vZGVybk9mZnNldHNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZWxlY3Rpb247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NU2VsZWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG52YXIgaXNUZXh0Tm9kZSA9IHJlcXVpcmUoJy4vaXNUZXh0Tm9kZScpO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBET00gbm9kZSBjb250YWlucyBvciBpcyBhbm90aGVyIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcbiAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICByZXR1cm4gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlLnBhcmVudE5vZGUpO1xuICB9IGVsc2UgaWYgKCdjb250YWlucycgaW4gb3V0ZXJOb2RlKSB7XG4gICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250YWluc05vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzTm9kZShvYmplY3QpIHtcbiAgcmV0dXJuICEhKG9iamVjdCAmJiAodHlwZW9mIE5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBOb2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9mYmpzL2xpYi9pc05vZGUuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudCgpIC8qP0RPTUVsZW1lbnQqL3tcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIE5TID0ge1xuICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICB4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG59O1xuXG4vLyBXZSB1c2UgYXR0cmlidXRlcyBmb3IgZXZlcnl0aGluZyBTVkcgc28gbGV0J3MgYXZvaWQgc29tZSBkdXBsaWNhdGlvbiBhbmQgcnVuXG4vLyBjb2RlIGluc3RlYWQuXG4vLyBUaGUgZm9sbG93aW5nIGFyZSBhbGwgc3BlY2lmaWVkIGluIHRoZSBIVE1MIGNvbmZpZyBhbHJlYWR5IHNvIHdlIGV4Y2x1ZGUgaGVyZS5cbi8vIC0gY2xhc3MgKGFzIGNsYXNzTmFtZSlcbi8vIC0gY29sb3Jcbi8vIC0gaGVpZ2h0XG4vLyAtIGlkXG4vLyAtIGxhbmdcbi8vIC0gbWF4XG4vLyAtIG1lZGlhXG4vLyAtIG1ldGhvZFxuLy8gLSBtaW5cbi8vIC0gbmFtZVxuLy8gLSBzdHlsZVxuLy8gLSB0YXJnZXRcbi8vIC0gdHlwZVxuLy8gLSB3aWR0aFxudmFyIEFUVFJTID0ge1xuICBhY2NlbnRIZWlnaHQ6ICdhY2NlbnQtaGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogMCxcbiAgYWRkaXRpdmU6IDAsXG4gIGFsaWdubWVudEJhc2VsaW5lOiAnYWxpZ25tZW50LWJhc2VsaW5lJyxcbiAgYWxsb3dSZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogMCxcbiAgYW1wbGl0dWRlOiAwLFxuICBhcmFiaWNGb3JtOiAnYXJhYmljLWZvcm0nLFxuICBhc2NlbnQ6IDAsXG4gIGF0dHJpYnV0ZU5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRlVHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvUmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogMCxcbiAgYmFzZUZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlUHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmFzZWxpbmVTaGlmdDogJ2Jhc2VsaW5lLXNoaWZ0JyxcbiAgYmJveDogMCxcbiAgYmVnaW46IDAsXG4gIGJpYXM6IDAsXG4gIGJ5OiAwLFxuICBjYWxjTW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwSGVpZ2h0OiAnY2FwLWhlaWdodCcsXG4gIGNsaXA6IDAsXG4gIGNsaXBQYXRoOiAnY2xpcC1wYXRoJyxcbiAgY2xpcFJ1bGU6ICdjbGlwLXJ1bGUnLFxuICBjbGlwUGF0aFVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNvbG9ySW50ZXJwb2xhdGlvbjogJ2NvbG9yLWludGVycG9sYXRpb24nLFxuICBjb2xvckludGVycG9sYXRpb25GaWx0ZXJzOiAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJyxcbiAgY29sb3JQcm9maWxlOiAnY29sb3ItcHJvZmlsZScsXG4gIGNvbG9yUmVuZGVyaW5nOiAnY29sb3ItcmVuZGVyaW5nJyxcbiAgY29udGVudFNjcmlwdFR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRTdHlsZVR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAwLFxuICBjeDogMCxcbiAgY3k6IDAsXG4gIGQ6IDAsXG4gIGRlY2VsZXJhdGU6IDAsXG4gIGRlc2NlbnQ6IDAsXG4gIGRpZmZ1c2VDb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogMCxcbiAgZGlzcGxheTogMCxcbiAgZGl2aXNvcjogMCxcbiAgZG9taW5hbnRCYXNlbGluZTogJ2RvbWluYW50LWJhc2VsaW5lJyxcbiAgZHVyOiAwLFxuICBkeDogMCxcbiAgZHk6IDAsXG4gIGVkZ2VNb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246IDAsXG4gIGVuYWJsZUJhY2tncm91bmQ6ICdlbmFibGUtYmFja2dyb3VuZCcsXG4gIGVuZDogMCxcbiAgZXhwb25lbnQ6IDAsXG4gIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogMCxcbiAgZmlsbE9wYWNpdHk6ICdmaWxsLW9wYWNpdHknLFxuICBmaWxsUnVsZTogJ2ZpbGwtcnVsZScsXG4gIGZpbHRlcjogMCxcbiAgZmlsdGVyUmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVyVW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kQ29sb3I6ICdmbG9vZC1jb2xvcicsXG4gIGZsb29kT3BhY2l0eTogJ2Zsb29kLW9wYWNpdHknLFxuICBmb2N1c2FibGU6IDAsXG4gIGZvbnRGYW1pbHk6ICdmb250LWZhbWlseScsXG4gIGZvbnRTaXplOiAnZm9udC1zaXplJyxcbiAgZm9udFNpemVBZGp1c3Q6ICdmb250LXNpemUtYWRqdXN0JyxcbiAgZm9udFN0cmV0Y2g6ICdmb250LXN0cmV0Y2gnLFxuICBmb250U3R5bGU6ICdmb250LXN0eWxlJyxcbiAgZm9udFZhcmlhbnQ6ICdmb250LXZhcmlhbnQnLFxuICBmb250V2VpZ2h0OiAnZm9udC13ZWlnaHQnLFxuICBmb3JtYXQ6IDAsXG4gIGZyb206IDAsXG4gIGZ4OiAwLFxuICBmeTogMCxcbiAgZzE6IDAsXG4gIGcyOiAwLFxuICBnbHlwaE5hbWU6ICdnbHlwaC1uYW1lJyxcbiAgZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWw6ICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJyxcbiAgZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsOiAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLFxuICBnbHlwaFJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnRUcmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50VW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogMCxcbiAgaG9yaXpBZHZYOiAnaG9yaXotYWR2LXgnLFxuICBob3Jpek9yaWdpblg6ICdob3Jpei1vcmlnaW4teCcsXG4gIGlkZW9ncmFwaGljOiAwLFxuICBpbWFnZVJlbmRlcmluZzogJ2ltYWdlLXJlbmRlcmluZycsXG4gICdpbic6IDAsXG4gIGluMjogMCxcbiAgaW50ZXJjZXB0OiAwLFxuICBrOiAwLFxuICBrMTogMCxcbiAgazI6IDAsXG4gIGszOiAwLFxuICBrNDogMCxcbiAga2VybmVsTWF0cml4OiAna2VybmVsTWF0cml4JyxcbiAga2VybmVsVW5pdExlbmd0aDogJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICBrZXJuaW5nOiAwLFxuICBrZXlQb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlTcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleVRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhBZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJTcGFjaW5nOiAnbGV0dGVyLXNwYWNpbmcnLFxuICBsaWdodGluZ0NvbG9yOiAnbGlnaHRpbmctY29sb3InLFxuICBsaW1pdGluZ0NvbmVBbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6IDAsXG4gIG1hcmtlckVuZDogJ21hcmtlci1lbmQnLFxuICBtYXJrZXJNaWQ6ICdtYXJrZXItbWlkJyxcbiAgbWFya2VyU3RhcnQ6ICdtYXJrZXItc3RhcnQnLFxuICBtYXJrZXJIZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxuICBtYXJrZXJVbml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2VyV2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6IDAsXG4gIG1hc2tDb250ZW50VW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza1VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAwLFxuICBtb2RlOiAwLFxuICBudW1PY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogMCxcbiAgb3BhY2l0eTogMCxcbiAgb3BlcmF0b3I6IDAsXG4gIG9yZGVyOiAwLFxuICBvcmllbnQ6IDAsXG4gIG9yaWVudGF0aW9uOiAwLFxuICBvcmlnaW46IDAsXG4gIG92ZXJmbG93OiAwLFxuICBvdmVybGluZVBvc2l0aW9uOiAnb3ZlcmxpbmUtcG9zaXRpb24nLFxuICBvdmVybGluZVRoaWNrbmVzczogJ292ZXJsaW5lLXRoaWNrbmVzcycsXG4gIHBhaW50T3JkZXI6ICdwYWludC1vcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UtMScsXG4gIHBhdGhMZW5ndGg6ICdwYXRoTGVuZ3RoJyxcbiAgcGF0dGVybkNvbnRlbnRVbml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICBwYXR0ZXJuVHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gIHBhdHRlcm5Vbml0czogJ3BhdHRlcm5Vbml0cycsXG4gIHBvaW50ZXJFdmVudHM6ICdwb2ludGVyLWV2ZW50cycsXG4gIHBvaW50czogMCxcbiAgcG9pbnRzQXRYOiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzQXRZOiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzQXRaOiAncG9pbnRzQXRaJyxcbiAgcHJlc2VydmVBbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZVVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICByOiAwLFxuICByYWRpdXM6IDAsXG4gIHJlZlg6ICdyZWZYJyxcbiAgcmVmWTogJ3JlZlknLFxuICByZW5kZXJpbmdJbnRlbnQ6ICdyZW5kZXJpbmctaW50ZW50JyxcbiAgcmVwZWF0Q291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdER1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkRXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkRmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzdGFydDogMCxcbiAgcmVzdWx0OiAwLFxuICByb3RhdGU6IDAsXG4gIHJ4OiAwLFxuICByeTogMCxcbiAgc2NhbGU6IDAsXG4gIHNlZWQ6IDAsXG4gIHNoYXBlUmVuZGVyaW5nOiAnc2hhcGUtcmVuZGVyaW5nJyxcbiAgc2xvcGU6IDAsXG4gIHNwYWNpbmc6IDAsXG4gIHNwZWN1bGFyQ29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJFeHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogMCxcbiAgc3ByZWFkTWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRPZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZERldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAwLFxuICBzdGVtdjogMCxcbiAgc3RpdGNoVGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3BDb2xvcjogJ3N0b3AtY29sb3InLFxuICBzdG9wT3BhY2l0eTogJ3N0b3Atb3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hQb3NpdGlvbjogJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLFxuICBzdHJpa2V0aHJvdWdoVGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLFxuICBzdHJpbmc6IDAsXG4gIHN0cm9rZTogMCxcbiAgc3Ryb2tlRGFzaGFycmF5OiAnc3Ryb2tlLWRhc2hhcnJheScsXG4gIHN0cm9rZURhc2hvZmZzZXQ6ICdzdHJva2UtZGFzaG9mZnNldCcsXG4gIHN0cm9rZUxpbmVjYXA6ICdzdHJva2UtbGluZWNhcCcsXG4gIHN0cm9rZUxpbmVqb2luOiAnc3Ryb2tlLWxpbmVqb2luJyxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogJ3N0cm9rZS1taXRlcmxpbWl0JyxcbiAgc3Ryb2tlT3BhY2l0eTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgc3Ryb2tlV2lkdGg6ICdzdHJva2Utd2lkdGgnLFxuICBzdXJmYWNlU2NhbGU6ICdzdXJmYWNlU2NhbGUnLFxuICBzeXN0ZW1MYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgdGFibGVWYWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gIHRhcmdldFg6ICd0YXJnZXRYJyxcbiAgdGFyZ2V0WTogJ3RhcmdldFknLFxuICB0ZXh0QW5jaG9yOiAndGV4dC1hbmNob3InLFxuICB0ZXh0RGVjb3JhdGlvbjogJ3RleHQtZGVjb3JhdGlvbicsXG4gIHRleHRSZW5kZXJpbmc6ICd0ZXh0LXJlbmRlcmluZycsXG4gIHRleHRMZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdG86IDAsXG4gIHRyYW5zZm9ybTogMCxcbiAgdTE6IDAsXG4gIHUyOiAwLFxuICB1bmRlcmxpbmVQb3NpdGlvbjogJ3VuZGVybGluZS1wb3NpdGlvbicsXG4gIHVuZGVybGluZVRoaWNrbmVzczogJ3VuZGVybGluZS10aGlja25lc3MnLFxuICB1bmljb2RlOiAwLFxuICB1bmljb2RlQmlkaTogJ3VuaWNvZGUtYmlkaScsXG4gIHVuaWNvZGVSYW5nZTogJ3VuaWNvZGUtcmFuZ2UnLFxuICB1bml0c1BlckVtOiAndW5pdHMtcGVyLWVtJyxcbiAgdkFscGhhYmV0aWM6ICd2LWFscGhhYmV0aWMnLFxuICB2SGFuZ2luZzogJ3YtaGFuZ2luZycsXG4gIHZJZGVvZ3JhcGhpYzogJ3YtaWRlb2dyYXBoaWMnLFxuICB2TWF0aGVtYXRpY2FsOiAndi1tYXRoZW1hdGljYWwnLFxuICB2YWx1ZXM6IDAsXG4gIHZlY3RvckVmZmVjdDogJ3ZlY3Rvci1lZmZlY3QnLFxuICB2ZXJzaW9uOiAwLFxuICB2ZXJ0QWR2WTogJ3ZlcnQtYWR2LXknLFxuICB2ZXJ0T3JpZ2luWDogJ3ZlcnQtb3JpZ2luLXgnLFxuICB2ZXJ0T3JpZ2luWTogJ3ZlcnQtb3JpZ2luLXknLFxuICB2aWV3Qm94OiAndmlld0JveCcsXG4gIHZpZXdUYXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogMCxcbiAgd2lkdGhzOiAwLFxuICB3b3JkU3BhY2luZzogJ3dvcmQtc3BhY2luZycsXG4gIHdyaXRpbmdNb2RlOiAnd3JpdGluZy1tb2RlJyxcbiAgeDogMCxcbiAgeEhlaWdodDogJ3gtaGVpZ2h0JyxcbiAgeDE6IDAsXG4gIHgyOiAwLFxuICB4Q2hhbm5lbFNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhsaW5rQWN0dWF0ZTogJ3hsaW5rOmFjdHVhdGUnLFxuICB4bGlua0FyY3JvbGU6ICd4bGluazphcmNyb2xlJyxcbiAgeGxpbmtIcmVmOiAneGxpbms6aHJlZicsXG4gIHhsaW5rUm9sZTogJ3hsaW5rOnJvbGUnLFxuICB4bGlua1Nob3c6ICd4bGluazpzaG93JyxcbiAgeGxpbmtUaXRsZTogJ3hsaW5rOnRpdGxlJyxcbiAgeGxpbmtUeXBlOiAneGxpbms6dHlwZScsXG4gIHhtbEJhc2U6ICd4bWw6YmFzZScsXG4gIHhtbG5zOiAwLFxuICB4bWxuc1hsaW5rOiAneG1sbnM6eGxpbmsnLFxuICB4bWxMYW5nOiAneG1sOmxhbmcnLFxuICB4bWxTcGFjZTogJ3htbDpzcGFjZScsXG4gIHk6IDAsXG4gIHkxOiAwLFxuICB5MjogMCxcbiAgeUNoYW5uZWxTZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxuICB6OiAwLFxuICB6b29tQW5kUGFuOiAnem9vbUFuZFBhbidcbn07XG5cbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgUHJvcGVydGllczoge30sXG4gIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IHtcbiAgICB4bGlua0FjdHVhdGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rQXJjcm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtIcmVmOiBOUy54bGluayxcbiAgICB4bGlua1JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rU2hvdzogTlMueGxpbmssXG4gICAgeGxpbmtUaXRsZTogTlMueGxpbmssXG4gICAgeGxpbmtUeXBlOiBOUy54bGluayxcbiAgICB4bWxCYXNlOiBOUy54bWwsXG4gICAgeG1sTGFuZzogTlMueG1sLFxuICAgIHhtbFNwYWNlOiBOUy54bWxcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHt9XG59O1xuXG5PYmplY3Qua2V5cyhBVFRSUykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFNWR0RPTVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXNba2V5XSA9IDA7XG4gIGlmIChBVFRSU1trZXldKSB7XG4gICAgU1ZHRE9NUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNba2V5XSA9IEFUVFJTW2tleV07XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWR0RPTVByb3BlcnR5Q29uZmlnO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnB1dFNlbGVjdGlvbicpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKCcuL2lzVGV4dElucHV0RWxlbWVudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xuXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25TZWxlY3QnLFxuICAgICAgY2FwdHVyZWQ6ICdvblNlbGVjdENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb250ZXh0TWVudScsICd0b3BGb2N1cycsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93bicsICd0b3BNb3VzZVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG52YXIgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG52YXIgbW91c2VEb3duID0gZmFsc2U7XG5cbi8vIFRyYWNrIHdoZXRoZXIgYSBsaXN0ZW5lciBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuLy8gbm90IGV4dHJhY3QgZXZlbnRzLiBTZWUgIzM2MzkuXG52YXIgaGFzTGlzdGVuZXIgPSBmYWxzZTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmVudEVsZW1lbnQ6IHJhbmdlLnBhcmVudEVsZW1lbnQoKSxcbiAgICAgIHRleHQ6IHJhbmdlLnRleHQsXG4gICAgICB0b3A6IHJhbmdlLmJvdW5kaW5nVG9wLFxuICAgICAgbGVmdDogcmFuZ2UuYm91bmRpbmdMZWZ0XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9TeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50KTtcbiAgaWYgKCFsYXN0U2VsZWN0aW9uIHx8ICFzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICBsYXN0U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcblxuICAgIHZhciBzeW50aGV0aWNFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLnNlbGVjdCwgYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICBzeW50aGV0aWNFdmVudC50eXBlID0gJ3NlbGVjdCc7XG4gICAgc3ludGhldGljRXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudDtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhzeW50aGV0aWNFdmVudCk7XG5cbiAgICByZXR1cm4gc3ludGhldGljRXZlbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAoIWhhc0xpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSB8fCB0YXJnZXROb2RlLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xuICAgICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQmx1cic6XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuIElFJ3MgZXZlbnQgZmlyZXMgb3V0IG9mIG9yZGVyIHdpdGggcmVzcGVjdFxuICAgICAgLy8gdG8ga2V5IGFuZCBpbnB1dCBldmVudHMgb24gZGVsZXRpb24sIHNvIHdlIGRpc2NhcmQgaXQuXG4gICAgICAvL1xuICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXG4gICAgICAvLyBhZnRlciBlYWNoIGtleSBlbnRyeS4gVGhlIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIGtleWRvd24gYW5kIGJlZm9yZVxuICAgICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxuICAgICAgLy8gVGhpcyBpcyBhbHNvIG91ciBhcHByb2FjaCBmb3IgSUUgaGFuZGxpbmcsIGZvciB0aGUgcmVhc29uIGFib3ZlLlxuICAgICAgY2FzZSAndG9wU2VsZWN0aW9uQ2hhbmdlJzpcbiAgICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25TZWxlY3QnKSB7XG4gICAgICBoYXNMaXN0ZW5lciA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdEV2ZW50UGx1Z2luO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9TZWxlY3RFdmVudFBsdWdpbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgU3ludGhldGljQW5pbWF0aW9uRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljQ2xpcGJvYXJkRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50Jyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG52YXIgU3ludGhldGljRm9jdXNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRm9jdXNFdmVudCcpO1xudmFyIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQnKTtcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG52YXIgU3ludGhldGljRHJhZ0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNEcmFnRXZlbnQnKTtcbnZhciBTeW50aGV0aWNUb3VjaEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNUb3VjaEV2ZW50Jyk7XG52YXIgU3ludGhldGljVHJhbnNpdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQnKTtcbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljV2hlZWxFdmVudCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogVHVybnNcbiAqIFsnYWJvcnQnLCAuLi5dXG4gKiBpbnRvXG4gKiBldmVudFR5cGVzID0ge1xuICogICAnYWJvcnQnOiB7XG4gKiAgICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAqICAgICAgIGJ1YmJsZWQ6ICdvbkFib3J0JyxcbiAqICAgICAgIGNhcHR1cmVkOiAnb25BYm9ydENhcHR1cmUnLFxuICogICAgIH0sXG4gKiAgICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEFib3J0J10sXG4gKiAgIH0sXG4gKiAgIC4uLlxuICogfTtcbiAqIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHtcbiAqICAgJ3RvcEFib3J0JzogeyBzYW1lQ29uZmlnIH1cbiAqIH07XG4gKi9cbnZhciBldmVudFR5cGVzID0ge307XG52YXIgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge307XG5bJ2Fib3J0JywgJ2FuaW1hdGlvbkVuZCcsICdhbmltYXRpb25JdGVyYXRpb24nLCAnYW5pbWF0aW9uU3RhcnQnLCAnYmx1cicsICdjYW5QbGF5JywgJ2NhblBsYXlUaHJvdWdoJywgJ2NsaWNrJywgJ2NvbnRleHRNZW51JywgJ2NvcHknLCAnY3V0JywgJ2RvdWJsZUNsaWNrJywgJ2RyYWcnLCAnZHJhZ0VuZCcsICdkcmFnRW50ZXInLCAnZHJhZ0V4aXQnLCAnZHJhZ0xlYXZlJywgJ2RyYWdPdmVyJywgJ2RyYWdTdGFydCcsICdkcm9wJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2ZvY3VzJywgJ2lucHV0JywgJ2ludmFsaWQnLCAna2V5RG93bicsICdrZXlQcmVzcycsICdrZXlVcCcsICdsb2FkJywgJ2xvYWRlZERhdGEnLCAnbG9hZGVkTWV0YWRhdGEnLCAnbG9hZFN0YXJ0JywgJ21vdXNlRG93bicsICdtb3VzZU1vdmUnLCAnbW91c2VPdXQnLCAnbW91c2VPdmVyJywgJ21vdXNlVXAnLCAncGFzdGUnLCAncGF1c2UnLCAncGxheScsICdwbGF5aW5nJywgJ3Byb2dyZXNzJywgJ3JhdGVDaGFuZ2UnLCAncmVzZXQnLCAnc2Nyb2xsJywgJ3NlZWtlZCcsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3VibWl0JywgJ3N1c3BlbmQnLCAndGltZVVwZGF0ZScsICd0b3VjaENhbmNlbCcsICd0b3VjaEVuZCcsICd0b3VjaE1vdmUnLCAndG91Y2hTdGFydCcsICd0cmFuc2l0aW9uRW5kJywgJ3ZvbHVtZUNoYW5nZScsICd3YWl0aW5nJywgJ3doZWVsJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIGNhcGl0YWxpemVkRXZlbnQgPSBldmVudFswXS50b1VwcGVyQ2FzZSgpICsgZXZlbnQuc2xpY2UoMSk7XG4gIHZhciBvbkV2ZW50ID0gJ29uJyArIGNhcGl0YWxpemVkRXZlbnQ7XG4gIHZhciB0b3BFdmVudCA9ICd0b3AnICsgY2FwaXRhbGl6ZWRFdmVudDtcblxuICB2YXIgdHlwZSA9IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogb25FdmVudCxcbiAgICAgIGNhcHR1cmVkOiBvbkV2ZW50ICsgJ0NhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BFdmVudF1cbiAgfTtcbiAgZXZlbnRUeXBlc1tldmVudF0gPSB0eXBlO1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wRXZlbnRdID0gdHlwZTtcbn0pO1xuXG52YXIgb25DbGlja0xpc3RlbmVycyA9IHt9O1xuXG5mdW5jdGlvbiBnZXREaWN0aW9uYXJ5S2V5KGluc3QpIHtcbiAgLy8gUHJldmVudHMgVjggcGVyZm9ybWFuY2UgaXNzdWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbiAgcmV0dXJuICcuJyArIGluc3QuX3Jvb3ROb2RlSUQ7XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJhY3RpdmUodGFnKSB7XG4gIHJldHVybiB0YWcgPT09ICdidXR0b24nIHx8IHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICdzZWxlY3QnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJztcbn1cblxuZnVuY3Rpb24gc2hvdWxkUHJldmVudE1vdXNlRXZlbnQoaW5zdCkge1xuICBpZiAoaW5zdCkge1xuICAgIHZhciBkaXNhYmxlZCA9IGluc3QuX2N1cnJlbnRFbGVtZW50ICYmIGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzLmRpc2FibGVkO1xuXG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gaXNJbnRlcmFjdGl2ZShpbnN0Ll90YWcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcExldmVsVHlwZV07XG4gICAgaWYgKCFkaXNwYXRjaENvbmZpZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBFdmVudENvbnN0cnVjdG9yO1xuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICBjYXNlICd0b3BBYm9ydCc6XG4gICAgICBjYXNlICd0b3BDYW5QbGF5JzpcbiAgICAgIGNhc2UgJ3RvcENhblBsYXlUaHJvdWdoJzpcbiAgICAgIGNhc2UgJ3RvcER1cmF0aW9uQ2hhbmdlJzpcbiAgICAgIGNhc2UgJ3RvcEVtcHRpZWQnOlxuICAgICAgY2FzZSAndG9wRW5jcnlwdGVkJzpcbiAgICAgIGNhc2UgJ3RvcEVuZGVkJzpcbiAgICAgIGNhc2UgJ3RvcEVycm9yJzpcbiAgICAgIGNhc2UgJ3RvcElucHV0JzpcbiAgICAgIGNhc2UgJ3RvcEludmFsaWQnOlxuICAgICAgY2FzZSAndG9wTG9hZCc6XG4gICAgICBjYXNlICd0b3BMb2FkZWREYXRhJzpcbiAgICAgIGNhc2UgJ3RvcExvYWRlZE1ldGFkYXRhJzpcbiAgICAgIGNhc2UgJ3RvcExvYWRTdGFydCc6XG4gICAgICBjYXNlICd0b3BQYXVzZSc6XG4gICAgICBjYXNlICd0b3BQbGF5JzpcbiAgICAgIGNhc2UgJ3RvcFBsYXlpbmcnOlxuICAgICAgY2FzZSAndG9wUHJvZ3Jlc3MnOlxuICAgICAgY2FzZSAndG9wUmF0ZUNoYW5nZSc6XG4gICAgICBjYXNlICd0b3BSZXNldCc6XG4gICAgICBjYXNlICd0b3BTZWVrZWQnOlxuICAgICAgY2FzZSAndG9wU2Vla2luZyc6XG4gICAgICBjYXNlICd0b3BTdGFsbGVkJzpcbiAgICAgIGNhc2UgJ3RvcFN1Ym1pdCc6XG4gICAgICBjYXNlICd0b3BTdXNwZW5kJzpcbiAgICAgIGNhc2UgJ3RvcFRpbWVVcGRhdGUnOlxuICAgICAgY2FzZSAndG9wVm9sdW1lQ2hhbmdlJzpcbiAgICAgIGNhc2UgJ3RvcFdhaXRpbmcnOlxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbiAgICAgICAgLy8gbm9uLXByaW50YWJsZS4gT25lIHdvdWxkIGV4cGVjdCBUYWIgdG8gYmUgYXMgd2VsbCAoYnV0IGl0IGlzbid0KS5cbiAgICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ2xpY2snOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbiAgICAgICAgLy8gdW53YW50ZWQgY2xpY2sgZXZlbnRzLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcERvdWJsZUNsaWNrJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICBjYXNlICd0b3BNb3VzZU1vdmUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAgIC8vIERpc2FibGVkIGVsZW1lbnRzIHNob3VsZCBub3QgcmVzcG9uZCB0byBtb3VzZSBldmVudHNcbiAgICAgICAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHRhcmdldEluc3QpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3V0JzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3Zlcic6XG4gICAgICBjYXNlICd0b3BDb250ZXh0TWVudSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcERyYWcnOlxuICAgICAgY2FzZSAndG9wRHJhZ0VuZCc6XG4gICAgICBjYXNlICd0b3BEcmFnRW50ZXInOlxuICAgICAgY2FzZSAndG9wRHJhZ0V4aXQnOlxuICAgICAgY2FzZSAndG9wRHJhZ0xlYXZlJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdPdmVyJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdTdGFydCc6XG4gICAgICBjYXNlICd0b3BEcm9wJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BUb3VjaENhbmNlbCc6XG4gICAgICBjYXNlICd0b3BUb3VjaEVuZCc6XG4gICAgICBjYXNlICd0b3BUb3VjaE1vdmUnOlxuICAgICAgY2FzZSAndG9wVG91Y2hTdGFydCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvbkVuZCc6XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25JdGVyYXRpb24nOlxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uU3RhcnQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wVHJhbnNpdGlvbkVuZCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wU2Nyb2xsJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wV2hlZWwnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljV2hlZWxFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDb3B5JzpcbiAgICAgIGNhc2UgJ3RvcEN1dCc6XG4gICAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgICFFdmVudENvbnN0cnVjdG9yID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4nLCB0b3BMZXZlbFR5cGUpIDogX3Byb2RJbnZhcmlhbnQoJzg2JywgdG9wTGV2ZWxUeXBlKSA6IHZvaWQgMDtcbiAgICB2YXIgZXZlbnQgPSBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfSxcblxuICBkaWRQdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gICAgLy8gZmlyZS4gVGhlIHdvcmthcm91bmQgZm9yIHRoaXMgYnVnIGludm9sdmVzIGF0dGFjaGluZyBhbiBlbXB0eSBjbGlja1xuICAgIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgICAvLyBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25DbGljaycgJiYgIWlzSW50ZXJhY3RpdmUoaW5zdC5fdGFnKSkge1xuICAgICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgICAgaWYgKCFvbkNsaWNrTGlzdGVuZXJzW2tleV0pIHtcbiAgICAgICAgb25DbGlja0xpc3RlbmVyc1trZXldID0gRXZlbnRMaXN0ZW5lci5saXN0ZW4obm9kZSwgJ2NsaWNrJywgZW1wdHlGdW5jdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHdpbGxEZWxldGVMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uQ2xpY2snICYmICFpc0ludGVyYWN0aXZlKGluc3QuX3RhZykpIHtcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgICAgb25DbGlja0xpc3RlbmVyc1trZXldLnJlbW92ZSgpO1xuICAgICAgZGVsZXRlIG9uQ2xpY2tMaXN0ZW5lcnNba2V5XTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVFdmVudFBsdWdpbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvU2ltcGxlRXZlbnRQbHVnaW4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWFuaW1hdGlvbnMvI0FuaW1hdGlvbkV2ZW50LWludGVyZmFjZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uRXZlbnRcbiAqL1xudmFyIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBhbmltYXRpb25OYW1lOiBudWxsLFxuICBlbGFwc2VkVGltZTogbnVsbCxcbiAgcHNldWRvRWxlbWVudDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LCBBbmltYXRpb25FdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY2xpcGJvYXJkLWFwaXMvXG4gKi9cbnZhciBDbGlwYm9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAgY2xpcGJvYXJkRGF0YTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdjbGlwYm9hcmREYXRhJyBpbiBldmVudCA/IGV2ZW50LmNsaXBib2FyZERhdGEgOiB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ2xpcGJvYXJkRXZlbnQsIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljQ2xpcGJvYXJkRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0ge1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNGb2N1c0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNGb2N1c0V2ZW50LCBGb2N1c0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNGb2N1c0V2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcbnZhciBnZXRFdmVudEtleSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRLZXknKTtcbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgS2V5Ym9hcmRFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBLZXlib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBrZXk6IGdldEV2ZW50S2V5LFxuICBsb2NhdGlvbjogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgcmVwZWF0OiBudWxsLFxuICBsb2NhbGU6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgLy8gTGVnYWN5IEludGVyZmFjZVxuICBjaGFyQ29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGNoYXJDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5UHJlc3MgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuXG4gICAgLy8gS2V5UHJlc3MgaXMgZGVwcmVjYXRlZCwgYnV0IGl0cyByZXBsYWNlbWVudCBpcyBub3QgeWV0IGZpbmFsIGFuZCBub3RcbiAgICAvLyBpbXBsZW1lbnRlZCBpbiBhbnkgbWFqb3IgYnJvd3Nlci4gT25seSBLZXlQcmVzcyBoYXMgY2hhckNvZGUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGtleUNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBrZXlDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5RG93bi9VcCBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyBwaHlzaWNhbCBrZXlib2FyZCBrZXkuXG5cbiAgICAvLyBUaGUgYWN0dWFsIG1lYW5pbmcgb2YgdGhlIHZhbHVlIGRlcGVuZHMgb24gdGhlIHVzZXJzJyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyB3aGljaCBjYW5ub3QgYmUgZGV0ZWN0ZWQuIEFzc3VtaW5nIHRoYXQgaXQgaXMgYSBVUyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyBwcm92aWRlcyBhIHN1cnByaXNpbmdseSBhY2N1cmF0ZSBtYXBwaW5nIGZvciBVUyBhbmQgRXVyb3BlYW4gdXNlcnMuXG4gICAgLy8gRHVlIHRvIHRoaXMsIGl0IGlzIGxlZnQgdG8gdGhlIHVzZXIgdG8gaW1wbGVtZW50IGF0IHRoaXMgdGltZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0tleWJvYXJkRXZlbnQsIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5cbmZ1bmN0aW9uIGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGNoYXJDb2RlO1xuICB2YXIga2V5Q29kZSA9IG5hdGl2ZUV2ZW50LmtleUNvZGU7XG5cbiAgaWYgKCdjaGFyQ29kZScgaW4gbmF0aXZlRXZlbnQpIHtcbiAgICBjaGFyQ29kZSA9IG5hdGl2ZUV2ZW50LmNoYXJDb2RlO1xuXG4gICAgLy8gRkYgZG9lcyBub3Qgc2V0IGBjaGFyQ29kZWAgZm9yIHRoZSBFbnRlci1rZXksIGNoZWNrIGFnYWluc3QgYGtleUNvZGVgLlxuICAgIGlmIChjaGFyQ29kZSA9PT0gMCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgY2hhckNvZGUgPSAxMztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XG4gIH1cblxuICAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbiAgLy8gTXVzdCBub3QgZGlzY2FyZCB0aGUgKG5vbi0pcHJpbnRhYmxlIEVudGVyLWtleS5cbiAgaWYgKGNoYXJDb2RlID49IDMyIHx8IGNoYXJDb2RlID09PSAxMykge1xuICAgIHJldHVybiBjaGFyQ29kZTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50Q2hhckNvZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2dldEV2ZW50Q2hhckNvZGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xuXG4vKipcbiAqIE5vcm1hbGl6YXRpb24gb2YgZGVwcmVjYXRlZCBIVE1MNSBga2V5YCB2YWx1ZXNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gICdFc2MnOiAnRXNjYXBlJyxcbiAgJ1NwYWNlYmFyJzogJyAnLFxuICAnTGVmdCc6ICdBcnJvd0xlZnQnLFxuICAnVXAnOiAnQXJyb3dVcCcsXG4gICdSaWdodCc6ICdBcnJvd1JpZ2h0JyxcbiAgJ0Rvd24nOiAnQXJyb3dEb3duJyxcbiAgJ0RlbCc6ICdEZWxldGUnLFxuICAnV2luJzogJ09TJyxcbiAgJ01lbnUnOiAnQ29udGV4dE1lbnUnLFxuICAnQXBwcyc6ICdDb250ZXh0TWVudScsXG4gICdTY3JvbGwnOiAnU2Nyb2xsTG9jaycsXG4gICdNb3pQcmludGFibGVLZXknOiAnVW5pZGVudGlmaWVkJ1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIGxlZ2FjeSBga2V5Q29kZWAgdG8gSFRNTDUgYGtleWBcbiAqIE9ubHkgc3BlY2lhbCBrZXlzIHN1cHBvcnRlZCwgYWxsIG90aGVycyBkZXBlbmQgb24ga2V5Ym9hcmQgbGF5b3V0IG9yIGJyb3dzZXJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgODogJ0JhY2tzcGFjZScsXG4gIDk6ICdUYWInLFxuICAxMjogJ0NsZWFyJyxcbiAgMTM6ICdFbnRlcicsXG4gIDE2OiAnU2hpZnQnLFxuICAxNzogJ0NvbnRyb2wnLFxuICAxODogJ0FsdCcsXG4gIDE5OiAnUGF1c2UnLFxuICAyMDogJ0NhcHNMb2NrJyxcbiAgMjc6ICdFc2NhcGUnLFxuICAzMjogJyAnLFxuICAzMzogJ1BhZ2VVcCcsXG4gIDM0OiAnUGFnZURvd24nLFxuICAzNTogJ0VuZCcsXG4gIDM2OiAnSG9tZScsXG4gIDM3OiAnQXJyb3dMZWZ0JyxcbiAgMzg6ICdBcnJvd1VwJyxcbiAgMzk6ICdBcnJvd1JpZ2h0JyxcbiAgNDA6ICdBcnJvd0Rvd24nLFxuICA0NTogJ0luc2VydCcsXG4gIDQ2OiAnRGVsZXRlJyxcbiAgMTEyOiAnRjEnLCAxMTM6ICdGMicsIDExNDogJ0YzJywgMTE1OiAnRjQnLCAxMTY6ICdGNScsIDExNzogJ0Y2JyxcbiAgMTE4OiAnRjcnLCAxMTk6ICdGOCcsIDEyMDogJ0Y5JywgMTIxOiAnRjEwJywgMTIyOiAnRjExJywgMTIzOiAnRjEyJyxcbiAgMTQ0OiAnTnVtTG9jaycsXG4gIDE0NTogJ1Njcm9sbExvY2snLFxuICAyMjQ6ICdNZXRhJ1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG5cbiAgICAvLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxuICAgIC8vIHByaW50YWJsZSBjaGFyYWN0ZXJzIChub3JtYWxpemVkIHRvIGBVbmlkZW50aWZpZWRgKSwgaWdub3JlIGl0LlxuICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG5cbiAgLy8gQnJvd3NlciBkb2VzIG5vdCBpbXBsZW1lbnQgYGtleWAsIHBvbHlmaWxsIGFzIG11Y2ggb2YgaXQgYXMgd2UgY2FuLlxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgIHZhciBjaGFyQ29kZSA9IGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpO1xuXG4gICAgLy8gVGhlIGVudGVyLWtleSBpcyB0ZWNobmljYWxseSBib3RoIHByaW50YWJsZSBhbmQgbm9uLXByaW50YWJsZSBhbmQgY2FuXG4gICAgLy8gdGh1cyBiZSBjYXB0dXJlZCBieSBga2V5cHJlc3NgLCBubyBvdGhlciBub24tcHJpbnRhYmxlIGtleSBzaG91bGQuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgfVxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAvLyBXaGlsZSB1c2VyIGtleWJvYXJkIGxheW91dCBkZXRlcm1pbmVzIHRoZSBhY3R1YWwgbWVhbmluZyBvZiBlYWNoXG4gICAgLy8gYGtleUNvZGVgIHZhbHVlLCBhbG1vc3QgYWxsIGZ1bmN0aW9uIGtleXMgaGF2ZSBhIHVuaXZlcnNhbCB2YWx1ZS5cbiAgICByZXR1cm4gdHJhbnNsYXRlVG9LZXlbbmF0aXZlRXZlbnQua2V5Q29kZV0gfHwgJ1VuaWRlbnRpZmllZCc7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50S2V5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9nZXRFdmVudEtleS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRHJhZ0V2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhVHJhbnNmZXI6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0RyYWdFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRHJhZ0V2ZW50LCBEcmFnRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0RyYWdFdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljRHJhZ0V2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA5L1dELWNzczMtdHJhbnNpdGlvbnMtMjAwOTAzMjAvI3RyYW5zaXRpb24tZXZlbnRzLVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNpdGlvbkV2ZW50XG4gKi9cbnZhciBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHByb3BlcnR5TmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LCBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNXaGVlbEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNXaGVlbEV2ZW50LCBXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNXaGVlbEV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01Db250YWluZXJJbmZvID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbnRhaW5lckluZm8nKTtcbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RET01GZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RGZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHJlcXVpcmUoJy4vUmVhY3RNYXJrdXBDaGVja3N1bScpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIFJPT1RfQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuUk9PVF9BVFRSSUJVVEVfTkFNRTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcbnZhciBET0NfTk9ERV9UWVBFID0gOTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxudmFyIGluc3RhbmNlc0J5UmVhY3RSb290SUQgPSB7fTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlclxuICogdGhhdCdzIG5vdCBjb21tb24gYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHN0cmluZ3MuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGNoYXJhY3RlciB3aGVyZSB0aGUgc3RyaW5ncyBkaXZlcmdlXG4gKi9cbmZ1bmN0aW9uIGZpcnN0RGlmZmVyZW5jZUluZGV4KHN0cmluZzEsIHN0cmluZzIpIHtcbiAgdmFyIG1pbkxlbiA9IE1hdGgubWluKHN0cmluZzEubGVuZ3RoLCBzdHJpbmcyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluTGVuOyBpKyspIHtcbiAgICBpZiAoc3RyaW5nMS5jaGFyQXQoaSkgIT09IHN0cmluZzIuY2hhckF0KGkpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cmluZzEubGVuZ3RoID09PSBzdHJpbmcyLmxlbmd0aCA/IC0xIDogbWluTGVuO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01Eb2N1bWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgbWF5IGNvbnRhaW5cbiAqIGEgUmVhY3QgY29tcG9uZW50XG4gKiBAcmV0dXJuIHs/Kn0gRE9NIGVsZW1lbnQgdGhhdCBtYXkgaGF2ZSB0aGUgcmVhY3RSb290IElELCBvciBudWxsLlxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVybmFsR2V0SUQobm9kZSkge1xuICAvLyBJZiBub2RlIGlzIHNvbWV0aGluZyBsaWtlIGEgd2luZG93LCBkb2N1bWVudCwgb3IgdGV4dCBub2RlLCBub25lIG9mXG4gIC8vIHdoaWNoIHN1cHBvcnQgYXR0cmlidXRlcyBvciBhIC5nZXRBdHRyaWJ1dGUgbWV0aG9kLCBncmFjZWZ1bGx5IHJldHVyblxuICAvLyB0aGUgZW1wdHkgc3RyaW5nLCBhcyBpZiB0aGUgYXR0cmlidXRlIHdlcmUgbWlzc2luZy5cbiAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgfHwgJyc7XG59XG5cbi8qKlxuICogTW91bnRzIHRoaXMgY29tcG9uZW50IGFuZCBpbnNlcnRzIGl0IGludG8gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudEludG9Ob2RlKHdyYXBwZXJJbnN0YW5jZSwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgdmFyIG1hcmtlck5hbWU7XG4gIGlmIChSZWFjdEZlYXR1cmVGbGFncy5sb2dUb3BMZXZlbFJlbmRlcnMpIHtcbiAgICB2YXIgd3JhcHBlZEVsZW1lbnQgPSB3cmFwcGVySW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnByb3BzLmNoaWxkO1xuICAgIHZhciB0eXBlID0gd3JhcHBlZEVsZW1lbnQudHlwZTtcbiAgICBtYXJrZXJOYW1lID0gJ1JlYWN0IG1vdW50OiAnICsgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSk7XG4gICAgY29uc29sZS50aW1lKG1hcmtlck5hbWUpO1xuICB9XG5cbiAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudCh3cmFwcGVySW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBudWxsLCBSZWFjdERPTUNvbnRhaW5lckluZm8od3JhcHBlckluc3RhbmNlLCBjb250YWluZXIpLCBjb250ZXh0LCAwIC8qIHBhcmVudERlYnVnSUQgKi9cbiAgKTtcblxuICBpZiAobWFya2VyTmFtZSkge1xuICAgIGNvbnNvbGUudGltZUVuZChtYXJrZXJOYW1lKTtcbiAgfVxuXG4gIHdyYXBwZXJJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQuX3RvcExldmVsV3JhcHBlciA9IHdyYXBwZXJJbnN0YW5jZTtcbiAgUmVhY3RNb3VudC5fbW91bnRJbWFnZUludG9Ob2RlKG1hcmt1cCwgY29udGFpbmVyLCB3cmFwcGVySW5zdGFuY2UsIHNob3VsZFJldXNlTWFya3VwLCB0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogQmF0Y2hlZCBtb3VudC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZShjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXG4gIC8qIHVzZUNyZWF0ZUVsZW1lbnQgKi9cbiAgIXNob3VsZFJldXNlTWFya3VwICYmIFJlYWN0RE9NRmVhdHVyZUZsYWdzLnVzZUNyZWF0ZUVsZW1lbnQpO1xuICB0cmFuc2FjdGlvbi5wZXJmb3JtKG1vdW50Q29tcG9uZW50SW50b05vZGUsIG51bGwsIGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHRyYW5zYWN0aW9uLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XG4gIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xufVxuXG4vKipcbiAqIFVubW91bnRzIGEgY29tcG9uZW50IGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnN0YW5jZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byB1bm1vdW50IGZyb20uXG4gKiBAZmluYWxcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7UmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlfVxuICovXG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUoaW5zdGFuY2UsIGNvbnRhaW5lciwgc2FmZWx5KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCgpO1xuICB9XG4gIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KGluc3RhbmNlLCBzYWZlbHkpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoKCk7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgY29udGFpbmVyID0gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2VtcHR5aW5nLWEtbm9kZVxuICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIubGFzdENoaWxkKTtcbiAgfVxufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGhhcyBhIGRpcmVjdCBSZWFjdC1yZW5kZXJlZCBjaGlsZCB0aGF0IGlzXG4gKiBub3QgYSBSZWFjdCByb290IGVsZW1lbnQuIFVzZWZ1bCBmb3Igd2FybmluZyBpbiBgcmVuZGVyYCxcbiAqIGB1bm1vdW50Q29tcG9uZW50QXROb2RlYCwgZXRjLlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBlbGVtZW50IGNvbnRhaW5zIGEgZGlyZWN0IGNoaWxkIHRoYXQgd2FzXG4gKiByZW5kZXJlZCBieSBSZWFjdCBidXQgaXMgbm90IGEgcm9vdCBlbGVtZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIGlmIChyb290RWwpIHtcbiAgICB2YXIgaW5zdCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCk7XG4gICAgcmV0dXJuICEhKGluc3QgJiYgaW5zdC5faG9zdFBhcmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIFJlYWN0IERPTSBlbGVtZW50IGFuZFxuICogaXQgaGFzIGJlZW4gcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBoYXMgYmVlbiByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3RcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBub2RlSXNSZW5kZXJlZEJ5T3RoZXJJbnN0YW5jZShjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEocm9vdEVsICYmIGlzUmVhY3ROb2RlKHJvb3RFbCkgJiYgIVJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCkpO1xufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgbm9kZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIERPTSBub2RlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUpKTtcbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIFJlYWN0IG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBSZWFjdCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1JlYWN0Tm9kZShub2RlKSB7XG4gIHJldHVybiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpICYmIChub2RlLmhhc0F0dHJpYnV0ZShST09UX0FUVFJfTkFNRSkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoQVRUUl9OQU1FKSk7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RSb290SW5zdGFuY2VJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICB2YXIgcHJldkhvc3RJbnN0YW5jZSA9IHJvb3RFbCAmJiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpO1xuICByZXR1cm4gcHJldkhvc3RJbnN0YW5jZSAmJiAhcHJldkhvc3RJbnN0YW5jZS5faG9zdFBhcmVudCA/IHByZXZIb3N0SW5zdGFuY2UgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgdmFyIHJvb3QgPSBnZXRIb3N0Um9vdEluc3RhbmNlSW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuIHJvb3QgPyByb290Ll9ob3N0Q29udGFpbmVySW5mby5fdG9wTGV2ZWxXcmFwcGVyIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUZW1wb3JhcnkgKD8pIGhhY2sgc28gdGhhdCB3ZSBjYW4gc3RvcmUgYWxsIHRvcC1sZXZlbCBwZW5kaW5nIHVwZGF0ZXMgb25cbiAqIGNvbXBvc2l0ZXMgaW5zdGVhZCBvZiBoYXZpbmcgdG8gd29ycnkgYWJvdXQgZGlmZmVyZW50IHR5cGVzIG9mIGNvbXBvbmVudHNcbiAqIGhlcmUuXG4gKi9cbnZhciB0b3BMZXZlbFJvb3RDb3VudGVyID0gMTtcbnZhciBUb3BMZXZlbFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucm9vdElEID0gdG9wTGV2ZWxSb290Q291bnRlcisrO1xufTtcblRvcExldmVsV3JhcHBlci5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVG9wTGV2ZWxXcmFwcGVyLmRpc3BsYXlOYW1lID0gJ1RvcExldmVsV3JhcHBlcic7XG59XG5Ub3BMZXZlbFdyYXBwZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGQ7XG59O1xuVG9wTGV2ZWxXcmFwcGVyLmlzUmVhY3RUb3BMZXZlbFdyYXBwZXIgPSB0cnVlO1xuXG4vKipcbiAqIE1vdW50aW5nIGlzIHRoZSBwcm9jZXNzIG9mIGluaXRpYWxpemluZyBhIFJlYWN0IGNvbXBvbmVudCBieSBjcmVhdGluZyBpdHNcbiAqIHJlcHJlc2VudGF0aXZlIERPTSBlbGVtZW50cyBhbmQgaW5zZXJ0aW5nIHRoZW0gaW50byBhIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICogQW55IHByaW9yIGNvbnRlbnQgaW5zaWRlIGBjb250YWluZXJgIGlzIGRlc3Ryb3llZCBpbiB0aGUgcHJvY2Vzcy5cbiAqXG4gKiAgIFJlYWN0TW91bnQucmVuZGVyKFxuICogICAgIGNvbXBvbmVudCxcbiAqICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyJylcbiAqICAgKTtcbiAqXG4gKiAgIDxkaXYgaWQ9XCJjb250YWluZXJcIj4gICAgICAgICAgICAgICAgICAgPC0tIFN1cHBsaWVkIGBjb250YWluZXJgLlxuICogICAgIDxkaXYgZGF0YS1yZWFjdGlkPVwiLjNcIj4gICAgICAgICAgICAgIDwtLSBSZW5kZXJlZCByZWFjdFJvb3Qgb2YgUmVhY3RcbiAqICAgICAgIC8vIC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5cbiAqICAgICA8L2Rpdj5cbiAqICAgPC9kaXY+XG4gKlxuICogSW5zaWRlIG9mIGBjb250YWluZXJgLCB0aGUgZmlyc3QgZWxlbWVudCByZW5kZXJlZCBpcyB0aGUgXCJyZWFjdFJvb3RcIi5cbiAqL1xudmFyIFJlYWN0TW91bnQgPSB7XG5cbiAgVG9wTGV2ZWxXcmFwcGVyOiBUb3BMZXZlbFdyYXBwZXIsXG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgZGV2dG9vbHMuIFRoZSBrZXlzIGFyZSBub3QgaW1wb3J0YW50LlxuICAgKi9cbiAgX2luc3RhbmNlc0J5UmVhY3RSb290SUQ6IGluc3RhbmNlc0J5UmVhY3RSb290SUQsXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBob29rIHByb3ZpZGVkIHRvIHN1cHBvcnQgcmVuZGVyaW5nIFJlYWN0IGNvbXBvbmVudHMgd2hpbGVcbiAgICogZW5zdXJpbmcgdGhhdCB0aGUgYXBwYXJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIGl0cyBgY29udGFpbmVyYCBkb2VzIG5vdFxuICAgKiBjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIFRoZSBgY29udGFpbmVyYCBiZWluZyByZW5kZXJlZCBpbnRvLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZW5kZXJDYWxsYmFjayBUaGlzIG11c3QgYmUgY2FsbGVkIG9uY2UgdG8gZG8gdGhlIHJlbmRlci5cbiAgICovXG4gIHNjcm9sbE1vbml0b3I6IGZ1bmN0aW9uIChjb250YWluZXIsIHJlbmRlckNhbGxiYWNrKSB7XG4gICAgcmVuZGVyQ2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogVGFrZSBhIGNvbXBvbmVudCB0aGF0J3MgYWxyZWFkeSBtb3VudGVkIGludG8gdGhlIERPTSBhbmQgcmVwbGFjZSBpdHMgcHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcHJldkNvbXBvbmVudCBjb21wb25lbnQgaW5zdGFuY2UgYWxyZWFkeSBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBjb21wb25lbnQgaW5zdGFuY2UgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICovXG4gIF91cGRhdGVSb290Q29tcG9uZW50OiBmdW5jdGlvbiAocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQsIG5leHRDb250ZXh0LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgUmVhY3RNb3VudC5zY3JvbGxNb25pdG9yKGNvbnRhaW5lciwgZnVuY3Rpb24gKCkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlRWxlbWVudEludGVybmFsKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCk7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbChwcmV2Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJldkNvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIGEgbmV3IGNvbXBvbmVudCBpbnRvIHRoZSBET00uIEhvb2tlZCBieSBob29rcyFcbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGVsZW1lbnQgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIGlmIHdlIHNob3VsZCBza2lwIHRoZSBtYXJrdXAgaW5zZXJ0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50XG4gICAqL1xuICBfcmVuZGVyTmV3Um9vdENvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gICAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJ19yZW5kZXJOZXdSb290Q29tcG9uZW50KCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gJyArICdyZW5kZXIgaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnX3JlZ2lzdGVyQ29tcG9uZW50KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzcnKSA6IHZvaWQgMDtcblxuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5lbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3JpbmcoKTtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCBmYWxzZSk7XG5cbiAgICAvLyBUaGUgaW5pdGlhbCByZW5kZXIgaXMgc3luY2hyb25vdXMgYnV0IGFueSB1cGRhdGVzIHRoYXQgaGFwcGVuIGR1cmluZ1xuICAgIC8vIHJlbmRlcmluZywgaW4gY29tcG9uZW50V2lsbE1vdW50IG9yIGNvbXBvbmVudERpZE1vdW50LCB3aWxsIGJlIGJhdGNoZWRcbiAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgYmF0Y2hpbmcgc3RyYXRlZ3kuXG5cbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUsIGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcblxuICAgIHZhciB3cmFwcGVySUQgPSBjb21wb25lbnRJbnN0YW5jZS5faW5zdGFuY2Uucm9vdElEO1xuICAgIGluc3RhbmNlc0J5UmVhY3RSb290SURbd3JhcHBlcklEXSA9IGNvbXBvbmVudEluc3RhbmNlO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudEluc3RhbmNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwYXJlbnRDb21wb25lbnQgVGhlIGNvbmNlcHR1YWwgcGFyZW50IG9mIHRoaXMgcmVuZGVyIHRyZWUuXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgICEocGFyZW50Q29tcG9uZW50ICE9IG51bGwgJiYgUmVhY3RJbnN0YW5jZU1hcC5oYXMocGFyZW50Q29tcG9uZW50KSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncGFyZW50Q29tcG9uZW50IG11c3QgYmUgYSB2YWxpZCBSZWFjdCBDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCczOCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBSZWFjdE1vdW50Ll9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS52YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCAnUmVhY3RET00ucmVuZGVyJyk7XG4gICAgIVJlYWN0LmlzVmFsaWRFbGVtZW50KG5leHRFbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTS5yZW5kZXIoKTogSW52YWxpZCBjb21wb25lbnQgZWxlbWVudC4lcycsIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ3N0cmluZycgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIHN0cmluZyBsaWtlIFxcJ2RpdlxcJywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoXFwnZGl2XFwnKSBvciA8ZGl2IC8+LicgOiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdmdW5jdGlvbicgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIGNsYXNzIGxpa2UgRm9vLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChGb28pIG9yIDxGb28gLz4uJyA6XG4gICAgLy8gQ2hlY2sgaWYgaXQgcXVhY2tzIGxpa2UgYW4gZWxlbWVudFxuICAgIG5leHRFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQucHJvcHMgIT09IHVuZGVmaW5lZCA/ICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICsgJ2NvcGllcyBvZiBSZWFjdC4nIDogJycpIDogX3Byb2RJbnZhcmlhbnQoJzM5JywgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnc3RyaW5nJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgc3RyaW5nIGxpa2UgXFwnZGl2XFwnLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChcXCdkaXZcXCcpIG9yIDxkaXYgLz4uJyA6IHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY2xhc3MgbGlrZSBGb28sIHBhc3MgJyArICdSZWFjdC5jcmVhdGVFbGVtZW50KEZvbykgb3IgPEZvbyAvPi4nIDogbmV4dEVsZW1lbnQgIT0gbnVsbCAmJiBuZXh0RWxlbWVudC5wcm9wcyAhPT0gdW5kZWZpbmVkID8gJyBUaGlzIG1heSBiZSBjYXVzZWQgYnkgdW5pbnRlbnRpb25hbGx5IGxvYWRpbmcgdHdvIGluZGVwZW5kZW50ICcgKyAnY29waWVzIG9mIFJlYWN0LicgOiAnJykgOiB2b2lkIDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVyIHx8ICFjb250YWluZXIudGFnTmFtZSB8fCBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnQk9EWScsICdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIG5leHRXcmFwcGVkRWxlbWVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG9wTGV2ZWxXcmFwcGVyLCB7IGNoaWxkOiBuZXh0RWxlbWVudCB9KTtcblxuICAgIHZhciBuZXh0Q29udGV4dDtcbiAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICB2YXIgcGFyZW50SW5zdCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gICAgICBuZXh0Q29udGV4dCA9IHBhcmVudEluc3QuX3Byb2Nlc3NDaGlsZENvbnRleHQocGFyZW50SW5zdC5fY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG4gICAgfVxuXG4gICAgdmFyIHByZXZDb21wb25lbnQgPSBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpO1xuXG4gICAgaWYgKHByZXZDb21wb25lbnQpIHtcbiAgICAgIHZhciBwcmV2V3JhcHBlZEVsZW1lbnQgPSBwcmV2Q29tcG9uZW50Ll9jdXJyZW50RWxlbWVudDtcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZXcmFwcGVkRWxlbWVudC5wcm9wcy5jaGlsZDtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIHZhciBwdWJsaWNJbnN0ID0gcHJldkNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAgICAgdmFyIHVwZGF0ZWRDYWxsYmFjayA9IGNhbGxiYWNrICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHB1YmxpY0luc3QpO1xuICAgICAgICB9O1xuICAgICAgICBSZWFjdE1vdW50Ll91cGRhdGVSb290Q29tcG9uZW50KHByZXZDb21wb25lbnQsIG5leHRXcmFwcGVkRWxlbWVudCwgbmV4dENvbnRleHQsIGNvbnRhaW5lciwgdXBkYXRlZENhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0luc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVhY3RSb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIHZhciBjb250YWluZXJIYXNSZWFjdE1hcmt1cCA9IHJlYWN0Um9vdEVsZW1lbnQgJiYgISFpbnRlcm5hbEdldElEKHJlYWN0Um9vdEVsZW1lbnQpO1xuICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkLCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKCFjb250YWluZXJIYXNSZWFjdE1hcmt1cCB8fCByZWFjdFJvb3RFbGVtZW50Lm5leHRTaWJsaW5nKSB7XG4gICAgICAgIHZhciByb290RWxlbWVudFNpYmxpbmcgPSByZWFjdFJvb3RFbGVtZW50O1xuICAgICAgICB3aGlsZSAocm9vdEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgaWYgKGludGVybmFsR2V0SUQocm9vdEVsZW1lbnRTaWJsaW5nKSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgKyAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgKyAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcm9vdEVsZW1lbnRTaWJsaW5nID0gcm9vdEVsZW1lbnRTaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZFJldXNlTWFya3VwID0gY29udGFpbmVySGFzUmVhY3RNYXJrdXAgJiYgIXByZXZDb21wb25lbnQgJiYgIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkO1xuICAgIHZhciBjb21wb25lbnQgPSBSZWFjdE1vdW50Ll9yZW5kZXJOZXdSb290Q29tcG9uZW50KG5leHRXcmFwcGVkRWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgbmV4dENvbnRleHQpLl9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2suY2FsbChjb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS5yZW5kZXJcbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYW5kIGRlc3Ryb3lzIHRoZSBSZWFjdCBjb21wb25lbnQgcmVuZGVyZWQgaW4gdGhlIGBjb250YWluZXJgLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3Rkb20udW5tb3VudGNvbXBvbmVudGF0bm9kZVxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCBjb250YWluaW5nIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgY29tcG9uZW50IHdhcyBmb3VuZCBpbiBhbmQgdW5tb3VudGVkIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgYGNvbnRhaW5lcmBcbiAgICovXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChTdHJpY3RseSBzcGVha2luZywgdW5tb3VudGluZyB3b24ndCBjYXVzZSBhXG4gICAgLy8gcmVuZGVyIGJ1dCB3ZSBzdGlsbCBkb24ndCBleHBlY3QgdG8gYmUgaW4gYSByZW5kZXIgY2FsbCBoZXJlLilcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyICcgKyAnaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzQwJykgOiB2b2lkIDA7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIW5vZGVJc1JlbmRlcmVkQnlPdGhlckluc3RhbmNlKGNvbnRhaW5lciksICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIHByZXZDb21wb25lbnQgPSBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIGlmICghcHJldkNvbXBvbmVudCkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIG5vZGUgYmVpbmcgdW5tb3VudGVkIHdhcyByZW5kZXJlZCBieSBSZWFjdCwgYnV0IGlzbid0IGFcbiAgICAgIC8vIHJvb3Qgbm9kZS5cbiAgICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIGNvbnRhaW5lci5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSX05BTUUpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBSZWFjdCBhbmQgaXMgbm90IGEgdG9wLWxldmVsIGNvbnRhaW5lci4gJXMnLCBpc0NvbnRhaW5lclJlYWN0Um9vdCA/ICdZb3UgbWF5IGhhdmUgYWNjaWRlbnRhbGx5IHBhc3NlZCBpbiBhIFJlYWN0IHJvb3Qgbm9kZSBpbnN0ZWFkICcgKyAnb2YgaXRzIGNvbnRhaW5lci4nIDogJ0luc3RlYWQsIGhhdmUgdGhlIHBhcmVudCBjb21wb25lbnQgdXBkYXRlIGl0cyBzdGF0ZSBhbmQgJyArICdyZXJlbmRlciBpbiBvcmRlciB0byByZW1vdmUgdGhpcyBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVsZXRlIGluc3RhbmNlc0J5UmVhY3RSb290SURbcHJldkNvbXBvbmVudC5faW5zdGFuY2Uucm9vdElEXTtcbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXModW5tb3VudENvbXBvbmVudEZyb21Ob2RlLCBwcmV2Q29tcG9uZW50LCBjb250YWluZXIsIGZhbHNlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBfbW91bnRJbWFnZUludG9Ob2RlOiBmdW5jdGlvbiAobWFya3VwLCBjb250YWluZXIsIGluc3RhbmNlLCBzaG91bGRSZXVzZU1hcmt1cCwgdHJhbnNhY3Rpb24pIHtcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21vdW50Q29tcG9uZW50SW50b05vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgdmFsaWQuJykgOiBfcHJvZEludmFyaWFudCgnNDEnKSA6IHZvaWQgMDtcblxuICAgIGlmIChzaG91bGRSZXVzZU1hcmt1cCkge1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICBpZiAoUmVhY3RNYXJrdXBDaGVja3N1bS5jYW5SZXVzZU1hcmt1cChtYXJrdXAsIHJvb3RFbGVtZW50KSkge1xuICAgICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKGluc3RhbmNlLCByb290RWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaGVja3N1bSA9IHJvb3RFbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG4gICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG5cbiAgICAgICAgdmFyIHJvb3RNYXJrdXAgPSByb290RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgIHJvb3RFbGVtZW50LnNldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSwgY2hlY2tzdW0pO1xuXG4gICAgICAgIHZhciBub3JtYWxpemVkTWFya3VwID0gbWFya3VwO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIC8vIGJlY2F1c2Ugcm9vdE1hcmt1cCBpcyByZXRyaWV2ZWQgZnJvbSB0aGUgRE9NLCB2YXJpb3VzIG5vcm1hbGl6YXRpb25zXG4gICAgICAgICAgLy8gd2lsbCBoYXZlIG9jY3VycmVkIHdoaWNoIHdpbGwgbm90IGJlIHByZXNlbnQgaW4gYG1hcmt1cGAuIEhlcmUsXG4gICAgICAgICAgLy8gaW5zZXJ0IG1hcmt1cCBpbnRvIGEgPGRpdj4gb3IgPGlmcmFtZT4gZGVwZW5kaW5nIG9uIHRoZSBjb250YWluZXJcbiAgICAgICAgICAvLyB0eXBlIHRvIHBlcmZvcm0gdGhlIHNhbWUgbm9ybWFsaXphdGlvbnMgYmVmb3JlIGNvbXBhcmluZy5cbiAgICAgICAgICB2YXIgbm9ybWFsaXplcjtcbiAgICAgICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSkge1xuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbm9ybWFsaXplci5pbm5lckhUTUwgPSBtYXJrdXA7XG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5pbm5lckhUTUw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9ybWFsaXplcik7XG4gICAgICAgICAgICBub3JtYWxpemVyLmNvbnRlbnREb2N1bWVudC53cml0ZShtYXJrdXApO1xuICAgICAgICAgICAgbm9ybWFsaXplZE1hcmt1cCA9IG5vcm1hbGl6ZXIuY29udGVudERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG5vcm1hbGl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWZmSW5kZXggPSBmaXJzdERpZmZlcmVuY2VJbmRleChub3JtYWxpemVkTWFya3VwLCByb290TWFya3VwKTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSAnIChjbGllbnQpICcgKyBub3JtYWxpemVkTWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApICsgJ1xcbiAoc2VydmVyKSAnICsgcm9vdE1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKTtcblxuICAgICAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBidXQgdGhlIGNoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IHJlbmRlcmVkIGEgZGlmZmVyZW50IGNvbXBvbmVudCB0eXBlIG9yIHByb3BzIG9uIHRoZSBjbGllbnQgZnJvbSB0aGUgb25lIG9uIHRoZSBzZXJ2ZXIsIG9yIHlvdXIgcmVuZGVyKCkgbWV0aG9kcyBhcmUgaW1wdXJlLiBSZWFjdCBjYW5ub3QgaGFuZGxlIHRoaXMgY2FzZSBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MgYnkgcmVuZGVyaW5nIGF0IHRoZSBkb2N1bWVudCByb290LiBZb3Ugc2hvdWxkIGxvb2sgZm9yIGVudmlyb25tZW50IGRlcGVuZGVudCBjb2RlIGluIHlvdXIgY29tcG9uZW50cyBhbmQgZW5zdXJlIHRoZSBwcm9wcyBhcmUgdGhlIHNhbWUgY2xpZW50IGFuZCBzZXJ2ZXIgc2lkZTpcXG4lcycsIGRpZmZlcmVuY2UpIDogX3Byb2RJbnZhcmlhbnQoJzQyJywgZGlmZmVyZW5jZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0IGF0dGVtcHRlZCB0byByZXVzZSBtYXJrdXAgaW4gYSBjb250YWluZXIgYnV0IHRoZSAnICsgJ2NoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IHlvdSBhcmUgJyArICd1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGFuZCB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgJyArICdzZXJ2ZXIgd2FzIG5vdCB3aGF0IHRoZSBjbGllbnQgd2FzIGV4cGVjdGluZy4gUmVhY3QgaW5qZWN0ZWQgJyArICduZXcgbWFya3VwIHRvIGNvbXBlbnNhdGUgd2hpY2ggd29ya3MgYnV0IHlvdSBoYXZlIGxvc3QgbWFueSAnICsgJ29mIHRoZSBiZW5lZml0cyBvZiBzZXJ2ZXIgcmVuZGVyaW5nLiBJbnN0ZWFkLCBmaWd1cmUgb3V0ICcgKyAnd2h5IHRoZSBtYXJrdXAgYmVpbmcgZ2VuZXJhdGVkIGlzIGRpZmZlcmVudCBvbiB0aGUgY2xpZW50ICcgKyAnb3Igc2VydmVyOlxcbiVzJywgZGlmZmVyZW5jZSkgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgYnV0IHlvdSBkaWRuXFwndCB1c2Ugc2VydmVyIHJlbmRlcmluZy4gV2UgY2FuXFwndCBkbyB0aGlzIHdpdGhvdXQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MuIFNlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogX3Byb2RJbnZhcmlhbnQoJzQzJykgOiB2b2lkIDA7XG5cbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZShjb250YWluZXIsIG1hcmt1cCwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldElubmVySFRNTChjb250YWluZXIsIG1hcmt1cCk7XG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKGluc3RhbmNlLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBob3N0Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgIGlmIChob3N0Tm9kZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgICBpbnN0YW5jZUlEOiBob3N0Tm9kZS5fZGVidWdJRCxcbiAgICAgICAgICB0eXBlOiAnbW91bnQnLFxuICAgICAgICAgIHBheWxvYWQ6IG1hcmt1cC50b1N0cmluZygpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdE1vdW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG5cbnZhciBET0NfTk9ERV9UWVBFID0gOTtcblxuZnVuY3Rpb24gUmVhY3RET01Db250YWluZXJJbmZvKHRvcExldmVsV3JhcHBlciwgbm9kZSkge1xuICB2YXIgaW5mbyA9IHtcbiAgICBfdG9wTGV2ZWxXcmFwcGVyOiB0b3BMZXZlbFdyYXBwZXIsXG4gICAgX2lkQ291bnRlcjogMSxcbiAgICBfb3duZXJEb2N1bWVudDogbm9kZSA/IG5vZGUubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgPyBub2RlIDogbm9kZS5vd25lckRvY3VtZW50IDogbnVsbCxcbiAgICBfbm9kZTogbm9kZSxcbiAgICBfdGFnOiBub2RlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogbnVsbCxcbiAgICBfbmFtZXNwYWNlVVJJOiBub2RlID8gbm9kZS5uYW1lc3BhY2VVUkkgOiBudWxsXG4gIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaW5mby5fYW5jZXN0b3JJbmZvID0gbm9kZSA/IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIGluZm8uX3RhZywgbnVsbCkgOiBudWxsO1xuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29udGFpbmVySW5mbztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01Db250YWluZXJJbmZvLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NRmVhdHVyZUZsYWdzID0ge1xuICB1c2VDcmVhdGVFbGVtZW50OiB0cnVlLFxuICB1c2VGaWJlcjogZmFsc2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GZWF0dXJlRmxhZ3M7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NRmVhdHVyZUZsYWdzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcblxudmFyIFRBR19FTkQgPSAvXFwvPz4vO1xudmFyIENPTU1FTlRfU1RBUlQgPSAvXjxcXCFcXC1cXC0vO1xuXG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHtcbiAgQ0hFQ0tTVU1fQVRUUl9OQU1FOiAnZGF0YS1yZWFjdC1jaGVja3N1bScsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcgd2l0aCBjaGVja3N1bSBhdHRyaWJ1dGUgYXR0YWNoZWRcbiAgICovXG4gIGFkZENoZWNrc3VtVG9NYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgY2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG5cbiAgICAvLyBBZGQgY2hlY2tzdW0gKGhhbmRsZSBib3RoIHBhcmVudCB0YWdzLCBjb21tZW50cyBhbmQgc2VsZi1jbG9zaW5nIHRhZ3MpXG4gICAgaWYgKENPTU1FTlRfU1RBUlQudGVzdChtYXJrdXApKSB7XG4gICAgICByZXR1cm4gbWFya3VwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWFya3VwLnJlcGxhY2UoVEFHX0VORCwgJyAnICsgUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUgKyAnPVwiJyArIGNoZWNrc3VtICsgJ1wiJCYnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgdG8gdXNlXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCByb290IFJlYWN0IGVsZW1lbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBtYXJrdXAgaXMgdGhlIHNhbWVcbiAgICovXG4gIGNhblJldXNlTWFya3VwOiBmdW5jdGlvbiAobWFya3VwLCBlbGVtZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nQ2hlY2tzdW0gPSBlbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG4gICAgZXhpc3RpbmdDaGVja3N1bSA9IGV4aXN0aW5nQ2hlY2tzdW0gJiYgcGFyc2VJbnQoZXhpc3RpbmdDaGVja3N1bSwgMTApO1xuICAgIHZhciBtYXJrdXBDaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcbiAgICByZXR1cm4gbWFya3VwQ2hlY2tzdW0gPT09IGV4aXN0aW5nQ2hlY2tzdW07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNYXJrdXBDaGVja3N1bTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIE1PRCA9IDY1NTIxO1xuXG4vLyBhZGxlcjMyIGlzIG5vdCBjcnlwdG9ncmFwaGljYWxseSBzdHJvbmcsIGFuZCBpcyBvbmx5IHVzZWQgdG8gc2FuaXR5IGNoZWNrIHRoYXRcbi8vIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlIHNlcnZlciBtYXRjaGVzIHRoZSBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBjbGllbnQuXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIChhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIFNoZWV0SlMgdmVyc2lvbikgaGFzIGJlZW4gb3B0aW1pemVkXG4vLyBmb3Igb3VyIHVzZSBjYXNlLCBhdCB0aGUgZXhwZW5zZSBvZiBjb25mb3JtaW5nIHRvIHRoZSBhZGxlcjMyIHNwZWNpZmljYXRpb25cbi8vIGZvciBub24tYXNjaWkgaW5wdXRzLlxuZnVuY3Rpb24gYWRsZXIzMihkYXRhKSB7XG4gIHZhciBhID0gMTtcbiAgdmFyIGIgPSAwO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0gZGF0YS5sZW5ndGg7XG4gIHZhciBtID0gbCAmIH4weDM7XG4gIHdoaWxlIChpIDwgbSkge1xuICAgIHZhciBuID0gTWF0aC5taW4oaSArIDQwOTYsIG0pO1xuICAgIGZvciAoOyBpIDwgbjsgaSArPSA0KSB7XG4gICAgICBiICs9IChhICs9IGRhdGEuY2hhckNvZGVBdChpKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDEpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMikpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAzKSk7XG4gICAgfVxuICAgIGEgJT0gTU9EO1xuICAgIGIgJT0gTU9EO1xuICB9XG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgYiArPSBhICs9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgfVxuICBhICU9IE1PRDtcbiAgYiAlPSBNT0Q7XG4gIHJldHVybiBhIHwgYiA8PCAxNjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9hZGxlcjMyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAnMTUuNC4wJztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RWZXJzaW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG5cbnZhciBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZSA9IHJlcXVpcmUoJy4vZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIERPTSBub2RlIHJlbmRlcmVkIGJ5IHRoaXMgZWxlbWVudC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3Rkb20uZmluZGRvbW5vZGVcbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fERPTUVsZW1lbnR9IGNvbXBvbmVudE9yRWxlbWVudFxuICogQHJldHVybiB7P0RPTUVsZW1lbnR9IFRoZSByb290IG5vZGUgb2YgdGhpcyBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBmaW5kRE9NTm9kZShjb21wb25lbnRPckVsZW1lbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcob3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgfVxuXG4gIHZhciBpbnN0ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgaWYgKGluc3QpIHtcbiAgICBpbnN0ID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCk7XG4gICAgcmV0dXJuIGluc3QgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSA6IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbXBvbmVudE9yRWxlbWVudC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZmluZERPTU5vZGUgd2FzIGNhbGxlZCBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzQ0JykgOiB2b2lkIDA7XG4gIH0gZWxzZSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgYXBwZWFycyB0byBiZSBuZWl0aGVyIFJlYWN0Q29tcG9uZW50IG5vciBET01Ob2RlIChrZXlzOiAlcyknLCBPYmplY3Qua2V5cyhjb21wb25lbnRPckVsZW1lbnQpKSA6IF9wcm9kSW52YXJpYW50KCc0NScsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpIDogdm9pZCAwO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZERPTU5vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2ZpbmRET01Ob2RlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Tm9kZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE5vZGVUeXBlcycpO1xuXG5mdW5jdGlvbiBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZShpbnN0KSB7XG4gIHZhciB0eXBlO1xuXG4gIHdoaWxlICgodHlwZSA9IGluc3QuX3JlbmRlcmVkTm9kZVR5cGUpID09PSBSZWFjdE5vZGVUeXBlcy5DT01QT1NJVEUpIHtcbiAgICBpbnN0ID0gaW5zdC5fcmVuZGVyZWRDb21wb25lbnQ7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUmVhY3ROb2RlVHlwZXMuSE9TVCkge1xuICAgIHJldHVybiBpbnN0Ll9yZW5kZXJlZENvbXBvbmVudDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBSZWFjdE5vZGVUeXBlcy5FTVBUWSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50LnJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcmVhY3RQcm9wcyA9IHtcbiAgICBjaGlsZHJlbjogdHJ1ZSxcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgICBrZXk6IHRydWUsXG4gICAgcmVmOiB0cnVlLFxuXG4gICAgYXV0b0ZvY3VzOiB0cnVlLFxuICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZSxcbiAgICB2YWx1ZUxpbms6IHRydWUsXG4gICAgZGVmYXVsdENoZWNrZWQ6IHRydWUsXG4gICAgY2hlY2tlZExpbms6IHRydWUsXG4gICAgaW5uZXJIVE1MOiB0cnVlLFxuICAgIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogdHJ1ZSxcbiAgICBvbkZvY3VzSW46IHRydWUsXG4gICAgb25Gb2N1c091dDogdHJ1ZVxuICB9O1xuICB2YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xuXG4gIHZhciB2YWxpZGF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIGRlYnVnSUQpIHtcbiAgICBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyZWFjdFByb3BzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHJlYWN0UHJvcHNbbmFtZV0gfHwgd2FybmVkUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBkYXRhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgIGlmIChzdGFuZGFyZE5hbWUgIT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIERPTSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCByZWdpc3RyYXRpb25OYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSB3ZXJlIHVuYWJsZSB0byBndWVzcyB3aGljaCBwcm9wIHRoZSB1c2VyIGludGVuZGVkLlxuICAgICAgLy8gSXQgaXMgbGlrZWx5IHRoYXQgdGhlIHVzZXIgd2FzIGp1c3QgYmxpbmRseSBzcHJlYWRpbmcvZm9yd2FyZGluZyBwcm9wc1xuICAgICAgLy8gQ29tcG9uZW50cyBzaG91bGQgYmUgY2FyZWZ1bCB0byBvbmx5IHJlbmRlciB2YWxpZCBwcm9wcy9hdHRyaWJ1dGVzLlxuICAgICAgLy8gV2FybmluZyB3aWxsIGJlIGludm9rZWQgaW4gd2FyblVua25vd25Qcm9wZXJ0aWVzIHRvIGFsbG93IGdyb3VwaW5nLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIHZhciB1bmtub3duUHJvcHMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIGVsZW1lbnQucHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkoZWxlbWVudC50eXBlLCBrZXksIGRlYnVnSUQpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG5cbiAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gcHJvcCAlcyBvbiA8JXM+IHRhZy4gUmVtb3ZlIHRoaXMgcHJvcCBmcm9tIHRoZSBlbGVtZW50LiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC11bmtub3duLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIHByb3BzICVzIG9uIDwlcz4gdGFnLiBSZW1vdmUgdGhlc2UgcHJvcHMgZnJvbSB0aGUgZWxlbWVudC4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtdW5rbm93bi1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgfVxufTtcblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwgfHwgdHlwZW9mIGVsZW1lbnQudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQudHlwZS5pbmRleE9mKCctJykgPj0gMCB8fCBlbGVtZW50LnByb3BzLmlzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyhkZWJ1Z0lELCBlbGVtZW50KTtcbn1cblxudmFyIFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayA9IHtcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vaztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQudHlwZSAhPT0gJ2lucHV0JyAmJiBlbGVtZW50LnR5cGUgIT09ICd0ZXh0YXJlYScgJiYgZWxlbWVudC50eXBlICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC5wcm9wcyAhPSBudWxsICYmIGVsZW1lbnQucHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyB0aGUgZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJXMnLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuXG4gICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayA9IHtcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vaztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUsIGRlYnVnSUQpIHtcbiAgaWYgKHdhcm5lZFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHJBUklBLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHN0YW5kYXJkTmFtZSA9IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG4gICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIEFSSUEgYXR0cmlidXRlICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBzdGFuZGFyZE5hbWUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2FybkludmFsaWRBUklBUHJvcHMoZGVidWdJRCwgZWxlbWVudCkge1xuICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIGVsZW1lbnQucHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkoZWxlbWVudC50eXBlLCBrZXksIGRlYnVnSUQpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG5cbiAgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gIH0gZWxzZSBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsIHx8IHR5cGVvZiBlbGVtZW50LnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50LnR5cGUuaW5kZXhPZignLScpID49IDAgfHwgZWxlbWVudC5wcm9wcy5pcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdhcm5JbnZhbGlkQVJJQVByb3BzKGRlYnVnSUQsIGVsZW1lbnQpO1xufVxuXG52YXIgUmVhY3RET01JbnZhbGlkQVJJQUhvb2sgPSB7XG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gICAgfVxuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JbnZhbGlkQVJJQUhvb2s7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NSW52YWxpZEFSSUFIb29rLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jcmVhdGVNZW1vcnlIaXN0b3J5ID0gZXhwb3J0cy5oYXNoSGlzdG9yeSA9IGV4cG9ydHMuYnJvd3Nlckhpc3RvcnkgPSBleHBvcnRzLmFwcGx5Um91dGVyTWlkZGxld2FyZSA9IGV4cG9ydHMuZm9ybWF0UGF0dGVybiA9IGV4cG9ydHMudXNlUm91dGVySGlzdG9yeSA9IGV4cG9ydHMubWF0Y2ggPSBleHBvcnRzLnJvdXRlclNoYXBlID0gZXhwb3J0cy5sb2NhdGlvblNoYXBlID0gZXhwb3J0cy5Sb3V0ZXJDb250ZXh0ID0gZXhwb3J0cy5jcmVhdGVSb3V0ZXMgPSBleHBvcnRzLlJvdXRlID0gZXhwb3J0cy5SZWRpcmVjdCA9IGV4cG9ydHMuSW5kZXhSb3V0ZSA9IGV4cG9ydHMuSW5kZXhSZWRpcmVjdCA9IGV4cG9ydHMud2l0aFJvdXRlciA9IGV4cG9ydHMuSW5kZXhMaW5rID0gZXhwb3J0cy5MaW5rID0gZXhwb3J0cy5Sb3V0ZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2NyZWF0ZVJvdXRlcycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcztcbiAgfVxufSk7XG5cbnZhciBfUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9Qcm9wVHlwZXMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdsb2NhdGlvblNoYXBlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1Byb3BUeXBlcy5sb2NhdGlvblNoYXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncm91dGVyU2hhcGUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUHJvcFR5cGVzLnJvdXRlclNoYXBlO1xuICB9XG59KTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2Zvcm1hdFBhdHRlcm4nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUGF0dGVyblV0aWxzLmZvcm1hdFBhdHRlcm47XG4gIH1cbn0pO1xuXG52YXIgX1JvdXRlcjIgPSByZXF1aXJlKCcuL1JvdXRlcicpO1xuXG52YXIgX1JvdXRlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXIyKTtcblxudmFyIF9MaW5rMiA9IHJlcXVpcmUoJy4vTGluaycpO1xuXG52YXIgX0xpbmszID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGluazIpO1xuXG52YXIgX0luZGV4TGluazIgPSByZXF1aXJlKCcuL0luZGV4TGluaycpO1xuXG52YXIgX0luZGV4TGluazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbmRleExpbmsyKTtcblxudmFyIF93aXRoUm91dGVyMiA9IHJlcXVpcmUoJy4vd2l0aFJvdXRlcicpO1xuXG52YXIgX3dpdGhSb3V0ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2l0aFJvdXRlcjIpO1xuXG52YXIgX0luZGV4UmVkaXJlY3QyID0gcmVxdWlyZSgnLi9JbmRleFJlZGlyZWN0Jyk7XG5cbnZhciBfSW5kZXhSZWRpcmVjdDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbmRleFJlZGlyZWN0Mik7XG5cbnZhciBfSW5kZXhSb3V0ZTIgPSByZXF1aXJlKCcuL0luZGV4Um91dGUnKTtcblxudmFyIF9JbmRleFJvdXRlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0luZGV4Um91dGUyKTtcblxudmFyIF9SZWRpcmVjdDIgPSByZXF1aXJlKCcuL1JlZGlyZWN0Jyk7XG5cbnZhciBfUmVkaXJlY3QzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVkaXJlY3QyKTtcblxudmFyIF9Sb3V0ZTIgPSByZXF1aXJlKCcuL1JvdXRlJyk7XG5cbnZhciBfUm91dGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGUyKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MiA9IHJlcXVpcmUoJy4vUm91dGVyQ29udGV4dCcpO1xuXG52YXIgX1JvdXRlckNvbnRleHQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyQ29udGV4dDIpO1xuXG52YXIgX21hdGNoMiA9IHJlcXVpcmUoJy4vbWF0Y2gnKTtcblxudmFyIF9tYXRjaDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRjaDIpO1xuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkyID0gcmVxdWlyZSgnLi91c2VSb3V0ZXJIaXN0b3J5Jyk7XG5cbnZhciBfdXNlUm91dGVySGlzdG9yeTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VSb3V0ZXJIaXN0b3J5Mik7XG5cbnZhciBfYXBwbHlSb3V0ZXJNaWRkbGV3YXJlMiA9IHJlcXVpcmUoJy4vYXBwbHlSb3V0ZXJNaWRkbGV3YXJlJyk7XG5cbnZhciBfYXBwbHlSb3V0ZXJNaWRkbGV3YXJlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FwcGx5Um91dGVyTWlkZGxld2FyZTIpO1xuXG52YXIgX2Jyb3dzZXJIaXN0b3J5MiA9IHJlcXVpcmUoJy4vYnJvd3Nlckhpc3RvcnknKTtcblxudmFyIF9icm93c2VySGlzdG9yeTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9icm93c2VySGlzdG9yeTIpO1xuXG52YXIgX2hhc2hIaXN0b3J5MiA9IHJlcXVpcmUoJy4vaGFzaEhpc3RvcnknKTtcblxudmFyIF9oYXNoSGlzdG9yeTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYXNoSGlzdG9yeTIpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyID0gcmVxdWlyZSgnLi9jcmVhdGVNZW1vcnlIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVNZW1vcnlIaXN0b3J5Mik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuUm91dGVyID0gX1JvdXRlcjMuZGVmYXVsdDsgLyogY29tcG9uZW50cyAqL1xuXG5leHBvcnRzLkxpbmsgPSBfTGluazMuZGVmYXVsdDtcbmV4cG9ydHMuSW5kZXhMaW5rID0gX0luZGV4TGluazMuZGVmYXVsdDtcbmV4cG9ydHMud2l0aFJvdXRlciA9IF93aXRoUm91dGVyMy5kZWZhdWx0O1xuXG4vKiBjb21wb25lbnRzIChjb25maWd1cmF0aW9uKSAqL1xuXG5leHBvcnRzLkluZGV4UmVkaXJlY3QgPSBfSW5kZXhSZWRpcmVjdDMuZGVmYXVsdDtcbmV4cG9ydHMuSW5kZXhSb3V0ZSA9IF9JbmRleFJvdXRlMy5kZWZhdWx0O1xuZXhwb3J0cy5SZWRpcmVjdCA9IF9SZWRpcmVjdDMuZGVmYXVsdDtcbmV4cG9ydHMuUm91dGUgPSBfUm91dGUzLmRlZmF1bHQ7XG5cbi8qIHV0aWxzICovXG5cbmV4cG9ydHMuUm91dGVyQ29udGV4dCA9IF9Sb3V0ZXJDb250ZXh0My5kZWZhdWx0O1xuZXhwb3J0cy5tYXRjaCA9IF9tYXRjaDMuZGVmYXVsdDtcbmV4cG9ydHMudXNlUm91dGVySGlzdG9yeSA9IF91c2VSb3V0ZXJIaXN0b3J5My5kZWZhdWx0O1xuZXhwb3J0cy5hcHBseVJvdXRlck1pZGRsZXdhcmUgPSBfYXBwbHlSb3V0ZXJNaWRkbGV3YXJlMy5kZWZhdWx0O1xuXG4vKiBoaXN0b3JpZXMgKi9cblxuZXhwb3J0cy5icm93c2VySGlzdG9yeSA9IF9icm93c2VySGlzdG9yeTMuZGVmYXVsdDtcbmV4cG9ydHMuaGFzaEhpc3RvcnkgPSBfaGFzaEhpc3RvcnkzLmRlZmF1bHQ7XG5leHBvcnRzLmNyZWF0ZU1lbW9yeUhpc3RvcnkgPSBfY3JlYXRlTWVtb3J5SGlzdG9yeTMuZGVmYXVsdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuaXNSZWFjdENoaWxkcmVuID0gaXNSZWFjdENoaWxkcmVuO1xuZXhwb3J0cy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQgPSBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQ7XG5leHBvcnRzLmNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW47XG5leHBvcnRzLmNyZWF0ZVJvdXRlcyA9IGNyZWF0ZVJvdXRlcztcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc1ZhbGlkQ2hpbGQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBfcmVhY3QyLmRlZmF1bHQuaXNWYWxpZEVsZW1lbnQob2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gaXNSZWFjdENoaWxkcmVuKG9iamVjdCkge1xuICByZXR1cm4gaXNWYWxpZENoaWxkKG9iamVjdCkgfHwgQXJyYXkuaXNBcnJheShvYmplY3QpICYmIG9iamVjdC5ldmVyeShpc1ZhbGlkQ2hpbGQpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZShkZWZhdWx0UHJvcHMsIHByb3BzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgZGVmYXVsdFByb3BzLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50KSB7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIgcm91dGUgPSBjcmVhdGVSb3V0ZSh0eXBlLmRlZmF1bHRQcm9wcywgZWxlbWVudC5wcm9wcyk7XG5cbiAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgdmFyIGNoaWxkUm91dGVzID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4ocm91dGUuY2hpbGRyZW4sIHJvdXRlKTtcblxuICAgIGlmIChjaGlsZFJvdXRlcy5sZW5ndGgpIHJvdXRlLmNoaWxkUm91dGVzID0gY2hpbGRSb3V0ZXM7XG5cbiAgICBkZWxldGUgcm91dGUuY2hpbGRyZW47XG4gIH1cblxuICByZXR1cm4gcm91dGU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHJvdXRlcyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gUmVhY3RDaGlsZHJlbi4gSlNYXG4gKiBwcm92aWRlcyBhIGNvbnZlbmllbnQgd2F5IHRvIHZpc3VhbGl6ZSBob3cgcm91dGVzIGluIHRoZSBoaWVyYXJjaHkgYXJlXG4gKiBuZXN0ZWQuXG4gKlxuICogICBpbXBvcnQgeyBSb3V0ZSwgY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4gfSBmcm9tICdyZWFjdC1yb3V0ZXInXG4gKlxuICogICBjb25zdCByb3V0ZXMgPSBjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbihcbiAqICAgICA8Um91dGUgY29tcG9uZW50PXtBcHB9PlxuICogICAgICAgPFJvdXRlIHBhdGg9XCJob21lXCIgY29tcG9uZW50PXtEYXNoYm9hcmR9Lz5cbiAqICAgICAgIDxSb3V0ZSBwYXRoPVwibmV3c1wiIGNvbXBvbmVudD17TmV3c0ZlZWR9Lz5cbiAqICAgICA8L1JvdXRlPlxuICogICApXG4gKlxuICogTm90ZTogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSB1c2VkIHdoZW4geW91IHByb3ZpZGUgPFJvdXRlPiBjaGlsZHJlblxuICogdG8gYSA8Um91dGVyPiBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRSb3V0ZSkge1xuICB2YXIgcm91dGVzID0gW107XG5cbiAgX3JlYWN0Mi5kZWZhdWx0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKF9yZWFjdDIuZGVmYXVsdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgLy8gQ29tcG9uZW50IGNsYXNzZXMgbWF5IGhhdmUgYSBzdGF0aWMgY3JlYXRlKiBtZXRob2QuXG4gICAgICBpZiAoZWxlbWVudC50eXBlLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudCkge1xuICAgICAgICB2YXIgcm91dGUgPSBlbGVtZW50LnR5cGUuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQsIHBhcmVudFJvdXRlKTtcblxuICAgICAgICBpZiAocm91dGUpIHJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlcy5wdXNoKGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcm91dGVzO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gYXJyYXkgb2Ygcm91dGVzIGZyb20gdGhlIGdpdmVuIG9iamVjdCB3aGljaFxuICogbWF5IGJlIGEgSlNYIHJvdXRlLCBhIHBsYWluIG9iamVjdCByb3V0ZSwgb3IgYW4gYXJyYXkgb2YgZWl0aGVyLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXMocm91dGVzKSB7XG4gIGlmIChpc1JlYWN0Q2hpbGRyZW4ocm91dGVzKSkge1xuICAgIHJvdXRlcyA9IGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKHJvdXRlcyk7XG4gIH0gZWxzZSBpZiAocm91dGVzICYmICFBcnJheS5pc0FycmF5KHJvdXRlcykpIHtcbiAgICByb3V0ZXMgPSBbcm91dGVzXTtcbiAgfVxuXG4gIHJldHVybiByb3V0ZXM7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlVXRpbHMuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmxvY2F0aW9uU2hhcGUgPSBleHBvcnRzLnJvdXRlclNoYXBlID0gdW5kZWZpbmVkO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIGZ1bmMgPSBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb2JqZWN0ID0gX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgc2hhcGUgPSBfcmVhY3QuUHJvcFR5cGVzLnNoYXBlLFxuICAgIHN0cmluZyA9IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nO1xudmFyIHJvdXRlclNoYXBlID0gZXhwb3J0cy5yb3V0ZXJTaGFwZSA9IHNoYXBlKHtcbiAgcHVzaDogZnVuYy5pc1JlcXVpcmVkLFxuICByZXBsYWNlOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGdvOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGdvQmFjazogZnVuYy5pc1JlcXVpcmVkLFxuICBnb0ZvcndhcmQ6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgc2V0Um91dGVMZWF2ZUhvb2s6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgaXNBY3RpdmU6IGZ1bmMuaXNSZXF1aXJlZFxufSk7XG5cbnZhciBsb2NhdGlvblNoYXBlID0gZXhwb3J0cy5sb2NhdGlvblNoYXBlID0gc2hhcGUoe1xuICBwYXRobmFtZTogc3RyaW5nLmlzUmVxdWlyZWQsXG4gIHNlYXJjaDogc3RyaW5nLmlzUmVxdWlyZWQsXG4gIHN0YXRlOiBvYmplY3QsXG4gIGFjdGlvbjogc3RyaW5nLmlzUmVxdWlyZWQsXG4gIGtleTogc3RyaW5nXG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvUHJvcFR5cGVzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jb21waWxlUGF0dGVybiA9IGNvbXBpbGVQYXR0ZXJuO1xuZXhwb3J0cy5tYXRjaFBhdHRlcm4gPSBtYXRjaFBhdHRlcm47XG5leHBvcnRzLmdldFBhcmFtTmFtZXMgPSBnZXRQYXJhbU5hbWVzO1xuZXhwb3J0cy5nZXRQYXJhbXMgPSBnZXRQYXJhbXM7XG5leHBvcnRzLmZvcm1hdFBhdHRlcm4gPSBmb3JtYXRQYXR0ZXJuO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbn1cblxuZnVuY3Rpb24gX2NvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgdmFyIHJlZ2V4cFNvdXJjZSA9ICcnO1xuICB2YXIgcGFyYW1OYW1lcyA9IFtdO1xuICB2YXIgdG9rZW5zID0gW107XG5cbiAgdmFyIG1hdGNoID0gdm9pZCAwLFxuICAgICAgbGFzdEluZGV4ID0gMCxcbiAgICAgIG1hdGNoZXIgPSAvOihbYS16QS1aXyRdW2EtekEtWjAtOV8kXSopfFxcKlxcKnxcXCp8XFwofFxcKS9nO1xuICB3aGlsZSAobWF0Y2ggPSBtYXRjaGVyLmV4ZWMocGF0dGVybikpIHtcbiAgICBpZiAobWF0Y2guaW5kZXggIT09IGxhc3RJbmRleCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0dGVybi5zbGljZShsYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICByZWdleHBTb3VyY2UgKz0gZXNjYXBlUmVnRXhwKHBhdHRlcm4uc2xpY2UobGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgIH1cblxuICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgcmVnZXhwU291cmNlICs9ICcoW14vXSspJztcbiAgICAgIHBhcmFtTmFtZXMucHVzaChtYXRjaFsxXSk7XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJyoqJykge1xuICAgICAgcmVnZXhwU291cmNlICs9ICcoLiopJztcbiAgICAgIHBhcmFtTmFtZXMucHVzaCgnc3BsYXQnKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzBdID09PSAnKicpIHtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSAnKC4qPyknO1xuICAgICAgcGFyYW1OYW1lcy5wdXNoKCdzcGxhdCcpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0gPT09ICcoJykge1xuICAgICAgcmVnZXhwU291cmNlICs9ICcoPzonO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0gPT09ICcpJykge1xuICAgICAgcmVnZXhwU291cmNlICs9ICcpPyc7XG4gICAgfVxuXG4gICAgdG9rZW5zLnB1c2gobWF0Y2hbMF0pO1xuXG4gICAgbGFzdEluZGV4ID0gbWF0Y2hlci5sYXN0SW5kZXg7XG4gIH1cblxuICBpZiAobGFzdEluZGV4ICE9PSBwYXR0ZXJuLmxlbmd0aCkge1xuICAgIHRva2Vucy5wdXNoKHBhdHRlcm4uc2xpY2UobGFzdEluZGV4LCBwYXR0ZXJuLmxlbmd0aCkpO1xuICAgIHJlZ2V4cFNvdXJjZSArPSBlc2NhcGVSZWdFeHAocGF0dGVybi5zbGljZShsYXN0SW5kZXgsIHBhdHRlcm4ubGVuZ3RoKSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdHRlcm46IHBhdHRlcm4sXG4gICAgcmVnZXhwU291cmNlOiByZWdleHBTb3VyY2UsXG4gICAgcGFyYW1OYW1lczogcGFyYW1OYW1lcyxcbiAgICB0b2tlbnM6IHRva2Vuc1xuICB9O1xufVxuXG52YXIgQ29tcGlsZWRQYXR0ZXJuc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gY29tcGlsZVBhdHRlcm4ocGF0dGVybikge1xuICBpZiAoIUNvbXBpbGVkUGF0dGVybnNDYWNoZVtwYXR0ZXJuXSkgQ29tcGlsZWRQYXR0ZXJuc0NhY2hlW3BhdHRlcm5dID0gX2NvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pO1xuXG4gIHJldHVybiBDb21waWxlZFBhdHRlcm5zQ2FjaGVbcGF0dGVybl07XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gbWF0Y2ggYSBwYXR0ZXJuIG9uIHRoZSBnaXZlbiBwYXRobmFtZS4gUGF0dGVybnMgbWF5IHVzZVxuICogdGhlIGZvbGxvd2luZyBzcGVjaWFsIGNoYXJhY3RlcnM6XG4gKlxuICogLSA6cGFyYW1OYW1lICAgICBNYXRjaGVzIGEgVVJMIHNlZ21lbnQgdXAgdG8gdGhlIG5leHQgLywgPywgb3IgIy4gVGhlXG4gKiAgICAgICAgICAgICAgICAgIGNhcHR1cmVkIHN0cmluZyBpcyBjb25zaWRlcmVkIGEgXCJwYXJhbVwiXG4gKiAtICgpICAgICAgICAgICAgIFdyYXBzIGEgc2VnbWVudCBvZiB0aGUgVVJMIHRoYXQgaXMgb3B0aW9uYWxcbiAqIC0gKiAgICAgICAgICAgICAgQ29uc3VtZXMgKG5vbi1ncmVlZHkpIGFsbCBjaGFyYWN0ZXJzIHVwIHRvIHRoZSBuZXh0XG4gKiAgICAgICAgICAgICAgICAgIGNoYXJhY3RlciBpbiB0aGUgcGF0dGVybiwgb3IgdG8gdGhlIGVuZCBvZiB0aGUgVVJMIGlmXG4gKiAgICAgICAgICAgICAgICAgIHRoZXJlIGlzIG5vbmVcbiAqIC0gKiogICAgICAgICAgICAgQ29uc3VtZXMgKGdyZWVkeSkgYWxsIGNoYXJhY3RlcnMgdXAgdG8gdGhlIG5leHQgY2hhcmFjdGVyXG4gKiAgICAgICAgICAgICAgICAgIGluIHRoZSBwYXR0ZXJuLCBvciB0byB0aGUgZW5kIG9mIHRoZSBVUkwgaWYgdGhlcmUgaXMgbm9uZVxuICpcbiAqICBUaGUgZnVuY3Rpb24gY2FsbHMgY2FsbGJhY2soZXJyb3IsIG1hdGNoZWQpIHdoZW4gZmluaXNoZWQuXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAtIHJlbWFpbmluZ1BhdGhuYW1lXG4gKiAtIHBhcmFtTmFtZXNcbiAqIC0gcGFyYW1WYWx1ZXNcbiAqL1xuZnVuY3Rpb24gbWF0Y2hQYXR0ZXJuKHBhdHRlcm4sIHBhdGhuYW1lKSB7XG4gIC8vIEVuc3VyZSBwYXR0ZXJuIHN0YXJ0cyB3aXRoIGxlYWRpbmcgc2xhc2ggZm9yIGNvbnNpc3RlbmN5IHdpdGggcGF0aG5hbWUuXG4gIGlmIChwYXR0ZXJuLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgcGF0dGVybiA9ICcvJyArIHBhdHRlcm47XG4gIH1cblxuICB2YXIgX2NvbXBpbGVQYXR0ZXJuMiA9IGNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pLFxuICAgICAgcmVnZXhwU291cmNlID0gX2NvbXBpbGVQYXR0ZXJuMi5yZWdleHBTb3VyY2UsXG4gICAgICBwYXJhbU5hbWVzID0gX2NvbXBpbGVQYXR0ZXJuMi5wYXJhbU5hbWVzLFxuICAgICAgdG9rZW5zID0gX2NvbXBpbGVQYXR0ZXJuMi50b2tlbnM7XG5cbiAgaWYgKHBhdHRlcm4uY2hhckF0KHBhdHRlcm4ubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgIHJlZ2V4cFNvdXJjZSArPSAnLz8nOyAvLyBBbGxvdyBvcHRpb25hbCBwYXRoIHNlcGFyYXRvciBhdCBlbmQuXG4gIH1cblxuICAvLyBTcGVjaWFsLWNhc2UgcGF0dGVybnMgbGlrZSAnKicgZm9yIGNhdGNoLWFsbCByb3V0ZXMuXG4gIGlmICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZWdleHBTb3VyY2UgKz0gJyQnO1xuICB9XG5cbiAgdmFyIG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobmV3IFJlZ0V4cCgnXicgKyByZWdleHBTb3VyY2UsICdpJykpO1xuICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1hdGNoZWRQYXRoID0gbWF0Y2hbMF07XG4gIHZhciByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cihtYXRjaGVkUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChyZW1haW5pbmdQYXRobmFtZSkge1xuICAgIC8vIFJlcXVpcmUgdGhhdCB0aGUgbWF0Y2ggZW5kcyBhdCBhIHBhdGggc2VwYXJhdG9yLCBpZiB3ZSBkaWRuJ3QgbWF0Y2hcbiAgICAvLyB0aGUgZnVsbCBwYXRoLCBzbyBhbnkgcmVtYWluaW5nIHBhdGhuYW1lIGlzIGEgbmV3IHBhdGggc2VnbWVudC5cbiAgICBpZiAobWF0Y2hlZFBhdGguY2hhckF0KG1hdGNoZWRQYXRoLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmVtYWluaW5nIHBhdGhuYW1lLCB0cmVhdCB0aGUgcGF0aCBzZXBhcmF0b3IgYXMgcGFydCBvZlxuICAgIC8vIHRoZSByZW1haW5pbmcgcGF0aG5hbWUgZm9yIHByb3Blcmx5IGNvbnRpbnVpbmcgdGhlIG1hdGNoLlxuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gJy8nICsgcmVtYWluaW5nUGF0aG5hbWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlbWFpbmluZ1BhdGhuYW1lOiByZW1haW5pbmdQYXRobmFtZSxcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzLFxuICAgIHBhcmFtVmFsdWVzOiBtYXRjaC5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2ICYmIGRlY29kZVVSSUNvbXBvbmVudCh2KTtcbiAgICB9KVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJhbU5hbWVzKHBhdHRlcm4pIHtcbiAgcmV0dXJuIGNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pLnBhcmFtTmFtZXM7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmFtcyhwYXR0ZXJuLCBwYXRobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcGF0aG5hbWUpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcGFyYW1OYW1lcyA9IG1hdGNoLnBhcmFtTmFtZXMsXG4gICAgICBwYXJhbVZhbHVlcyA9IG1hdGNoLnBhcmFtVmFsdWVzO1xuXG4gIHZhciBwYXJhbXMgPSB7fTtcblxuICBwYXJhbU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICBwYXJhbXNbcGFyYW1OYW1lXSA9IHBhcmFtVmFsdWVzW2luZGV4XTtcbiAgfSk7XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gcGF0dGVybiB3aXRoIHBhcmFtcyBpbnRlcnBvbGF0ZWQuIFRocm93c1xuICogaWYgdGhlcmUgaXMgYSBkeW5hbWljIHNlZ21lbnQgb2YgdGhlIHBhdHRlcm4gZm9yIHdoaWNoIHRoZXJlIGlzIG5vIHBhcmFtLlxuICovXG5mdW5jdGlvbiBmb3JtYXRQYXR0ZXJuKHBhdHRlcm4sIHBhcmFtcykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgdmFyIF9jb21waWxlUGF0dGVybjMgPSBjb21waWxlUGF0dGVybihwYXR0ZXJuKSxcbiAgICAgIHRva2VucyA9IF9jb21waWxlUGF0dGVybjMudG9rZW5zO1xuXG4gIHZhciBwYXJlbkNvdW50ID0gMCxcbiAgICAgIHBhdGhuYW1lID0gJycsXG4gICAgICBzcGxhdEluZGV4ID0gMCxcbiAgICAgIHBhcmVuSGlzdG9yeSA9IFtdO1xuXG4gIHZhciB0b2tlbiA9IHZvaWQgMCxcbiAgICAgIHBhcmFtTmFtZSA9IHZvaWQgMCxcbiAgICAgIHBhcmFtVmFsdWUgPSB2b2lkIDA7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbiA9PT0gJyonIHx8IHRva2VuID09PSAnKionKSB7XG4gICAgICBwYXJhbVZhbHVlID0gQXJyYXkuaXNBcnJheShwYXJhbXMuc3BsYXQpID8gcGFyYW1zLnNwbGF0W3NwbGF0SW5kZXgrK10gOiBwYXJhbXMuc3BsYXQ7XG5cbiAgICAgICEocGFyYW1WYWx1ZSAhPSBudWxsIHx8IHBhcmVuQ291bnQgPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdNaXNzaW5nIHNwbGF0ICMlcyBmb3IgcGF0aCBcIiVzXCInLCBzcGxhdEluZGV4LCBwYXR0ZXJuKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChwYXJhbVZhbHVlICE9IG51bGwpIHBhdGhuYW1lICs9IGVuY29kZVVSSShwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnKCcpIHtcbiAgICAgIHBhcmVuSGlzdG9yeVtwYXJlbkNvdW50XSA9ICcnO1xuICAgICAgcGFyZW5Db3VudCArPSAxO1xuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICcpJykge1xuICAgICAgdmFyIHBhcmVuVGV4dCA9IHBhcmVuSGlzdG9yeS5wb3AoKTtcbiAgICAgIHBhcmVuQ291bnQgLT0gMTtcblxuICAgICAgaWYgKHBhcmVuQ291bnQpIHBhcmVuSGlzdG9yeVtwYXJlbkNvdW50IC0gMV0gKz0gcGFyZW5UZXh0O2Vsc2UgcGF0aG5hbWUgKz0gcGFyZW5UZXh0O1xuICAgIH0gZWxzZSBpZiAodG9rZW4uY2hhckF0KDApID09PSAnOicpIHtcbiAgICAgIHBhcmFtTmFtZSA9IHRva2VuLnN1YnN0cmluZygxKTtcbiAgICAgIHBhcmFtVmFsdWUgPSBwYXJhbXNbcGFyYW1OYW1lXTtcblxuICAgICAgIShwYXJhbVZhbHVlICE9IG51bGwgfHwgcGFyZW5Db3VudCA+IDApID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ01pc3NpbmcgXCIlc1wiIHBhcmFtZXRlciBmb3IgcGF0aCBcIiVzXCInLCBwYXJhbU5hbWUsIHBhdHRlcm4pIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKHBhcmFtVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAocGFyZW5Db3VudCkge1xuICAgICAgICAgIHBhcmVuSGlzdG9yeVtwYXJlbkNvdW50IC0gMV0gPSAnJztcblxuICAgICAgICAgIHZhciBjdXJUb2tlbklkeCA9IHRva2Vucy5pbmRleE9mKHRva2VuKTtcbiAgICAgICAgICB2YXIgdG9rZW5zU3Vic2V0ID0gdG9rZW5zLnNsaWNlKGN1clRva2VuSWR4LCB0b2tlbnMubGVuZ3RoKTtcbiAgICAgICAgICB2YXIgbmV4dFBhcmVuSWR4ID0gLTE7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdG9rZW5zU3Vic2V0Lmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgaWYgKHRva2Vuc1N1YnNldFtfaV0gPT0gJyknKSB7XG4gICAgICAgICAgICAgIG5leHRQYXJlbklkeCA9IF9pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAhKG5leHRQYXJlbklkeCA+IDApID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1BhdGggXCIlc1wiIGlzIG1pc3NpbmcgZW5kIHBhcmVuIGF0IHNlZ21lbnQgXCIlc1wiJywgcGF0dGVybiwgdG9rZW5zU3Vic2V0LmpvaW4oJycpKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgICAvLyBqdW1wIHRvIGVuZGluZyBwYXJlblxuICAgICAgICAgIGkgPSBjdXJUb2tlbklkeCArIG5leHRQYXJlbklkeCAtIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyZW5Db3VudCkgcGFyZW5IaXN0b3J5W3BhcmVuQ291bnQgLSAxXSArPSBlbmNvZGVVUklDb21wb25lbnQocGFyYW1WYWx1ZSk7ZWxzZSBwYXRobmFtZSArPSBlbmNvZGVVUklDb21wb25lbnQocGFyYW1WYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXJlbkNvdW50KSBwYXJlbkhpc3RvcnlbcGFyZW5Db3VudCAtIDFdICs9IHRva2VuO2Vsc2UgcGF0aG5hbWUgKz0gdG9rZW47XG4gICAgfVxuICB9XG5cbiAgIShwYXJlbkNvdW50IDw9IDApID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1BhdGggXCIlc1wiIGlzIG1pc3NpbmcgZW5kIHBhcmVuJywgcGF0dGVybikgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gIHJldHVybiBwYXRobmFtZS5yZXBsYWNlKC9cXC8rL2csICcvJyk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1BhdHRlcm5VdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ludmFyaWFudC9icm93c2VyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMik7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbnZhciBfUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoJy4vUm91dGVyQ29udGV4dCcpO1xuXG52YXIgX1JvdXRlckNvbnRleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyQ29udGV4dCk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX1JvdXRlclV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZXJVdGlscycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcyxcbiAgICBmdW5jID0gX1JlYWN0JFByb3BUeXBlcy5mdW5jLFxuICAgIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIEEgPFJvdXRlcj4gaXMgYSBoaWdoLWxldmVsIEFQSSBmb3IgYXV0b21hdGljYWxseSBzZXR0aW5nIHVwXG4gKiBhIHJvdXRlciB0aGF0IHJlbmRlcnMgYSA8Um91dGVyQ29udGV4dD4gd2l0aCBhbGwgdGhlIHByb3BzXG4gKiBpdCBuZWVkcyBlYWNoIHRpbWUgdGhlIFVSTCBjaGFuZ2VzLlxuICovXG5cbnZhciBSb3V0ZXIgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JvdXRlcicsXG5cblxuICBwcm9wVHlwZXM6IHtcbiAgICBoaXN0b3J5OiBvYmplY3QsXG4gICAgY2hpbGRyZW46IF9JbnRlcm5hbFByb3BUeXBlcy5yb3V0ZXMsXG4gICAgcm91dGVzOiBfSW50ZXJuYWxQcm9wVHlwZXMucm91dGVzLCAvLyBhbGlhcyBmb3IgY2hpbGRyZW5cbiAgICByZW5kZXI6IGZ1bmMsXG4gICAgY3JlYXRlRWxlbWVudDogZnVuYyxcbiAgICBvbkVycm9yOiBmdW5jLFxuICAgIG9uVXBkYXRlOiBmdW5jLFxuXG4gICAgLy8gUFJJVkFURTogRm9yIGNsaWVudC1zaWRlIHJlaHlkcmF0aW9uIG9mIHNlcnZlciBtYXRjaC5cbiAgICBtYXRjaENvbnRleHQ6IG9iamVjdFxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihwcm9wcykge1xuICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX1JvdXRlckNvbnRleHQyLmRlZmF1bHQsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG9jYXRpb246IG51bGwsXG4gICAgICByb3V0ZXM6IG51bGwsXG4gICAgICBwYXJhbXM6IG51bGwsXG4gICAgICBjb21wb25lbnRzOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgaGFuZGxlRXJyb3I6IGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yKSB7XG4gICAgaWYgKHRoaXMucHJvcHMub25FcnJvcikge1xuICAgICAgdGhpcy5wcm9wcy5vbkVycm9yLmNhbGwodGhpcywgZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaHJvdyBlcnJvcnMgYnkgZGVmYXVsdCBzbyB3ZSBkb24ndCBzaWxlbnRseSBzd2FsbG93IHRoZW0hXG4gICAgICB0aHJvdyBlcnJvcjsgLy8gVGhpcyBlcnJvciBwcm9iYWJseSBvY2N1cnJlZCBpbiBnZXRDaGlsZFJvdXRlcyBvciBnZXRDb21wb25lbnRzLlxuICAgIH1cbiAgfSxcbiAgY3JlYXRlUm91dGVyT2JqZWN0OiBmdW5jdGlvbiBjcmVhdGVSb3V0ZXJPYmplY3Qoc3RhdGUpIHtcbiAgICB2YXIgbWF0Y2hDb250ZXh0ID0gdGhpcy5wcm9wcy5tYXRjaENvbnRleHQ7XG5cbiAgICBpZiAobWF0Y2hDb250ZXh0KSB7XG4gICAgICByZXR1cm4gbWF0Y2hDb250ZXh0LnJvdXRlcjtcbiAgICB9XG5cbiAgICB2YXIgaGlzdG9yeSA9IHRoaXMucHJvcHMuaGlzdG9yeTtcblxuICAgIHJldHVybiAoMCwgX1JvdXRlclV0aWxzLmNyZWF0ZVJvdXRlck9iamVjdCkoaGlzdG9yeSwgdGhpcy50cmFuc2l0aW9uTWFuYWdlciwgc3RhdGUpO1xuICB9LFxuICBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjogZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKSB7XG4gICAgdmFyIG1hdGNoQ29udGV4dCA9IHRoaXMucHJvcHMubWF0Y2hDb250ZXh0O1xuXG4gICAgaWYgKG1hdGNoQ29udGV4dCkge1xuICAgICAgcmV0dXJuIG1hdGNoQ29udGV4dC50cmFuc2l0aW9uTWFuYWdlcjtcbiAgICB9XG5cbiAgICB2YXIgaGlzdG9yeSA9IHRoaXMucHJvcHMuaGlzdG9yeTtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgcm91dGVzID0gX3Byb3BzLnJvdXRlcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW47XG5cblxuICAgICFoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdZb3UgaGF2ZSBwcm92aWRlZCBhIGhpc3Rvcnkgb2JqZWN0IGNyZWF0ZWQgd2l0aCBoaXN0b3J5IHYyLnggb3IgJyArICdlYXJsaWVyLiBUaGlzIHZlcnNpb24gb2YgUmVhY3QgUm91dGVyIGlzIG9ubHkgY29tcGF0aWJsZSB3aXRoIHYzICcgKyAnaGlzdG9yeSBvYmplY3RzLiBQbGVhc2UgdXBncmFkZSB0byBoaXN0b3J5IHYzLnguJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgcmV0dXJuICgwLCBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIzLmRlZmF1bHQpKGhpc3RvcnksICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXMpKHJvdXRlcyB8fCBjaGlsZHJlbikpO1xuICB9LFxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uTWFuYWdlciA9IHRoaXMuY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcbiAgICB0aGlzLnJvdXRlciA9IHRoaXMuY3JlYXRlUm91dGVyT2JqZWN0KHRoaXMuc3RhdGUpO1xuXG4gICAgdGhpcy5fdW5saXN0ZW4gPSB0aGlzLnRyYW5zaXRpb25NYW5hZ2VyLmxpc3RlbihmdW5jdGlvbiAoZXJyb3IsIHN0YXRlKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgX3RoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gS2VlcCB0aGUgaWRlbnRpdHkgb2YgdGhpcy5yb3V0ZXIgYmVjYXVzZSBvZiBhIGNhdmVhdCBpbiBDb250ZXh0VXRpbHM6XG4gICAgICAgIC8vIHRoZXkgb25seSB3b3JrIGlmIHRoZSBvYmplY3QgaWRlbnRpdHkgaXMgcHJlc2VydmVkLlxuICAgICAgICAoMCwgX1JvdXRlclV0aWxzLmFzc2lnblJvdXRlclN0YXRlKShfdGhpcy5yb3V0ZXIsIHN0YXRlKTtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoc3RhdGUsIF90aGlzLnByb3BzLm9uVXBkYXRlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShuZXh0UHJvcHMuaGlzdG9yeSA9PT0gdGhpcy5wcm9wcy5oaXN0b3J5LCAnWW91IGNhbm5vdCBjaGFuZ2UgPFJvdXRlciBoaXN0b3J5PjsgaXQgd2lsbCBiZSBpZ25vcmVkJykgOiB2b2lkIDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KSgobmV4dFByb3BzLnJvdXRlcyB8fCBuZXh0UHJvcHMuY2hpbGRyZW4pID09PSAodGhpcy5wcm9wcy5yb3V0ZXMgfHwgdGhpcy5wcm9wcy5jaGlsZHJlbiksICdZb3UgY2Fubm90IGNoYW5nZSA8Um91dGVyIHJvdXRlcz47IGl0IHdpbGwgYmUgaWdub3JlZCcpIDogdm9pZCAwO1xuICB9LFxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuX3VubGlzdGVuKSB0aGlzLl91bmxpc3RlbigpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3N0YXRlID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgbG9jYXRpb24gPSBfc3RhdGUubG9jYXRpb24sXG4gICAgICAgIHJvdXRlcyA9IF9zdGF0ZS5yb3V0ZXMsXG4gICAgICAgIHBhcmFtcyA9IF9zdGF0ZS5wYXJhbXMsXG4gICAgICAgIGNvbXBvbmVudHMgPSBfc3RhdGUuY29tcG9uZW50cztcblxuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY3JlYXRlRWxlbWVudCA9IF9wcm9wczIuY3JlYXRlRWxlbWVudCxcbiAgICAgICAgcmVuZGVyID0gX3Byb3BzMi5yZW5kZXIsXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wczIsIFsnY3JlYXRlRWxlbWVudCcsICdyZW5kZXInXSk7XG5cbiAgICBpZiAobG9jYXRpb24gPT0gbnVsbCkgcmV0dXJuIG51bGw7IC8vIEFzeW5jIG1hdGNoXG5cbiAgICAvLyBPbmx5IGZvcndhcmQgbm9uLVJvdXRlci1zcGVjaWZpYyBwcm9wcyB0byByb3V0aW5nIGNvbnRleHQsIGFzIHRob3NlIGFyZVxuICAgIC8vIHRoZSBvbmx5IG9uZXMgdGhhdCBtaWdodCBiZSBjdXN0b20gcm91dGluZyBjb250ZXh0IHByb3BzLlxuICAgIE9iamVjdC5rZXlzKFJvdXRlci5wcm9wVHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BUeXBlKSB7XG4gICAgICByZXR1cm4gZGVsZXRlIHByb3BzW3Byb3BUeXBlXTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZW5kZXIoX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICByb3V0ZXI6IHRoaXMucm91dGVyLFxuICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgcm91dGVzOiByb3V0ZXMsXG4gICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gICAgICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50XG4gICAgfSkpO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXI7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMyID0gcmVxdWlyZSgnLi9jb21wdXRlQ2hhbmdlZFJvdXRlcycpO1xuXG52YXIgX2NvbXB1dGVDaGFuZ2VkUm91dGVzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXB1dGVDaGFuZ2VkUm91dGVzMik7XG5cbnZhciBfVHJhbnNpdGlvblV0aWxzID0gcmVxdWlyZSgnLi9UcmFuc2l0aW9uVXRpbHMnKTtcblxudmFyIF9pc0FjdGl2ZTIgPSByZXF1aXJlKCcuL2lzQWN0aXZlJyk7XG5cbnZhciBfaXNBY3RpdmUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNBY3RpdmUyKTtcblxudmFyIF9nZXRDb21wb25lbnRzID0gcmVxdWlyZSgnLi9nZXRDb21wb25lbnRzJyk7XG5cbnZhciBfZ2V0Q29tcG9uZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRDb21wb25lbnRzKTtcblxudmFyIF9tYXRjaFJvdXRlcyA9IHJlcXVpcmUoJy4vbWF0Y2hSb3V0ZXMnKTtcblxudmFyIF9tYXRjaFJvdXRlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRjaFJvdXRlcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGhhc0FueVByb3BlcnRpZXMob2JqZWN0KSB7XG4gIGZvciAodmFyIHAgaW4gb2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHApKSByZXR1cm4gdHJ1ZTtcbiAgfXJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoaGlzdG9yeSwgcm91dGVzKSB7XG4gIHZhciBzdGF0ZSA9IHt9O1xuXG4gIC8vIFNpZ25hdHVyZSBzaG91bGQgYmUgKGxvY2F0aW9uLCBpbmRleE9ubHkpLCBidXQgbmVlZHMgdG8gc3VwcG9ydCAocGF0aCxcbiAgLy8gcXVlcnksIGluZGV4T25seSlcbiAgZnVuY3Rpb24gaXNBY3RpdmUobG9jYXRpb24sIGluZGV4T25seSkge1xuICAgIGxvY2F0aW9uID0gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihsb2NhdGlvbik7XG5cbiAgICByZXR1cm4gKDAsIF9pc0FjdGl2ZTMuZGVmYXVsdCkobG9jYXRpb24sIGluZGV4T25seSwgc3RhdGUubG9jYXRpb24sIHN0YXRlLnJvdXRlcywgc3RhdGUucGFyYW1zKTtcbiAgfVxuXG4gIHZhciBwYXJ0aWFsTmV4dFN0YXRlID0gdm9pZCAwO1xuXG4gIGZ1bmN0aW9uIG1hdGNoKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgIGlmIChwYXJ0aWFsTmV4dFN0YXRlICYmIHBhcnRpYWxOZXh0U3RhdGUubG9jYXRpb24gPT09IGxvY2F0aW9uKSB7XG4gICAgICAvLyBDb250aW51ZSBmcm9tIHdoZXJlIHdlIGxlZnQgb2ZmLlxuICAgICAgZmluaXNoTWF0Y2gocGFydGlhbE5leHRTdGF0ZSwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAoMCwgX21hdGNoUm91dGVzMi5kZWZhdWx0KShyb3V0ZXMsIGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIG5leHRTdGF0ZSkge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFN0YXRlKSB7XG4gICAgICAgICAgZmluaXNoTWF0Y2goX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwgeyBsb2NhdGlvbjogbG9jYXRpb24gfSksIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hNYXRjaChuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF9jb21wdXRlQ2hhbmdlZFJvdXRlcyA9ICgwLCBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMzLmRlZmF1bHQpKHN0YXRlLCBuZXh0U3RhdGUpLFxuICAgICAgICBsZWF2ZVJvdXRlcyA9IF9jb21wdXRlQ2hhbmdlZFJvdXRlcy5sZWF2ZVJvdXRlcyxcbiAgICAgICAgY2hhbmdlUm91dGVzID0gX2NvbXB1dGVDaGFuZ2VkUm91dGVzLmNoYW5nZVJvdXRlcyxcbiAgICAgICAgZW50ZXJSb3V0ZXMgPSBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMuZW50ZXJSb3V0ZXM7XG5cbiAgICAoMCwgX1RyYW5zaXRpb25VdGlscy5ydW5MZWF2ZUhvb2tzKShsZWF2ZVJvdXRlcywgc3RhdGUpO1xuXG4gICAgLy8gVGVhciBkb3duIGNvbmZpcm1hdGlvbiBob29rcyBmb3IgbGVmdCByb3V0ZXNcbiAgICBsZWF2ZVJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICByZXR1cm4gZW50ZXJSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgPT09IC0xO1xuICAgIH0pLmZvckVhY2gocmVtb3ZlTGlzdGVuQmVmb3JlSG9va3NGb3JSb3V0ZSk7XG5cbiAgICAvLyBjaGFuZ2UgYW5kIGVudGVyIGhvb2tzIGFyZSBydW4gaW4gc2VyaWVzXG4gICAgKDAsIF9UcmFuc2l0aW9uVXRpbHMucnVuQ2hhbmdlSG9va3MpKGNoYW5nZVJvdXRlcywgc3RhdGUsIG5leHRTdGF0ZSwgZnVuY3Rpb24gKGVycm9yLCByZWRpcmVjdEluZm8pIHtcbiAgICAgIGlmIChlcnJvciB8fCByZWRpcmVjdEluZm8pIHJldHVybiBoYW5kbGVFcnJvck9yUmVkaXJlY3QoZXJyb3IsIHJlZGlyZWN0SW5mbyk7XG5cbiAgICAgICgwLCBfVHJhbnNpdGlvblV0aWxzLnJ1bkVudGVySG9va3MpKGVudGVyUm91dGVzLCBuZXh0U3RhdGUsIGZpbmlzaEVudGVySG9va3MpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZmluaXNoRW50ZXJIb29rcyhlcnJvciwgcmVkaXJlY3RJbmZvKSB7XG4gICAgICBpZiAoZXJyb3IgfHwgcmVkaXJlY3RJbmZvKSByZXR1cm4gaGFuZGxlRXJyb3JPclJlZGlyZWN0KGVycm9yLCByZWRpcmVjdEluZm8pO1xuXG4gICAgICAvLyBUT0RPOiBGZXRjaCBjb21wb25lbnRzIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAgICAoMCwgX2dldENvbXBvbmVudHMyLmRlZmF1bHQpKG5leHRTdGF0ZSwgZnVuY3Rpb24gKGVycm9yLCBjb21wb25lbnRzKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUT0RPOiBNYWtlIG1hdGNoIGEgcHVyZSBmdW5jdGlvbiBhbmQgaGF2ZSBzb21lIG90aGVyIEFQSVxuICAgICAgICAgIC8vIGZvciBcIm1hdGNoIGFuZCB1cGRhdGUgc3RhdGVcIi5cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBudWxsLCBzdGF0ZSA9IF9leHRlbmRzKHt9LCBuZXh0U3RhdGUsIHsgY29tcG9uZW50czogY29tcG9uZW50cyB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9yT3JSZWRpcmVjdChlcnJvciwgcmVkaXJlY3RJbmZvKSB7XG4gICAgICBpZiAoZXJyb3IpIGNhbGxiYWNrKGVycm9yKTtlbHNlIGNhbGxiYWNrKG51bGwsIHJlZGlyZWN0SW5mbyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIFJvdXRlR3VpZCA9IDE7XG5cbiAgZnVuY3Rpb24gZ2V0Um91dGVJRChyb3V0ZSkge1xuICAgIHZhciBjcmVhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgcmV0dXJuIHJvdXRlLl9faWRfXyB8fCBjcmVhdGUgJiYgKHJvdXRlLl9faWRfXyA9IFJvdXRlR3VpZCsrKTtcbiAgfVxuXG4gIHZhciBSb3V0ZUhvb2tzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmdW5jdGlvbiBnZXRSb3V0ZUhvb2tzRm9yUm91dGVzKHJvdXRlcykge1xuICAgIHJldHVybiByb3V0ZXMubWFwKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmV0dXJuIFJvdXRlSG9va3NbZ2V0Um91dGVJRChyb3V0ZSldO1xuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoaG9vaykge1xuICAgICAgcmV0dXJuIGhvb2s7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uSG9vayhsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAoMCwgX21hdGNoUm91dGVzMi5kZWZhdWx0KShyb3V0ZXMsIGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIG5leHRTdGF0ZSkge1xuICAgICAgaWYgKG5leHRTdGF0ZSA9PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFdlIGRpZG4ndCBhY3R1YWxseSBtYXRjaCBhbnl0aGluZywgYnV0IGhhbmdcbiAgICAgICAgLy8gb250byBlcnJvci9uZXh0U3RhdGUgc28gd2UgZG9uJ3QgaGF2ZSB0byBtYXRjaFJvdXRlc1xuICAgICAgICAvLyBhZ2FpbiBpbiB0aGUgbGlzdGVuIGNhbGxiYWNrLlxuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENhY2hlIHNvbWUgc3RhdGUgaGVyZSBzbyB3ZSBkb24ndCBoYXZlIHRvXG4gICAgICAvLyBtYXRjaFJvdXRlcygpIGFnYWluIGluIHRoZSBsaXN0ZW4gY2FsbGJhY2suXG4gICAgICBwYXJ0aWFsTmV4dFN0YXRlID0gX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwgeyBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG5cbiAgICAgIHZhciBob29rcyA9IGdldFJvdXRlSG9va3NGb3JSb3V0ZXMoKDAsIF9jb21wdXRlQ2hhbmdlZFJvdXRlczMuZGVmYXVsdCkoc3RhdGUsIHBhcnRpYWxOZXh0U3RhdGUpLmxlYXZlUm91dGVzKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob29rcy5sZW5ndGg7IHJlc3VsdCA9PSBudWxsICYmIGkgPCBsZW47ICsraSkge1xuICAgICAgICAvLyBQYXNzaW5nIHRoZSBsb2NhdGlvbiBhcmcgaGVyZSBpbmRpY2F0ZXMgdG9cbiAgICAgICAgLy8gdGhlIHVzZXIgdGhhdCB0aGlzIGlzIGEgdHJhbnNpdGlvbiBob29rLlxuICAgICAgICByZXN1bHQgPSBob29rc1tpXShsb2NhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogdW50ZXN0YWJsZSB3aXRoIEthcm1hICovXG4gIGZ1bmN0aW9uIGJlZm9yZVVubG9hZEhvb2soKSB7XG4gICAgLy8gU3luY2hyb25vdXNseSBjaGVjayB0byBzZWUgaWYgYW55IHJvdXRlIGhvb2tzIHdhbnRcbiAgICAvLyB0byBwcmV2ZW50IHRoZSBjdXJyZW50IHdpbmRvdy90YWIgZnJvbSBjbG9zaW5nLlxuICAgIGlmIChzdGF0ZS5yb3V0ZXMpIHtcbiAgICAgIHZhciBob29rcyA9IGdldFJvdXRlSG9va3NGb3JSb3V0ZXMoc3RhdGUucm91dGVzKTtcblxuICAgICAgdmFyIG1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9va3MubGVuZ3RoOyB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycgJiYgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIC8vIFBhc3Npbmcgbm8gYXJncyBpbmRpY2F0ZXMgdG8gdGhlIHVzZXIgdGhhdCB0aGlzIGlzIGFcbiAgICAgICAgLy8gYmVmb3JldW5sb2FkIGhvb2suIFdlIGRvbid0IGtub3cgdGhlIG5leHQgbG9jYXRpb24uXG4gICAgICAgIG1lc3NhZ2UgPSBob29rc1tpXSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5saXN0ZW5CZWZvcmUgPSB2b2lkIDAsXG4gICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5CZWZvcmVIb29rc0ZvclJvdXRlKHJvdXRlKSB7XG4gICAgdmFyIHJvdXRlSUQgPSBnZXRSb3V0ZUlEKHJvdXRlKTtcbiAgICBpZiAoIXJvdXRlSUQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWxldGUgUm91dGVIb29rc1tyb3V0ZUlEXTtcblxuICAgIGlmICghaGFzQW55UHJvcGVydGllcyhSb3V0ZUhvb2tzKSkge1xuICAgICAgLy8gdGVhcmRvd24gdHJhbnNpdGlvbiAmIGJlZm9yZXVubG9hZCBob29rc1xuICAgICAgaWYgKHVubGlzdGVuQmVmb3JlKSB7XG4gICAgICAgIHVubGlzdGVuQmVmb3JlKCk7XG4gICAgICAgIHVubGlzdGVuQmVmb3JlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHVubGlzdGVuQmVmb3JlVW5sb2FkKSB7XG4gICAgICAgIHVubGlzdGVuQmVmb3JlVW5sb2FkKCk7XG4gICAgICAgIHVubGlzdGVuQmVmb3JlVW5sb2FkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIHRoZSBnaXZlbiBob29rIGZ1bmN0aW9uIHRvIHJ1biBiZWZvcmUgbGVhdmluZyB0aGUgZ2l2ZW4gcm91dGUuXG4gICAqXG4gICAqIER1cmluZyBhIG5vcm1hbCB0cmFuc2l0aW9uLCB0aGUgaG9vayBmdW5jdGlvbiByZWNlaXZlcyB0aGUgbmV4dCBsb2NhdGlvblxuICAgKiBhcyBpdHMgb25seSBhcmd1bWVudCBhbmQgY2FuIHJldHVybiBlaXRoZXIgYSBwcm9tcHQgbWVzc2FnZSAoc3RyaW5nKSB0byBzaG93IHRoZSB1c2VyLFxuICAgKiB0byBtYWtlIHN1cmUgdGhleSB3YW50IHRvIGxlYXZlIHRoZSBwYWdlOyBvciBgZmFsc2VgLCB0byBwcmV2ZW50IHRoZSB0cmFuc2l0aW9uLlxuICAgKiBBbnkgb3RoZXIgcmV0dXJuIHZhbHVlIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gICAqXG4gICAqIER1cmluZyB0aGUgYmVmb3JldW5sb2FkIGV2ZW50IChpbiBicm93c2VycykgdGhlIGhvb2sgcmVjZWl2ZXMgbm8gYXJndW1lbnRzLlxuICAgKiBJbiB0aGlzIGNhc2UgaXQgbXVzdCByZXR1cm4gYSBwcm9tcHQgbWVzc2FnZSB0byBwcmV2ZW50IHRoZSB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byB1bmJpbmQgdGhlIGxpc3RlbmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlKHJvdXRlLCBob29rKSB7XG4gICAgdmFyIHRoZXJlV2VyZU5vUm91dGVIb29rcyA9ICFoYXNBbnlQcm9wZXJ0aWVzKFJvdXRlSG9va3MpO1xuICAgIHZhciByb3V0ZUlEID0gZ2V0Um91dGVJRChyb3V0ZSwgdHJ1ZSk7XG5cbiAgICBSb3V0ZUhvb2tzW3JvdXRlSURdID0gaG9vaztcblxuICAgIGlmICh0aGVyZVdlcmVOb1JvdXRlSG9va3MpIHtcbiAgICAgIC8vIHNldHVwIHRyYW5zaXRpb24gJiBiZWZvcmV1bmxvYWQgaG9va3NcbiAgICAgIHVubGlzdGVuQmVmb3JlID0gaGlzdG9yeS5saXN0ZW5CZWZvcmUodHJhbnNpdGlvbkhvb2spO1xuXG4gICAgICBpZiAoaGlzdG9yeS5saXN0ZW5CZWZvcmVVbmxvYWQpIHVubGlzdGVuQmVmb3JlVW5sb2FkID0gaGlzdG9yeS5saXN0ZW5CZWZvcmVVbmxvYWQoYmVmb3JlVW5sb2FkSG9vayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlbW92ZUxpc3RlbkJlZm9yZUhvb2tzRm9yUm91dGUocm91dGUpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgQVBJIGZvciBzdGF0ZWZ1bCBlbnZpcm9ubWVudHMuIEFzIHRoZSBsb2NhdGlvblxuICAgKiBjaGFuZ2VzLCB3ZSB1cGRhdGUgc3RhdGUgYW5kIGNhbGwgdGhlIGxpc3RlbmVyLiBXZSBjYW4gYWxzb1xuICAgKiBncmFjZWZ1bGx5IGhhbmRsZSBlcnJvcnMgYW5kIHJlZGlyZWN0cy5cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIGZ1bmN0aW9uIGhpc3RvcnlMaXN0ZW5lcihsb2NhdGlvbikge1xuICAgICAgaWYgKHN0YXRlLmxvY2F0aW9uID09PSBsb2NhdGlvbikge1xuICAgICAgICBsaXN0ZW5lcihudWxsLCBzdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaChsb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCByZWRpcmVjdExvY2F0aW9uLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKGVycm9yKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlZGlyZWN0TG9jYXRpb24pIHtcbiAgICAgICAgICAgIGhpc3RvcnkucmVwbGFjZShyZWRpcmVjdExvY2F0aW9uKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5leHRTdGF0ZSkge1xuICAgICAgICAgICAgbGlzdGVuZXIobnVsbCwgbmV4dFN0YXRlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdMb2NhdGlvbiBcIiVzXCIgZGlkIG5vdCBtYXRjaCBhbnkgcm91dGVzJywgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoKSA6IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IE9ubHkgdXNlIGEgc2luZ2xlIGhpc3RvcnkgbGlzdGVuZXIuIE90aGVyd2lzZSB3ZSdsbCBlbmQgdXAgd2l0aFxuICAgIC8vIG11bHRpcGxlIGNvbmN1cnJlbnQgY2FsbHMgdG8gbWF0Y2guXG5cbiAgICAvLyBTZXQgdXAgdGhlIGhpc3RvcnkgbGlzdGVuZXIgZmlyc3QgaW4gY2FzZSB0aGUgaW5pdGlhbCBtYXRjaCByZWRpcmVjdHMuXG4gICAgdmFyIHVuc3Vic2NyaWJlID0gaGlzdG9yeS5saXN0ZW4oaGlzdG9yeUxpc3RlbmVyKTtcblxuICAgIGlmIChzdGF0ZS5sb2NhdGlvbikge1xuICAgICAgLy8gUGlja2luZyB1cCBvbiBhIG1hdGNoQ29udGV4dC5cbiAgICAgIGxpc3RlbmVyKG51bGwsIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlzdG9yeUxpc3RlbmVyKGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaXNBY3RpdmU6IGlzQWN0aXZlLFxuICAgIG1hdGNoOiBtYXRjaCxcbiAgICBsaXN0ZW5CZWZvcmVMZWF2aW5nUm91dGU6IGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gcm91dGVyV2FybmluZztcbmV4cG9ydHMuX3Jlc2V0V2FybmVkID0gX3Jlc2V0V2FybmVkO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHdhcm5lZCA9IHt9O1xuXG5mdW5jdGlvbiByb3V0ZXJXYXJuaW5nKGZhbHNlVG9XYXJuLCBtZXNzYWdlKSB7XG4gIC8vIE9ubHkgaXNzdWUgZGVwcmVjYXRpb24gd2FybmluZ3Mgb25jZS5cbiAgaWYgKG1lc3NhZ2UuaW5kZXhPZignZGVwcmVjYXRlZCcpICE9PSAtMSkge1xuICAgIGlmICh3YXJuZWRbbWVzc2FnZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRbbWVzc2FnZV0gPSB0cnVlO1xuICB9XG5cbiAgbWVzc2FnZSA9ICdbcmVhY3Qtcm91dGVyXSAnICsgbWVzc2FnZTtcblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIF93YXJuaW5nMi5kZWZhdWx0LmFwcGx5KHVuZGVmaW5lZCwgW2ZhbHNlVG9XYXJuLCBtZXNzYWdlXS5jb25jYXQoYXJncykpO1xufVxuXG5mdW5jdGlvbiBfcmVzZXRXYXJuZWQoKSB7XG4gIHdhcm5lZCA9IHt9O1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9yb3V0ZXJXYXJuaW5nLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8ICgvXltzXFxXXSokLykudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgd2FybmluZyBmb3JtYXQgc2hvdWxkIGJlIGFibGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyAnICtcbiAgICAgICAgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3dhcm5pbmcvYnJvd3Nlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG5mdW5jdGlvbiByb3V0ZVBhcmFtc0NoYW5nZWQocm91dGUsIHByZXZTdGF0ZSwgbmV4dFN0YXRlKSB7XG4gIGlmICghcm91dGUucGF0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBwYXJhbU5hbWVzID0gKDAsIF9QYXR0ZXJuVXRpbHMuZ2V0UGFyYW1OYW1lcykocm91dGUucGF0aCk7XG5cbiAgcmV0dXJuIHBhcmFtTmFtZXMuc29tZShmdW5jdGlvbiAocGFyYW1OYW1lKSB7XG4gICAgcmV0dXJuIHByZXZTdGF0ZS5wYXJhbXNbcGFyYW1OYW1lXSAhPT0gbmV4dFN0YXRlLnBhcmFtc1twYXJhbU5hbWVdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBvZiB7IGxlYXZlUm91dGVzLCBjaGFuZ2VSb3V0ZXMsIGVudGVyUm91dGVzIH0gZGV0ZXJtaW5lZCBieVxuICogdGhlIGNoYW5nZSBmcm9tIHByZXZTdGF0ZSB0byBuZXh0U3RhdGUuIFdlIGxlYXZlIHJvdXRlcyBpZiBlaXRoZXJcbiAqIDEpIHRoZXkgYXJlIG5vdCBpbiB0aGUgbmV4dCBzdGF0ZSBvciAyKSB0aGV5IGFyZSBpbiB0aGUgbmV4dCBzdGF0ZVxuICogYnV0IHRoZWlyIHBhcmFtcyBoYXZlIGNoYW5nZWQgKGkuZS4gL3VzZXJzLzEyMyA9PiAvdXNlcnMvNDU2KS5cbiAqXG4gKiBsZWF2ZVJvdXRlcyBhcmUgb3JkZXJlZCBzdGFydGluZyBhdCB0aGUgbGVhZiByb3V0ZSBvZiB0aGUgdHJlZVxuICogd2UncmUgbGVhdmluZyB1cCB0byB0aGUgY29tbW9uIHBhcmVudCByb3V0ZS4gZW50ZXJSb3V0ZXMgYXJlIG9yZGVyZWRcbiAqIGZyb20gdGhlIHRvcCBvZiB0aGUgdHJlZSB3ZSdyZSBlbnRlcmluZyBkb3duIHRvIHRoZSBsZWFmIHJvdXRlLlxuICpcbiAqIGNoYW5nZVJvdXRlcyBhcmUgYW55IHJvdXRlcyB0aGF0IGRpZG4ndCBsZWF2ZSBvciBlbnRlciBkdXJpbmdcbiAqIHRoZSB0cmFuc2l0aW9uLlxuICovXG5mdW5jdGlvbiBjb21wdXRlQ2hhbmdlZFJvdXRlcyhwcmV2U3RhdGUsIG5leHRTdGF0ZSkge1xuICB2YXIgcHJldlJvdXRlcyA9IHByZXZTdGF0ZSAmJiBwcmV2U3RhdGUucm91dGVzO1xuICB2YXIgbmV4dFJvdXRlcyA9IG5leHRTdGF0ZS5yb3V0ZXM7XG5cbiAgdmFyIGxlYXZlUm91dGVzID0gdm9pZCAwLFxuICAgICAgY2hhbmdlUm91dGVzID0gdm9pZCAwLFxuICAgICAgZW50ZXJSb3V0ZXMgPSB2b2lkIDA7XG4gIGlmIChwcmV2Um91dGVzKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnRJc0xlYXZpbmcgPSBmYWxzZTtcbiAgICAgIGxlYXZlUm91dGVzID0gcHJldlJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIGlmIChwYXJlbnRJc0xlYXZpbmcpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaXNMZWF2aW5nID0gbmV4dFJvdXRlcy5pbmRleE9mKHJvdXRlKSA9PT0gLTEgfHwgcm91dGVQYXJhbXNDaGFuZ2VkKHJvdXRlLCBwcmV2U3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgICAgICAgaWYgKGlzTGVhdmluZykgcGFyZW50SXNMZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gaXNMZWF2aW5nO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gb25MZWF2ZSBob29rcyBzdGFydCBhdCB0aGUgbGVhZiByb3V0ZS5cbiAgICAgIGxlYXZlUm91dGVzLnJldmVyc2UoKTtcblxuICAgICAgZW50ZXJSb3V0ZXMgPSBbXTtcbiAgICAgIGNoYW5nZVJvdXRlcyA9IFtdO1xuXG4gICAgICBuZXh0Um91dGVzLmZvckVhY2goZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIHZhciBpc05ldyA9IHByZXZSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgPT09IC0xO1xuICAgICAgICB2YXIgcGFyYW1zQ2hhbmdlZCA9IGxlYXZlUm91dGVzLmluZGV4T2Yocm91dGUpICE9PSAtMTtcblxuICAgICAgICBpZiAoaXNOZXcgfHwgcGFyYW1zQ2hhbmdlZCkgZW50ZXJSb3V0ZXMucHVzaChyb3V0ZSk7ZWxzZSBjaGFuZ2VSb3V0ZXMucHVzaChyb3V0ZSk7XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9IGVsc2Uge1xuICAgIGxlYXZlUm91dGVzID0gW107XG4gICAgY2hhbmdlUm91dGVzID0gW107XG4gICAgZW50ZXJSb3V0ZXMgPSBuZXh0Um91dGVzO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsZWF2ZVJvdXRlczogbGVhdmVSb3V0ZXMsXG4gICAgY2hhbmdlUm91dGVzOiBjaGFuZ2VSb3V0ZXMsXG4gICAgZW50ZXJSb3V0ZXM6IGVudGVyUm91dGVzXG4gIH07XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNvbXB1dGVDaGFuZ2VkUm91dGVzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2NvbXB1dGVDaGFuZ2VkUm91dGVzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5ydW5FbnRlckhvb2tzID0gcnVuRW50ZXJIb29rcztcbmV4cG9ydHMucnVuQ2hhbmdlSG9va3MgPSBydW5DaGFuZ2VIb29rcztcbmV4cG9ydHMucnVuTGVhdmVIb29rcyA9IHJ1bkxlYXZlSG9va3M7XG5cbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUGVuZGluZ0hvb2tzID0gZnVuY3Rpb24gUGVuZGluZ0hvb2tzKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQZW5kaW5nSG9va3MpO1xuXG4gIHRoaXMuaG9va3MgPSBbXTtcblxuICB0aGlzLmFkZCA9IGZ1bmN0aW9uIChob29rKSB7XG4gICAgcmV0dXJuIF90aGlzLmhvb2tzLnB1c2goaG9vayk7XG4gIH07XG5cbiAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbiAoaG9vaykge1xuICAgIHJldHVybiBfdGhpcy5ob29rcyA9IF90aGlzLmhvb2tzLmZpbHRlcihmdW5jdGlvbiAoaCkge1xuICAgICAgcmV0dXJuIGggIT09IGhvb2s7XG4gICAgfSk7XG4gIH07XG5cbiAgdGhpcy5oYXMgPSBmdW5jdGlvbiAoaG9vaykge1xuICAgIHJldHVybiBfdGhpcy5ob29rcy5pbmRleE9mKGhvb2spICE9PSAtMTtcbiAgfTtcblxuICB0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGhpcy5ob29rcyA9IFtdO1xuICB9O1xufTtcblxudmFyIGVudGVySG9va3MgPSBuZXcgUGVuZGluZ0hvb2tzKCk7XG52YXIgY2hhbmdlSG9va3MgPSBuZXcgUGVuZGluZ0hvb2tzKCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25Ib29rKGhvb2ssIHJvdXRlLCBhc3luY0FyaXR5LCBwZW5kaW5nSG9va3MpIHtcbiAgdmFyIGlzU3luYyA9IGhvb2subGVuZ3RoIDwgYXN5bmNBcml0eTtcblxuICB2YXIgdHJhbnNpdGlvbkhvb2sgPSBmdW5jdGlvbiB0cmFuc2l0aW9uSG9vaygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBob29rLmFwcGx5KHJvdXRlLCBhcmdzKTtcblxuICAgIGlmIChpc1N5bmMpIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgIC8vIEFzc3VtZSBob29rIGV4ZWN1dGVzIHN5bmNocm9ub3VzbHkgYW5kXG4gICAgICAvLyBhdXRvbWF0aWNhbGx5IGNhbGwgdGhlIGNhbGxiYWNrLlxuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH07XG5cbiAgcGVuZGluZ0hvb2tzLmFkZCh0cmFuc2l0aW9uSG9vayk7XG5cbiAgcmV0dXJuIHRyYW5zaXRpb25Ib29rO1xufVxuXG5mdW5jdGlvbiBnZXRFbnRlckhvb2tzKHJvdXRlcykge1xuICByZXR1cm4gcm91dGVzLnJlZHVjZShmdW5jdGlvbiAoaG9va3MsIHJvdXRlKSB7XG4gICAgaWYgKHJvdXRlLm9uRW50ZXIpIGhvb2tzLnB1c2goY3JlYXRlVHJhbnNpdGlvbkhvb2socm91dGUub25FbnRlciwgcm91dGUsIDMsIGVudGVySG9va3MpKTtcbiAgICByZXR1cm4gaG9va3M7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2hhbmdlSG9va3Mocm91dGVzKSB7XG4gIHJldHVybiByb3V0ZXMucmVkdWNlKGZ1bmN0aW9uIChob29rcywgcm91dGUpIHtcbiAgICBpZiAocm91dGUub25DaGFuZ2UpIGhvb2tzLnB1c2goY3JlYXRlVHJhbnNpdGlvbkhvb2socm91dGUub25DaGFuZ2UsIHJvdXRlLCA0LCBjaGFuZ2VIb29rcykpO1xuICAgIHJldHVybiBob29rcztcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBydW5UcmFuc2l0aW9uSG9va3MobGVuZ3RoLCBpdGVyLCBjYWxsYmFjaykge1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGNhbGxiYWNrKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlZGlyZWN0SW5mbyA9IHZvaWQgMDtcbiAgZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgIHJlZGlyZWN0SW5mbyA9IGxvY2F0aW9uO1xuICB9XG5cbiAgKDAsIF9Bc3luY1V0aWxzLmxvb3BBc3luYykobGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIG5leHQsIGRvbmUpIHtcbiAgICBpdGVyKGluZGV4LCByZXBsYWNlLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciB8fCByZWRpcmVjdEluZm8pIHtcbiAgICAgICAgZG9uZShlcnJvciwgcmVkaXJlY3RJbmZvKTsgLy8gTm8gbmVlZCB0byBjb250aW51ZS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFJ1bnMgYWxsIG9uRW50ZXIgaG9va3MgaW4gdGhlIGdpdmVuIGFycmF5IG9mIHJvdXRlcyBpbiBvcmRlclxuICogd2l0aCBvbkVudGVyKG5leHRTdGF0ZSwgcmVwbGFjZSwgY2FsbGJhY2spIGFuZCBjYWxsc1xuICogY2FsbGJhY2soZXJyb3IsIHJlZGlyZWN0SW5mbykgd2hlbiBmaW5pc2hlZC4gVGhlIGZpcnN0IGhvb2tcbiAqIHRvIHVzZSByZXBsYWNlIHNob3J0LWNpcmN1aXRzIHRoZSBsb29wLlxuICpcbiAqIElmIGEgaG9vayBuZWVkcyB0byBydW4gYXN5bmNocm9ub3VzbHksIGl0IG1heSB1c2UgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi4gSG93ZXZlciwgZG9pbmcgc28gd2lsbCBjYXVzZSB0aGUgdHJhbnNpdGlvbiB0byBwYXVzZSxcbiAqIHdoaWNoIGNvdWxkIGxlYWQgdG8gYSBub24tcmVzcG9uc2l2ZSBVSSBpZiB0aGUgaG9vayBpcyBzbG93LlxuICovXG5mdW5jdGlvbiBydW5FbnRlckhvb2tzKHJvdXRlcywgbmV4dFN0YXRlLCBjYWxsYmFjaykge1xuICBlbnRlckhvb2tzLmNsZWFyKCk7XG4gIHZhciBob29rcyA9IGdldEVudGVySG9va3Mocm91dGVzKTtcbiAgcmV0dXJuIHJ1blRyYW5zaXRpb25Ib29rcyhob29rcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZSwgbmV4dCkge1xuICAgIHZhciB3cmFwcGVkTmV4dCA9IGZ1bmN0aW9uIHdyYXBwZWROZXh0KCkge1xuICAgICAgaWYgKGVudGVySG9va3MuaGFzKGhvb2tzW2luZGV4XSkpIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBlbnRlckhvb2tzLnJlbW92ZShob29rc1tpbmRleF0pO1xuICAgICAgfVxuICAgIH07XG4gICAgaG9va3NbaW5kZXhdKG5leHRTdGF0ZSwgcmVwbGFjZSwgd3JhcHBlZE5leHQpO1xuICB9LCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUnVucyBhbGwgb25DaGFuZ2UgaG9va3MgaW4gdGhlIGdpdmVuIGFycmF5IG9mIHJvdXRlcyBpbiBvcmRlclxuICogd2l0aCBvbkNoYW5nZShwcmV2U3RhdGUsIG5leHRTdGF0ZSwgcmVwbGFjZSwgY2FsbGJhY2spIGFuZCBjYWxsc1xuICogY2FsbGJhY2soZXJyb3IsIHJlZGlyZWN0SW5mbykgd2hlbiBmaW5pc2hlZC4gVGhlIGZpcnN0IGhvb2tcbiAqIHRvIHVzZSByZXBsYWNlIHNob3J0LWNpcmN1aXRzIHRoZSBsb29wLlxuICpcbiAqIElmIGEgaG9vayBuZWVkcyB0byBydW4gYXN5bmNocm9ub3VzbHksIGl0IG1heSB1c2UgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi4gSG93ZXZlciwgZG9pbmcgc28gd2lsbCBjYXVzZSB0aGUgdHJhbnNpdGlvbiB0byBwYXVzZSxcbiAqIHdoaWNoIGNvdWxkIGxlYWQgdG8gYSBub24tcmVzcG9uc2l2ZSBVSSBpZiB0aGUgaG9vayBpcyBzbG93LlxuICovXG5mdW5jdGlvbiBydW5DaGFuZ2VIb29rcyhyb3V0ZXMsIHN0YXRlLCBuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gIGNoYW5nZUhvb2tzLmNsZWFyKCk7XG4gIHZhciBob29rcyA9IGdldENoYW5nZUhvb2tzKHJvdXRlcyk7XG4gIHJldHVybiBydW5UcmFuc2l0aW9uSG9va3MoaG9va3MubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2UsIG5leHQpIHtcbiAgICB2YXIgd3JhcHBlZE5leHQgPSBmdW5jdGlvbiB3cmFwcGVkTmV4dCgpIHtcbiAgICAgIGlmIChjaGFuZ2VIb29rcy5oYXMoaG9va3NbaW5kZXhdKSkge1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIGNoYW5nZUhvb2tzLnJlbW92ZShob29rc1tpbmRleF0pO1xuICAgICAgfVxuICAgIH07XG4gICAgaG9va3NbaW5kZXhdKHN0YXRlLCBuZXh0U3RhdGUsIHJlcGxhY2UsIHdyYXBwZWROZXh0KTtcbiAgfSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFJ1bnMgYWxsIG9uTGVhdmUgaG9va3MgaW4gdGhlIGdpdmVuIGFycmF5IG9mIHJvdXRlcyBpbiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gcnVuTGVhdmVIb29rcyhyb3V0ZXMsIHByZXZTdGF0ZSkge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm91dGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHJvdXRlc1tpXS5vbkxlYXZlKSByb3V0ZXNbaV0ub25MZWF2ZS5jYWxsKHJvdXRlc1tpXSwgcHJldlN0YXRlKTtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9UcmFuc2l0aW9uVXRpbHMuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMubG9vcEFzeW5jID0gbG9vcEFzeW5jO1xuZXhwb3J0cy5tYXBBc3luYyA9IG1hcEFzeW5jO1xuZnVuY3Rpb24gbG9vcEFzeW5jKHR1cm5zLCB3b3JrLCBjYWxsYmFjaykge1xuICB2YXIgY3VycmVudFR1cm4gPSAwLFxuICAgICAgaXNEb25lID0gZmFsc2U7XG4gIHZhciBzeW5jID0gZmFsc2UsXG4gICAgICBoYXNOZXh0ID0gZmFsc2UsXG4gICAgICBkb25lQXJncyA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiBkb25lKCkge1xuICAgIGlzRG9uZSA9IHRydWU7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG4gICAgICBkb25lQXJncyA9IFtdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGFzTmV4dCA9IHRydWU7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3luYyA9IHRydWU7XG5cbiAgICB3aGlsZSAoIWlzRG9uZSAmJiBjdXJyZW50VHVybiA8IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGhhc05leHQgPSBmYWxzZTtcbiAgICAgIHdvcmsuY2FsbCh0aGlzLCBjdXJyZW50VHVybisrLCBuZXh0LCBkb25lKTtcbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG5cbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICAvLyBUaGlzIG1lYW5zIHRoZSBsb29wIGZpbmlzaGVkIHN5bmNocm9ub3VzbHkuXG4gICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBkb25lQXJncyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRUdXJuID49IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIG5leHQoKTtcbn1cblxuZnVuY3Rpb24gbWFwQXN5bmMoYXJyYXksIHdvcmssIGNhbGxiYWNrKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciB2YWx1ZXMgPSBbXTtcblxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgdmFsdWVzKTtcblxuICB2YXIgaXNEb25lID0gZmFsc2UsXG4gICAgICBkb25lQ291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIGRvbmUoaW5kZXgsIGVycm9yLCB2YWx1ZSkge1xuICAgIGlmIChpc0RvbmUpIHJldHVybjtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuXG4gICAgICBpc0RvbmUgPSArK2RvbmVDb3VudCA9PT0gbGVuZ3RoO1xuXG4gICAgICBpZiAoaXNEb25lKSBjYWxsYmFjayhudWxsLCB2YWx1ZXMpO1xuICAgIH1cbiAgfVxuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgd29yayhpdGVtLCBpbmRleCwgZnVuY3Rpb24gKGVycm9yLCB2YWx1ZSkge1xuICAgICAgZG9uZShpbmRleCwgZXJyb3IsIHZhbHVlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0FzeW5jVXRpbHMuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gaXNBY3RpdmU7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGRlZXBFcXVhbChpdGVtLCBiW2luZGV4XSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoKHR5cGVvZiBhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhKSkgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2YXIgcCBpbiBhKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBwKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFbcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYltwXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghZGVlcEVxdWFsKGFbcF0sIGJbcF0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgcGF0aG5hbWUgbWF0Y2hlcyB0aGUgc3VwcGxpZWQgb25lLCBuZXQgb2ZcbiAqIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoIG5vcm1hbGl6YXRpb24uIFRoaXMgaXMgc3VmZmljaWVudCBmb3IgYW5cbiAqIGluZGV4T25seSByb3V0ZSBtYXRjaC5cbiAqL1xuZnVuY3Rpb24gcGF0aElzQWN0aXZlKHBhdGhuYW1lLCBjdXJyZW50UGF0aG5hbWUpIHtcbiAgLy8gTm9ybWFsaXplIGxlYWRpbmcgc2xhc2ggZm9yIGNvbnNpc3RlbmN5LiBMZWFkaW5nIHNsYXNoIG9uIHBhdGhuYW1lIGhhc1xuICAvLyBhbHJlYWR5IGJlZW4gbm9ybWFsaXplZCBpbiBpc0FjdGl2ZS4gU2VlIGNhdmVhdCB0aGVyZS5cbiAgaWYgKGN1cnJlbnRQYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIGN1cnJlbnRQYXRobmFtZSA9ICcvJyArIGN1cnJlbnRQYXRobmFtZTtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgZW5kIG9mIGJvdGggcGF0aCBuYW1lcyB0b28uIE1heWJlIGAvZm9vL2Agc2hvdWxkbid0IHNob3dcbiAgLy8gYC9mb29gIGFzIGFjdGl2ZSwgYnV0IGluIHRoaXMgY2FzZSwgd2Ugd291bGQgYWxyZWFkeSBoYXZlIGZhaWxlZCB0aGVcbiAgLy8gbWF0Y2guXG4gIGlmIChwYXRobmFtZS5jaGFyQXQocGF0aG5hbWUubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgIHBhdGhuYW1lICs9ICcvJztcbiAgfVxuICBpZiAoY3VycmVudFBhdGhuYW1lLmNoYXJBdChjdXJyZW50UGF0aG5hbWUubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgIGN1cnJlbnRQYXRobmFtZSArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gY3VycmVudFBhdGhuYW1lID09PSBwYXRobmFtZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBhdGhuYW1lIG1hdGNoZXMgdGhlIGFjdGl2ZSByb3V0ZXMgYW5kIHBhcmFtcy5cbiAqL1xuZnVuY3Rpb24gcm91dGVJc0FjdGl2ZShwYXRobmFtZSwgcm91dGVzLCBwYXJhbXMpIHtcbiAgdmFyIHJlbWFpbmluZ1BhdGhuYW1lID0gcGF0aG5hbWUsXG4gICAgICBwYXJhbU5hbWVzID0gW10sXG4gICAgICBwYXJhbVZhbHVlcyA9IFtdO1xuXG4gIC8vIGZvci4uLm9mIHdvdWxkIHdvcmsgaGVyZSBidXQgaXQncyBwcm9iYWJseSBzbG93ZXIgcG9zdC10cmFuc3BpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm91dGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHJvdXRlID0gcm91dGVzW2ldO1xuICAgIHZhciBwYXR0ZXJuID0gcm91dGUucGF0aCB8fCAnJztcblxuICAgIGlmIChwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgcGFyYW1OYW1lcyA9IFtdO1xuICAgICAgcGFyYW1WYWx1ZXMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAocmVtYWluaW5nUGF0aG5hbWUgIT09IG51bGwgJiYgcGF0dGVybikge1xuICAgICAgdmFyIG1hdGNoZWQgPSAoMCwgX1BhdHRlcm5VdGlscy5tYXRjaFBhdHRlcm4pKHBhdHRlcm4sIHJlbWFpbmluZ1BhdGhuYW1lKTtcbiAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbWF0Y2hlZC5yZW1haW5pbmdQYXRobmFtZTtcbiAgICAgICAgcGFyYW1OYW1lcyA9IFtdLmNvbmNhdChwYXJhbU5hbWVzLCBtYXRjaGVkLnBhcmFtTmFtZXMpO1xuICAgICAgICBwYXJhbVZhbHVlcyA9IFtdLmNvbmNhdChwYXJhbVZhbHVlcywgbWF0Y2hlZC5wYXJhbVZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1haW5pbmdQYXRobmFtZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW1haW5pbmdQYXRobmFtZSA9PT0gJycpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhbiBleGFjdCBtYXRjaCBvbiB0aGUgcm91dGUuIEp1c3QgY2hlY2sgdGhhdCBhbGwgdGhlIHBhcmFtc1xuICAgICAgICAvLyBtYXRjaC5cbiAgICAgICAgLy8gRklYTUU6IFRoaXMgZG9lc24ndCB3b3JrIG9uIHJlcGVhdGVkIHBhcmFtcy5cbiAgICAgICAgcmV0dXJuIHBhcmFtTmFtZXMuZXZlcnkoZnVuY3Rpb24gKHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHBhcmFtVmFsdWVzW2luZGV4XSkgPT09IFN0cmluZyhwYXJhbXNbcGFyYW1OYW1lXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYWxsIGtleS92YWx1ZSBwYWlycyBpbiB0aGUgZ2l2ZW4gcXVlcnkgYXJlXG4gKiBjdXJyZW50bHkgYWN0aXZlLlxuICovXG5mdW5jdGlvbiBxdWVyeUlzQWN0aXZlKHF1ZXJ5LCBhY3RpdmVRdWVyeSkge1xuICBpZiAoYWN0aXZlUXVlcnkgPT0gbnVsbCkgcmV0dXJuIHF1ZXJ5ID09IG51bGw7XG5cbiAgaWYgKHF1ZXJ5ID09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHJldHVybiBkZWVwRXF1YWwocXVlcnksIGFjdGl2ZVF1ZXJ5KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSA8TGluaz4gdG8gdGhlIGdpdmVuIHBhdGhuYW1lL3F1ZXJ5IGNvbWJpbmF0aW9uIGlzXG4gKiBjdXJyZW50bHkgYWN0aXZlLlxuICovXG5mdW5jdGlvbiBpc0FjdGl2ZShfcmVmLCBpbmRleE9ubHksIGN1cnJlbnRMb2NhdGlvbiwgcm91dGVzLCBwYXJhbXMpIHtcbiAgdmFyIHBhdGhuYW1lID0gX3JlZi5wYXRobmFtZSxcbiAgICAgIHF1ZXJ5ID0gX3JlZi5xdWVyeTtcblxuICBpZiAoY3VycmVudExvY2F0aW9uID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAvLyBUT0RPOiBUaGlzIGlzIGEgYml0IHVnbHkuIEl0IGtlZXBzIGFyb3VuZCBzdXBwb3J0IGZvciB0cmVhdGluZyBwYXRobmFtZXNcbiAgLy8gd2l0aG91dCBwcmVjZWRpbmcgc2xhc2hlcyBhcyBhYnNvbHV0ZSBwYXRocywgYnV0IHBvc3NpYmx5IGFsc28gd29ya3NcbiAgLy8gYXJvdW5kIHRoZSBzYW1lIHF1aXJrcyB3aXRoIGJhc2VuYW1lcyBhcyBpbiBtYXRjaFJvdXRlcy5cbiAgaWYgKHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfVxuXG4gIGlmICghcGF0aElzQWN0aXZlKHBhdGhuYW1lLCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUpKSB7XG4gICAgLy8gVGhlIHBhdGggY2hlY2sgaXMgbmVjZXNzYXJ5IGFuZCBzdWZmaWNpZW50IGZvciBpbmRleE9ubHksIGJ1dCBvdGhlcndpc2VcbiAgICAvLyB3ZSBzdGlsbCBuZWVkIHRvIGNoZWNrIHRoZSByb3V0ZXMuXG4gICAgaWYgKGluZGV4T25seSB8fCAhcm91dGVJc0FjdGl2ZShwYXRobmFtZSwgcm91dGVzLCBwYXJhbXMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHF1ZXJ5SXNBY3RpdmUocXVlcnksIGN1cnJlbnRMb2NhdGlvbi5xdWVyeSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvaXNBY3RpdmUuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xuXG52YXIgX1Byb21pc2VVdGlscyA9IHJlcXVpcmUoJy4vUHJvbWlzZVV0aWxzJyk7XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudHNGb3JSb3V0ZShuZXh0U3RhdGUsIHJvdXRlLCBjYWxsYmFjaykge1xuICBpZiAocm91dGUuY29tcG9uZW50IHx8IHJvdXRlLmNvbXBvbmVudHMpIHtcbiAgICBjYWxsYmFjayhudWxsLCByb3V0ZS5jb21wb25lbnQgfHwgcm91dGUuY29tcG9uZW50cyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGdldENvbXBvbmVudCA9IHJvdXRlLmdldENvbXBvbmVudCB8fCByb3V0ZS5nZXRDb21wb25lbnRzO1xuICBpZiAoZ2V0Q29tcG9uZW50KSB7XG4gICAgdmFyIGNvbXBvbmVudFJldHVybiA9IGdldENvbXBvbmVudC5jYWxsKHJvdXRlLCBuZXh0U3RhdGUsIGNhbGxiYWNrKTtcbiAgICBpZiAoKDAsIF9Qcm9taXNlVXRpbHMuaXNQcm9taXNlKShjb21wb25lbnRSZXR1cm4pKSBjb21wb25lbnRSZXR1cm4udGhlbihmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgY29tcG9uZW50KTtcbiAgICB9LCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IGZldGNoZXMgYWxsIGNvbXBvbmVudHMgbmVlZGVkIGZvciB0aGUgZ2l2ZW4gcm91dGVyXG4gKiBzdGF0ZSBhbmQgY2FsbHMgY2FsbGJhY2soZXJyb3IsIGNvbXBvbmVudHMpIHdoZW4gZmluaXNoZWQuXG4gKlxuICogTm90ZTogVGhpcyBvcGVyYXRpb24gbWF5IGZpbmlzaCBzeW5jaHJvbm91c2x5IGlmIG5vIHJvdXRlcyBoYXZlIGFuXG4gKiBhc3luY2hyb25vdXMgZ2V0Q29tcG9uZW50cyBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudHMobmV4dFN0YXRlLCBjYWxsYmFjaykge1xuICAoMCwgX0FzeW5jVXRpbHMubWFwQXN5bmMpKG5leHRTdGF0ZS5yb3V0ZXMsIGZ1bmN0aW9uIChyb3V0ZSwgaW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgZ2V0Q29tcG9uZW50c0ZvclJvdXRlKG5leHRTdGF0ZSwgcm91dGUsIGNhbGxiYWNrKTtcbiAgfSwgY2FsbGJhY2spO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBnZXRDb21wb25lbnRzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2dldENvbXBvbmVudHMuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbmZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1Byb21pc2VVdGlscy5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBtYXRjaFJvdXRlcztcblxudmFyIF9Bc3luY1V0aWxzID0gcmVxdWlyZSgnLi9Bc3luY1V0aWxzJyk7XG5cbnZhciBfUHJvbWlzZVV0aWxzID0gcmVxdWlyZSgnLi9Qcm9taXNlVXRpbHMnKTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0Q2hpbGRSb3V0ZXMocm91dGUsIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgY2FsbGJhY2spIHtcbiAgaWYgKHJvdXRlLmNoaWxkUm91dGVzKSB7XG4gICAgcmV0dXJuIFtudWxsLCByb3V0ZS5jaGlsZFJvdXRlc107XG4gIH1cbiAgaWYgKCFyb3V0ZS5nZXRDaGlsZFJvdXRlcykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBzeW5jID0gdHJ1ZSxcbiAgICAgIHJlc3VsdCA9IHZvaWQgMDtcblxuICB2YXIgcGFydGlhbE5leHRTdGF0ZSA9IHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgcGFyYW1zOiBjcmVhdGVQYXJhbXMocGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpXG4gIH07XG5cbiAgdmFyIGNoaWxkUm91dGVzUmV0dXJuID0gcm91dGUuZ2V0Q2hpbGRSb3V0ZXMocGFydGlhbE5leHRTdGF0ZSwgZnVuY3Rpb24gKGVycm9yLCBjaGlsZFJvdXRlcykge1xuICAgIGNoaWxkUm91dGVzID0gIWVycm9yICYmICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXMpKGNoaWxkUm91dGVzKTtcbiAgICBpZiAoc3luYykge1xuICAgICAgcmVzdWx0ID0gW2Vycm9yLCBjaGlsZFJvdXRlc107XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2soZXJyb3IsIGNoaWxkUm91dGVzKTtcbiAgfSk7XG5cbiAgaWYgKCgwLCBfUHJvbWlzZVV0aWxzLmlzUHJvbWlzZSkoY2hpbGRSb3V0ZXNSZXR1cm4pKSBjaGlsZFJvdXRlc1JldHVybi50aGVuKGZ1bmN0aW9uIChjaGlsZFJvdXRlcykge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKShjaGlsZFJvdXRlcykpO1xuICB9LCBjYWxsYmFjayk7XG5cbiAgc3luYyA9IGZhbHNlO1xuICByZXR1cm4gcmVzdWx0OyAvLyBNaWdodCBiZSB1bmRlZmluZWQuXG59XG5cbmZ1bmN0aW9uIGdldEluZGV4Um91dGUocm91dGUsIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgY2FsbGJhY2spIHtcbiAgaWYgKHJvdXRlLmluZGV4Um91dGUpIHtcbiAgICBjYWxsYmFjayhudWxsLCByb3V0ZS5pbmRleFJvdXRlKTtcbiAgfSBlbHNlIGlmIChyb3V0ZS5nZXRJbmRleFJvdXRlKSB7XG4gICAgdmFyIHBhcnRpYWxOZXh0U3RhdGUgPSB7XG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICBwYXJhbXM6IGNyZWF0ZVBhcmFtcyhwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4Um91dGVzUmV0dXJuID0gcm91dGUuZ2V0SW5kZXhSb3V0ZShwYXJ0aWFsTmV4dFN0YXRlLCBmdW5jdGlvbiAoZXJyb3IsIGluZGV4Um91dGUpIHtcbiAgICAgIGNhbGxiYWNrKGVycm9yLCAhZXJyb3IgJiYgKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcykoaW5kZXhSb3V0ZSlbMF0pO1xuICAgIH0pO1xuXG4gICAgaWYgKCgwLCBfUHJvbWlzZVV0aWxzLmlzUHJvbWlzZSkoaW5kZXhSb3V0ZXNSZXR1cm4pKSBpbmRleFJvdXRlc1JldHVybi50aGVuKGZ1bmN0aW9uIChpbmRleFJvdXRlKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcykoaW5kZXhSb3V0ZSlbMF0pO1xuICAgIH0sIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmIChyb3V0ZS5jaGlsZFJvdXRlcykge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGF0aGxlc3MgPSByb3V0ZS5jaGlsZFJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkUm91dGUpIHtcbiAgICAgICAgcmV0dXJuICFjaGlsZFJvdXRlLnBhdGg7XG4gICAgICB9KTtcblxuICAgICAgKDAsIF9Bc3luY1V0aWxzLmxvb3BBc3luYykocGF0aGxlc3MubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIG5leHQsIGRvbmUpIHtcbiAgICAgICAgZ2V0SW5kZXhSb3V0ZShwYXRobGVzc1tpbmRleF0sIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgZnVuY3Rpb24gKGVycm9yLCBpbmRleFJvdXRlKSB7XG4gICAgICAgICAgaWYgKGVycm9yIHx8IGluZGV4Um91dGUpIHtcbiAgICAgICAgICAgIHZhciByb3V0ZXMgPSBbcGF0aGxlc3NbaW5kZXhdXS5jb25jYXQoQXJyYXkuaXNBcnJheShpbmRleFJvdXRlKSA/IGluZGV4Um91dGUgOiBbaW5kZXhSb3V0ZV0pO1xuICAgICAgICAgICAgZG9uZShlcnJvciwgcm91dGVzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyLCByb3V0ZXMpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcm91dGVzKTtcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25QYXJhbXMocGFyYW1zLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcykge1xuICByZXR1cm4gcGFyYW1OYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKHBhcmFtcywgcGFyYW1OYW1lLCBpbmRleCkge1xuICAgIHZhciBwYXJhbVZhbHVlID0gcGFyYW1WYWx1ZXMgJiYgcGFyYW1WYWx1ZXNbaW5kZXhdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1zW3BhcmFtTmFtZV0pKSB7XG4gICAgICBwYXJhbXNbcGFyYW1OYW1lXS5wdXNoKHBhcmFtVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lIGluIHBhcmFtcykge1xuICAgICAgcGFyYW1zW3BhcmFtTmFtZV0gPSBbcGFyYW1zW3BhcmFtTmFtZV0sIHBhcmFtVmFsdWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbXNbcGFyYW1OYW1lXSA9IHBhcmFtVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSwgcGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGFyYW1zKHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKSB7XG4gIHJldHVybiBhc3NpZ25QYXJhbXMoe30sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hSb3V0ZURlZXAocm91dGUsIGxvY2F0aW9uLCByZW1haW5pbmdQYXRobmFtZSwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGNhbGxiYWNrKSB7XG4gIHZhciBwYXR0ZXJuID0gcm91dGUucGF0aCB8fCAnJztcblxuICBpZiAocGF0dGVybi5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgcGFyYW1OYW1lcyA9IFtdO1xuICAgIHBhcmFtVmFsdWVzID0gW107XG4gIH1cblxuICAvLyBPbmx5IHRyeSB0byBtYXRjaCB0aGUgcGF0aCBpZiB0aGUgcm91dGUgYWN0dWFsbHkgaGFzIGEgcGF0dGVybiwgYW5kIGlmXG4gIC8vIHdlJ3JlIG5vdCBqdXN0IHNlYXJjaGluZyBmb3IgcG90ZW50aWFsIG5lc3RlZCBhYnNvbHV0ZSBwYXRocy5cbiAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lICE9PSBudWxsICYmIHBhdHRlcm4pIHtcbiAgICB0cnkge1xuICAgICAgdmFyIG1hdGNoZWQgPSAoMCwgX1BhdHRlcm5VdGlscy5tYXRjaFBhdHRlcm4pKHBhdHRlcm4sIHJlbWFpbmluZ1BhdGhuYW1lKTtcbiAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbWF0Y2hlZC5yZW1haW5pbmdQYXRobmFtZTtcbiAgICAgICAgcGFyYW1OYW1lcyA9IFtdLmNvbmNhdChwYXJhbU5hbWVzLCBtYXRjaGVkLnBhcmFtTmFtZXMpO1xuICAgICAgICBwYXJhbVZhbHVlcyA9IFtdLmNvbmNhdChwYXJhbVZhbHVlcywgbWF0Y2hlZC5wYXJhbVZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1haW5pbmdQYXRobmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9XG5cbiAgICAvLyBCeSBhc3N1bXB0aW9uLCBwYXR0ZXJuIGlzIG5vbi1lbXB0eSBoZXJlLCB3aGljaCBpcyB0aGUgcHJlcmVxdWlzaXRlIGZvclxuICAgIC8vIGFjdHVhbGx5IHRlcm1pbmF0aW5nIGEgbWF0Y2guXG4gICAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lID09PSAnJykge1xuICAgICAgdmFyIF9yZXQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgICAgcm91dGVzOiBbcm91dGVdLFxuICAgICAgICAgIHBhcmFtczogY3JlYXRlUGFyYW1zKHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKVxuICAgICAgICB9O1xuXG4gICAgICAgIGdldEluZGV4Um91dGUocm91dGUsIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgZnVuY3Rpb24gKGVycm9yLCBpbmRleFJvdXRlKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGluZGV4Um91dGUpKSB7XG4gICAgICAgICAgICAgIHZhciBfbWF0Y2gkcm91dGVzO1xuXG4gICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGluZGV4Um91dGUuZXZlcnkoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFyb3V0ZS5wYXRoO1xuICAgICAgICAgICAgICB9KSwgJ0luZGV4IHJvdXRlcyBzaG91bGQgbm90IGhhdmUgcGF0aHMnKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgKF9tYXRjaCRyb3V0ZXMgPSBtYXRjaC5yb3V0ZXMpLnB1c2guYXBwbHkoX21hdGNoJHJvdXRlcywgaW5kZXhSb3V0ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4Um91dGUpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoIWluZGV4Um91dGUucGF0aCwgJ0luZGV4IHJvdXRlcyBzaG91bGQgbm90IGhhdmUgcGF0aHMnKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgbWF0Y2gucm91dGVzLnB1c2goaW5kZXhSb3V0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1hdGNoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdjogdm9pZCAwXG4gICAgICAgIH07XG4gICAgICB9KCk7XG5cbiAgICAgIGlmICgodHlwZW9mIF9yZXQyID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihfcmV0MikpID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldDIudjtcbiAgICB9XG4gIH1cblxuICBpZiAocmVtYWluaW5nUGF0aG5hbWUgIT0gbnVsbCB8fCByb3V0ZS5jaGlsZFJvdXRlcykge1xuICAgIC8vIEVpdGhlciBhKSB0aGlzIHJvdXRlIG1hdGNoZWQgYXQgbGVhc3Qgc29tZSBvZiB0aGUgcGF0aCBvciBiKVxuICAgIC8vIHdlIGRvbid0IGhhdmUgdG8gbG9hZCB0aGlzIHJvdXRlJ3MgY2hpbGRyZW4gYXN5bmNocm9ub3VzbHkuIEluXG4gICAgLy8gZWl0aGVyIGNhc2UgY29udGludWUgY2hlY2tpbmcgZm9yIG1hdGNoZXMgaW4gdGhlIHN1YnRyZWUuXG4gICAgdmFyIG9uQ2hpbGRSb3V0ZXMgPSBmdW5jdGlvbiBvbkNoaWxkUm91dGVzKGVycm9yLCBjaGlsZFJvdXRlcykge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRSb3V0ZXMpIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGNoaWxkIHJvdXRlcyB0byBzZWUgaWYgYW55IG9mIHRoZW0gbWF0Y2guXG4gICAgICAgIG1hdGNoUm91dGVzKGNoaWxkUm91dGVzLCBsb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCBtYXRjaCkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIEEgY2hpbGQgcm91dGUgbWF0Y2hlZCEgQXVnbWVudCB0aGUgbWF0Y2ggYW5kIHBhc3MgaXQgdXAgdGhlIHN0YWNrLlxuICAgICAgICAgICAgbWF0Y2gucm91dGVzLnVuc2hpZnQocm91dGUpO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWF0Y2gpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgcmVtYWluaW5nUGF0aG5hbWUsIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXN1bHQgPSBnZXRDaGlsZFJvdXRlcyhyb3V0ZSwgbG9jYXRpb24sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBvbkNoaWxkUm91dGVzKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBvbkNoaWxkUm91dGVzLmFwcGx5KHVuZGVmaW5lZCwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IG1hdGNoZXMgdGhlIGdpdmVuIGxvY2F0aW9uIHRvIGEgc2V0IG9mIHJvdXRlcyBhbmQgY2FsbHNcbiAqIGNhbGxiYWNrKGVycm9yLCBzdGF0ZSkgd2hlbiBmaW5pc2hlZC4gVGhlIHN0YXRlIG9iamVjdCB3aWxsIGhhdmUgdGhlXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAtIHJvdXRlcyAgICAgICBBbiBhcnJheSBvZiByb3V0ZXMgdGhhdCBtYXRjaGVkLCBpbiBoaWVyYXJjaGljYWwgb3JkZXJcbiAqIC0gcGFyYW1zICAgICAgIEFuIG9iamVjdCBvZiBVUkwgcGFyYW1ldGVyc1xuICpcbiAqIE5vdGU6IFRoaXMgb3BlcmF0aW9uIG1heSBmaW5pc2ggc3luY2hyb25vdXNseSBpZiBubyByb3V0ZXMgaGF2ZSBhblxuICogYXN5bmNocm9ub3VzIGdldENoaWxkUm91dGVzIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hSb3V0ZXMocm91dGVzLCBsb2NhdGlvbiwgY2FsbGJhY2ssIHJlbWFpbmluZ1BhdGhuYW1lKSB7XG4gIHZhciBwYXJhbU5hbWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBbXTtcbiAgdmFyIHBhcmFtVmFsdWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBbXTtcblxuICBpZiAocmVtYWluaW5nUGF0aG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFRPRE86IFRoaXMgaXMgYSBsaXR0bGUgYml0IHVnbHksIGJ1dCBpdCB3b3JrcyBhcm91bmQgYSBxdWlyayBpbiBoaXN0b3J5XG4gICAgLy8gdGhhdCBzdHJpcHMgdGhlIGxlYWRpbmcgc2xhc2ggZnJvbSBwYXRobmFtZXMgd2hlbiB1c2luZyBiYXNlbmFtZXMgd2l0aFxuICAgIC8vIHRyYWlsaW5nIHNsYXNoZXMuXG4gICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgICAgICBwYXRobmFtZTogJy8nICsgbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZW1haW5pbmdQYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICB9XG5cbiAgKDAsIF9Bc3luY1V0aWxzLmxvb3BBc3luYykocm91dGVzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCBuZXh0LCBkb25lKSB7XG4gICAgbWF0Y2hSb3V0ZURlZXAocm91dGVzW2luZGV4XSwgbG9jYXRpb24sIHJlbWFpbmluZ1BhdGhuYW1lLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgZnVuY3Rpb24gKGVycm9yLCBtYXRjaCkge1xuICAgICAgaWYgKGVycm9yIHx8IG1hdGNoKSB7XG4gICAgICAgIGRvbmUoZXJyb3IsIG1hdGNoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgY2FsbGJhY2spO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL21hdGNoUm91dGVzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5yb3V0ZXMgPSBleHBvcnRzLnJvdXRlID0gZXhwb3J0cy5jb21wb25lbnRzID0gZXhwb3J0cy5jb21wb25lbnQgPSBleHBvcnRzLmhpc3RvcnkgPSB1bmRlZmluZWQ7XG5leHBvcnRzLmZhbHN5ID0gZmFsc3k7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgZnVuYyA9IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvYmplY3QgPSBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBhcnJheU9mID0gX3JlYWN0LlByb3BUeXBlcy5hcnJheU9mLFxuICAgIG9uZU9mVHlwZSA9IF9yZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlLFxuICAgIGVsZW1lbnQgPSBfcmVhY3QuUHJvcFR5cGVzLmVsZW1lbnQsXG4gICAgc2hhcGUgPSBfcmVhY3QuUHJvcFR5cGVzLnNoYXBlLFxuICAgIHN0cmluZyA9IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nO1xuZnVuY3Rpb24gZmFsc3kocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gIGlmIChwcm9wc1twcm9wTmFtZV0pIHJldHVybiBuZXcgRXJyb3IoJzwnICsgY29tcG9uZW50TmFtZSArICc+IHNob3VsZCBub3QgaGF2ZSBhIFwiJyArIHByb3BOYW1lICsgJ1wiIHByb3AnKTtcbn1cblxudmFyIGhpc3RvcnkgPSBleHBvcnRzLmhpc3RvcnkgPSBzaGFwZSh7XG4gIGxpc3RlbjogZnVuYy5pc1JlcXVpcmVkLFxuICBwdXNoOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHJlcGxhY2U6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ286IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ29CYWNrOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGdvRm9yd2FyZDogZnVuYy5pc1JlcXVpcmVkXG59KTtcblxudmFyIGNvbXBvbmVudCA9IGV4cG9ydHMuY29tcG9uZW50ID0gb25lT2ZUeXBlKFtmdW5jLCBzdHJpbmddKTtcbnZhciBjb21wb25lbnRzID0gZXhwb3J0cy5jb21wb25lbnRzID0gb25lT2ZUeXBlKFtjb21wb25lbnQsIG9iamVjdF0pO1xudmFyIHJvdXRlID0gZXhwb3J0cy5yb3V0ZSA9IG9uZU9mVHlwZShbb2JqZWN0LCBlbGVtZW50XSk7XG52YXIgcm91dGVzID0gZXhwb3J0cy5yb3V0ZXMgPSBvbmVPZlR5cGUoW3JvdXRlLCBhcnJheU9mKHJvdXRlKV0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9JbnRlcm5hbFByb3BUeXBlcy5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfZ2V0Um91dGVQYXJhbXMgPSByZXF1aXJlKCcuL2dldFJvdXRlUGFyYW1zJyk7XG5cbnZhciBfZ2V0Um91dGVQYXJhbXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Um91dGVQYXJhbXMpO1xuXG52YXIgX0NvbnRleHRVdGlscyA9IHJlcXVpcmUoJy4vQ29udGV4dFV0aWxzJyk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXMsXG4gICAgYXJyYXkgPSBfUmVhY3QkUHJvcFR5cGVzLmFycmF5LFxuICAgIGZ1bmMgPSBfUmVhY3QkUHJvcFR5cGVzLmZ1bmMsXG4gICAgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogQSA8Um91dGVyQ29udGV4dD4gcmVuZGVycyB0aGUgY29tcG9uZW50IHRyZWUgZm9yIGEgZ2l2ZW4gcm91dGVyIHN0YXRlXG4gKiBhbmQgc2V0cyB0aGUgaGlzdG9yeSBvYmplY3QgYW5kIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIGNvbnRleHQuXG4gKi9cblxudmFyIFJvdXRlckNvbnRleHQgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JvdXRlckNvbnRleHQnLFxuXG5cbiAgbWl4aW5zOiBbKDAsIF9Db250ZXh0VXRpbHMuQ29udGV4dFByb3ZpZGVyKSgncm91dGVyJyldLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHJvdXRlcjogb2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgbG9jYXRpb246IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHJvdXRlczogYXJyYXkuaXNSZXF1aXJlZCxcbiAgICBwYXJhbXM6IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIGNvbXBvbmVudHM6IGFycmF5LmlzUmVxdWlyZWQsXG4gICAgY3JlYXRlRWxlbWVudDogZnVuYy5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZUVsZW1lbnQ6IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50XG4gICAgfTtcbiAgfSxcblxuXG4gIGNoaWxkQ29udGV4dFR5cGVzOiB7XG4gICAgcm91dGVyOiBvYmplY3QuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldENoaWxkQ29udGV4dDogZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZXI6IHRoaXMucHJvcHMucm91dGVyXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudCA9PSBudWxsID8gbnVsbCA6IHRoaXMucHJvcHMuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBsb2NhdGlvbiA9IF9wcm9wcy5sb2NhdGlvbixcbiAgICAgICAgcm91dGVzID0gX3Byb3BzLnJvdXRlcyxcbiAgICAgICAgcGFyYW1zID0gX3Byb3BzLnBhcmFtcyxcbiAgICAgICAgY29tcG9uZW50cyA9IF9wcm9wcy5jb21wb25lbnRzLFxuICAgICAgICByb3V0ZXIgPSBfcHJvcHMucm91dGVyO1xuXG4gICAgdmFyIGVsZW1lbnQgPSBudWxsO1xuXG4gICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgIGVsZW1lbnQgPSBjb21wb25lbnRzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChlbGVtZW50LCBjb21wb25lbnRzLCBpbmRleCkge1xuICAgICAgICBpZiAoY29tcG9uZW50cyA9PSBudWxsKSByZXR1cm4gZWxlbWVudDsgLy8gRG9uJ3QgY3JlYXRlIG5ldyBjaGlsZHJlbjsgdXNlIHRoZSBncmFuZGNoaWxkcmVuLlxuXG4gICAgICAgIHZhciByb3V0ZSA9IHJvdXRlc1tpbmRleF07XG4gICAgICAgIHZhciByb3V0ZVBhcmFtcyA9ICgwLCBfZ2V0Um91dGVQYXJhbXMyLmRlZmF1bHQpKHJvdXRlLCBwYXJhbXMpO1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgIHJvdXRlOiByb3V0ZSxcbiAgICAgICAgICByb3V0ZXI6IHJvdXRlcixcbiAgICAgICAgICByb3V0ZVBhcmFtczogcm91dGVQYXJhbXMsXG4gICAgICAgICAgcm91dGVzOiByb3V0ZXNcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoKDAsIF9Sb3V0ZVV0aWxzLmlzUmVhY3RDaGlsZHJlbikoZWxlbWVudCkpIHtcbiAgICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IGVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlbGVtZW50LCBwcm9wKSkgcHJvcHNbcHJvcF0gPSBlbGVtZW50W3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgodHlwZW9mIGNvbXBvbmVudHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbXBvbmVudHMpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB2YXIgZWxlbWVudHMgPSB7fTtcblxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBjb21wb25lbnRzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbXBvbmVudHMsIGtleSkpIHtcbiAgICAgICAgICAgICAgLy8gUGFzcyB0aHJvdWdoIHRoZSBrZXkgYXMgYSBwcm9wIHRvIGNyZWF0ZUVsZW1lbnQgdG8gYWxsb3dcbiAgICAgICAgICAgICAgLy8gY3VzdG9tIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb25zIHRvIGtub3cgd2hpY2ggbmFtZWQgY29tcG9uZW50XG4gICAgICAgICAgICAgIC8vIHRoZXkncmUgcmVuZGVyaW5nLCBmb3IgZS5nLiBtYXRjaGluZyB1cCB0byBmZXRjaGVkIGRhdGEuXG4gICAgICAgICAgICAgIGVsZW1lbnRzW2tleV0gPSBfdGhpcy5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNba2V5XSwgX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIGtleToga2V5IH0sIHByb3BzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90aGlzLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50cywgcHJvcHMpO1xuICAgICAgfSwgZWxlbWVudCk7XG4gICAgfVxuXG4gICAgIShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlIHx8IF9yZWFjdDIuZGVmYXVsdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnVGhlIHJvb3Qgcm91dGUgbXVzdCByZW5kZXIgYSBzaW5nbGUgZWxlbWVudCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGVyQ29udGV4dDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXJDb250ZXh0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XG5cbi8qKlxuICogRXh0cmFjdHMgYW4gb2JqZWN0IG9mIHBhcmFtcyB0aGUgZ2l2ZW4gcm91dGUgY2FyZXMgYWJvdXQgZnJvbVxuICogdGhlIGdpdmVuIHBhcmFtcyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGdldFJvdXRlUGFyYW1zKHJvdXRlLCBwYXJhbXMpIHtcbiAgdmFyIHJvdXRlUGFyYW1zID0ge307XG5cbiAgaWYgKCFyb3V0ZS5wYXRoKSByZXR1cm4gcm91dGVQYXJhbXM7XG5cbiAgKDAsIF9QYXR0ZXJuVXRpbHMuZ2V0UGFyYW1OYW1lcykocm91dGUucGF0aCkuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCBwKSkge1xuICAgICAgcm91dGVQYXJhbXNbcF0gPSBwYXJhbXNbcF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcm91dGVQYXJhbXM7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGdldFJvdXRlUGFyYW1zO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2dldFJvdXRlUGFyYW1zLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkNvbnRleHRTdWJzY3JpYmVyID0gQ29udGV4dFN1YnNjcmliZXI7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vLyBXb3JrcyBhcm91bmQgaXNzdWVzIHdpdGggY29udGV4dCB1cGRhdGVzIGZhaWxpbmcgdG8gcHJvcGFnYXRlLlxuLy8gQ2F2ZWF0OiB0aGUgY29udGV4dCB2YWx1ZSBpcyBleHBlY3RlZCB0byBuZXZlciBjaGFuZ2UgaXRzIGlkZW50aXR5LlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yNTE3XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yb3V0ZXIvaXNzdWVzLzQ3MFxuXG52YXIgY29udGV4dFByb3ZpZGVyU2hhcGUgPSBfcmVhY3QuUHJvcFR5cGVzLnNoYXBlKHtcbiAgc3Vic2NyaWJlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgZXZlbnRJbmRleDogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxufSk7XG5cbmZ1bmN0aW9uIG1ha2VDb250ZXh0TmFtZShuYW1lKSB7XG4gIHJldHVybiAnQEBjb250ZXh0U3Vic2NyaWJlci8nICsgbmFtZTtcbn1cblxuZnVuY3Rpb24gQ29udGV4dFByb3ZpZGVyKG5hbWUpIHtcbiAgdmFyIF9jaGlsZENvbnRleHRUeXBlcywgX3JlZjI7XG5cbiAgdmFyIGNvbnRleHROYW1lID0gbWFrZUNvbnRleHROYW1lKG5hbWUpO1xuICB2YXIgbGlzdGVuZXJzS2V5ID0gY29udGV4dE5hbWUgKyAnL2xpc3RlbmVycyc7XG4gIHZhciBldmVudEluZGV4S2V5ID0gY29udGV4dE5hbWUgKyAnL2V2ZW50SW5kZXgnO1xuICB2YXIgc3Vic2NyaWJlS2V5ID0gY29udGV4dE5hbWUgKyAnL3N1YnNjcmliZSc7XG5cbiAgcmV0dXJuIF9yZWYyID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiAoX2NoaWxkQ29udGV4dFR5cGVzID0ge30sIF9jaGlsZENvbnRleHRUeXBlc1tjb250ZXh0TmFtZV0gPSBjb250ZXh0UHJvdmlkZXJTaGFwZS5pc1JlcXVpcmVkLCBfY2hpbGRDb250ZXh0VHlwZXMpLFxuXG4gICAgZ2V0Q2hpbGRDb250ZXh0OiBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltjb250ZXh0TmFtZV0gPSB7XG4gICAgICAgIGV2ZW50SW5kZXg6IHRoaXNbZXZlbnRJbmRleEtleV0sXG4gICAgICAgIHN1YnNjcmliZTogdGhpc1tzdWJzY3JpYmVLZXldXG4gICAgICB9LCBfcmVmO1xuICAgIH0sXG4gICAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICB0aGlzW2xpc3RlbmVyc0tleV0gPSBbXTtcbiAgICAgIHRoaXNbZXZlbnRJbmRleEtleV0gPSAwO1xuICAgIH0sXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpIHtcbiAgICAgIHRoaXNbZXZlbnRJbmRleEtleV0rKztcbiAgICB9LFxuICAgIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpc1tsaXN0ZW5lcnNLZXldLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcihfdGhpc1tldmVudEluZGV4S2V5XSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIF9yZWYyW3N1YnNjcmliZUtleV0gPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIC8vIE5vIG5lZWQgdG8gaW1tZWRpYXRlbHkgY2FsbCBsaXN0ZW5lciBoZXJlLlxuICAgIHRoaXNbbGlzdGVuZXJzS2V5XS5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczJbbGlzdGVuZXJzS2V5XSA9IF90aGlzMltsaXN0ZW5lcnNLZXldLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBfcmVmMjtcbn1cblxuZnVuY3Rpb24gQ29udGV4dFN1YnNjcmliZXIobmFtZSkge1xuICB2YXIgX2NvbnRleHRUeXBlcywgX3JlZjQ7XG5cbiAgdmFyIGNvbnRleHROYW1lID0gbWFrZUNvbnRleHROYW1lKG5hbWUpO1xuICB2YXIgbGFzdFJlbmRlcmVkRXZlbnRJbmRleEtleSA9IGNvbnRleHROYW1lICsgJy9sYXN0UmVuZGVyZWRFdmVudEluZGV4JztcbiAgdmFyIGhhbmRsZUNvbnRleHRVcGRhdGVLZXkgPSBjb250ZXh0TmFtZSArICcvaGFuZGxlQ29udGV4dFVwZGF0ZSc7XG4gIHZhciB1bnN1YnNjcmliZUtleSA9IGNvbnRleHROYW1lICsgJy91bnN1YnNjcmliZSc7XG5cbiAgcmV0dXJuIF9yZWY0ID0ge1xuICAgIGNvbnRleHRUeXBlczogKF9jb250ZXh0VHlwZXMgPSB7fSwgX2NvbnRleHRUeXBlc1tjb250ZXh0TmFtZV0gPSBjb250ZXh0UHJvdmlkZXJTaGFwZSwgX2NvbnRleHRUeXBlcyksXG5cbiAgICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICAgIHZhciBfcmVmMztcblxuICAgICAgaWYgKCF0aGlzLmNvbnRleHRbY29udGV4dE5hbWVdKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9yZWYzID0ge30sIF9yZWYzW2xhc3RSZW5kZXJlZEV2ZW50SW5kZXhLZXldID0gdGhpcy5jb250ZXh0W2NvbnRleHROYW1lXS5ldmVudEluZGV4LCBfcmVmMztcbiAgICB9LFxuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0W2NvbnRleHROYW1lXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXNbdW5zdWJzY3JpYmVLZXldID0gdGhpcy5jb250ZXh0W2NvbnRleHROYW1lXS5zdWJzY3JpYmUodGhpc1toYW5kbGVDb250ZXh0VXBkYXRlS2V5XSk7XG4gICAgfSxcbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkge1xuICAgICAgdmFyIF9zZXRTdGF0ZTtcblxuICAgICAgaWYgKCF0aGlzLmNvbnRleHRbY29udGV4dE5hbWVdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTdGF0ZSgoX3NldFN0YXRlID0ge30sIF9zZXRTdGF0ZVtsYXN0UmVuZGVyZWRFdmVudEluZGV4S2V5XSA9IHRoaXMuY29udGV4dFtjb250ZXh0TmFtZV0uZXZlbnRJbmRleCwgX3NldFN0YXRlKSk7XG4gICAgfSxcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICBpZiAoIXRoaXNbdW5zdWJzY3JpYmVLZXldKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpc1t1bnN1YnNjcmliZUtleV0oKTtcbiAgICAgIHRoaXNbdW5zdWJzY3JpYmVLZXldID0gbnVsbDtcbiAgICB9XG4gIH0sIF9yZWY0W2hhbmRsZUNvbnRleHRVcGRhdGVLZXldID0gZnVuY3Rpb24gKGV2ZW50SW5kZXgpIHtcbiAgICBpZiAoZXZlbnRJbmRleCAhPT0gdGhpcy5zdGF0ZVtsYXN0UmVuZGVyZWRFdmVudEluZGV4S2V5XSkge1xuICAgICAgdmFyIF9zZXRTdGF0ZTI7XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoKF9zZXRTdGF0ZTIgPSB7fSwgX3NldFN0YXRlMltsYXN0UmVuZGVyZWRFdmVudEluZGV4S2V5XSA9IGV2ZW50SW5kZXgsIF9zZXRTdGF0ZTIpKTtcbiAgICB9XG4gIH0sIF9yZWY0O1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9Db250ZXh0VXRpbHMuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5jcmVhdGVSb3V0ZXJPYmplY3QgPSBjcmVhdGVSb3V0ZXJPYmplY3Q7XG5leHBvcnRzLmFzc2lnblJvdXRlclN0YXRlID0gYXNzaWduUm91dGVyU3RhdGU7XG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXJPYmplY3QoaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIsIHN0YXRlKSB7XG4gIHZhciByb3V0ZXIgPSBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIHNldFJvdXRlTGVhdmVIb29rOiB0cmFuc2l0aW9uTWFuYWdlci5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUsXG4gICAgaXNBY3RpdmU6IHRyYW5zaXRpb25NYW5hZ2VyLmlzQWN0aXZlXG4gIH0pO1xuXG4gIHJldHVybiBhc3NpZ25Sb3V0ZXJTdGF0ZShyb3V0ZXIsIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gYXNzaWduUm91dGVyU3RhdGUocm91dGVyLCBfcmVmKSB7XG4gIHZhciBsb2NhdGlvbiA9IF9yZWYubG9jYXRpb24sXG4gICAgICBwYXJhbXMgPSBfcmVmLnBhcmFtcyxcbiAgICAgIHJvdXRlcyA9IF9yZWYucm91dGVzO1xuXG4gIHJvdXRlci5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICByb3V0ZXIucGFyYW1zID0gcGFyYW1zO1xuICByb3V0ZXIucm91dGVzID0gcm91dGVzO1xuXG4gIHJldHVybiByb3V0ZXI7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlclV0aWxzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9Qcm9wVHlwZXMnKTtcblxudmFyIF9Db250ZXh0VXRpbHMgPSByZXF1aXJlKCcuL0NvbnRleHRVdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcyxcbiAgICBib29sID0gX1JlYWN0JFByb3BUeXBlcy5ib29sLFxuICAgIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0LFxuICAgIHN0cmluZyA9IF9SZWFjdCRQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGZ1bmMgPSBfUmVhY3QkUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25lT2ZUeXBlID0gX1JlYWN0JFByb3BUeXBlcy5vbmVPZlR5cGU7XG5cblxuZnVuY3Rpb24gaXNMZWZ0Q2xpY2tFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQuYnV0dG9uID09PSAwO1xufVxuXG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufVxuXG4vLyBUT0RPOiBEZS1kdXBsaWNhdGUgYWdhaW5zdCBoYXNBbnlQcm9wZXJ0aWVzIGluIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLlxuZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmplY3QpIHtcbiAgZm9yICh2YXIgcCBpbiBvYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcCkpIHJldHVybiBmYWxzZTtcbiAgfXJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlVG9Mb2NhdGlvbih0bywgcm91dGVyKSB7XG4gIHJldHVybiB0eXBlb2YgdG8gPT09ICdmdW5jdGlvbicgPyB0byhyb3V0ZXIubG9jYXRpb24pIDogdG87XG59XG5cbi8qKlxuICogQSA8TGluaz4gaXMgdXNlZCB0byBjcmVhdGUgYW4gPGE+IGVsZW1lbnQgdGhhdCBsaW5rcyB0byBhIHJvdXRlLlxuICogV2hlbiB0aGF0IHJvdXRlIGlzIGFjdGl2ZSwgdGhlIGxpbmsgZ2V0cyB0aGUgdmFsdWUgb2YgaXRzXG4gKiBhY3RpdmVDbGFzc05hbWUgcHJvcC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgYXNzdW1pbmcgeW91IGhhdmUgdGhlIGZvbGxvd2luZyByb3V0ZTpcbiAqXG4gKiAgIDxSb3V0ZSBwYXRoPVwiL3Bvc3RzLzpwb3N0SURcIiBjb21wb25lbnQ9e1Bvc3R9IC8+XG4gKlxuICogWW91IGNvdWxkIHVzZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudCB0byBsaW5rIHRvIHRoYXQgcm91dGU6XG4gKlxuICogICA8TGluayB0bz17YC9wb3N0cy8ke3Bvc3QuaWR9YH0gLz5cbiAqXG4gKiBMaW5rcyBtYXkgcGFzcyBhbG9uZyBsb2NhdGlvbiBzdGF0ZSBhbmQvb3IgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnNcbiAqIGluIHRoZSBzdGF0ZS9xdWVyeSBwcm9wcywgcmVzcGVjdGl2ZWx5LlxuICpcbiAqICAgPExpbmsgLi4uIHF1ZXJ5PXt7IHNob3c6IHRydWUgfX0gc3RhdGU9e3sgdGhlOiAnc3RhdGUnIH19IC8+XG4gKi9cbnZhciBMaW5rID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdMaW5rJyxcblxuXG4gIG1peGluczogWygwLCBfQ29udGV4dFV0aWxzLkNvbnRleHRTdWJzY3JpYmVyKSgncm91dGVyJyldLFxuXG4gIGNvbnRleHRUeXBlczoge1xuICAgIHJvdXRlcjogX1Byb3BUeXBlcy5yb3V0ZXJTaGFwZVxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIHRvOiBvbmVPZlR5cGUoW3N0cmluZywgb2JqZWN0LCBmdW5jXSksXG4gICAgcXVlcnk6IG9iamVjdCxcbiAgICBoYXNoOiBzdHJpbmcsXG4gICAgc3RhdGU6IG9iamVjdCxcbiAgICBhY3RpdmVTdHlsZTogb2JqZWN0LFxuICAgIGFjdGl2ZUNsYXNzTmFtZTogc3RyaW5nLFxuICAgIG9ubHlBY3RpdmVPbkluZGV4OiBib29sLmlzUmVxdWlyZWQsXG4gICAgb25DbGljazogZnVuYyxcbiAgICB0YXJnZXQ6IHN0cmluZ1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbmx5QWN0aXZlT25JbmRleDogZmFsc2UsXG4gICAgICBzdHlsZToge31cbiAgICB9O1xuICB9LFxuICBoYW5kbGVDbGljazogZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vbkNsaWNrKSB0aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuXG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgIHZhciByb3V0ZXIgPSB0aGlzLmNvbnRleHQucm91dGVyO1xuXG4gICAgIXJvdXRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICc8TGluaz5zIHJlbmRlcmVkIG91dHNpZGUgb2YgYSByb3V0ZXIgY29udGV4dCBjYW5ub3QgbmF2aWdhdGUuJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgaWYgKGlzTW9kaWZpZWRFdmVudChldmVudCkgfHwgIWlzTGVmdENsaWNrRXZlbnQoZXZlbnQpKSByZXR1cm47XG5cbiAgICAvLyBJZiB0YXJnZXQgcHJvcCBpcyBzZXQgKGUuZy4gdG8gXCJfYmxhbmtcIiksIGxldCBicm93c2VyIGhhbmRsZSBsaW5rLlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogdW50ZXN0YWJsZSB3aXRoIEthcm1hICovXG4gICAgaWYgKHRoaXMucHJvcHMudGFyZ2V0KSByZXR1cm47XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgcm91dGVyLnB1c2gocmVzb2x2ZVRvTG9jYXRpb24odGhpcy5wcm9wcy50bywgcm91dGVyKSk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICB0byA9IF9wcm9wcy50byxcbiAgICAgICAgYWN0aXZlQ2xhc3NOYW1lID0gX3Byb3BzLmFjdGl2ZUNsYXNzTmFtZSxcbiAgICAgICAgYWN0aXZlU3R5bGUgPSBfcHJvcHMuYWN0aXZlU3R5bGUsXG4gICAgICAgIG9ubHlBY3RpdmVPbkluZGV4ID0gX3Byb3BzLm9ubHlBY3RpdmVPbkluZGV4LFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsndG8nLCAnYWN0aXZlQ2xhc3NOYW1lJywgJ2FjdGl2ZVN0eWxlJywgJ29ubHlBY3RpdmVPbkluZGV4J10pO1xuXG4gICAgLy8gSWdub3JlIGlmIHJlbmRlcmVkIG91dHNpZGUgdGhlIGNvbnRleHQgb2Ygcm91dGVyIHRvIHNpbXBsaWZ5IHVuaXQgdGVzdGluZy5cblxuXG4gICAgdmFyIHJvdXRlciA9IHRoaXMuY29udGV4dC5yb3V0ZXI7XG5cblxuICAgIGlmIChyb3V0ZXIpIHtcbiAgICAgIC8vIElmIHVzZXIgZG9lcyBub3Qgc3BlY2lmeSBhIGB0b2AgcHJvcCwgcmV0dXJuIGFuIGVtcHR5IGFuY2hvciB0YWcuXG4gICAgICBpZiAodG8gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoJ2EnLCBwcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b0xvY2F0aW9uID0gcmVzb2x2ZVRvTG9jYXRpb24odG8sIHJvdXRlcik7XG4gICAgICBwcm9wcy5ocmVmID0gcm91dGVyLmNyZWF0ZUhyZWYodG9Mb2NhdGlvbik7XG5cbiAgICAgIGlmIChhY3RpdmVDbGFzc05hbWUgfHwgYWN0aXZlU3R5bGUgIT0gbnVsbCAmJiAhaXNFbXB0eU9iamVjdChhY3RpdmVTdHlsZSkpIHtcbiAgICAgICAgaWYgKHJvdXRlci5pc0FjdGl2ZSh0b0xvY2F0aW9uLCBvbmx5QWN0aXZlT25JbmRleCkpIHtcbiAgICAgICAgICBpZiAoYWN0aXZlQ2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgIHByb3BzLmNsYXNzTmFtZSArPSAnICcgKyBhY3RpdmVDbGFzc05hbWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcm9wcy5jbGFzc05hbWUgPSBhY3RpdmVDbGFzc05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFjdGl2ZVN0eWxlKSBwcm9wcy5zdHlsZSA9IF9leHRlbmRzKHt9LCBwcm9wcy5zdHlsZSwgYWN0aXZlU3R5bGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdhJywgX2V4dGVuZHMoe30sIHByb3BzLCB7IG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xpY2sgfSkpO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTGluaztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9MaW5rLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfTGluayA9IHJlcXVpcmUoJy4vTGluaycpO1xuXG52YXIgX0xpbmsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGluayk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogQW4gPEluZGV4TGluaz4gaXMgdXNlZCB0byBsaW5rIHRvIGFuIDxJbmRleFJvdXRlPi5cbiAqL1xudmFyIEluZGV4TGluayA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnSW5kZXhMaW5rJyxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9MaW5rMi5kZWZhdWx0LCBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywgeyBvbmx5QWN0aXZlT25JbmRleDogdHJ1ZSB9KSk7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJbmRleExpbms7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhMaW5rLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSB3aXRoUm91dGVyO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfaG9pc3ROb25SZWFjdFN0YXRpY3MgPSByZXF1aXJlKCdob2lzdC1ub24tcmVhY3Qtc3RhdGljcycpO1xuXG52YXIgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hvaXN0Tm9uUmVhY3RTdGF0aWNzKTtcblxudmFyIF9Db250ZXh0VXRpbHMgPSByZXF1aXJlKCcuL0NvbnRleHRVdGlscycpO1xuXG52YXIgX1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpIHtcbiAgcmV0dXJuIFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xufVxuXG5mdW5jdGlvbiB3aXRoUm91dGVyKFdyYXBwZWRDb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgdmFyIHdpdGhSZWYgPSBvcHRpb25zICYmIG9wdGlvbnMud2l0aFJlZjtcblxuICB2YXIgV2l0aFJvdXRlciA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gICAgZGlzcGxheU5hbWU6ICdXaXRoUm91dGVyJyxcblxuICAgIG1peGluczogWygwLCBfQ29udGV4dFV0aWxzLkNvbnRleHRTdWJzY3JpYmVyKSgncm91dGVyJyldLFxuXG4gICAgY29udGV4dFR5cGVzOiB7IHJvdXRlcjogX1Byb3BUeXBlcy5yb3V0ZXJTaGFwZSB9LFxuICAgIHByb3BUeXBlczogeyByb3V0ZXI6IF9Qcm9wVHlwZXMucm91dGVyU2hhcGUgfSxcblxuICAgIGdldFdyYXBwZWRJbnN0YW5jZTogZnVuY3Rpb24gZ2V0V3JhcHBlZEluc3RhbmNlKCkge1xuICAgICAgIXdpdGhSZWYgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnVG8gYWNjZXNzIHRoZSB3cmFwcGVkIGluc3RhbmNlLCB5b3UgbmVlZCB0byBzcGVjaWZ5ICcgKyAnYHsgd2l0aFJlZjogdHJ1ZSB9YCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9mIHRoZSB3aXRoUm91dGVyKCkgY2FsbC4nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWRJbnN0YW5jZTtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHJvdXRlciA9IHRoaXMucHJvcHMucm91dGVyIHx8IHRoaXMuY29udGV4dC5yb3V0ZXI7XG4gICAgICB2YXIgcGFyYW1zID0gcm91dGVyLnBhcmFtcyxcbiAgICAgICAgICBsb2NhdGlvbiA9IHJvdXRlci5sb2NhdGlvbixcbiAgICAgICAgICByb3V0ZXMgPSByb3V0ZXIucm91dGVzO1xuXG4gICAgICB2YXIgcHJvcHMgPSBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywgeyByb3V0ZXI6IHJvdXRlciwgcGFyYW1zOiBwYXJhbXMsIGxvY2F0aW9uOiBsb2NhdGlvbiwgcm91dGVzOiByb3V0ZXMgfSk7XG5cbiAgICAgIGlmICh3aXRoUmVmKSB7XG4gICAgICAgIHByb3BzLnJlZiA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgX3RoaXMud3JhcHBlZEluc3RhbmNlID0gYztcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFdyYXBwZWRDb21wb25lbnQsIHByb3BzKTtcbiAgICB9XG4gIH0pO1xuXG4gIFdpdGhSb3V0ZXIuZGlzcGxheU5hbWUgPSAnd2l0aFJvdXRlcignICsgZ2V0RGlzcGxheU5hbWUoV3JhcHBlZENvbXBvbmVudCkgKyAnKSc7XG4gIFdpdGhSb3V0ZXIuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG5cbiAgcmV0dXJuICgwLCBfaG9pc3ROb25SZWFjdFN0YXRpY3MyLmRlZmF1bHQpKFdpdGhSb3V0ZXIsIFdyYXBwZWRDb21wb25lbnQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL3dpdGhSb3V0ZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIG1peGluczogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZVxufTtcblxudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gICAgbmFtZTogdHJ1ZSxcbiAgICBsZW5ndGg6IHRydWUsXG4gICAgcHJvdG90eXBlOiB0cnVlLFxuICAgIGNhbGxlcjogdHJ1ZSxcbiAgICBhcmd1bWVudHM6IHRydWUsXG4gICAgYXJpdHk6IHRydWVcbn07XG5cbnZhciBpc0dldE93blByb3BlcnR5U3ltYm9sc0F2YWlsYWJsZSA9IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBjdXN0b21TdGF0aWNzKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7IC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHNBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIVJFQUNUX1NUQVRJQ1Nba2V5c1tpXV0gJiYgIUtOT1dOX1NUQVRJQ1Nba2V5c1tpXV0gJiYgKCFjdXN0b21TdGF0aWNzIHx8ICFjdXN0b21TdGF0aWNzW2tleXNbaV1dKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENvbXBvbmVudFtrZXlzW2ldXSA9IHNvdXJjZUNvbXBvbmVudFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUmVkaXJlY3QgPSByZXF1aXJlKCcuL1JlZGlyZWN0Jyk7XG5cbnZhciBfUmVkaXJlY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVkaXJlY3QpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXMsXG4gICAgc3RyaW5nID0gX1JlYWN0JFByb3BUeXBlcy5zdHJpbmcsXG4gICAgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogQW4gPEluZGV4UmVkaXJlY3Q+IGlzIHVzZWQgdG8gcmVkaXJlY3QgZnJvbSBhbiBpbmRleFJvdXRlLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9yZXF1aXJlLXJlbmRlci1yZXR1cm4gKi9cblxudmFyIEluZGV4UmVkaXJlY3QgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0luZGV4UmVkaXJlY3QnLFxuXG5cbiAgc3RhdGljczoge1xuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogZnVuY3Rpb24gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQsIHBhcmVudFJvdXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogc2FuaXR5IGNoZWNrICovXG4gICAgICBpZiAocGFyZW50Um91dGUpIHtcbiAgICAgICAgcGFyZW50Um91dGUuaW5kZXhSb3V0ZSA9IF9SZWRpcmVjdDIuZGVmYXVsdC5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0FuIDxJbmRleFJlZGlyZWN0PiBkb2VzIG5vdCBtYWtlIHNlbnNlIGF0IHRoZSByb290IG9mIHlvdXIgcm91dGUgY29uZmlnJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIHRvOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBxdWVyeTogb2JqZWN0LFxuICAgIHN0YXRlOiBvYmplY3QsXG4gICAgb25FbnRlcjogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5LFxuICAgIGNoaWxkcmVuOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3lcbiAgfSxcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICc8SW5kZXhSZWRpcmVjdD4gZWxlbWVudHMgYXJlIGZvciByb3V0ZXIgY29uZmlndXJhdGlvbiBvbmx5IGFuZCBzaG91bGQgbm90IGJlIHJlbmRlcmVkJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSW5kZXhSZWRpcmVjdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9JbmRleFJlZGlyZWN0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcyxcbiAgICBzdHJpbmcgPSBfUmVhY3QkUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBBIDxSZWRpcmVjdD4gaXMgdXNlZCB0byBkZWNsYXJlIGFub3RoZXIgVVJMIHBhdGggYSBjbGllbnQgc2hvdWxkXG4gKiBiZSBzZW50IHRvIHdoZW4gdGhleSByZXF1ZXN0IGEgZ2l2ZW4gVVJMLlxuICpcbiAqIFJlZGlyZWN0cyBhcmUgcGxhY2VkIGFsb25nc2lkZSByb3V0ZXMgaW4gdGhlIHJvdXRlIGNvbmZpZ3VyYXRpb25cbiAqIGFuZCBhcmUgdHJhdmVyc2VkIGluIHRoZSBzYW1lIG1hbm5lci5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcmVxdWlyZS1yZW5kZXItcmV0dXJuICovXG5cbnZhciBSZWRpcmVjdCA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVkaXJlY3QnLFxuXG5cbiAgc3RhdGljczoge1xuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogZnVuY3Rpb24gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHZhciByb3V0ZSA9ICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQpKGVsZW1lbnQpO1xuXG4gICAgICBpZiAocm91dGUuZnJvbSkgcm91dGUucGF0aCA9IHJvdXRlLmZyb207XG5cbiAgICAgIHJvdXRlLm9uRW50ZXIgPSBmdW5jdGlvbiAobmV4dFN0YXRlLCByZXBsYWNlKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IG5leHRTdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgICAgIHBhcmFtcyA9IG5leHRTdGF0ZS5wYXJhbXM7XG5cblxuICAgICAgICB2YXIgcGF0aG5hbWUgPSB2b2lkIDA7XG4gICAgICAgIGlmIChyb3V0ZS50by5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9QYXR0ZXJuVXRpbHMuZm9ybWF0UGF0dGVybikocm91dGUudG8sIHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXJvdXRlLnRvKSB7XG4gICAgICAgICAgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcm91dGVJbmRleCA9IG5leHRTdGF0ZS5yb3V0ZXMuaW5kZXhPZihyb3V0ZSk7XG4gICAgICAgICAgdmFyIHBhcmVudFBhdHRlcm4gPSBSZWRpcmVjdC5nZXRSb3V0ZVBhdHRlcm4obmV4dFN0YXRlLnJvdXRlcywgcm91dGVJbmRleCAtIDEpO1xuICAgICAgICAgIHZhciBwYXR0ZXJuID0gcGFyZW50UGF0dGVybi5yZXBsYWNlKC9cXC8qJC8sICcvJykgKyByb3V0ZS50bztcbiAgICAgICAgICBwYXRobmFtZSA9ICgwLCBfUGF0dGVyblV0aWxzLmZvcm1hdFBhdHRlcm4pKHBhdHRlcm4sIHBhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXBsYWNlKHtcbiAgICAgICAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgICAgICAgcXVlcnk6IHJvdXRlLnF1ZXJ5IHx8IGxvY2F0aW9uLnF1ZXJ5LFxuICAgICAgICAgIHN0YXRlOiByb3V0ZS5zdGF0ZSB8fCBsb2NhdGlvbi5zdGF0ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByb3V0ZTtcbiAgICB9LFxuICAgIGdldFJvdXRlUGF0dGVybjogZnVuY3Rpb24gZ2V0Um91dGVQYXR0ZXJuKHJvdXRlcywgcm91dGVJbmRleCkge1xuICAgICAgdmFyIHBhcmVudFBhdHRlcm4gPSAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IHJvdXRlSW5kZXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciByb3V0ZSA9IHJvdXRlc1tpXTtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSByb3V0ZS5wYXRoIHx8ICcnO1xuXG4gICAgICAgIHBhcmVudFBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoL1xcLyokLywgJy8nKSArIHBhcmVudFBhdHRlcm47XG5cbiAgICAgICAgaWYgKHBhdHRlcm4uaW5kZXhPZignLycpID09PSAwKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcvJyArIHBhcmVudFBhdHRlcm47XG4gICAgfVxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIHBhdGg6IHN0cmluZyxcbiAgICBmcm9tOiBzdHJpbmcsIC8vIEFsaWFzIGZvciBwYXRoXG4gICAgdG86IHN0cmluZy5pc1JlcXVpcmVkLFxuICAgIHF1ZXJ5OiBvYmplY3QsXG4gICAgc3RhdGU6IG9iamVjdCxcbiAgICBvbkVudGVyOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3ksXG4gICAgY2hpbGRyZW46IF9JbnRlcm5hbFByb3BUeXBlcy5mYWxzeVxuICB9LFxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxSZWRpcmVjdD4gZWxlbWVudHMgYXJlIGZvciByb3V0ZXIgY29uZmlndXJhdGlvbiBvbmx5IGFuZCBzaG91bGQgbm90IGJlIHJlbmRlcmVkJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUmVkaXJlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvUmVkaXJlY3QuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBmdW5jID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcy5mdW5jO1xuXG4vKipcbiAqIEFuIDxJbmRleFJvdXRlPiBpcyB1c2VkIHRvIHNwZWNpZnkgaXRzIHBhcmVudCdzIDxSb3V0ZSBpbmRleFJvdXRlPiBpblxuICogYSBKU1ggcm91dGUgY29uZmlnLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9yZXF1aXJlLXJlbmRlci1yZXR1cm4gKi9cblxudmFyIEluZGV4Um91dGUgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0luZGV4Um91dGUnLFxuXG5cbiAgc3RhdGljczoge1xuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogZnVuY3Rpb24gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQsIHBhcmVudFJvdXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogc2FuaXR5IGNoZWNrICovXG4gICAgICBpZiAocGFyZW50Um91dGUpIHtcbiAgICAgICAgcGFyZW50Um91dGUuaW5kZXhSb3V0ZSA9ICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQpKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdBbiA8SW5kZXhSb3V0ZT4gZG9lcyBub3QgbWFrZSBzZW5zZSBhdCB0aGUgcm9vdCBvZiB5b3VyIHJvdXRlIGNvbmZpZycpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBwYXRoOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3ksXG4gICAgY29tcG9uZW50OiBfSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50LFxuICAgIGNvbXBvbmVudHM6IF9JbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnRzLFxuICAgIGdldENvbXBvbmVudDogZnVuYyxcbiAgICBnZXRDb21wb25lbnRzOiBmdW5jXG4gIH0sXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnPEluZGV4Um91dGU+IGVsZW1lbnRzIGFyZSBmb3Igcm91dGVyIGNvbmZpZ3VyYXRpb24gb25seSBhbmQgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEluZGV4Um91dGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSb3V0ZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzLFxuICAgIHN0cmluZyA9IF9SZWFjdCRQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGZ1bmMgPSBfUmVhY3QkUHJvcFR5cGVzLmZ1bmM7XG5cbi8qKlxuICogQSA8Um91dGU+IGlzIHVzZWQgdG8gZGVjbGFyZSB3aGljaCBjb21wb25lbnRzIGFyZSByZW5kZXJlZCB0byB0aGVcbiAqIHBhZ2Ugd2hlbiB0aGUgVVJMIG1hdGNoZXMgYSBnaXZlbiBwYXR0ZXJuLlxuICpcbiAqIFJvdXRlcyBhcmUgYXJyYW5nZWQgaW4gYSBuZXN0ZWQgdHJlZSBzdHJ1Y3R1cmUuIFdoZW4gYSBuZXcgVVJMIGlzXG4gKiByZXF1ZXN0ZWQsIHRoZSB0cmVlIGlzIHNlYXJjaGVkIGRlcHRoLWZpcnN0IHRvIGZpbmQgYSByb3V0ZSB3aG9zZVxuICogcGF0aCBtYXRjaGVzIHRoZSBVUkwuICBXaGVuIG9uZSBpcyBmb3VuZCwgYWxsIHJvdXRlcyBpbiB0aGUgdHJlZVxuICogdGhhdCBsZWFkIHRvIGl0IGFyZSBjb25zaWRlcmVkIFwiYWN0aXZlXCIgYW5kIHRoZWlyIGNvbXBvbmVudHMgYXJlXG4gKiByZW5kZXJlZCBpbnRvIHRoZSBET00sIG5lc3RlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyBpbiB0aGUgdHJlZS5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcmVxdWlyZS1yZW5kZXItcmV0dXJuICovXG5cbnZhciBSb3V0ZSA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUm91dGUnLFxuXG5cbiAgc3RhdGljczoge1xuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGNvbXBvbmVudDogX0ludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudCxcbiAgICBjb21wb25lbnRzOiBfSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50cyxcbiAgICBnZXRDb21wb25lbnQ6IGZ1bmMsXG4gICAgZ2V0Q29tcG9uZW50czogZnVuY1xuICB9LFxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxSb3V0ZT4gZWxlbWVudHMgYXJlIGZvciByb3V0ZXIgY29uZmlndXJhdGlvbiBvbmx5IGFuZCBzaG91bGQgbm90IGJlIHJlbmRlcmVkJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGUuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL0FjdGlvbnMnKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVNZW1vcnlIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVNZW1vcnlIaXN0b3J5KTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX1JvdXRlclV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZXJVdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbi8qKlxuICogQSBoaWdoLWxldmVsIEFQSSB0byBiZSB1c2VkIGZvciBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBtYXRjaGVzIGEgbG9jYXRpb24gdG8gYSBzZXQgb2Ygcm91dGVzIGFuZCBjYWxsc1xuICogY2FsbGJhY2soZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIHJlbmRlclByb3BzKSB3aGVuIGZpbmlzaGVkLlxuICpcbiAqIE5vdGU6IFlvdSBwcm9iYWJseSBkb24ndCB3YW50IHRvIHVzZSB0aGlzIGluIGEgYnJvd3NlciB1bmxlc3MgeW91J3JlIHVzaW5nXG4gKiBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgd2l0aCBhc3luYyByb3V0ZXMuXG4gKi9cbmZ1bmN0aW9uIG1hdGNoKF9yZWYsIGNhbGxiYWNrKSB7XG4gIHZhciBoaXN0b3J5ID0gX3JlZi5oaXN0b3J5LFxuICAgICAgcm91dGVzID0gX3JlZi5yb3V0ZXMsXG4gICAgICBsb2NhdGlvbiA9IF9yZWYubG9jYXRpb24sXG4gICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnaGlzdG9yeScsICdyb3V0ZXMnLCAnbG9jYXRpb24nXSk7XG5cbiAgIShoaXN0b3J5IHx8IGxvY2F0aW9uKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdtYXRjaCBuZWVkcyBhIGhpc3Rvcnkgb3IgYSBsb2NhdGlvbicpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICBoaXN0b3J5ID0gaGlzdG9yeSA/IGhpc3RvcnkgOiAoMCwgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyLmRlZmF1bHQpKG9wdGlvbnMpO1xuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KShoaXN0b3J5LCAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKShyb3V0ZXMpKTtcblxuICBpZiAobG9jYXRpb24pIHtcbiAgICAvLyBBbGxvdyBtYXRjaCh7IGxvY2F0aW9uOiAnL3RoZS9wYXRoJywgLi4uIH0pXG4gICAgbG9jYXRpb24gPSBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBsb2NhdGlvbiA9IGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCk7XG4gIH1cblxuICB0cmFuc2l0aW9uTWFuYWdlci5tYXRjaChsb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCByZWRpcmVjdExvY2F0aW9uLCBuZXh0U3RhdGUpIHtcbiAgICB2YXIgcmVuZGVyUHJvcHMgPSB2b2lkIDA7XG5cbiAgICBpZiAobmV4dFN0YXRlKSB7XG4gICAgICB2YXIgcm91dGVyID0gKDAsIF9Sb3V0ZXJVdGlscy5jcmVhdGVSb3V0ZXJPYmplY3QpKGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyLCBuZXh0U3RhdGUpO1xuICAgICAgcmVuZGVyUHJvcHMgPSBfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7XG4gICAgICAgIHJvdXRlcjogcm91dGVyLFxuICAgICAgICBtYXRjaENvbnRleHQ6IHsgdHJhbnNpdGlvbk1hbmFnZXI6IHRyYW5zaXRpb25NYW5hZ2VyLCByb3V0ZXI6IHJvdXRlciB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhlcnJvciwgcmVkaXJlY3RMb2NhdGlvbiAmJiBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKHJlZGlyZWN0TG9jYXRpb24sIF9BY3Rpb25zLlJFUExBQ0UpLCByZW5kZXJQcm9wcyk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBtYXRjaDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaC5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgbmF2aWdhdGlvbiB3YXMgY2F1c2VkIGJ5IGEgY2FsbCB0byBoaXN0b3J5LnB1c2guXG4gKi9cbnZhciBQVVNIID0gZXhwb3J0cy5QVVNIID0gJ1BVU0gnO1xuXG4vKipcbiAqIEluZGljYXRlcyB0aGF0IG5hdmlnYXRpb24gd2FzIGNhdXNlZCBieSBhIGNhbGwgdG8gaGlzdG9yeS5yZXBsYWNlLlxuICovXG52YXIgUkVQTEFDRSA9IGV4cG9ydHMuUkVQTEFDRSA9ICdSRVBMQUNFJztcblxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBuYXZpZ2F0aW9uIHdhcyBjYXVzZWQgYnkgc29tZSBvdGhlciBhY3Rpb24gc3VjaFxuICogYXMgdXNpbmcgYSBicm93c2VyJ3MgYmFjay9mb3J3YXJkIGJ1dHRvbnMgYW5kL29yIG1hbnVhbGx5IG1hbmlwdWxhdGluZ1xuICogdGhlIFVSTCBpbiBhIGJyb3dzZXIncyBsb2NhdGlvbiBiYXIuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXG4gKlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dFdmVudEhhbmRsZXJzL29ucG9wc3RhdGVcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG52YXIgUE9QID0gZXhwb3J0cy5QT1AgPSAnUE9QJztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2hpc3RvcnkvbGliL0FjdGlvbnMuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5O1xuXG52YXIgX3VzZVF1ZXJpZXMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VRdWVyaWVzJyk7XG5cbnZhciBfdXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzKTtcblxudmFyIF91c2VCYXNlbmFtZSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lJyk7XG5cbnZhciBfdXNlQmFzZW5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlQmFzZW5hbWUpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVNZW1vcnlIaXN0b3J5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShvcHRpb25zKSB7XG4gIC8vIHNpZ25hdHVyZXMgYW5kIHR5cGUgY2hlY2tpbmcgZGlmZmVyIGJldHdlZW4gYHVzZVF1ZXJpZXNgIGFuZFxuICAvLyBgY3JlYXRlTWVtb3J5SGlzdG9yeWAsIGhhdmUgdG8gY3JlYXRlIGBtZW1vcnlIaXN0b3J5YCBmaXJzdCBiZWNhdXNlXG4gIC8vIGB1c2VRdWVyaWVzYCBkb2Vzbid0IHVuZGVyc3RhbmQgdGhlIHNpZ25hdHVyZVxuICB2YXIgbWVtb3J5SGlzdG9yeSA9ICgwLCBfY3JlYXRlTWVtb3J5SGlzdG9yeTIuZGVmYXVsdCkob3B0aW9ucyk7XG4gIHZhciBjcmVhdGVIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGlzdG9yeSgpIHtcbiAgICByZXR1cm4gbWVtb3J5SGlzdG9yeTtcbiAgfTtcbiAgdmFyIGhpc3RvcnkgPSAoMCwgX3VzZVF1ZXJpZXMyLmRlZmF1bHQpKCgwLCBfdXNlQmFzZW5hbWUyLmRlZmF1bHQpKGNyZWF0ZUhpc3RvcnkpKShvcHRpb25zKTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9xdWVyeVN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5LXN0cmluZycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rID0gcmVxdWlyZSgnLi9ydW5UcmFuc2l0aW9uSG9vaycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3J1blRyYW5zaXRpb25Ib29rKTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmF1bHRTdHJpbmdpZnlRdWVyeSA9IGZ1bmN0aW9uIGRlZmF1bHRTdHJpbmdpZnlRdWVyeShxdWVyeSkge1xuICByZXR1cm4gKDAsIF9xdWVyeVN0cmluZy5zdHJpbmdpZnkpKHF1ZXJ5KS5yZXBsYWNlKC8lMjAvZywgJysnKTtcbn07XG5cbnZhciBkZWZhdWx0UGFyc2VRdWVyeVN0cmluZyA9IF9xdWVyeVN0cmluZy5wYXJzZTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGNyZWF0ZUhpc3RvcnkgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBjcmVhdGVcbiAqIGhpc3Rvcnkgb2JqZWN0cyB0aGF0IGtub3cgaG93IHRvIGhhbmRsZSBVUkwgcXVlcmllcy5cbiAqL1xudmFyIHVzZVF1ZXJpZXMgPSBmdW5jdGlvbiB1c2VRdWVyaWVzKGNyZWF0ZUhpc3RvcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgdmFyIGhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KG9wdGlvbnMpO1xuICAgIHZhciBzdHJpbmdpZnlRdWVyeSA9IG9wdGlvbnMuc3RyaW5naWZ5UXVlcnk7XG4gICAgdmFyIHBhcnNlUXVlcnlTdHJpbmcgPSBvcHRpb25zLnBhcnNlUXVlcnlTdHJpbmc7XG5cblxuICAgIGlmICh0eXBlb2Ygc3RyaW5naWZ5UXVlcnkgIT09ICdmdW5jdGlvbicpIHN0cmluZ2lmeVF1ZXJ5ID0gZGVmYXVsdFN0cmluZ2lmeVF1ZXJ5O1xuXG4gICAgaWYgKHR5cGVvZiBwYXJzZVF1ZXJ5U3RyaW5nICE9PSAnZnVuY3Rpb24nKSBwYXJzZVF1ZXJ5U3RyaW5nID0gZGVmYXVsdFBhcnNlUXVlcnlTdHJpbmc7XG5cbiAgICB2YXIgZGVjb2RlUXVlcnkgPSBmdW5jdGlvbiBkZWNvZGVRdWVyeShsb2NhdGlvbikge1xuICAgICAgaWYgKCFsb2NhdGlvbikgcmV0dXJuIGxvY2F0aW9uO1xuXG4gICAgICBpZiAobG9jYXRpb24ucXVlcnkgPT0gbnVsbCkgbG9jYXRpb24ucXVlcnkgPSBwYXJzZVF1ZXJ5U3RyaW5nKGxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuXG4gICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfTtcblxuICAgIHZhciBlbmNvZGVRdWVyeSA9IGZ1bmN0aW9uIGVuY29kZVF1ZXJ5KGxvY2F0aW9uLCBxdWVyeSkge1xuICAgICAgaWYgKHF1ZXJ5ID09IG51bGwpIHJldHVybiBsb2NhdGlvbjtcblxuICAgICAgdmFyIG9iamVjdCA9IHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycgPyAoMCwgX1BhdGhVdGlscy5wYXJzZVBhdGgpKGxvY2F0aW9uKSA6IGxvY2F0aW9uO1xuICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gc3RyaW5naWZ5UXVlcnkocXVlcnkpO1xuICAgICAgdmFyIHNlYXJjaCA9IHF1ZXJ5U3RyaW5nID8gJz8nICsgcXVlcnlTdHJpbmcgOiAnJztcblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBvYmplY3QsIHtcbiAgICAgICAgc2VhcmNoOiBzZWFyY2hcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgcmVhZCBtZXRob2RzIHdpdGggcXVlcnktYXdhcmUgdmVyc2lvbnMuXG4gICAgdmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBkZWNvZGVRdWVyeShoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3RlbkJlZm9yZSA9IGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShob29rKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW5CZWZvcmUoZnVuY3Rpb24gKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gKDAsIF9ydW5UcmFuc2l0aW9uSG9vazIuZGVmYXVsdCkoaG9vaywgZGVjb2RlUXVlcnkobG9jYXRpb24pLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoZGVjb2RlUXVlcnkobG9jYXRpb24pKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgd3JpdGUgbWV0aG9kcyB3aXRoIHF1ZXJ5LWF3YXJlIHZlcnNpb25zLlxuICAgIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkucHVzaChlbmNvZGVRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5yZXBsYWNlKGVuY29kZVF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZVBhdGgoZW5jb2RlUXVlcnkobG9jYXRpb24sIGxvY2F0aW9uLnF1ZXJ5KSk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlSHJlZihlbmNvZGVRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0xvY2F0aW9uID0gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbi5hcHBseShoaXN0b3J5LCBbZW5jb2RlUXVlcnkobG9jYXRpb24sIGxvY2F0aW9uLnF1ZXJ5KV0uY29uY2F0KGFyZ3MpKTtcblxuICAgICAgaWYgKGxvY2F0aW9uLnF1ZXJ5KSBuZXdMb2NhdGlvbi5xdWVyeSA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVRdWVyeSkobG9jYXRpb24ucXVlcnkpO1xuXG4gICAgICByZXR1cm4gZGVjb2RlUXVlcnkobmV3TG9jYXRpb24pO1xuICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgICBsaXN0ZW46IGxpc3RlbixcbiAgICAgIHB1c2g6IHB1c2gsXG4gICAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgICAgY3JlYXRlUGF0aDogY3JlYXRlUGF0aCxcbiAgICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgICBjcmVhdGVMb2NhdGlvbjogY3JlYXRlTG9jYXRpb25cbiAgICB9KTtcbiAgfTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHVzZVF1ZXJpZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9oaXN0b3J5L2xpYi91c2VRdWVyaWVzLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cmljdFVyaUVuY29kZSA9IHJlcXVpcmUoJ3N0cmljdC11cmktZW5jb2RlJyk7XG52YXIgb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsdWUsIG9wdHMpIHtcblx0aWYgKG9wdHMuZW5jb2RlKSB7XG5cdFx0cmV0dXJuIG9wdHMuc3RyaWN0ID8gc3RyaWN0VXJpRW5jb2RlKHZhbHVlKSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydHMuZXh0cmFjdCA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHN0ci5zcGxpdCgnPycpWzFdIHx8ICcnO1xufTtcblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzdHIpIHtcblx0Ly8gQ3JlYXRlIGFuIG9iamVjdCB3aXRoIG5vIHByb3RvdHlwZVxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3F1ZXJ5LXN0cmluZy9pc3N1ZXMvNDdcblx0dmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblx0aWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cdHN0ciA9IHN0ci50cmltKCkucmVwbGFjZSgvXihcXD98I3wmKS8sICcnKTtcblxuXHRpZiAoIXN0cikge1xuXHRcdHJldHVybiByZXQ7XG5cdH1cblxuXHRzdHIuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuXHRcdHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XG5cdFx0Ly8gRmlyZWZveCAocHJlIDQwKSBkZWNvZGVzIGAlM0RgIHRvIGA9YFxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcXVlcnktc3RyaW5nL3B1bGwvMzdcblx0XHR2YXIga2V5ID0gcGFydHMuc2hpZnQoKTtcblx0XHR2YXIgdmFsID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzLmpvaW4oJz0nKSA6IHVuZGVmaW5lZDtcblxuXHRcdGtleSA9IGRlY29kZVVSSUNvbXBvbmVudChrZXkpO1xuXG5cdFx0Ly8gbWlzc2luZyBgPWAgc2hvdWxkIGJlIGBudWxsYDpcblx0XHQvLyBodHRwOi8vdzMub3JnL1RSLzIwMTIvV0QtdXJsLTIwMTIwNTI0LyNjb2xsZWN0LXVybC1wYXJhbWV0ZXJzXG5cdFx0dmFsID0gdmFsID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVjb2RlVVJJQ29tcG9uZW50KHZhbCk7XG5cblx0XHRpZiAocmV0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0W2tleV0gPSB2YWw7XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldFtrZXldKSkge1xuXHRcdFx0cmV0W2tleV0ucHVzaCh2YWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXRba2V5XSA9IFtyZXRba2V5XSwgdmFsXTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5leHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcblx0dmFyIGRlZmF1bHRzID0ge1xuXHRcdGVuY29kZTogdHJ1ZSxcblx0XHRzdHJpY3Q6IHRydWVcblx0fTtcblxuXHRvcHRzID0gb2JqZWN0QXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcblxuXHRyZXR1cm4gb2JqID8gT2JqZWN0LmtleXMob2JqKS5zb3J0KCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgdmFsID0gb2JqW2tleV07XG5cblx0XHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cblx0XHRpZiAodmFsID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKGtleSwgb3B0cyk7XG5cdFx0fVxuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IFtdO1xuXG5cdFx0XHR2YWwuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwyKSB7XG5cdFx0XHRcdGlmICh2YWwyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodmFsMiA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKGVuY29kZShrZXksIG9wdHMpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaChlbmNvZGUoa2V5LCBvcHRzKSArICc9JyArIGVuY29kZSh2YWwyLCBvcHRzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oJyYnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZW5jb2RlKGtleSwgb3B0cykgKyAnPScgKyBlbmNvZGUodmFsLCBvcHRzKTtcblx0fSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIHgubGVuZ3RoID4gMDtcblx0fSkuam9pbignJicpIDogJyc7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9xdWVyeS1zdHJpbmcvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpKl0vZywgZnVuY3Rpb24gKGMpIHtcblx0XHRyZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHR9KTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3N0cmljdC11cmktZW5jb2RlL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHJ1blRyYW5zaXRpb25Ib29rID0gZnVuY3Rpb24gcnVuVHJhbnNpdGlvbkhvb2soaG9vaywgbG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gIHZhciByZXN1bHQgPSBob29rKGxvY2F0aW9uLCBjYWxsYmFjayk7XG5cbiAgaWYgKGhvb2subGVuZ3RoIDwgMikge1xuICAgIC8vIEFzc3VtZSB0aGUgaG9vayBydW5zIHN5bmNocm9ub3VzbHkgYW5kIGF1dG9tYXRpY2FsbHlcbiAgICAvLyBjYWxsIHRoZSBjYWxsYmFjayB3aXRoIHRoZSByZXR1cm4gdmFsdWUuXG4gICAgY2FsbGJhY2socmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShyZXN1bHQgPT09IHVuZGVmaW5lZCwgJ1lvdSBzaG91bGQgbm90IFwicmV0dXJuXCIgaW4gYSB0cmFuc2l0aW9uIGhvb2sgd2l0aCBhIGNhbGxiYWNrIGFyZ3VtZW50OyAnICsgJ2NhbGwgdGhlIGNhbGxiYWNrIGluc3RlYWQnKSA6IHZvaWQgMDtcbiAgfVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gcnVuVHJhbnNpdGlvbkhvb2s7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9oaXN0b3J5L2xpYi9ydW5UcmFuc2l0aW9uSG9vay5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMubG9jYXRpb25zQXJlRXF1YWwgPSBleHBvcnRzLnN0YXRlc0FyZUVxdWFsID0gZXhwb3J0cy5jcmVhdGVMb2NhdGlvbiA9IGV4cG9ydHMuY3JlYXRlUXVlcnkgPSB1bmRlZmluZWQ7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNyZWF0ZVF1ZXJ5ID0gZXhwb3J0cy5jcmVhdGVRdWVyeSA9IGZ1bmN0aW9uIGNyZWF0ZVF1ZXJ5KHByb3BzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyhPYmplY3QuY3JlYXRlKG51bGwpLCBwcm9wcyk7XG59O1xuXG52YXIgY3JlYXRlTG9jYXRpb24gPSBleHBvcnRzLmNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24oKSB7XG4gIHZhciBpbnB1dCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/ICcvJyA6IGFyZ3VtZW50c1swXTtcbiAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IF9BY3Rpb25zLlBPUCA6IGFyZ3VtZW50c1sxXTtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMl07XG5cbiAgdmFyIG9iamVjdCA9IHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgPyAoMCwgX1BhdGhVdGlscy5wYXJzZVBhdGgpKGlucHV0KSA6IGlucHV0O1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCFvYmplY3QucGF0aCwgJ0xvY2F0aW9uIGRlc2NyaXB0b3Igb2JqZWN0cyBzaG91bGQgaGF2ZSBhIGBwYXRobmFtZWAsIG5vdCBhIGBwYXRoYC4nKSA6IHZvaWQgMDtcblxuICB2YXIgcGF0aG5hbWUgPSBvYmplY3QucGF0aG5hbWUgfHwgJy8nO1xuICB2YXIgc2VhcmNoID0gb2JqZWN0LnNlYXJjaCB8fCAnJztcbiAgdmFyIGhhc2ggPSBvYmplY3QuaGFzaCB8fCAnJztcbiAgdmFyIHN0YXRlID0gb2JqZWN0LnN0YXRlO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2gsXG4gICAgc3RhdGU6IHN0YXRlLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGtleToga2V5XG4gIH07XG59O1xuXG52YXIgaXNEYXRlID0gZnVuY3Rpb24gaXNEYXRlKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn07XG5cbnZhciBzdGF0ZXNBcmVFcXVhbCA9IGV4cG9ydHMuc3RhdGVzQXJlRXF1YWwgPSBmdW5jdGlvbiBzdGF0ZXNBcmVFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgdHlwZW9mQSA9IHR5cGVvZiBhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhKTtcbiAgdmFyIHR5cGVvZkIgPSB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYik7XG5cbiAgaWYgKHR5cGVvZkEgIT09IHR5cGVvZkIpIHJldHVybiBmYWxzZTtcblxuICAhKHR5cGVvZkEgIT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1lvdSBtdXN0IG5vdCBzdG9yZSBmdW5jdGlvbnMgaW4gbG9jYXRpb24gc3RhdGUnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgLy8gTm90IHRoZSBzYW1lIG9iamVjdCwgYnV0IHNhbWUgdHlwZS5cbiAgaWYgKHR5cGVvZkEgPT09ICdvYmplY3QnKSB7XG4gICAgISEoaXNEYXRlKGEpICYmIGlzRGF0ZShiKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnWW91IG11c3Qgbm90IHN0b3JlIERhdGUgb2JqZWN0cyBpbiBsb2NhdGlvbiBzdGF0ZScpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgdmFyIGtleXNvZkEgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgIHZhciBrZXlzb2ZCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICByZXR1cm4ga2V5c29mQS5sZW5ndGggPT09IGtleXNvZkIubGVuZ3RoICYmIGtleXNvZkEuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gc3RhdGVzQXJlRXF1YWwoYVtrZXldLCBiW2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYikgJiYgYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICByZXR1cm4gc3RhdGVzQXJlRXF1YWwoaXRlbSwgYltpbmRleF0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQWxsIG90aGVyIHNlcmlhbGl6YWJsZSB0eXBlcyAoc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4pXG4gIC8vIHNob3VsZCBiZSBzdHJpY3QgZXF1YWwuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBsb2NhdGlvbnNBcmVFcXVhbCA9IGV4cG9ydHMubG9jYXRpb25zQXJlRXF1YWwgPSBmdW5jdGlvbiBsb2NhdGlvbnNBcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLmtleSA9PT0gYi5rZXkgJiZcbiAgLy8gYS5hY3Rpb24gPT09IGIuYWN0aW9uICYmIC8vIERpZmZlcmVudCBhY3Rpb24gIT09IGxvY2F0aW9uIGNoYW5nZS5cbiAgYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiYgYS5oYXNoID09PSBiLmhhc2ggJiYgc3RhdGVzQXJlRXF1YWwoYS5zdGF0ZSwgYi5zdGF0ZSk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vaGlzdG9yeS9saWIvTG9jYXRpb25VdGlscy5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY3JlYXRlUGF0aCA9IGV4cG9ydHMucGFyc2VQYXRoID0gZXhwb3J0cy5nZXRRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGggPSBleHBvcnRzLnN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoID0gZXhwb3J0cy5hZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoID0gdW5kZWZpbmVkO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGggPSBleHBvcnRzLmFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGggPSBmdW5jdGlvbiBhZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoKHBhdGgsIGtleSwgdmFsdWUpIHtcbiAgdmFyIF9wYXJzZVBhdGggPSBwYXJzZVBhdGgocGF0aCk7XG5cbiAgdmFyIHBhdGhuYW1lID0gX3BhcnNlUGF0aC5wYXRobmFtZTtcbiAgdmFyIHNlYXJjaCA9IF9wYXJzZVBhdGguc2VhcmNoO1xuICB2YXIgaGFzaCA9IF9wYXJzZVBhdGguaGFzaDtcblxuXG4gIHJldHVybiBjcmVhdGVQYXRoKHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2ggKyAoc2VhcmNoLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsga2V5ICsgJz0nICsgdmFsdWUsXG4gICAgaGFzaDogaGFzaFxuICB9KTtcbn07XG5cbnZhciBzdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCA9IGV4cG9ydHMuc3RyaXBRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGggPSBmdW5jdGlvbiBzdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aChwYXRoLCBrZXkpIHtcbiAgdmFyIF9wYXJzZVBhdGgyID0gcGFyc2VQYXRoKHBhdGgpO1xuXG4gIHZhciBwYXRobmFtZSA9IF9wYXJzZVBhdGgyLnBhdGhuYW1lO1xuICB2YXIgc2VhcmNoID0gX3BhcnNlUGF0aDIuc2VhcmNoO1xuICB2YXIgaGFzaCA9IF9wYXJzZVBhdGgyLmhhc2g7XG5cblxuICByZXR1cm4gY3JlYXRlUGF0aCh7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoLnJlcGxhY2UobmV3IFJlZ0V4cCgnKFs/Jl0pJyArIGtleSArICc9W2EtekEtWjAtOV0rKCY/KScpLCBmdW5jdGlvbiAobWF0Y2gsIHByZWZpeCwgc3VmZml4KSB7XG4gICAgICByZXR1cm4gcHJlZml4ID09PSAnPycgPyBwcmVmaXggOiBzdWZmaXg7XG4gICAgfSksXG4gICAgaGFzaDogaGFzaFxuICB9KTtcbn07XG5cbnZhciBnZXRRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGggPSBleHBvcnRzLmdldFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCA9IGZ1bmN0aW9uIGdldFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aChwYXRoLCBrZXkpIHtcbiAgdmFyIF9wYXJzZVBhdGgzID0gcGFyc2VQYXRoKHBhdGgpO1xuXG4gIHZhciBzZWFyY2ggPSBfcGFyc2VQYXRoMy5zZWFyY2g7XG5cbiAgdmFyIG1hdGNoID0gc2VhcmNoLm1hdGNoKG5ldyBSZWdFeHAoJ1s/Jl0nICsga2V5ICsgJz0oW2EtekEtWjAtOV0rKScpKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xufTtcblxudmFyIGV4dHJhY3RQYXRoID0gZnVuY3Rpb24gZXh0cmFjdFBhdGgoc3RyaW5nKSB7XG4gIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaCgvXihodHRwcz86KT9cXC9cXC9bXlxcL10qLyk7XG4gIHJldHVybiBtYXRjaCA9PSBudWxsID8gc3RyaW5nIDogc3RyaW5nLnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpO1xufTtcblxudmFyIHBhcnNlUGF0aCA9IGV4cG9ydHMucGFyc2VQYXRoID0gZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHBhdGhuYW1lID0gZXh0cmFjdFBhdGgocGF0aCk7XG4gIHZhciBzZWFyY2ggPSAnJztcbiAgdmFyIGhhc2ggPSAnJztcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShwYXRoID09PSBwYXRobmFtZSwgJ0EgcGF0aCBtdXN0IGJlIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaCBvbmx5LCBub3QgYSBmdWxsIFVSTCBsaWtlIFwiJXNcIicsIHBhdGgpIDogdm9pZCAwO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoSW5kZXggIT09IC0xKSB7XG4gICAgaGFzaCA9IHBhdGhuYW1lLnN1YnN0cmluZyhoYXNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyaW5nKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgc2VhcmNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCc/Jyk7XG4gIGlmIChzZWFyY2hJbmRleCAhPT0gLTEpIHtcbiAgICBzZWFyY2ggPSBwYXRobmFtZS5zdWJzdHJpbmcoc2VhcmNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyaW5nKDAsIHNlYXJjaEluZGV4KTtcbiAgfVxuXG4gIGlmIChwYXRobmFtZSA9PT0gJycpIHBhdGhuYW1lID0gJy8nO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2hcbiAgfTtcbn07XG5cbnZhciBjcmVhdGVQYXRoID0gZXhwb3J0cy5jcmVhdGVQYXRoID0gZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICBpZiAobG9jYXRpb24gPT0gbnVsbCB8fCB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKSByZXR1cm4gbG9jYXRpb247XG5cbiAgdmFyIGJhc2VuYW1lID0gbG9jYXRpb24uYmFzZW5hbWU7XG4gIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICB2YXIgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG5cbiAgdmFyIHBhdGggPSAoYmFzZW5hbWUgfHwgJycpICsgcGF0aG5hbWU7XG5cbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09ICc/JykgcGF0aCArPSBzZWFyY2g7XG5cbiAgaWYgKGhhc2gpIHBhdGggKz0gaGFzaDtcblxuICByZXR1cm4gcGF0aDtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9oaXN0b3J5L2xpYi9QYXRoVXRpbHMuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2sgPSByZXF1aXJlKCcuL3J1blRyYW5zaXRpb25Ib29rJyk7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcnVuVHJhbnNpdGlvbkhvb2spO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB1c2VCYXNlbmFtZSA9IGZ1bmN0aW9uIHVzZUJhc2VuYW1lKGNyZWF0ZUhpc3RvcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgdmFyIGhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KG9wdGlvbnMpO1xuICAgIHZhciBiYXNlbmFtZSA9IG9wdGlvbnMuYmFzZW5hbWU7XG5cblxuICAgIHZhciBhZGRCYXNlbmFtZSA9IGZ1bmN0aW9uIGFkZEJhc2VuYW1lKGxvY2F0aW9uKSB7XG4gICAgICBpZiAoIWxvY2F0aW9uKSByZXR1cm4gbG9jYXRpb247XG5cbiAgICAgIGlmIChiYXNlbmFtZSAmJiBsb2NhdGlvbi5iYXNlbmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZS5pbmRleE9mKGJhc2VuYW1lKSA9PT0gMCkge1xuICAgICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUuc3Vic3RyaW5nKGJhc2VuYW1lLmxlbmd0aCk7XG4gICAgICAgICAgbG9jYXRpb24uYmFzZW5hbWUgPSBiYXNlbmFtZTtcblxuICAgICAgICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZSA9PT0gJycpIGxvY2F0aW9uLnBhdGhuYW1lID0gJy8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvY2F0aW9uLmJhc2VuYW1lID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH07XG5cbiAgICB2YXIgcHJlcGVuZEJhc2VuYW1lID0gZnVuY3Rpb24gcHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSB7XG4gICAgICBpZiAoIWJhc2VuYW1lKSByZXR1cm4gbG9jYXRpb247XG5cbiAgICAgIHZhciBvYmplY3QgPSB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnID8gKDAsIF9QYXRoVXRpbHMucGFyc2VQYXRoKShsb2NhdGlvbikgOiBsb2NhdGlvbjtcbiAgICAgIHZhciBwbmFtZSA9IG9iamVjdC5wYXRobmFtZTtcbiAgICAgIHZhciBub3JtYWxpemVkQmFzZW5hbWUgPSBiYXNlbmFtZS5zbGljZSgtMSkgPT09ICcvJyA/IGJhc2VuYW1lIDogYmFzZW5hbWUgKyAnLyc7XG4gICAgICB2YXIgbm9ybWFsaXplZFBhdGhuYW1lID0gcG5hbWUuY2hhckF0KDApID09PSAnLycgPyBwbmFtZS5zbGljZSgxKSA6IHBuYW1lO1xuICAgICAgdmFyIHBhdGhuYW1lID0gbm9ybWFsaXplZEJhc2VuYW1lICsgbm9ybWFsaXplZFBhdGhuYW1lO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIG9iamVjdCwge1xuICAgICAgICBwYXRobmFtZTogcGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgcmVhZCBtZXRob2RzIHdpdGggYmFzZW5hbWUtYXdhcmUgdmVyc2lvbnMuXG4gICAgdmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBhZGRCYXNlbmFtZShoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3RlbkJlZm9yZSA9IGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShob29rKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW5CZWZvcmUoZnVuY3Rpb24gKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gKDAsIF9ydW5UcmFuc2l0aW9uSG9vazIuZGVmYXVsdCkoaG9vaywgYWRkQmFzZW5hbWUobG9jYXRpb24pLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoYWRkQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgd3JpdGUgbWV0aG9kcyB3aXRoIGJhc2VuYW1lLWF3YXJlIHZlcnNpb25zLlxuICAgIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkucHVzaChwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5yZXBsYWNlKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZVBhdGgocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlSHJlZihwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFkZEJhc2VuYW1lKGhpc3RvcnkuY3JlYXRlTG9jYXRpb24uYXBwbHkoaGlzdG9yeSwgW3ByZXBlbmRCYXNlbmFtZShsb2NhdGlvbildLmNvbmNhdChhcmdzKSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgICBsaXN0ZW46IGxpc3RlbixcbiAgICAgIHB1c2g6IHB1c2gsXG4gICAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgICAgY3JlYXRlUGF0aDogY3JlYXRlUGF0aCxcbiAgICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgICBjcmVhdGVMb2NhdGlvbjogY3JlYXRlTG9jYXRpb25cbiAgICB9KTtcbiAgfTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHVzZUJhc2VuYW1lO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vaGlzdG9yeS9saWIvdXNlQmFzZW5hbWUuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhpc3RvcnkpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNyZWF0ZVN0YXRlU3RvcmFnZSA9IGZ1bmN0aW9uIGNyZWF0ZVN0YXRlU3RvcmFnZShlbnRyaWVzKSB7XG4gIHJldHVybiBlbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuc3RhdGU7XG4gIH0pLnJlZHVjZShmdW5jdGlvbiAobWVtbywgZW50cnkpIHtcbiAgICBtZW1vW2VudHJ5LmtleV0gPSBlbnRyeS5zdGF0ZTtcbiAgICByZXR1cm4gbWVtbztcbiAgfSwge30pO1xufTtcblxudmFyIGNyZWF0ZU1lbW9yeUhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucyA9IHsgZW50cmllczogb3B0aW9ucyB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7IGVudHJpZXM6IFtvcHRpb25zXSB9O1xuICB9XG5cbiAgdmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2N1cnJlbnRdO1xuICAgIHZhciBwYXRoID0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoZW50cnkpO1xuXG4gICAgdmFyIGtleSA9IHZvaWQgMCxcbiAgICAgICAgc3RhdGUgPSB2b2lkIDA7XG4gICAgaWYgKGVudHJ5LmtleSkge1xuICAgICAga2V5ID0gZW50cnkua2V5O1xuICAgICAgc3RhdGUgPSByZWFkU3RhdGUoa2V5KTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdCA9ICgwLCBfUGF0aFV0aWxzLnBhcnNlUGF0aCkocGF0aCk7XG5cbiAgICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShfZXh0ZW5kcyh7fSwgaW5pdCwgeyBzdGF0ZTogc3RhdGUgfSksIHVuZGVmaW5lZCwga2V5KTtcbiAgfTtcblxuICB2YXIgY2FuR28gPSBmdW5jdGlvbiBjYW5HbyhuKSB7XG4gICAgdmFyIGluZGV4ID0gY3VycmVudCArIG47XG4gICAgcmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPCBlbnRyaWVzLmxlbmd0aDtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgaWYgKCFuKSByZXR1cm47XG5cbiAgICBpZiAoIWNhbkdvKG4pKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0Nhbm5vdCBnbyglcykgdGhlcmUgaXMgbm90IGVub3VnaCBoaXN0b3J5JywgbikgOiB2b2lkIDA7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdXJyZW50ICs9IG47XG4gICAgdmFyIGN1cnJlbnRMb2NhdGlvbiA9IGdldEN1cnJlbnRMb2NhdGlvbigpO1xuXG4gICAgLy8gQ2hhbmdlIGFjdGlvbiB0byBQT1BcbiAgICBoaXN0b3J5LnRyYW5zaXRpb25UbyhfZXh0ZW5kcyh7fSwgY3VycmVudExvY2F0aW9uLCB7IGFjdGlvbjogX0FjdGlvbnMuUE9QIH0pKTtcbiAgfTtcblxuICB2YXIgcHVzaExvY2F0aW9uID0gZnVuY3Rpb24gcHVzaExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgY3VycmVudCArPSAxO1xuXG4gICAgaWYgKGN1cnJlbnQgPCBlbnRyaWVzLmxlbmd0aCkgZW50cmllcy5zcGxpY2UoY3VycmVudCk7XG5cbiAgICBlbnRyaWVzLnB1c2gobG9jYXRpb24pO1xuXG4gICAgc2F2ZVN0YXRlKGxvY2F0aW9uLmtleSwgbG9jYXRpb24uc3RhdGUpO1xuICB9O1xuXG4gIHZhciByZXBsYWNlTG9jYXRpb24gPSBmdW5jdGlvbiByZXBsYWNlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICBlbnRyaWVzW2N1cnJlbnRdID0gbG9jYXRpb247XG4gICAgc2F2ZVN0YXRlKGxvY2F0aW9uLmtleSwgbG9jYXRpb24uc3RhdGUpO1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0gKDAsIF9jcmVhdGVIaXN0b3J5Mi5kZWZhdWx0KShfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgIHB1c2hMb2NhdGlvbjogcHVzaExvY2F0aW9uLFxuICAgIHJlcGxhY2VMb2NhdGlvbjogcmVwbGFjZUxvY2F0aW9uLFxuICAgIGdvOiBnb1xuICB9KSk7XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucztcbiAgdmFyIGVudHJpZXMgPSBfb3B0aW9ucy5lbnRyaWVzO1xuICB2YXIgY3VycmVudCA9IF9vcHRpb25zLmN1cnJlbnQ7XG5cblxuICBpZiAodHlwZW9mIGVudHJpZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgZW50cmllcyA9IFtlbnRyaWVzXTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShlbnRyaWVzKSkge1xuICAgIGVudHJpZXMgPSBbJy8nXTtcbiAgfVxuXG4gIGVudHJpZXMgPSBlbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShlbnRyeSk7XG4gIH0pO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICBjdXJyZW50ID0gZW50cmllcy5sZW5ndGggLSAxO1xuICB9IGVsc2Uge1xuICAgICEoY3VycmVudCA+PSAwICYmIGN1cnJlbnQgPCBlbnRyaWVzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnQ3VycmVudCBpbmRleCBtdXN0IGJlID49IDAgYW5kIDwgJXMsIHdhcyAlcycsIGVudHJpZXMubGVuZ3RoLCBjdXJyZW50KSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG4gIH1cblxuICB2YXIgc3RvcmFnZSA9IGNyZWF0ZVN0YXRlU3RvcmFnZShlbnRyaWVzKTtcblxuICB2YXIgc2F2ZVN0YXRlID0gZnVuY3Rpb24gc2F2ZVN0YXRlKGtleSwgc3RhdGUpIHtcbiAgICByZXR1cm4gc3RvcmFnZVtrZXldID0gc3RhdGU7XG4gIH07XG5cbiAgdmFyIHJlYWRTdGF0ZSA9IGZ1bmN0aW9uIHJlYWRTdGF0ZShrZXkpIHtcbiAgICByZXR1cm4gc3RvcmFnZVtrZXldO1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIGNhbkdvOiBjYW5Hb1xuICB9KTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9oaXN0b3J5L2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX0FzeW5jVXRpbHMgPSByZXF1aXJlKCcuL0FzeW5jVXRpbHMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rID0gcmVxdWlyZSgnLi9ydW5UcmFuc2l0aW9uSG9vaycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3J1blRyYW5zaXRpb25Ib29rKTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY3JlYXRlSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhpc3RvcnkoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gIHZhciBnZXRDdXJyZW50TG9jYXRpb24gPSBvcHRpb25zLmdldEN1cnJlbnRMb2NhdGlvbjtcbiAgdmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBvcHRpb25zLmdldFVzZXJDb25maXJtYXRpb247XG4gIHZhciBwdXNoTG9jYXRpb24gPSBvcHRpb25zLnB1c2hMb2NhdGlvbjtcbiAgdmFyIHJlcGxhY2VMb2NhdGlvbiA9IG9wdGlvbnMucmVwbGFjZUxvY2F0aW9uO1xuICB2YXIgZ28gPSBvcHRpb25zLmdvO1xuICB2YXIga2V5TGVuZ3RoID0gb3B0aW9ucy5rZXlMZW5ndGg7XG5cblxuICB2YXIgY3VycmVudExvY2F0aW9uID0gdm9pZCAwO1xuICB2YXIgcGVuZGluZ0xvY2F0aW9uID0gdm9pZCAwO1xuICB2YXIgYmVmb3JlTGlzdGVuZXJzID0gW107XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGFsbEtleXMgPSBbXTtcblxuICB2YXIgZ2V0Q3VycmVudEluZGV4ID0gZnVuY3Rpb24gZ2V0Q3VycmVudEluZGV4KCkge1xuICAgIGlmIChwZW5kaW5nTG9jYXRpb24gJiYgcGVuZGluZ0xvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSByZXR1cm4gYWxsS2V5cy5pbmRleE9mKHBlbmRpbmdMb2NhdGlvbi5rZXkpO1xuXG4gICAgaWYgKGN1cnJlbnRMb2NhdGlvbikgcmV0dXJuIGFsbEtleXMuaW5kZXhPZihjdXJyZW50TG9jYXRpb24ua2V5KTtcblxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICB2YXIgdXBkYXRlTG9jYXRpb24gPSBmdW5jdGlvbiB1cGRhdGVMb2NhdGlvbihuZXh0TG9jYXRpb24pIHtcbiAgICB2YXIgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG5cbiAgICBjdXJyZW50TG9jYXRpb24gPSBuZXh0TG9jYXRpb247XG5cbiAgICBpZiAoY3VycmVudExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgYWxsS2V5cyA9IFtdLmNvbmNhdChhbGxLZXlzLnNsaWNlKDAsIGN1cnJlbnRJbmRleCArIDEpLCBbY3VycmVudExvY2F0aW9uLmtleV0pO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUkVQTEFDRSkge1xuICAgICAgYWxsS2V5c1tjdXJyZW50SW5kZXhdID0gY3VycmVudExvY2F0aW9uLmtleTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lcihjdXJyZW50TG9jYXRpb24pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5CZWZvcmUgPSBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUobGlzdGVuZXIpIHtcbiAgICBiZWZvcmVMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGJlZm9yZUxpc3RlbmVycyA9IGJlZm9yZUxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBsaXN0ZW5lcjtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNvbmZpcm1UcmFuc2l0aW9uVG8gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgICgwLCBfQXN5bmNVdGlscy5sb29wQXN5bmMpKGJlZm9yZUxpc3RlbmVycy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgICAgKDAsIF9ydW5UcmFuc2l0aW9uSG9vazIuZGVmYXVsdCkoYmVmb3JlTGlzdGVuZXJzW2luZGV4XSwgbG9jYXRpb24sIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCAhPSBudWxsID8gZG9uZShyZXN1bHQpIDogbmV4dCgpO1xuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIGlmIChnZXRVc2VyQ29uZmlybWF0aW9uICYmIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICBnZXRVc2VyQ29uZmlybWF0aW9uKG1lc3NhZ2UsIGZ1bmN0aW9uIChvaykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhvayAhPT0gZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvblRvID0gZnVuY3Rpb24gdHJhbnNpdGlvblRvKG5leHRMb2NhdGlvbikge1xuICAgIGlmIChjdXJyZW50TG9jYXRpb24gJiYgKDAsIF9Mb2NhdGlvblV0aWxzLmxvY2F0aW9uc0FyZUVxdWFsKShjdXJyZW50TG9jYXRpb24sIG5leHRMb2NhdGlvbikgfHwgcGVuZGluZ0xvY2F0aW9uICYmICgwLCBfTG9jYXRpb25VdGlscy5sb2NhdGlvbnNBcmVFcXVhbCkocGVuZGluZ0xvY2F0aW9uLCBuZXh0TG9jYXRpb24pKSByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG9cblxuICAgIHBlbmRpbmdMb2NhdGlvbiA9IG5leHRMb2NhdGlvbjtcblxuICAgIGNvbmZpcm1UcmFuc2l0aW9uVG8obmV4dExvY2F0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmIChwZW5kaW5nTG9jYXRpb24gIT09IG5leHRMb2NhdGlvbikgcmV0dXJuOyAvLyBUcmFuc2l0aW9uIHdhcyBpbnRlcnJ1cHRlZCBkdXJpbmcgY29uZmlybWF0aW9uXG5cbiAgICAgIHBlbmRpbmdMb2NhdGlvbiA9IG51bGw7XG5cbiAgICAgIGlmIChvaykge1xuICAgICAgICAvLyBUcmVhdCBQVVNIIHRvIHNhbWUgcGF0aCBsaWtlIFJFUExBQ0UgdG8gYmUgY29uc2lzdGVudCB3aXRoIGJyb3dzZXJzXG4gICAgICAgIGlmIChuZXh0TG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICAgICAgdmFyIHByZXZQYXRoID0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoY3VycmVudExvY2F0aW9uKTtcbiAgICAgICAgICB2YXIgbmV4dFBhdGggPSAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShuZXh0TG9jYXRpb24pO1xuXG4gICAgICAgICAgaWYgKG5leHRQYXRoID09PSBwcmV2UGF0aCAmJiAoMCwgX0xvY2F0aW9uVXRpbHMuc3RhdGVzQXJlRXF1YWwpKGN1cnJlbnRMb2NhdGlvbi5zdGF0ZSwgbmV4dExvY2F0aW9uLnN0YXRlKSkgbmV4dExvY2F0aW9uLmFjdGlvbiA9IF9BY3Rpb25zLlJFUExBQ0U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSB7XG4gICAgICAgICAgdXBkYXRlTG9jYXRpb24obmV4dExvY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0TG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICAgICAgaWYgKHB1c2hMb2NhdGlvbihuZXh0TG9jYXRpb24pICE9PSBmYWxzZSkgdXBkYXRlTG9jYXRpb24obmV4dExvY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0TG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5SRVBMQUNFKSB7XG4gICAgICAgICAgaWYgKHJlcGxhY2VMb2NhdGlvbihuZXh0TG9jYXRpb24pICE9PSBmYWxzZSkgdXBkYXRlTG9jYXRpb24obmV4dExvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50TG9jYXRpb24gJiYgbmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSB7XG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoY3VycmVudExvY2F0aW9uLmtleSk7XG4gICAgICAgIHZhciBuZXh0SW5kZXggPSBhbGxLZXlzLmluZGV4T2YobmV4dExvY2F0aW9uLmtleSk7XG5cbiAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEgJiYgbmV4dEluZGV4ICE9PSAtMSkgZ28ocHJldkluZGV4IC0gbmV4dEluZGV4KTsgLy8gUmVzdG9yZSB0aGUgVVJMXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKGlucHV0KSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25UbyhjcmVhdGVMb2NhdGlvbihpbnB1dCwgX0FjdGlvbnMuUFVTSCkpO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShpbnB1dCkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uVG8oY3JlYXRlTG9jYXRpb24oaW5wdXQsIF9BY3Rpb25zLlJFUExBQ0UpKTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCB8fCA2KTtcbiAgfTtcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBhY3Rpb24pIHtcbiAgICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gY3JlYXRlS2V5KCkgOiBhcmd1bWVudHNbMl07XG4gICAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikobG9jYXRpb24sIGFjdGlvbiwga2V5KTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgIGxpc3RlbjogbGlzdGVuLFxuICAgIHRyYW5zaXRpb25UbzogdHJhbnNpdGlvblRvLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgY3JlYXRlS2V5OiBjcmVhdGVLZXksXG4gICAgY3JlYXRlUGF0aDogX1BhdGhVdGlscy5jcmVhdGVQYXRoLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uXG4gIH07XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVIaXN0b3J5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vaGlzdG9yeS9saWIvY3JlYXRlSGlzdG9yeS5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGxvb3BBc3luYyA9IGV4cG9ydHMubG9vcEFzeW5jID0gZnVuY3Rpb24gbG9vcEFzeW5jKHR1cm5zLCB3b3JrLCBjYWxsYmFjaykge1xuICB2YXIgY3VycmVudFR1cm4gPSAwLFxuICAgICAgaXNEb25lID0gZmFsc2U7XG4gIHZhciBpc1N5bmMgPSBmYWxzZSxcbiAgICAgIGhhc05leHQgPSBmYWxzZSxcbiAgICAgIGRvbmVBcmdzID0gdm9pZCAwO1xuXG4gIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZSgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpc0RvbmUgPSB0cnVlO1xuXG4gICAgaWYgKGlzU3luYykge1xuICAgICAgLy8gSXRlcmF0ZSBpbnN0ZWFkIG9mIHJlY3Vyc2luZyBpZiBwb3NzaWJsZS5cbiAgICAgIGRvbmVBcmdzID0gYXJncztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICB9O1xuXG4gIHZhciBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpZiAoaXNEb25lKSByZXR1cm47XG5cbiAgICBoYXNOZXh0ID0gdHJ1ZTtcblxuICAgIGlmIChpc1N5bmMpIHJldHVybjsgLy8gSXRlcmF0ZSBpbnN0ZWFkIG9mIHJlY3Vyc2luZyBpZiBwb3NzaWJsZS5cblxuICAgIGlzU3luYyA9IHRydWU7XG5cbiAgICB3aGlsZSAoIWlzRG9uZSAmJiBjdXJyZW50VHVybiA8IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGhhc05leHQgPSBmYWxzZTtcbiAgICAgIHdvcmsoY3VycmVudFR1cm4rKywgbmV4dCwgZG9uZSk7XG4gICAgfVxuXG4gICAgaXNTeW5jID0gZmFsc2U7XG5cbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICAvLyBUaGlzIG1lYW5zIHRoZSBsb29wIGZpbmlzaGVkIHN5bmNocm9ub3VzbHkuXG4gICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGRvbmVBcmdzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFR1cm4gPj0gdHVybnMgJiYgaGFzTmV4dCkge1xuICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9O1xuXG4gIG5leHQoKTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9oaXN0b3J5L2xpYi9Bc3luY1V0aWxzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gdXNlUm91dGVySGlzdG9yeTtcblxudmFyIF91c2VRdWVyaWVzID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvdXNlUXVlcmllcycpO1xuXG52YXIgX3VzZVF1ZXJpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUXVlcmllcyk7XG5cbnZhciBfdXNlQmFzZW5hbWUgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VCYXNlbmFtZScpO1xuXG52YXIgX3VzZUJhc2VuYW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZUJhc2VuYW1lKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdXNlUm91dGVySGlzdG9yeShjcmVhdGVIaXN0b3J5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBoaXN0b3J5ID0gKDAsIF91c2VRdWVyaWVzMi5kZWZhdWx0KSgoMCwgX3VzZUJhc2VuYW1lMi5kZWZhdWx0KShjcmVhdGVIaXN0b3J5KSkob3B0aW9ucyk7XG4gICAgcmV0dXJuIGhpc3Rvcnk7XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvdXNlUm91dGVySGlzdG9yeS5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX1JvdXRlckNvbnRleHQgPSByZXF1aXJlKCcuL1JvdXRlckNvbnRleHQnKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlckNvbnRleHQpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtaWRkbGV3YXJlcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1pZGRsZXdhcmVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBtaWRkbGV3YXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChtaWRkbGV3YXJlLCBpbmRleCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkobWlkZGxld2FyZS5yZW5kZXJSb3V0ZXJDb250ZXh0IHx8IG1pZGRsZXdhcmUucmVuZGVyUm91dGVDb21wb25lbnQsICdUaGUgbWlkZGxld2FyZSBzcGVjaWZpZWQgYXQgaW5kZXggJyArIGluZGV4ICsgJyBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgJyArICdhIHZhbGlkIFJlYWN0IFJvdXRlciBtaWRkbGV3YXJlLicpIDogdm9pZCAwO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHdpdGhDb250ZXh0ID0gbWlkZGxld2FyZXMubWFwKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgcmV0dXJuIG1pZGRsZXdhcmUucmVuZGVyUm91dGVyQ29udGV4dDtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICB2YXIgd2l0aENvbXBvbmVudCA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgIHJldHVybiBtaWRkbGV3YXJlLnJlbmRlclJvdXRlQ29tcG9uZW50O1xuICB9KS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgdmFyIG1ha2VDcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gbWFrZUNyZWF0ZUVsZW1lbnQoKSB7XG4gICAgdmFyIGJhc2VDcmVhdGVFbGVtZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBfcmVhY3QuY3JlYXRlRWxlbWVudDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKENvbXBvbmVudCwgcHJvcHMpIHtcbiAgICAgIHJldHVybiB3aXRoQ29tcG9uZW50LnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChwcmV2aW91cywgcmVuZGVyUm91dGVDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlclJvdXRlQ29tcG9uZW50KHByZXZpb3VzLCBwcm9wcyk7XG4gICAgICB9LCBiYXNlQ3JlYXRlRWxlbWVudChDb21wb25lbnQsIHByb3BzKSk7XG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKHJlbmRlclByb3BzKSB7XG4gICAgcmV0dXJuIHdpdGhDb250ZXh0LnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChwcmV2aW91cywgcmVuZGVyUm91dGVyQ29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlbmRlclJvdXRlckNvbnRleHQocHJldmlvdXMsIHJlbmRlclByb3BzKTtcbiAgICB9LCBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfUm91dGVyQ29udGV4dDIuZGVmYXVsdCwgX2V4dGVuZHMoe30sIHJlbmRlclByb3BzLCB7XG4gICAgICBjcmVhdGVFbGVtZW50OiBtYWtlQ3JlYXRlRWxlbWVudChyZW5kZXJQcm9wcy5jcmVhdGVFbGVtZW50KVxuICAgIH0pKSk7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvYXBwbHlSb3V0ZXJNaWRkbGV3YXJlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUJyb3dzZXJIaXN0b3J5ID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvY3JlYXRlQnJvd3Nlckhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVCcm93c2VySGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVCcm93c2VySGlzdG9yeSk7XG5cbnZhciBfY3JlYXRlUm91dGVySGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlUm91dGVySGlzdG9yeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfY3JlYXRlUm91dGVySGlzdG9yeTIuZGVmYXVsdCkoX2NyZWF0ZUJyb3dzZXJIaXN0b3J5Mi5kZWZhdWx0KTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9icm93c2VySGlzdG9yeS5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIF9Ccm93c2VyUHJvdG9jb2wgPSByZXF1aXJlKCcuL0Jyb3dzZXJQcm90b2NvbCcpO1xuXG52YXIgQnJvd3NlclByb3RvY29sID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX0Jyb3dzZXJQcm90b2NvbCk7XG5cbnZhciBfUmVmcmVzaFByb3RvY29sID0gcmVxdWlyZSgnLi9SZWZyZXNoUHJvdG9jb2wnKTtcblxudmFyIFJlZnJlc2hQcm90b2NvbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9SZWZyZXNoUHJvdG9jb2wpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhpc3RvcnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHVzZXMgSFRNTDUncyBoaXN0b3J5IEFQSVxuICogKHB1c2hTdGF0ZSwgcmVwbGFjZVN0YXRlLCBhbmQgdGhlIHBvcHN0YXRlIGV2ZW50KSB0byBtYW5hZ2UgaGlzdG9yeS5cbiAqIFRoaXMgaXMgdGhlIHJlY29tbWVuZGVkIG1ldGhvZCBvZiBtYW5hZ2luZyBoaXN0b3J5IGluIGJyb3dzZXJzIGJlY2F1c2VcbiAqIGl0IHByb3ZpZGVzIHRoZSBjbGVhbmVzdCBVUkxzLlxuICpcbiAqIE5vdGU6IEluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGZ1bGxcbiAqIHBhZ2UgcmVsb2FkcyB3aWxsIGJlIHVzZWQgdG8gcHJlc2VydmUgY2xlYW4gVVJMcy4gWW91IGNhbiBmb3JjZSB0aGlzXG4gKiBiZWhhdmlvciB1c2luZyB7IGZvcmNlUmVmcmVzaDogdHJ1ZSB9IGluIG9wdGlvbnMuXG4gKi9cbnZhciBjcmVhdGVCcm93c2VySGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICFfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ0Jyb3dzZXIgaGlzdG9yeSBuZWVkcyBhIERPTScpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICB2YXIgdXNlUmVmcmVzaCA9IG9wdGlvbnMuZm9yY2VSZWZyZXNoIHx8ICEoMCwgX0RPTVV0aWxzLnN1cHBvcnRzSGlzdG9yeSkoKTtcbiAgdmFyIFByb3RvY29sID0gdXNlUmVmcmVzaCA/IFJlZnJlc2hQcm90b2NvbCA6IEJyb3dzZXJQcm90b2NvbDtcblxuICB2YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IFByb3RvY29sLmdldFVzZXJDb25maXJtYXRpb247XG4gIHZhciBnZXRDdXJyZW50TG9jYXRpb24gPSBQcm90b2NvbC5nZXRDdXJyZW50TG9jYXRpb247XG4gIHZhciBwdXNoTG9jYXRpb24gPSBQcm90b2NvbC5wdXNoTG9jYXRpb247XG4gIHZhciByZXBsYWNlTG9jYXRpb24gPSBQcm90b2NvbC5yZXBsYWNlTG9jYXRpb247XG4gIHZhciBnbyA9IFByb3RvY29sLmdvO1xuXG5cbiAgdmFyIGhpc3RvcnkgPSAoMCwgX2NyZWF0ZUhpc3RvcnkyLmRlZmF1bHQpKF9leHRlbmRzKHtcbiAgICBnZXRVc2VyQ29uZmlybWF0aW9uOiBnZXRVc2VyQ29uZmlybWF0aW9uIH0sIG9wdGlvbnMsIHtcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBwdXNoTG9jYXRpb246IHB1c2hMb2NhdGlvbixcbiAgICByZXBsYWNlTG9jYXRpb246IHJlcGxhY2VMb2NhdGlvbixcbiAgICBnbzogZ29cbiAgfSkpO1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMCxcbiAgICAgIHN0b3BMaXN0ZW5lciA9IHZvaWQgMDtcblxuICB2YXIgc3RhcnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHN0YXJ0TGlzdGVuZXIobGlzdGVuZXIsIGJlZm9yZSkge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BMaXN0ZW5lciA9IEJyb3dzZXJQcm90b2NvbC5zdGFydExpc3RlbmVyKGhpc3RvcnkudHJhbnNpdGlvblRvKTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGJlZm9yZSA/IGhpc3RvcnkubGlzdGVuQmVmb3JlKGxpc3RlbmVyKSA6IGhpc3RvcnkubGlzdGVuKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuXG4gICAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsaXN0ZW5CZWZvcmUgPSBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUobGlzdGVuZXIpIHtcbiAgICByZXR1cm4gc3RhcnRMaXN0ZW5lcihsaXN0ZW5lciwgdHJ1ZSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHJldHVybiBzdGFydExpc3RlbmVyKGxpc3RlbmVyLCBmYWxzZSk7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfSk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVCcm93c2VySGlzdG9yeTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGNhblVzZURPTSA9IGV4cG9ydHMuY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2hpc3RvcnkvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5nbyA9IGV4cG9ydHMucmVwbGFjZUxvY2F0aW9uID0gZXhwb3J0cy5wdXNoTG9jYXRpb24gPSBleHBvcnRzLnN0YXJ0TGlzdGVuZXIgPSBleHBvcnRzLmdldFVzZXJDb25maXJtYXRpb24gPSBleHBvcnRzLmdldEN1cnJlbnRMb2NhdGlvbiA9IHVuZGVmaW5lZDtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbnZhciBfRE9NU3RhdGVTdG9yYWdlID0gcmVxdWlyZSgnLi9ET01TdGF0ZVN0b3JhZ2UnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgUG9wU3RhdGVFdmVudCA9ICdwb3BzdGF0ZSc7XG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG52YXIgbmVlZHNIYXNoY2hhbmdlTGlzdGVuZXIgPSBfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICEoMCwgX0RPTVV0aWxzLnN1cHBvcnRzUG9wc3RhdGVPbkhhc2hjaGFuZ2UpKCk7XG5cbnZhciBfY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBfY3JlYXRlTG9jYXRpb24oaGlzdG9yeVN0YXRlKSB7XG4gIHZhciBrZXkgPSBoaXN0b3J5U3RhdGUgJiYgaGlzdG9yeVN0YXRlLmtleTtcblxuICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKSh7XG4gICAgcGF0aG5hbWU6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICBzZWFyY2g6IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gsXG4gICAgaGFzaDogd2luZG93LmxvY2F0aW9uLmhhc2gsXG4gICAgc3RhdGU6IGtleSA/ICgwLCBfRE9NU3RhdGVTdG9yYWdlLnJlYWRTdGF0ZSkoa2V5KSA6IHVuZGVmaW5lZFxuICB9LCB1bmRlZmluZWQsIGtleSk7XG59O1xuXG52YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gZXhwb3J0cy5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XG4gIHZhciBoaXN0b3J5U3RhdGUgPSB2b2lkIDA7XG4gIHRyeSB7XG4gICAgaGlzdG9yeVN0YXRlID0gd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwge307XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gSUUgMTEgc29tZXRpbWVzIHRocm93cyB3aGVuIGFjY2Vzc2luZyB3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUmVhY3RUcmFpbmluZy9oaXN0b3J5L3B1bGwvMjg5XG4gICAgaGlzdG9yeVN0YXRlID0ge307XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUxvY2F0aW9uKGhpc3RvcnlTdGF0ZSk7XG59O1xuXG52YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IGV4cG9ydHMuZ2V0VXNlckNvbmZpcm1hdGlvbiA9IGZ1bmN0aW9uIGdldFVzZXJDb25maXJtYXRpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTtcbn07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcblxudmFyIHN0YXJ0TGlzdGVuZXIgPSBleHBvcnRzLnN0YXJ0TGlzdGVuZXIgPSBmdW5jdGlvbiBzdGFydExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIHZhciBoYW5kbGVQb3BTdGF0ZSA9IGZ1bmN0aW9uIGhhbmRsZVBvcFN0YXRlKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnN0YXRlICE9PSB1bmRlZmluZWQpIC8vIElnbm9yZSBleHRyYW5lb3VzIHBvcHN0YXRlIGV2ZW50cyBpbiBXZWJLaXRcbiAgICAgIGxpc3RlbmVyKF9jcmVhdGVMb2NhdGlvbihldmVudC5zdGF0ZSkpO1xuICB9O1xuXG4gICgwLCBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcikod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgdmFyIGhhbmRsZVVucG9wcGVkSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVVucG9wcGVkSGFzaENoYW5nZSgpIHtcbiAgICByZXR1cm4gbGlzdGVuZXIoZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICB9O1xuXG4gIGlmIChuZWVkc0hhc2hjaGFuZ2VMaXN0ZW5lcikge1xuICAgICgwLCBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZVVucG9wcGVkSGFzaENoYW5nZSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICBpZiAobmVlZHNIYXNoY2hhbmdlTGlzdGVuZXIpIHtcbiAgICAgICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZVVucG9wcGVkSGFzaENoYW5nZSk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIHVwZGF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gdXBkYXRlTG9jYXRpb24obG9jYXRpb24sIHVwZGF0ZVN0YXRlKSB7XG4gIHZhciBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuICB2YXIga2V5ID0gbG9jYXRpb24ua2V5O1xuXG5cbiAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQpICgwLCBfRE9NU3RhdGVTdG9yYWdlLnNhdmVTdGF0ZSkoa2V5LCBzdGF0ZSk7XG5cbiAgdXBkYXRlU3RhdGUoeyBrZXk6IGtleSB9LCAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbikpO1xufTtcblxudmFyIHB1c2hMb2NhdGlvbiA9IGV4cG9ydHMucHVzaExvY2F0aW9uID0gZnVuY3Rpb24gcHVzaExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiB1cGRhdGVMb2NhdGlvbihsb2NhdGlvbiwgZnVuY3Rpb24gKHN0YXRlLCBwYXRoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgbnVsbCwgcGF0aCk7XG4gIH0pO1xufTtcblxudmFyIHJlcGxhY2VMb2NhdGlvbiA9IGV4cG9ydHMucmVwbGFjZUxvY2F0aW9uID0gZnVuY3Rpb24gcmVwbGFjZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiB1cGRhdGVMb2NhdGlvbihsb2NhdGlvbiwgZnVuY3Rpb24gKHN0YXRlLCBwYXRoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgbnVsbCwgcGF0aCk7XG4gIH0pO1xufTtcblxudmFyIGdvID0gZXhwb3J0cy5nbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgaWYgKG4pIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2hpc3RvcnkvbGliL0Jyb3dzZXJQcm90b2NvbC5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBhZGRFdmVudExpc3RlbmVyID0gZXhwb3J0cy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIG5vZGUuYWRkRXZlbnRMaXN0ZW5lciA/IG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSA6IG5vZGUuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG52YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGV4cG9ydHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPyBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3Qtcm91dGVyL2lzc3Vlcy81ODZcbiAqL1xudmFyIHN1cHBvcnRzSGlzdG9yeSA9IGV4cG9ydHMuc3VwcG9ydHNIaXN0b3J5ID0gZnVuY3Rpb24gc3VwcG9ydHNIaXN0b3J5KCkge1xuICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cbiAqL1xudmFyIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZXhwb3J0cy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IGZ1bmN0aW9uIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJyb3dzZXIgZmlyZXMgcG9wc3RhdGUgb24gaGFzaCBjaGFuZ2UuXG4gKiBJRTEwIGFuZCBJRTExIGRvIG5vdC5cbiAqL1xudmFyIHN1cHBvcnRzUG9wc3RhdGVPbkhhc2hjaGFuZ2UgPSBleHBvcnRzLnN1cHBvcnRzUG9wc3RhdGVPbkhhc2hjaGFuZ2UgPSBmdW5jdGlvbiBzdXBwb3J0c1BvcHN0YXRlT25IYXNoY2hhbmdlKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpID09PSAtMTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9oaXN0b3J5L2xpYi9ET01VdGlscy5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMucmVhZFN0YXRlID0gZXhwb3J0cy5zYXZlU3RhdGUgPSB1bmRlZmluZWQ7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgUXVvdGFFeGNlZWRlZEVycm9ycyA9IHtcbiAgUXVvdGFFeGNlZWRlZEVycm9yOiB0cnVlLFxuICBRVU9UQV9FWENFRURFRF9FUlI6IHRydWVcbn07XG5cbnZhciBTZWN1cml0eUVycm9ycyA9IHtcbiAgU2VjdXJpdHlFcnJvcjogdHJ1ZVxufTtcblxudmFyIEtleVByZWZpeCA9ICdAQEhpc3RvcnkvJztcblxudmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleShrZXkpIHtcbiAgcmV0dXJuIEtleVByZWZpeCArIGtleTtcbn07XG5cbnZhciBzYXZlU3RhdGUgPSBleHBvcnRzLnNhdmVTdGF0ZSA9IGZ1bmN0aW9uIHNhdmVTdGF0ZShrZXksIHN0YXRlKSB7XG4gIGlmICghd2luZG93LnNlc3Npb25TdG9yYWdlKSB7XG4gICAgLy8gU2Vzc2lvbiBzdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgb3IgaGlkZGVuLlxuICAgIC8vIHNlc3Npb25TdG9yYWdlIGlzIHVuZGVmaW5lZCBpbiBJbnRlcm5ldCBFeHBsb3JlciB3aGVuIHNlcnZlZCB2aWEgZmlsZSBwcm90b2NvbC5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ1toaXN0b3J5XSBVbmFibGUgdG8gc2F2ZSBzdGF0ZTsgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZScpIDogdm9pZCAwO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoc3RhdGUgPT0gbnVsbCkge1xuICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oY3JlYXRlS2V5KGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShjcmVhdGVLZXkoa2V5KSwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKFNlY3VyaXR5RXJyb3JzW2Vycm9yLm5hbWVdKSB7XG4gICAgICAvLyBCbG9ja2luZyBjb29raWVzIGluIENocm9tZS9GaXJlZm94L1NhZmFyaSB0aHJvd3MgU2VjdXJpdHlFcnJvciBvbiBhbnlcbiAgICAgIC8vIGF0dGVtcHQgdG8gYWNjZXNzIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byBzYXZlIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGR1ZSB0byBzZWN1cml0eSBzZXR0aW5ncycpIDogdm9pZCAwO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFF1b3RhRXhjZWVkZWRFcnJvcnNbZXJyb3IubmFtZV0gJiYgd2luZG93LnNlc3Npb25TdG9yYWdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gU2FmYXJpIFwicHJpdmF0ZSBtb2RlXCIgdGhyb3dzIFF1b3RhRXhjZWVkZWRFcnJvci5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byBzYXZlIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGluIFNhZmFyaSBwcml2YXRlIG1vZGUnKSA6IHZvaWQgMDtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG52YXIgcmVhZFN0YXRlID0gZXhwb3J0cy5yZWFkU3RhdGUgPSBmdW5jdGlvbiByZWFkU3RhdGUoa2V5KSB7XG4gIHZhciBqc29uID0gdm9pZCAwO1xuICB0cnkge1xuICAgIGpzb24gPSB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShjcmVhdGVLZXkoa2V5KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKFNlY3VyaXR5RXJyb3JzW2Vycm9yLm5hbWVdKSB7XG4gICAgICAvLyBCbG9ja2luZyBjb29raWVzIGluIENocm9tZS9GaXJlZm94L1NhZmFyaSB0aHJvd3MgU2VjdXJpdHlFcnJvciBvbiBhbnlcbiAgICAgIC8vIGF0dGVtcHQgdG8gYWNjZXNzIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byByZWFkIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGR1ZSB0byBzZWN1cml0eSBzZXR0aW5ncycpIDogdm9pZCAwO1xuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIGlmIChqc29uKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZ25vcmUgaW52YWxpZCBKU09OLlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vaGlzdG9yeS9saWIvRE9NU3RhdGVTdG9yYWdlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5yZXBsYWNlTG9jYXRpb24gPSBleHBvcnRzLnB1c2hMb2NhdGlvbiA9IGV4cG9ydHMuZ2V0Q3VycmVudExvY2F0aW9uID0gZXhwb3J0cy5nbyA9IGV4cG9ydHMuZ2V0VXNlckNvbmZpcm1hdGlvbiA9IHVuZGVmaW5lZDtcblxudmFyIF9Ccm93c2VyUHJvdG9jb2wgPSByZXF1aXJlKCcuL0Jyb3dzZXJQcm90b2NvbCcpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2dldFVzZXJDb25maXJtYXRpb24nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfQnJvd3NlclByb3RvY29sLmdldFVzZXJDb25maXJtYXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdnbycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Ccm93c2VyUHJvdG9jb2wuZ287XG4gIH1cbn0pO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gZXhwb3J0cy5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XG4gIHJldHVybiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHdpbmRvdy5sb2NhdGlvbik7XG59O1xuXG52YXIgcHVzaExvY2F0aW9uID0gZXhwb3J0cy5wdXNoTG9jYXRpb24gPSBmdW5jdGlvbiBwdXNoTG9jYXRpb24obG9jYXRpb24pIHtcbiAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbik7XG4gIHJldHVybiBmYWxzZTsgLy8gRG9uJ3QgdXBkYXRlIGxvY2F0aW9uXG59O1xuXG52YXIgcmVwbGFjZUxvY2F0aW9uID0gZXhwb3J0cy5yZXBsYWNlTG9jYXRpb24gPSBmdW5jdGlvbiByZXBsYWNlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pKTtcbiAgcmV0dXJuIGZhbHNlOyAvLyBEb24ndCB1cGRhdGUgbG9jYXRpb25cbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9oaXN0b3J5L2xpYi9SZWZyZXNoUHJvdG9jb2wuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChjcmVhdGVIaXN0b3J5KSB7XG4gIHZhciBoaXN0b3J5ID0gdm9pZCAwO1xuICBpZiAoY2FuVXNlRE9NKSBoaXN0b3J5ID0gKDAsIF91c2VSb3V0ZXJIaXN0b3J5Mi5kZWZhdWx0KShjcmVhdGVIaXN0b3J5KSgpO1xuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbnZhciBfdXNlUm91dGVySGlzdG9yeSA9IHJlcXVpcmUoJy4vdXNlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUm91dGVySGlzdG9yeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvY3JlYXRlUm91dGVySGlzdG9yeS5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVIYXNoSGlzdG9yeSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGFzaEhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGFzaEhpc3RvcnkpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZVJvdXRlckhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVSb3V0ZXJIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVJvdXRlckhpc3RvcnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgX2NyZWF0ZVJvdXRlckhpc3RvcnkyLmRlZmF1bHQpKF9jcmVhdGVIYXNoSGlzdG9yeTIuZGVmYXVsdCk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvaGFzaEhpc3RvcnkuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX0hhc2hQcm90b2NvbCA9IHJlcXVpcmUoJy4vSGFzaFByb3RvY29sJyk7XG5cbnZhciBIYXNoUHJvdG9jb2wgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfSGFzaFByb3RvY29sKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIaXN0b3J5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIERlZmF1bHRRdWVyeUtleSA9ICdfayc7XG5cbnZhciBhZGRMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiBhZGRMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGggOiAnLycgKyBwYXRoO1xufTtcblxudmFyIEhhc2hQYXRoQ29kZXJzID0ge1xuICBoYXNoYmFuZzoge1xuICAgIGVuY29kZVBhdGg6IGZ1bmN0aW9uIGVuY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoIDogJyEnICsgcGF0aDtcbiAgICB9LFxuICAgIGRlY29kZVBhdGg6IGZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoLnN1YnN0cmluZygxKSA6IHBhdGg7XG4gICAgfVxuICB9LFxuICBub3NsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogZnVuY3Rpb24gZW5jb2RlUGF0aChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc3Vic3RyaW5nKDEpIDogcGF0aDtcbiAgICB9LFxuICAgIGRlY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaFxuICB9LFxuICBzbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2hcbiAgfVxufTtcblxudmFyIGNyZWF0ZUhhc2hIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgIV9FeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnSGFzaCBoaXN0b3J5IG5lZWRzIGEgRE9NJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gIHZhciBxdWVyeUtleSA9IG9wdGlvbnMucXVlcnlLZXk7XG4gIHZhciBoYXNoVHlwZSA9IG9wdGlvbnMuaGFzaFR5cGU7XG5cblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShxdWVyeUtleSAhPT0gZmFsc2UsICdVc2luZyB7IHF1ZXJ5S2V5OiBmYWxzZSB9IG5vIGxvbmdlciB3b3Jrcy4gSW5zdGVhZCwganVzdCBkb25cXCd0ICcgKyAndXNlIGxvY2F0aW9uIHN0YXRlIGlmIHlvdSBkb25cXCd0IHdhbnQgYSBrZXkgaW4geW91ciBVUkwgcXVlcnkgc3RyaW5nJykgOiB2b2lkIDA7XG5cbiAgaWYgKHR5cGVvZiBxdWVyeUtleSAhPT0gJ3N0cmluZycpIHF1ZXJ5S2V5ID0gRGVmYXVsdFF1ZXJ5S2V5O1xuXG4gIGlmIChoYXNoVHlwZSA9PSBudWxsKSBoYXNoVHlwZSA9ICdzbGFzaCc7XG5cbiAgaWYgKCEoaGFzaFR5cGUgaW4gSGFzaFBhdGhDb2RlcnMpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdJbnZhbGlkIGhhc2ggdHlwZTogJXMnLCBoYXNoVHlwZSkgOiB2b2lkIDA7XG5cbiAgICBoYXNoVHlwZSA9ICdzbGFzaCc7XG4gIH1cblxuICB2YXIgcGF0aENvZGVyID0gSGFzaFBhdGhDb2RlcnNbaGFzaFR5cGVdO1xuXG4gIHZhciBnZXRVc2VyQ29uZmlybWF0aW9uID0gSGFzaFByb3RvY29sLmdldFVzZXJDb25maXJtYXRpb247XG5cblxuICB2YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICAgIHJldHVybiBIYXNoUHJvdG9jb2wuZ2V0Q3VycmVudExvY2F0aW9uKHBhdGhDb2RlciwgcXVlcnlLZXkpO1xuICB9O1xuXG4gIHZhciBwdXNoTG9jYXRpb24gPSBmdW5jdGlvbiBwdXNoTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICByZXR1cm4gSGFzaFByb3RvY29sLnB1c2hMb2NhdGlvbihsb2NhdGlvbiwgcGF0aENvZGVyLCBxdWVyeUtleSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIHJlcGxhY2VMb2NhdGlvbihsb2NhdGlvbikge1xuICAgIHJldHVybiBIYXNoUHJvdG9jb2wucmVwbGFjZUxvY2F0aW9uKGxvY2F0aW9uLCBwYXRoQ29kZXIsIHF1ZXJ5S2V5KTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9ICgwLCBfY3JlYXRlSGlzdG9yeTIuZGVmYXVsdCkoX2V4dGVuZHMoe1xuICAgIGdldFVzZXJDb25maXJtYXRpb246IGdldFVzZXJDb25maXJtYXRpb24gfSwgb3B0aW9ucywge1xuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgIHB1c2hMb2NhdGlvbjogcHVzaExvY2F0aW9uLFxuICAgIHJlcGxhY2VMb2NhdGlvbjogcmVwbGFjZUxvY2F0aW9uLFxuICAgIGdvOiBIYXNoUHJvdG9jb2wuZ29cbiAgfSkpO1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMCxcbiAgICAgIHN0b3BMaXN0ZW5lciA9IHZvaWQgMDtcblxuICB2YXIgc3RhcnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHN0YXJ0TGlzdGVuZXIobGlzdGVuZXIsIGJlZm9yZSkge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BMaXN0ZW5lciA9IEhhc2hQcm90b2NvbC5zdGFydExpc3RlbmVyKGhpc3RvcnkudHJhbnNpdGlvblRvLCBwYXRoQ29kZXIsIHF1ZXJ5S2V5KTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGJlZm9yZSA/IGhpc3RvcnkubGlzdGVuQmVmb3JlKGxpc3RlbmVyKSA6IGhpc3RvcnkubGlzdGVuKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuXG4gICAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsaXN0ZW5CZWZvcmUgPSBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUobGlzdGVuZXIpIHtcbiAgICByZXR1cm4gc3RhcnRMaXN0ZW5lcihsaXN0ZW5lciwgdHJ1ZSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHJldHVybiBzdGFydExpc3RlbmVyKGxpc3RlbmVyLCBmYWxzZSk7XG4gIH07XG5cbiAgdmFyIGdvSXNTdXBwb3J0ZWRXaXRob3V0UmVsb2FkID0gKDAsIF9ET01VdGlscy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCkoKTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZ29Jc1N1cHBvcnRlZFdpdGhvdXRSZWxvYWQsICdIYXNoIGhpc3RvcnkgZ28obikgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZCBpbiB0aGlzIGJyb3dzZXInKSA6IHZvaWQgMDtcblxuICAgIGhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKHBhdGgpIHtcbiAgICByZXR1cm4gJyMnICsgcGF0aENvZGVyLmVuY29kZVBhdGgoaGlzdG9yeS5jcmVhdGVIcmVmKHBhdGgpKTtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICBsaXN0ZW46IGxpc3RlbixcbiAgICBnbzogZ28sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZlxuICB9KTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZUhhc2hIaXN0b3J5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vaGlzdG9yeS9saWIvY3JlYXRlSGFzaEhpc3RvcnkuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnJlcGxhY2VMb2NhdGlvbiA9IGV4cG9ydHMucHVzaExvY2F0aW9uID0gZXhwb3J0cy5zdGFydExpc3RlbmVyID0gZXhwb3J0cy5nZXRDdXJyZW50TG9jYXRpb24gPSBleHBvcnRzLmdvID0gZXhwb3J0cy5nZXRVc2VyQ29uZmlybWF0aW9uID0gdW5kZWZpbmVkO1xuXG52YXIgX0Jyb3dzZXJQcm90b2NvbCA9IHJlcXVpcmUoJy4vQnJvd3NlclByb3RvY29sJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZ2V0VXNlckNvbmZpcm1hdGlvbicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Ccm93c2VyUHJvdG9jb2wuZ2V0VXNlckNvbmZpcm1hdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2dvJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0Jyb3dzZXJQcm90b2NvbC5nbztcbiAgfVxufSk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9ET01TdGF0ZVN0b3JhZ2UgPSByZXF1aXJlKCcuL0RPTVN0YXRlU3RvcmFnZScpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBnZXRIYXNoUGF0aCA9IGZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBoYXNoSW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGhhc2hJbmRleCA9PT0gLTEgPyAnJyA6IGhyZWYuc3Vic3RyaW5nKGhhc2hJbmRleCArIDEpO1xufTtcblxudmFyIHB1c2hIYXNoUGF0aCA9IGZ1bmN0aW9uIHB1c2hIYXNoUGF0aChwYXRoKSB7XG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG59O1xuXG52YXIgcmVwbGFjZUhhc2hQYXRoID0gZnVuY3Rpb24gcmVwbGFjZUhhc2hQYXRoKHBhdGgpIHtcbiAgdmFyIGhhc2hJbmRleCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJyMnKTtcblxuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh3aW5kb3cubG9jYXRpb24uaHJlZi5zbGljZSgwLCBoYXNoSW5kZXggPj0gMCA/IGhhc2hJbmRleCA6IDApICsgJyMnICsgcGF0aCk7XG59O1xuXG52YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gZXhwb3J0cy5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24ocGF0aENvZGVyLCBxdWVyeUtleSkge1xuICB2YXIgcGF0aCA9IHBhdGhDb2Rlci5kZWNvZGVQYXRoKGdldEhhc2hQYXRoKCkpO1xuICB2YXIga2V5ID0gKDAsIF9QYXRoVXRpbHMuZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKShwYXRoLCBxdWVyeUtleSk7XG5cbiAgdmFyIHN0YXRlID0gdm9pZCAwO1xuICBpZiAoa2V5KSB7XG4gICAgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLnN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKShwYXRoLCBxdWVyeUtleSk7XG4gICAgc3RhdGUgPSAoMCwgX0RPTVN0YXRlU3RvcmFnZS5yZWFkU3RhdGUpKGtleSk7XG4gIH1cblxuICB2YXIgaW5pdCA9ICgwLCBfUGF0aFV0aWxzLnBhcnNlUGF0aCkocGF0aCk7XG4gIGluaXQuc3RhdGUgPSBzdGF0ZTtcblxuICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShpbml0LCB1bmRlZmluZWQsIGtleSk7XG59O1xuXG52YXIgcHJldkxvY2F0aW9uID0gdm9pZCAwO1xuXG52YXIgc3RhcnRMaXN0ZW5lciA9IGV4cG9ydHMuc3RhcnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHN0YXJ0TGlzdGVuZXIobGlzdGVuZXIsIHBhdGhDb2RlciwgcXVlcnlLZXkpIHtcbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgICB2YXIgZW5jb2RlZFBhdGggPSBwYXRoQ29kZXIuZW5jb2RlUGF0aChwYXRoKTtcblxuICAgIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkge1xuICAgICAgLy8gQWx3YXlzIGJlIHN1cmUgd2UgaGF2ZSBhIHByb3Blcmx5LWVuY29kZWQgaGFzaC5cbiAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdXJyZW50TG9jYXRpb24gPSBnZXRDdXJyZW50TG9jYXRpb24ocGF0aENvZGVyLCBxdWVyeUtleSk7XG5cbiAgICAgIGlmIChwcmV2TG9jYXRpb24gJiYgY3VycmVudExvY2F0aW9uLmtleSAmJiBwcmV2TG9jYXRpb24ua2V5ID09PSBjdXJyZW50TG9jYXRpb24ua2V5KSByZXR1cm47IC8vIElnbm9yZSBleHRyYW5lb3VzIGhhc2hjaGFuZ2UgZXZlbnRzXG5cbiAgICAgIHByZXZMb2NhdGlvbiA9IGN1cnJlbnRMb2NhdGlvbjtcblxuICAgICAgbGlzdGVuZXIoY3VycmVudExvY2F0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRW5zdXJlIHRoZSBoYXNoIGlzIGVuY29kZWQgcHJvcGVybHkuXG4gIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgdmFyIGVuY29kZWRQYXRoID0gcGF0aENvZGVyLmVuY29kZVBhdGgocGF0aCk7XG5cbiAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gICgwLCBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICB9O1xufTtcblxudmFyIHVwZGF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gdXBkYXRlTG9jYXRpb24obG9jYXRpb24sIHBhdGhDb2RlciwgcXVlcnlLZXksIHVwZGF0ZUhhc2gpIHtcbiAgdmFyIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG4gIHZhciBrZXkgPSBsb2NhdGlvbi5rZXk7XG5cblxuICB2YXIgcGF0aCA9IHBhdGhDb2Rlci5lbmNvZGVQYXRoKCgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKSk7XG5cbiAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwYXRoID0gKDAsIF9QYXRoVXRpbHMuYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aCkocGF0aCwgcXVlcnlLZXksIGtleSk7XG4gICAgKDAsIF9ET01TdGF0ZVN0b3JhZ2Uuc2F2ZVN0YXRlKShrZXksIHN0YXRlKTtcbiAgfVxuXG4gIHByZXZMb2NhdGlvbiA9IGxvY2F0aW9uO1xuXG4gIHVwZGF0ZUhhc2gocGF0aCk7XG59O1xuXG52YXIgcHVzaExvY2F0aW9uID0gZXhwb3J0cy5wdXNoTG9jYXRpb24gPSBmdW5jdGlvbiBwdXNoTG9jYXRpb24obG9jYXRpb24sIHBhdGhDb2RlciwgcXVlcnlLZXkpIHtcbiAgcmV0dXJuIHVwZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBwYXRoQ29kZXIsIHF1ZXJ5S2V5LCBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmIChnZXRIYXNoUGF0aCgpICE9PSBwYXRoKSB7XG4gICAgICBwdXNoSGFzaFBhdGgocGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnWW91IGNhbm5vdCBQVVNIIHRoZSBzYW1lIHBhdGggdXNpbmcgaGFzaCBoaXN0b3J5JykgOiB2b2lkIDA7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciByZXBsYWNlTG9jYXRpb24gPSBleHBvcnRzLnJlcGxhY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIHJlcGxhY2VMb2NhdGlvbihsb2NhdGlvbiwgcGF0aENvZGVyLCBxdWVyeUtleSkge1xuICByZXR1cm4gdXBkYXRlTG9jYXRpb24obG9jYXRpb24sIHBhdGhDb2RlciwgcXVlcnlLZXksIGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKGdldEhhc2hQYXRoKCkgIT09IHBhdGgpIHJlcGxhY2VIYXNoUGF0aChwYXRoKTtcbiAgfSk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vaGlzdG9yeS9saWIvSGFzaFByb3RvY29sLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCBOYXYgZnJvbSAnLi9OYXYnO1xyXG5cclxuY29uc3QgTWFpbiA9IChwcm9wcykgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICA8TmF2IC8+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbHVtbnMgbWVkaXVtLTYgbGFyZ2UtNCBzbWFsbC1jZW50ZXJlZFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIHtwcm9wcy5jaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNYWluO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hcHAvY29tcG9uZW50cy9NYWluLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgTGluaywgSW5kZXhMaW5rIH0gZnJvbSAncmVhY3Qtcm91dGVyJztcclxuXHJcbmNvbnN0IE5hdiA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICAgIG9uU2VhcmNoOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBhbGVydChcIm5vdCB5ZXQgd2lyZWQgdXBcIik7XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0b3AtYmFyXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRvcC1iYXJcIj5cclxuICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3NOYW1lPVwibWVudVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibWVudS10ZXh0XCI+UmVhY3QgV2VhdGhlciBBcHA8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SW5kZXhMaW5rIHRvPVwiL1wiIGFjdGl2ZUNsYXNzTmFtZT1cImFjdGl2ZVwiIGFjdGl2ZVN0eWxlPXt7IGZvbnRXZWlnaHQ6ICdib2xkJyB9fT5HZXQgV2VhdGhlcjwvSW5kZXhMaW5rPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TGluayB0bz1cIi9hYm91dFwiIGFjdGl2ZUNsYXNzTmFtZT1cImFjdGl2ZVwiIGFjdGl2ZVN0eWxlPXt7IGZvbnRXZWlnaHQ6ICdib2xkJyB9fT5BYm91dDwvTGluaz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPExpbmsgdG89XCIvZXhhbXBsZXNcIiBhY3RpdmVDbGFzc05hbWU9XCJhY3RpdmVcIiBhY3RpdmVTdHlsZT17eyBmb250V2VpZ2h0OiAnYm9sZCcgfX0+RXhhbXBsZXM8L0xpbms+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0b3AtYmFyLXJpZ2h0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGZvcm0gb25TdWJtaXQ9e3RoaXMub25TZWFyY2h9ID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzTmFtZT1cIm1lbnVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInNlYXJjaFwiIHBsYWNlaG9sZGVyPVwiU2VhcmNoIGJ5IGNpdHlcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIGNsYXNzTmFtZT1cImJ1dHRvblwiIHZhbHVlPVwiR2V0IFdlYXRoZXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPC9mb3JtPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTmF2O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hcHAvY29tcG9uZW50cy9OYXYuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgV2VhdGhlckZvcm0gZnJvbSAnLi9XZWF0aGVyRm9ybSc7XHJcbmltcG9ydCBXZWF0aGVyTWVzc2FnZSBmcm9tICcuL1dlYXRoZXJNZXNzYWdlJztcclxuaW1wb3J0IHsgZ2V0VGVtcCB9IGZyb20gJy4uL2FwaS9vcGVuV2VhdGhlck1hcCc7XHJcbmltcG9ydCBFcnJvck1vZGFsIGZyb20gJy4vRXJyb3JNb2RhbCc7XHJcblxyXG5jb25zdCBXZWF0aGVyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xyXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbG9jYXRpb246ICcnLFxyXG4gICAgICAgICAgICB0ZW1wOiAnJyxcclxuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgZXJyb3I6ICcnXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBoYW5kbGVTZWFyY2g6IGZ1bmN0aW9uIChsb2NhdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICB0aGlzLnNldFN0YXRlKHsgaXNMb2FkaW5nOiB0cnVlLCBlcnJvcjogJycgfSk7XHJcblxyXG4gICAgICAgIGdldFRlbXAobG9jYXRpb24pLnRoZW4oZnVuY3Rpb24gKHRlbXApIHtcclxuICAgICAgICAgICAgdGhhdC5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbixcclxuICAgICAgICAgICAgICAgIHRlbXAsXHJcbiAgICAgICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHRoYXQuc2V0U3RhdGUoeyBpc0xvYWRpbmc6IGZhbHNlLCBlcnJvcjogZS5tZXNzYWdlIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IHsgbG9jYXRpb24sIHRlbXAsIGlzTG9hZGluZywgZXJyb3IgfSA9IHRoaXMuc3RhdGU7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlbmRlck1lc3NhZ2UoKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0xvYWRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiA8aDEgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIj5GZXRjaGluZyB3ZWF0aGVyLi4uPC9oMT47XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGVtcCAmJiBsb2NhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxXZWF0aGVyTWVzc2FnZSBsb2NhdGlvbj17bG9jYXRpb259IHRlbXA9e3RlbXB9IC8+O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZW5kZXJFcnJvcigpIHtcclxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPEVycm9yTW9kYWwgbWVzc2FnZT17ZXJyb3J9Lz47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8aDEgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXIgcGFnZS10aXRsZVwiPkdldCBXZWF0aGVyPC9oMT5cclxuICAgICAgICAgICAgICAgIDxXZWF0aGVyRm9ybSBvblNlYXJjaD17dGhpcy5oYW5kbGVTZWFyY2h9IC8+XHJcbiAgICAgICAgICAgICAgICB7cmVuZGVyTWVzc2FnZSgpfVxyXG4gICAgICAgICAgICAgICAge3JlbmRlckVycm9yKCl9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgV2VhdGhlcjtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXBwL2NvbXBvbmVudHMvV2VhdGhlci5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcblxyXG5jb25zdCBXZWF0aGVyRm9ybSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICAgIG9uRm9ybVN1Ym1pdDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5yZWZzLmxvY2F0aW9uLnZhbHVlO1xyXG5cclxuICAgICAgICBpZiAobG9jYXRpb24ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnMubG9jYXRpb24udmFsdWUgPSAnJztcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblNlYXJjaChsb2NhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8Zm9ybSBvblN1Ym1pdD17dGhpcy5vbkZvcm1TdWJtaXR9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwic2VhcmNoXCIgcmVmPVwibG9jYXRpb25cIiBwbGFjZWhvbGRlcj1cIlNlYXJjaCBieSBjaXR5XCIvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiYnV0dG9uIGV4cGFuZGVkIGhvbGxvd1wiPkdldCBXZWF0aGVyPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgV2VhdGhlckZvcm07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FwcC9jb21wb25lbnRzL1dlYXRoZXJGb3JtLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmNvbnN0IFdlYXRoZXJNZXNzYWdlID0gKHsgbG9jYXRpb24sIHRlbXAgfSkgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIj5pdCBpcyB7dGVtcH0gZGVncmVlcyBpbiB7bG9jYXRpb259PC9oMz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBXZWF0aGVyTWVzc2FnZTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXBwL2NvbXBvbmVudHMvV2VhdGhlck1lc3NhZ2UuanMiLCJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xyXG5cclxuY29uc3QgT1BFTl9XRUFUSEVSX01BUF9VUkwgPSAnaHR0cDovL2FwaS5vcGVud2VhdGhlcm1hcC5vcmcvZGF0YS8yLjUvd2VhdGhlcj91bml0cz1pbXBlcmlhbCc7XHJcbmNvbnN0IEFQSUtFWSA9ICcmYXBwaWQ9ZTQ0YzU2NDlmNDVhZjM5YTk4ZGJjODRlYTQ3ZTk5NDknO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFRlbXAgPSBmdW5jdGlvbiAobG9jYXRpb24pIHtcclxuICAgIGNvbnN0IGVuY29kZWRMb2NhdGlvbiA9IGVuY29kZVVSSUNvbXBvbmVudChsb2NhdGlvbik7XHJcbiAgICBjb25zdCByZXF1ZXN0VXJsID0gYCR7T1BFTl9XRUFUSEVSX01BUF9VUkx9JHtBUElLRVl9JnE9JHtlbmNvZGVkTG9jYXRpb259YDtcclxuXHJcbiAgICByZXR1cm4gYXhpb3MuZ2V0KHJlcXVlc3RVcmwpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgIGlmIChyZXMuZGF0YS5jb2QgJiYgcmVzLmRhdGEubWVzc2FnZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzLmRhdGEubWVzc2FnZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcy5kYXRhLm1haW4udGVtcDtcclxuICAgICAgICB9XHJcbiAgICB9LCBmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlcy5kYXRhLm1lc3NhZ2UpO1xyXG4gICAgfSk7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FwcC9hcGkvb3BlbldlYXRoZXJNYXAuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKCk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGRlZmF1bHRDb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpO1xufTtcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWwnKTtcbmF4aW9zLkNhbmNlbFRva2VuID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsVG9rZW4nKTtcbmF4aW9zLmlzQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvaXNDYW5jZWwnKTtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zcHJlYWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBheGlvcztcblxuLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gYXhpb3M7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9heGlvcy5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xuXG4vKmdsb2JhbCB0b1N0cmluZzp0cnVlKi9cblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IC0+IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgJiYgIWlzQXJyYXkob2JqKSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHRba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvdXRpbHMuanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vLi4vZGVmYXVsdHMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhkZWZhdWx0Q29uZmlnKSB7XG4gIHRoaXMuZGVmYXVsdHMgPSB1dGlscy5tZXJnZShkZWZhdWx0cywgZGVmYXVsdENvbmZpZyk7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gdXRpbHMubWVyZ2Uoe1xuICAgICAgdXJsOiBhcmd1bWVudHNbMF1cbiAgICB9LCBhcmd1bWVudHNbMV0pO1xuICB9XG5cbiAgY29uZmlnID0gdXRpbHMubWVyZ2UoZGVmYXVsdHMsIHRoaXMuZGVmYXVsdHMsIHsgbWV0aG9kOiAnZ2V0JyB9LCBjb25maWcpO1xuXG4gIC8vIFN1cHBvcnQgYmFzZVVSTCBjb25maWdcbiAgaWYgKGNvbmZpZy5iYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKGNvbmZpZy51cmwpKSB7XG4gICAgY29uZmlnLnVybCA9IGNvbWJpbmVVUkxzKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgfVxuXG4gIC8vIEhvb2sgdXAgaW50ZXJjZXB0b3JzIG1pZGRsZXdhcmVcbiAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcbiAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcblxudmFyIFBST1RFQ1RJT05fUFJFRklYID0gL15cXClcXF1cXH0nLD9cXG4vO1xudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoUFJPVEVDVElPTl9QUkVGSVgsICcnKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgaGVhZGVyczoge1xuICAgIGNvbW1vbjoge1xuICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gICAgfSxcbiAgICBwYXRjaDogdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpLFxuICAgIHBvc3Q6IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKSxcbiAgICBwdXQ6IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKVxuICB9LFxuXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9kZWZhdWx0cy5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG52YXIgYnRvYSA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYnRvYSkgfHwgcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J0b2EnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB2YXIgbG9hZEV2ZW50ID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG4gICAgdmFyIHhEb21haW4gPSBmYWxzZTtcblxuICAgIC8vIEZvciBJRSA4LzkgQ09SUyBzdXBwb3J0XG4gICAgLy8gT25seSBzdXBwb3J0cyBQT1NUIGFuZCBHRVQgY2FsbHMgYW5kIGRvZXNuJ3QgcmV0dXJucyB0aGUgcmVzcG9uc2UgaGVhZGVycy5cbiAgICAvLyBET04nVCBkbyB0aGlzIGZvciB0ZXN0aW5nIGIvYyBYTUxIdHRwUmVxdWVzdCBpcyBtb2NrZWQsIG5vdCBYRG9tYWluUmVxdWVzdC5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB3aW5kb3cuWERvbWFpblJlcXVlc3QgJiYgISgnd2l0aENyZWRlbnRpYWxzJyBpbiByZXF1ZXN0KSAmJlxuICAgICAgICAhaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSB7XG4gICAgICByZXF1ZXN0ID0gbmV3IHdpbmRvdy5YRG9tYWluUmVxdWVzdCgpO1xuICAgICAgbG9hZEV2ZW50ID0gJ29ubG9hZCc7XG4gICAgICB4RG9tYWluID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uIGhhbmRsZVByb2dyZXNzKCkge307XG4gICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7fTtcbiAgICB9XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkIHx8ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICByZXF1ZXN0W2xvYWRFdmVudF0gPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0IHx8IChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQgJiYgIXhEb21haW4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIWNvbmZpZy5yZXNwb25zZVR5cGUgfHwgY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIC8vIElFIHNlbmRzIDEyMjMgaW5zdGVhZCBvZiAyMDQgKGh0dHBzOi8vZ2l0aHViLmNvbS9temFicmlza2llL2F4aW9zL2lzc3Vlcy8yMDEpXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAnTm8gQ29udGVudCcgOiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIHZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcblxuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QucmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25VcGxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25VcGxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnByb21pc2UudGhlbihmdW5jdGlvbiBvbkNhbmNlbGVkKGNhbmNlbCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlamVjdChjYW5jZWwpO1xuICAgICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3REYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICAvLyBOb3RlOiBzdGF0dXMgaXMgbm90IGV4cG9zZWQgYnkgWERvbWFpblJlcXVlc3RcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vZW5oYW5jZUVycm9yJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gQCBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGNvbmZpZywgY29kZSwgcmVzcG9uc2UpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlc3BvbnNlKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gQCBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVzcG9uc2UpIHtcbiAgZXJyb3IuY29uZmlnID0gY29uZmlnO1xuICBpZiAoY29kZSkge1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICB9XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIHJldHVybiBlcnJvcjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lNDAvZ2ksICdAJykuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9XG5cbiAgICAgIGlmICghdXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgdmFyIG9yaWdpblVSTDtcblxuICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICB9XG5cbiAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH0pKClcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIid1c2Ugc3RyaWN0JztcblxuLy8gYnRvYSBwb2x5ZmlsbCBmb3IgSUU8MTAgY291cnRlc3kgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkY2hhbWJlcnMvQmFzZTY0LmpzXG5cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbmZ1bmN0aW9uIEUoKSB7XG4gIHRoaXMubWVzc2FnZSA9ICdTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXInO1xufVxuRS5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG5FLnByb3RvdHlwZS5jb2RlID0gNTtcbkUucHJvdG90eXBlLm5hbWUgPSAnSW52YWxpZENoYXJhY3RlckVycm9yJztcblxuZnVuY3Rpb24gYnRvYShpbnB1dCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGlucHV0KTtcbiAgdmFyIG91dHB1dCA9ICcnO1xuICBmb3IgKFxuICAgIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyXG4gICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnM7XG4gICAgLy8gaWYgdGhlIG5leHQgc3RyIGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgIC8vICAgY2hhbmdlIHRoZSBtYXBwaW5nIHRhYmxlIHRvIFwiPVwiXG4gICAgLy8gICBjaGVjayBpZiBkIGhhcyBubyBmcmFjdGlvbmFsIGRpZ2l0c1xuICAgIHN0ci5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG4gICAgLy8gXCI4IC0gaWR4ICUgMSAqIDhcIiBnZW5lcmF0ZXMgdGhlIHNlcXVlbmNlIDIsIDQsIDYsIDhcbiAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgKSB7XG4gICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpZHggKz0gMyAvIDQpO1xuICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgIHRocm93IG5ldyBFKCk7XG4gICAgfVxuICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnRvYTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2hlbHBlcnMvYnRvYS5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgdmFyIGNvb2tpZSA9IFtdO1xuICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgfSxcblxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgIHJldHVybiAobWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbCk7XG4gICAgICB9LFxuXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgIH07XG4gIH0pKClcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gSW50ZXJjZXB0b3JNYW5hZ2VyKCkge1xuICB0aGlzLmhhbmRsZXJzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkXG4gIH0pO1xuICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZWplY3QgPSBmdW5jdGlvbiBlamVjdChpZCkge1xuICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgZm4oaCk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJjZXB0b3JNYW5hZ2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVycyB8fCB7fVxuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4oZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuY29uc3QgRXJyb3JNb2RhbCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRpdGxlOiAnRXJyb3InXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBwcm9wVHlwZXM6IHtcclxuICAgICAgICB0aXRsZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcclxuICAgICAgICBtZXNzYWdlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcclxuICAgIH0sXHJcbiAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IG1vZGFsID0gbmV3IEZvdW5kYXRpb24uUmV2ZWFsKCQoJyNlcnJvci1tb2RhbCcpKTtcclxuICAgICAgICBtb2RhbC5vcGVuKCk7XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgeyB0aXRsZSwgbWVzc2FnZSB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2IGlkPVwiZXJyb3ItbW9kYWxcIiBjbGFzc05hbWU9XCJyZXZlYWwgdGlueVwiIGRhdGEtcmV2ZWFsPVwiXCI+XHJcbiAgICAgICAgICAgICAgICA8aDQ+e3RpdGxlfTwvaDQ+XHJcbiAgICAgICAgICAgICAgICA8cD57bWVzc2FnZX08L3A+XHJcbiAgICAgICAgICAgICAgICA8cD5cclxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cImJ1dHRvbiBob2xsb3dcIiBkYXRhLWNsb3NlPVwiXCI+T2theTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEVycm9yTW9kYWw7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FwcC9jb21wb25lbnRzL0Vycm9yTW9kYWwuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuY29uc3QgQWJvdXQgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlcmVkIHBhZ2UtdGl0bGVcIj5BYm91dDwvaDE+XHJcbiAgICAgICAgICAgIDxwPkEgcmVhY3Qgd2VhdGhlciBhcHA8L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL0Z1bmtTb3VsTmluamEvUmVhY3RXZWF0aGVyXCI+U291cmNlIGNvZGU8L2E+XHJcbiAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFib3V0O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hcHAvY29tcG9uZW50cy9BYm91dC5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IExpbmsgfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xyXG5cclxuY29uc3QgRXhhbXBsZXMgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlcmVkIHBhZ2UtdGl0bGVcIj5FeGFtcGxlczwvaDE+XHJcbiAgICAgICAgICAgIDxwPkhlcmUgYXJlIGEgZmV3IGV4YW1wbGVzIGxvY2F0aW9ucyB0byB0cnkgb3V0PC9wPlxyXG4gICAgICAgICAgICA8b2w+XHJcbiAgICAgICAgICAgICAgICA8bGk+PExpbmsgdG89XCIvP2xvY2F0aW9uPWxhcyUyMHZlZ2FzXCI+TGFzIFZlZ2FzPC9MaW5rPjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+PExpbmsgdG89XCIvP2xvY2F0aW9uPVRva3lvXCI+VG9reW88L0xpbms+PC9saT5cclxuICAgICAgICAgICAgPC9vbD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFeGFtcGxlcztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXBwL2NvbXBvbmVudHMvRXhhbXBsZXMuanMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vZm91bmRhdGlvbi5taW4uY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9mb3VuZGF0aW9uLm1pbi5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL2ZvdW5kYXRpb24ubWluLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlciEuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2ZvdW5kYXRpb24ubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMjc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAY2hhcnNldCBcXFwiVVRGLThcXFwiO1xcbi8qISBub3JtYWxpemUuY3NzIHYzLjAuMyB8IE1JVCBMaWNlbnNlIHwgZ2l0aHViLmNvbS9uZWNvbGFzL25vcm1hbGl6ZS5jc3MgKi9odG1se2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7LW1zLXRleHQtc2l6ZS1hZGp1c3Q6MTAwJTstd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6MTAwJX1ib2R5e21hcmdpbjowfWFydGljbGUsYXNpZGUsZGV0YWlscyxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsaGVhZGVyLGhncm91cCxtYWluLG1lbnUsbmF2LHNlY3Rpb24sc3VtbWFyeXtkaXNwbGF5OmJsb2NrfWF1ZGlvLGNhbnZhcyxwcm9ncmVzcyx2aWRlb3tkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjpiYXNlbGluZX1hdWRpbzpub3QoW2NvbnRyb2xzXSl7ZGlzcGxheTpub25lO2hlaWdodDowfVtoaWRkZW5dLHRlbXBsYXRle2Rpc3BsYXk6bm9uZX1he2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnR9YTphY3RpdmUsYTpob3ZlcntvdXRsaW5lOjB9YWJiclt0aXRsZV17Ym9yZGVyLWJvdHRvbToxcHggZG90dGVkfWIsc3Ryb25ne2ZvbnQtd2VpZ2h0OjcwMH1kZm57Zm9udC1zdHlsZTppdGFsaWN9aDF7Zm9udC1zaXplOjJlbTttYXJnaW46LjY3ZW0gMH1tYXJre2JhY2tncm91bmQ6I2ZmMDtjb2xvcjojMDAwfXNtYWxse2ZvbnQtc2l6ZTo4MCV9c3ViLHN1cHtmb250LXNpemU6NzUlO2xpbmUtaGVpZ2h0OjA7cG9zaXRpb246cmVsYXRpdmU7dmVydGljYWwtYWxpZ246YmFzZWxpbmV9c3Vwe3RvcDotLjVlbX1zdWJ7Ym90dG9tOi0uMjVlbX1pbWd7Ym9yZGVyOjB9c3ZnOm5vdCg6cm9vdCl7b3ZlcmZsb3c6aGlkZGVufWZpZ3VyZXttYXJnaW46MWVtIDQwcHh9aHJ7Ym94LXNpemluZzpjb250ZW50LWJveDtoZWlnaHQ6MH1wcmV7b3ZlcmZsb3c6YXV0b31jb2RlLGtiZCxwcmUsc2FtcHtmb250LWZhbWlseTptb25vc3BhY2U7Zm9udC1zaXplOjFlbX1idXR0b24saW5wdXQsb3B0Z3JvdXAsc2VsZWN0LHRleHRhcmVhe2NvbG9yOmluaGVyaXQ7Zm9udDppbmhlcml0O21hcmdpbjowfWJ1dHRvbntvdmVyZmxvdzp2aXNpYmxlfWJ1dHRvbixzZWxlY3R7dGV4dC10cmFuc2Zvcm06bm9uZX1idXR0b24saHRtbCBpbnB1dFt0eXBlPWJ1dHRvbl0saW5wdXRbdHlwZT1yZXNldF0saW5wdXRbdHlwZT1zdWJtaXRdey13ZWJraXQtYXBwZWFyYW5jZTpidXR0b247Y3Vyc29yOnBvaW50ZXJ9YnV0dG9uW2Rpc2FibGVkXSxodG1sIGlucHV0W2Rpc2FibGVkXXtjdXJzb3I6ZGVmYXVsdH1idXR0b246Oi1tb3otZm9jdXMtaW5uZXIsaW5wdXQ6Oi1tb3otZm9jdXMtaW5uZXJ7Ym9yZGVyOjA7cGFkZGluZzowfWlucHV0e2xpbmUtaGVpZ2h0Om5vcm1hbH1pbnB1dFt0eXBlPWNoZWNrYm94XSxpbnB1dFt0eXBlPXJhZGlvXXtib3gtc2l6aW5nOmJvcmRlci1ib3g7cGFkZGluZzowfWlucHV0W3R5cGU9bnVtYmVyXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixpbnB1dFt0eXBlPW51bWJlcl06Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b257aGVpZ2h0OmF1dG99aW5wdXRbdHlwZT1zZWFyY2hdey13ZWJraXQtYXBwZWFyYW5jZTp0ZXh0ZmllbGQ7Ym94LXNpemluZzpjb250ZW50LWJveH1pbnB1dFt0eXBlPXNlYXJjaF06Oi13ZWJraXQtc2VhcmNoLWNhbmNlbC1idXR0b24saW5wdXRbdHlwZT1zZWFyY2hdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uey13ZWJraXQtYXBwZWFyYW5jZTpub25lfWxlZ2VuZHtib3JkZXI6MDtwYWRkaW5nOjB9dGV4dGFyZWF7b3ZlcmZsb3c6YXV0b31vcHRncm91cHtmb250LXdlaWdodDo3MDB9dGFibGV7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlO2JvcmRlci1zcGFjaW5nOjB9dGQsdGh7cGFkZGluZzowfS5mb3VuZGF0aW9uLW1xe2ZvbnQtZmFtaWx5OlxcXCJzbWFsbD0wZW0mbWVkaXVtPTQwZW0mbGFyZ2U9NjRlbSZ4bGFyZ2U9NzVlbSZ4eGxhcmdlPTkwZW1cXFwifWh0bWx7Zm9udC1zaXplOjEwMCU7Ym94LXNpemluZzpib3JkZXItYm94fSosOmFmdGVyLDpiZWZvcmV7Ym94LXNpemluZzppbmhlcml0fWJvZHl7cGFkZGluZzowO21hcmdpbjowO2ZvbnQtZmFtaWx5OkhlbHZldGljYSBOZXVlLEhlbHZldGljYSxSb2JvdG8sQXJpYWwsc2Fucy1zZXJpZjtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6MS41O2NvbG9yOiMwYTBhMGE7YmFja2dyb3VuZDojZmVmZWZlOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlfWltZ3ttYXgtd2lkdGg6MTAwJTtoZWlnaHQ6YXV0bzstbXMtaW50ZXJwb2xhdGlvbi1tb2RlOmJpY3ViaWM7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246bWlkZGxlfXRleHRhcmVhe2hlaWdodDphdXRvO21pbi1oZWlnaHQ6NTBweDtib3JkZXItcmFkaXVzOjB9c2VsZWN0e3dpZHRoOjEwMCU7Ym9yZGVyLXJhZGl1czowfSNtYXBfY2FudmFzIGVtYmVkLCNtYXBfY2FudmFzIGltZywjbWFwX2NhbnZhcyBvYmplY3QsLm1hcF9jYW52YXMgZW1iZWQsLm1hcF9jYW52YXMgaW1nLC5tYXBfY2FudmFzIG9iamVjdCwubXFhLWRpc3BsYXkgZW1iZWQsLm1xYS1kaXNwbGF5IGltZywubXFhLWRpc3BsYXkgb2JqZWN0e21heC13aWR0aDpub25lIWltcG9ydGFudH1idXR0b257LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7LW1vei1hcHBlYXJhbmNlOm5vbmU7YmFja2dyb3VuZDp0cmFuc3BhcmVudDtwYWRkaW5nOjA7Ym9yZGVyOjA7Ym9yZGVyLXJhZGl1czowO2xpbmUtaGVpZ2h0OjF9LmlzLXZpc2libGV7ZGlzcGxheTpibG9jayFpbXBvcnRhbnR9LmlzLWhpZGRlbntkaXNwbGF5Om5vbmUhaW1wb3J0YW50fS5yb3d7bWF4LXdpZHRoOjc1cmVtO21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG99LnJvdzphZnRlciwucm93OmJlZm9yZXtjb250ZW50OicgJztkaXNwbGF5OnRhYmxlOy13ZWJraXQtZmxleC1iYXNpczowOy1tcy1mbGV4LXByZWZlcnJlZC1zaXplOjA7ZmxleC1iYXNpczowOy13ZWJraXQtb3JkZXI6MTstbXMtZmxleC1vcmRlcjoxO29yZGVyOjF9LnJvdzphZnRlcntjbGVhcjpib3RofS5yb3cuY29sbGFwc2U+LmNvbHVtbiwucm93LmNvbGxhcHNlPi5jb2x1bW5ze3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6MH0ucm93IC5yb3d7bWFyZ2luLWxlZnQ6LS42MjVyZW07bWFyZ2luLXJpZ2h0Oi0uNjI1cmVtfUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7LnJvdyAucm93e21hcmdpbi1sZWZ0Oi0uOTM3NXJlbTttYXJnaW4tcmlnaHQ6LS45Mzc1cmVtfX0ucm93IC5yb3cuY29sbGFwc2V7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MH0ucm93LmV4cGFuZGVke21heC13aWR0aDpub25lfS5yb3cuZXhwYW5kZWQgLnJvd3ttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvfS5jb2x1bW4sLmNvbHVtbnN7d2lkdGg6MTAwJTtmbG9hdDpsZWZ0O3BhZGRpbmctbGVmdDouNjI1cmVtO3BhZGRpbmctcmlnaHQ6LjYyNXJlbX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pey5jb2x1bW4sLmNvbHVtbnN7cGFkZGluZy1sZWZ0Oi45Mzc1cmVtO3BhZGRpbmctcmlnaHQ6LjkzNzVyZW19fS5jb2x1bW46bGFzdC1jaGlsZDpub3QoOmZpcnN0LWNoaWxkKSwuY29sdW1uczpsYXN0LWNoaWxkOm5vdCg6Zmlyc3QtY2hpbGQpe2Zsb2F0OnJpZ2h0fS5jb2x1bW4uZW5kOmxhc3QtY2hpbGQ6bGFzdC1jaGlsZCwuZW5kLmNvbHVtbnM6bGFzdC1jaGlsZDpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LmNvbHVtbi5yb3cucm93LC5yb3cucm93LmNvbHVtbnN7ZmxvYXQ6bm9uZX0ucm93IC5jb2x1bW4ucm93LnJvdywucm93IC5yb3cucm93LmNvbHVtbnN7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDowO21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjB9LnNtYWxsLTF7d2lkdGg6OC4zMzMzMyV9LnNtYWxsLXB1c2gtMXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjguMzMzMzMlfS5zbWFsbC1wdWxsLTF7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotOC4zMzMzMyV9LnNtYWxsLW9mZnNldC0we21hcmdpbi1sZWZ0OjB9LnNtYWxsLTJ7d2lkdGg6MTYuNjY2NjclfS5zbWFsbC1wdXNoLTJ7cG9zaXRpb246cmVsYXRpdmU7bGVmdDoxNi42NjY2NyV9LnNtYWxsLXB1bGwtMntwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi0xNi42NjY2NyV9LnNtYWxsLW9mZnNldC0xe21hcmdpbi1sZWZ0OjguMzMzMzMlfS5zbWFsbC0ze3dpZHRoOjI1JX0uc21hbGwtcHVzaC0ze3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6MjUlfS5zbWFsbC1wdWxsLTN7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotMjUlfS5zbWFsbC1vZmZzZXQtMnttYXJnaW4tbGVmdDoxNi42NjY2NyV9LnNtYWxsLTR7d2lkdGg6MzMuMzMzMzMlfS5zbWFsbC1wdXNoLTR7cG9zaXRpb246cmVsYXRpdmU7bGVmdDozMy4zMzMzMyV9LnNtYWxsLXB1bGwtNHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi0zMy4zMzMzMyV9LnNtYWxsLW9mZnNldC0ze21hcmdpbi1sZWZ0OjI1JX0uc21hbGwtNXt3aWR0aDo0MS42NjY2NyV9LnNtYWxsLXB1c2gtNXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjQxLjY2NjY3JX0uc21hbGwtcHVsbC01e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTQxLjY2NjY3JX0uc21hbGwtb2Zmc2V0LTR7bWFyZ2luLWxlZnQ6MzMuMzMzMzMlfS5zbWFsbC02e3dpZHRoOjUwJX0uc21hbGwtcHVzaC02e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NTAlfS5zbWFsbC1wdWxsLTZ7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotNTAlfS5zbWFsbC1vZmZzZXQtNXttYXJnaW4tbGVmdDo0MS42NjY2NyV9LnNtYWxsLTd7d2lkdGg6NTguMzMzMzMlfS5zbWFsbC1wdXNoLTd7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo1OC4zMzMzMyV9LnNtYWxsLXB1bGwtN3twb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi01OC4zMzMzMyV9LnNtYWxsLW9mZnNldC02e21hcmdpbi1sZWZ0OjUwJX0uc21hbGwtOHt3aWR0aDo2Ni42NjY2NyV9LnNtYWxsLXB1c2gtOHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjY2LjY2NjY3JX0uc21hbGwtcHVsbC04e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTY2LjY2NjY3JX0uc21hbGwtb2Zmc2V0LTd7bWFyZ2luLWxlZnQ6NTguMzMzMzMlfS5zbWFsbC05e3dpZHRoOjc1JX0uc21hbGwtcHVzaC05e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NzUlfS5zbWFsbC1wdWxsLTl7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotNzUlfS5zbWFsbC1vZmZzZXQtOHttYXJnaW4tbGVmdDo2Ni42NjY2NyV9LnNtYWxsLTEwe3dpZHRoOjgzLjMzMzMzJX0uc21hbGwtcHVzaC0xMHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjgzLjMzMzMzJX0uc21hbGwtcHVsbC0xMHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi04My4zMzMzMyV9LnNtYWxsLW9mZnNldC05e21hcmdpbi1sZWZ0Ojc1JX0uc21hbGwtMTF7d2lkdGg6OTEuNjY2NjclfS5zbWFsbC1wdXNoLTExe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6OTEuNjY2NjclfS5zbWFsbC1wdWxsLTExe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTkxLjY2NjY3JX0uc21hbGwtb2Zmc2V0LTEwe21hcmdpbi1sZWZ0OjgzLjMzMzMzJX0uc21hbGwtMTJ7d2lkdGg6MTAwJX0uc21hbGwtb2Zmc2V0LTExe21hcmdpbi1sZWZ0OjkxLjY2NjY3JX0uc21hbGwtdXAtMT4uY29sdW1uLC5zbWFsbC11cC0xPi5jb2x1bW5ze3dpZHRoOjEwMCU7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtMT4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwuc21hbGwtdXAtMT4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0uc21hbGwtdXAtMT4uY29sdW1uOm50aC1vZi10eXBlKDFuKzEpLC5zbWFsbC11cC0xPi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKzEpe2NsZWFyOmJvdGh9LnNtYWxsLXVwLTE+LmNvbHVtbjpsYXN0LWNoaWxkLC5zbWFsbC11cC0xPi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtMj4uY29sdW1uLC5zbWFsbC11cC0yPi5jb2x1bW5ze3dpZHRoOjUwJTtmbG9hdDpsZWZ0fS5zbWFsbC11cC0yPi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5zbWFsbC11cC0yPi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5zbWFsbC11cC0yPi5jb2x1bW46bnRoLW9mLXR5cGUoMm4rMSksLnNtYWxsLXVwLTI+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMm4rMSl7Y2xlYXI6Ym90aH0uc21hbGwtdXAtMj4uY29sdW1uOmxhc3QtY2hpbGQsLnNtYWxsLXVwLTI+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5zbWFsbC11cC0zPi5jb2x1bW4sLnNtYWxsLXVwLTM+LmNvbHVtbnN7d2lkdGg6MzMuMzMzMzMlO2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTM+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLnNtYWxsLXVwLTM+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LnNtYWxsLXVwLTM+LmNvbHVtbjpudGgtb2YtdHlwZSgzbisxKSwuc21hbGwtdXAtMz4uY29sdW1uczpudGgtb2YtdHlwZSgzbisxKXtjbGVhcjpib3RofS5zbWFsbC11cC0zPi5jb2x1bW46bGFzdC1jaGlsZCwuc21hbGwtdXAtMz4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTQ+LmNvbHVtbiwuc21hbGwtdXAtND4uY29sdW1uc3t3aWR0aDoyNSU7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtND4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwuc21hbGwtdXAtND4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0uc21hbGwtdXAtND4uY29sdW1uOm50aC1vZi10eXBlKDRuKzEpLC5zbWFsbC11cC00Pi5jb2x1bW5zOm50aC1vZi10eXBlKDRuKzEpe2NsZWFyOmJvdGh9LnNtYWxsLXVwLTQ+LmNvbHVtbjpsYXN0LWNoaWxkLC5zbWFsbC11cC00Pi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtNT4uY29sdW1uLC5zbWFsbC11cC01Pi5jb2x1bW5ze3dpZHRoOjIwJTtmbG9hdDpsZWZ0fS5zbWFsbC11cC01Pi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5zbWFsbC11cC01Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5zbWFsbC11cC01Pi5jb2x1bW46bnRoLW9mLXR5cGUoNW4rMSksLnNtYWxsLXVwLTU+LmNvbHVtbnM6bnRoLW9mLXR5cGUoNW4rMSl7Y2xlYXI6Ym90aH0uc21hbGwtdXAtNT4uY29sdW1uOmxhc3QtY2hpbGQsLnNtYWxsLXVwLTU+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5zbWFsbC11cC02Pi5jb2x1bW4sLnNtYWxsLXVwLTY+LmNvbHVtbnN7d2lkdGg6MTYuNjY2NjclO2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTY+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLnNtYWxsLXVwLTY+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LnNtYWxsLXVwLTY+LmNvbHVtbjpudGgtb2YtdHlwZSg2bisxKSwuc21hbGwtdXAtNj4uY29sdW1uczpudGgtb2YtdHlwZSg2bisxKXtjbGVhcjpib3RofS5zbWFsbC11cC02Pi5jb2x1bW46bGFzdC1jaGlsZCwuc21hbGwtdXAtNj4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTc+LmNvbHVtbiwuc21hbGwtdXAtNz4uY29sdW1uc3t3aWR0aDoxNC4yODU3MSU7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtNz4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwuc21hbGwtdXAtNz4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0uc21hbGwtdXAtNz4uY29sdW1uOm50aC1vZi10eXBlKDduKzEpLC5zbWFsbC11cC03Pi5jb2x1bW5zOm50aC1vZi10eXBlKDduKzEpe2NsZWFyOmJvdGh9LnNtYWxsLXVwLTc+LmNvbHVtbjpsYXN0LWNoaWxkLC5zbWFsbC11cC03Pi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtOD4uY29sdW1uLC5zbWFsbC11cC04Pi5jb2x1bW5ze3dpZHRoOjEyLjUlO2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTg+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLnNtYWxsLXVwLTg+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LnNtYWxsLXVwLTg+LmNvbHVtbjpudGgtb2YtdHlwZSg4bisxKSwuc21hbGwtdXAtOD4uY29sdW1uczpudGgtb2YtdHlwZSg4bisxKXtjbGVhcjpib3RofS5zbWFsbC11cC04Pi5jb2x1bW46bGFzdC1jaGlsZCwuc21hbGwtdXAtOD4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LnNtYWxsLWNvbGxhcHNlPi5jb2x1bW4sLnNtYWxsLWNvbGxhcHNlPi5jb2x1bW5ze3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6MH0uc21hbGwtY29sbGFwc2UgLnJvd3ttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowfS5zbWFsbC11bmNvbGxhcHNlPi5jb2x1bW4sLnNtYWxsLXVuY29sbGFwc2U+LmNvbHVtbnN7cGFkZGluZy1sZWZ0Oi42MjVyZW07cGFkZGluZy1yaWdodDouNjI1cmVtfS5zbWFsbC1jZW50ZXJlZHtmbG9hdDpub25lO21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG99LnNtYWxsLXB1bGwtMCwuc21hbGwtcHVzaC0wLC5zbWFsbC11bmNlbnRlcmVke3Bvc2l0aW9uOnN0YXRpYzttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO2Zsb2F0OmxlZnR9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsubWVkaXVtLTF7d2lkdGg6OC4zMzMzMyV9Lm1lZGl1bS1wdXNoLTF7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo4LjMzMzMzJX0ubWVkaXVtLXB1bGwtMXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi04LjMzMzMzJX0ubWVkaXVtLW9mZnNldC0we21hcmdpbi1sZWZ0OjB9Lm1lZGl1bS0ye3dpZHRoOjE2LjY2NjY3JX0ubWVkaXVtLXB1c2gtMntwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjE2LjY2NjY3JX0ubWVkaXVtLXB1bGwtMntwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi0xNi42NjY2NyV9Lm1lZGl1bS1vZmZzZXQtMXttYXJnaW4tbGVmdDo4LjMzMzMzJX0ubWVkaXVtLTN7d2lkdGg6MjUlfS5tZWRpdW0tcHVzaC0ze3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6MjUlfS5tZWRpdW0tcHVsbC0ze3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTI1JX0ubWVkaXVtLW9mZnNldC0ye21hcmdpbi1sZWZ0OjE2LjY2NjY3JX0ubWVkaXVtLTR7d2lkdGg6MzMuMzMzMzMlfS5tZWRpdW0tcHVzaC00e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6MzMuMzMzMzMlfS5tZWRpdW0tcHVsbC00e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTMzLjMzMzMzJX0ubWVkaXVtLW9mZnNldC0ze21hcmdpbi1sZWZ0OjI1JX0ubWVkaXVtLTV7d2lkdGg6NDEuNjY2NjclfS5tZWRpdW0tcHVzaC01e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NDEuNjY2NjclfS5tZWRpdW0tcHVsbC01e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTQxLjY2NjY3JX0ubWVkaXVtLW9mZnNldC00e21hcmdpbi1sZWZ0OjMzLjMzMzMzJX0ubWVkaXVtLTZ7d2lkdGg6NTAlfS5tZWRpdW0tcHVzaC02e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NTAlfS5tZWRpdW0tcHVsbC02e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTUwJX0ubWVkaXVtLW9mZnNldC01e21hcmdpbi1sZWZ0OjQxLjY2NjY3JX0ubWVkaXVtLTd7d2lkdGg6NTguMzMzMzMlfS5tZWRpdW0tcHVzaC03e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NTguMzMzMzMlfS5tZWRpdW0tcHVsbC03e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTU4LjMzMzMzJX0ubWVkaXVtLW9mZnNldC02e21hcmdpbi1sZWZ0OjUwJX0ubWVkaXVtLTh7d2lkdGg6NjYuNjY2NjclfS5tZWRpdW0tcHVzaC04e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NjYuNjY2NjclfS5tZWRpdW0tcHVsbC04e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTY2LjY2NjY3JX0ubWVkaXVtLW9mZnNldC03e21hcmdpbi1sZWZ0OjU4LjMzMzMzJX0ubWVkaXVtLTl7d2lkdGg6NzUlfS5tZWRpdW0tcHVzaC05e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NzUlfS5tZWRpdW0tcHVsbC05e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTc1JX0ubWVkaXVtLW9mZnNldC04e21hcmdpbi1sZWZ0OjY2LjY2NjY3JX0ubWVkaXVtLTEwe3dpZHRoOjgzLjMzMzMzJX0ubWVkaXVtLXB1c2gtMTB7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo4My4zMzMzMyV9Lm1lZGl1bS1wdWxsLTEwe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTgzLjMzMzMzJX0ubWVkaXVtLW9mZnNldC05e21hcmdpbi1sZWZ0Ojc1JX0ubWVkaXVtLTExe3dpZHRoOjkxLjY2NjY3JX0ubWVkaXVtLXB1c2gtMTF7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo5MS42NjY2NyV9Lm1lZGl1bS1wdWxsLTExe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTkxLjY2NjY3JX0ubWVkaXVtLW9mZnNldC0xMHttYXJnaW4tbGVmdDo4My4zMzMzMyV9Lm1lZGl1bS0xMnt3aWR0aDoxMDAlfS5tZWRpdW0tb2Zmc2V0LTExe21hcmdpbi1sZWZ0OjkxLjY2NjY3JX0ubWVkaXVtLXVwLTE+LmNvbHVtbiwubWVkaXVtLXVwLTE+LmNvbHVtbnN7d2lkdGg6MTAwJTtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtMT4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubWVkaXVtLXVwLTE+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9Lm1lZGl1bS11cC0xPi5jb2x1bW46bnRoLW9mLXR5cGUoMW4rMSksLm1lZGl1bS11cC0xPi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKzEpe2NsZWFyOmJvdGh9Lm1lZGl1bS11cC0xPi5jb2x1bW46bGFzdC1jaGlsZCwubWVkaXVtLXVwLTE+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtMj4uY29sdW1uLC5tZWRpdW0tdXAtMj4uY29sdW1uc3t3aWR0aDo1MCU7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTI+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLm1lZGl1bS11cC0yPi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5tZWRpdW0tdXAtMj4uY29sdW1uOm50aC1vZi10eXBlKDJuKzEpLC5tZWRpdW0tdXAtMj4uY29sdW1uczpudGgtb2YtdHlwZSgybisxKXtjbGVhcjpib3RofS5tZWRpdW0tdXAtMj4uY29sdW1uOmxhc3QtY2hpbGQsLm1lZGl1bS11cC0yPi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTM+LmNvbHVtbiwubWVkaXVtLXVwLTM+LmNvbHVtbnN7d2lkdGg6MzMuMzMzMzMlO2Zsb2F0OmxlZnR9Lm1lZGl1bS11cC0zPi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5tZWRpdW0tdXAtMz4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0ubWVkaXVtLXVwLTM+LmNvbHVtbjpudGgtb2YtdHlwZSgzbisxKSwubWVkaXVtLXVwLTM+LmNvbHVtbnM6bnRoLW9mLXR5cGUoM24rMSl7Y2xlYXI6Ym90aH0ubWVkaXVtLXVwLTM+LmNvbHVtbjpsYXN0LWNoaWxkLC5tZWRpdW0tdXAtMz4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9Lm1lZGl1bS11cC00Pi5jb2x1bW4sLm1lZGl1bS11cC00Pi5jb2x1bW5ze3dpZHRoOjI1JTtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtND4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubWVkaXVtLXVwLTQ+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9Lm1lZGl1bS11cC00Pi5jb2x1bW46bnRoLW9mLXR5cGUoNG4rMSksLm1lZGl1bS11cC00Pi5jb2x1bW5zOm50aC1vZi10eXBlKDRuKzEpe2NsZWFyOmJvdGh9Lm1lZGl1bS11cC00Pi5jb2x1bW46bGFzdC1jaGlsZCwubWVkaXVtLXVwLTQ+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtNT4uY29sdW1uLC5tZWRpdW0tdXAtNT4uY29sdW1uc3t3aWR0aDoyMCU7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTU+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLm1lZGl1bS11cC01Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5tZWRpdW0tdXAtNT4uY29sdW1uOm50aC1vZi10eXBlKDVuKzEpLC5tZWRpdW0tdXAtNT4uY29sdW1uczpudGgtb2YtdHlwZSg1bisxKXtjbGVhcjpib3RofS5tZWRpdW0tdXAtNT4uY29sdW1uOmxhc3QtY2hpbGQsLm1lZGl1bS11cC01Pi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTY+LmNvbHVtbiwubWVkaXVtLXVwLTY+LmNvbHVtbnN7d2lkdGg6MTYuNjY2NjclO2Zsb2F0OmxlZnR9Lm1lZGl1bS11cC02Pi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5tZWRpdW0tdXAtNj4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0ubWVkaXVtLXVwLTY+LmNvbHVtbjpudGgtb2YtdHlwZSg2bisxKSwubWVkaXVtLXVwLTY+LmNvbHVtbnM6bnRoLW9mLXR5cGUoNm4rMSl7Y2xlYXI6Ym90aH0ubWVkaXVtLXVwLTY+LmNvbHVtbjpsYXN0LWNoaWxkLC5tZWRpdW0tdXAtNj4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9Lm1lZGl1bS11cC03Pi5jb2x1bW4sLm1lZGl1bS11cC03Pi5jb2x1bW5ze3dpZHRoOjE0LjI4NTcxJTtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtNz4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubWVkaXVtLXVwLTc+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9Lm1lZGl1bS11cC03Pi5jb2x1bW46bnRoLW9mLXR5cGUoN24rMSksLm1lZGl1bS11cC03Pi5jb2x1bW5zOm50aC1vZi10eXBlKDduKzEpe2NsZWFyOmJvdGh9Lm1lZGl1bS11cC03Pi5jb2x1bW46bGFzdC1jaGlsZCwubWVkaXVtLXVwLTc+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtOD4uY29sdW1uLC5tZWRpdW0tdXAtOD4uY29sdW1uc3t3aWR0aDoxMi41JTtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtOD4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubWVkaXVtLXVwLTg+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9Lm1lZGl1bS11cC04Pi5jb2x1bW46bnRoLW9mLXR5cGUoOG4rMSksLm1lZGl1bS11cC04Pi5jb2x1bW5zOm50aC1vZi10eXBlKDhuKzEpe2NsZWFyOmJvdGh9Lm1lZGl1bS11cC04Pi5jb2x1bW46bGFzdC1jaGlsZCwubWVkaXVtLXVwLTg+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5tZWRpdW0tY29sbGFwc2U+LmNvbHVtbiwubWVkaXVtLWNvbGxhcHNlPi5jb2x1bW5ze3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6MH0ubWVkaXVtLWNvbGxhcHNlIC5yb3d7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MH0ubWVkaXVtLXVuY29sbGFwc2U+LmNvbHVtbiwubWVkaXVtLXVuY29sbGFwc2U+LmNvbHVtbnN7cGFkZGluZy1sZWZ0Oi45Mzc1cmVtO3BhZGRpbmctcmlnaHQ6LjkzNzVyZW19Lm1lZGl1bS1jZW50ZXJlZHtmbG9hdDpub25lO21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG99Lm1lZGl1bS1wdWxsLTAsLm1lZGl1bS1wdXNoLTAsLm1lZGl1bS11bmNlbnRlcmVke3Bvc2l0aW9uOnN0YXRpYzttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO2Zsb2F0OmxlZnR9fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NjRlbSl7LmxhcmdlLTF7d2lkdGg6OC4zMzMzMyV9LmxhcmdlLXB1c2gtMXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjguMzMzMzMlfS5sYXJnZS1wdWxsLTF7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotOC4zMzMzMyV9LmxhcmdlLW9mZnNldC0we21hcmdpbi1sZWZ0OjB9LmxhcmdlLTJ7d2lkdGg6MTYuNjY2NjclfS5sYXJnZS1wdXNoLTJ7cG9zaXRpb246cmVsYXRpdmU7bGVmdDoxNi42NjY2NyV9LmxhcmdlLXB1bGwtMntwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi0xNi42NjY2NyV9LmxhcmdlLW9mZnNldC0xe21hcmdpbi1sZWZ0OjguMzMzMzMlfS5sYXJnZS0ze3dpZHRoOjI1JX0ubGFyZ2UtcHVzaC0ze3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6MjUlfS5sYXJnZS1wdWxsLTN7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotMjUlfS5sYXJnZS1vZmZzZXQtMnttYXJnaW4tbGVmdDoxNi42NjY2NyV9LmxhcmdlLTR7d2lkdGg6MzMuMzMzMzMlfS5sYXJnZS1wdXNoLTR7cG9zaXRpb246cmVsYXRpdmU7bGVmdDozMy4zMzMzMyV9LmxhcmdlLXB1bGwtNHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi0zMy4zMzMzMyV9LmxhcmdlLW9mZnNldC0ze21hcmdpbi1sZWZ0OjI1JX0ubGFyZ2UtNXt3aWR0aDo0MS42NjY2NyV9LmxhcmdlLXB1c2gtNXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjQxLjY2NjY3JX0ubGFyZ2UtcHVsbC01e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTQxLjY2NjY3JX0ubGFyZ2Utb2Zmc2V0LTR7bWFyZ2luLWxlZnQ6MzMuMzMzMzMlfS5sYXJnZS02e3dpZHRoOjUwJX0ubGFyZ2UtcHVzaC02e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NTAlfS5sYXJnZS1wdWxsLTZ7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotNTAlfS5sYXJnZS1vZmZzZXQtNXttYXJnaW4tbGVmdDo0MS42NjY2NyV9LmxhcmdlLTd7d2lkdGg6NTguMzMzMzMlfS5sYXJnZS1wdXNoLTd7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo1OC4zMzMzMyV9LmxhcmdlLXB1bGwtN3twb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi01OC4zMzMzMyV9LmxhcmdlLW9mZnNldC02e21hcmdpbi1sZWZ0OjUwJX0ubGFyZ2UtOHt3aWR0aDo2Ni42NjY2NyV9LmxhcmdlLXB1c2gtOHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjY2LjY2NjY3JX0ubGFyZ2UtcHVsbC04e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTY2LjY2NjY3JX0ubGFyZ2Utb2Zmc2V0LTd7bWFyZ2luLWxlZnQ6NTguMzMzMzMlfS5sYXJnZS05e3dpZHRoOjc1JX0ubGFyZ2UtcHVzaC05e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NzUlfS5sYXJnZS1wdWxsLTl7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotNzUlfS5sYXJnZS1vZmZzZXQtOHttYXJnaW4tbGVmdDo2Ni42NjY2NyV9LmxhcmdlLTEwe3dpZHRoOjgzLjMzMzMzJX0ubGFyZ2UtcHVzaC0xMHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjgzLjMzMzMzJX0ubGFyZ2UtcHVsbC0xMHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi04My4zMzMzMyV9LmxhcmdlLW9mZnNldC05e21hcmdpbi1sZWZ0Ojc1JX0ubGFyZ2UtMTF7d2lkdGg6OTEuNjY2NjclfS5sYXJnZS1wdXNoLTExe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6OTEuNjY2NjclfS5sYXJnZS1wdWxsLTExe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTkxLjY2NjY3JX0ubGFyZ2Utb2Zmc2V0LTEwe21hcmdpbi1sZWZ0OjgzLjMzMzMzJX0ubGFyZ2UtMTJ7d2lkdGg6MTAwJX0ubGFyZ2Utb2Zmc2V0LTExe21hcmdpbi1sZWZ0OjkxLjY2NjY3JX0ubGFyZ2UtdXAtMT4uY29sdW1uLC5sYXJnZS11cC0xPi5jb2x1bW5ze3dpZHRoOjEwMCU7ZmxvYXQ6bGVmdH0ubGFyZ2UtdXAtMT4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubGFyZ2UtdXAtMT4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0ubGFyZ2UtdXAtMT4uY29sdW1uOm50aC1vZi10eXBlKDFuKzEpLC5sYXJnZS11cC0xPi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKzEpe2NsZWFyOmJvdGh9LmxhcmdlLXVwLTE+LmNvbHVtbjpsYXN0LWNoaWxkLC5sYXJnZS11cC0xPi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubGFyZ2UtdXAtMj4uY29sdW1uLC5sYXJnZS11cC0yPi5jb2x1bW5ze3dpZHRoOjUwJTtmbG9hdDpsZWZ0fS5sYXJnZS11cC0yPi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5sYXJnZS11cC0yPi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5sYXJnZS11cC0yPi5jb2x1bW46bnRoLW9mLXR5cGUoMm4rMSksLmxhcmdlLXVwLTI+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMm4rMSl7Y2xlYXI6Ym90aH0ubGFyZ2UtdXAtMj4uY29sdW1uOmxhc3QtY2hpbGQsLmxhcmdlLXVwLTI+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5sYXJnZS11cC0zPi5jb2x1bW4sLmxhcmdlLXVwLTM+LmNvbHVtbnN7d2lkdGg6MzMuMzMzMzMlO2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTM+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLmxhcmdlLXVwLTM+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LmxhcmdlLXVwLTM+LmNvbHVtbjpudGgtb2YtdHlwZSgzbisxKSwubGFyZ2UtdXAtMz4uY29sdW1uczpudGgtb2YtdHlwZSgzbisxKXtjbGVhcjpib3RofS5sYXJnZS11cC0zPi5jb2x1bW46bGFzdC1jaGlsZCwubGFyZ2UtdXAtMz4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTQ+LmNvbHVtbiwubGFyZ2UtdXAtND4uY29sdW1uc3t3aWR0aDoyNSU7ZmxvYXQ6bGVmdH0ubGFyZ2UtdXAtND4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubGFyZ2UtdXAtND4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0ubGFyZ2UtdXAtND4uY29sdW1uOm50aC1vZi10eXBlKDRuKzEpLC5sYXJnZS11cC00Pi5jb2x1bW5zOm50aC1vZi10eXBlKDRuKzEpe2NsZWFyOmJvdGh9LmxhcmdlLXVwLTQ+LmNvbHVtbjpsYXN0LWNoaWxkLC5sYXJnZS11cC00Pi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubGFyZ2UtdXAtNT4uY29sdW1uLC5sYXJnZS11cC01Pi5jb2x1bW5ze3dpZHRoOjIwJTtmbG9hdDpsZWZ0fS5sYXJnZS11cC01Pi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5sYXJnZS11cC01Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5sYXJnZS11cC01Pi5jb2x1bW46bnRoLW9mLXR5cGUoNW4rMSksLmxhcmdlLXVwLTU+LmNvbHVtbnM6bnRoLW9mLXR5cGUoNW4rMSl7Y2xlYXI6Ym90aH0ubGFyZ2UtdXAtNT4uY29sdW1uOmxhc3QtY2hpbGQsLmxhcmdlLXVwLTU+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5sYXJnZS11cC02Pi5jb2x1bW4sLmxhcmdlLXVwLTY+LmNvbHVtbnN7d2lkdGg6MTYuNjY2NjclO2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTY+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLmxhcmdlLXVwLTY+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LmxhcmdlLXVwLTY+LmNvbHVtbjpudGgtb2YtdHlwZSg2bisxKSwubGFyZ2UtdXAtNj4uY29sdW1uczpudGgtb2YtdHlwZSg2bisxKXtjbGVhcjpib3RofS5sYXJnZS11cC02Pi5jb2x1bW46bGFzdC1jaGlsZCwubGFyZ2UtdXAtNj4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTc+LmNvbHVtbiwubGFyZ2UtdXAtNz4uY29sdW1uc3t3aWR0aDoxNC4yODU3MSU7ZmxvYXQ6bGVmdH0ubGFyZ2UtdXAtNz4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubGFyZ2UtdXAtNz4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0ubGFyZ2UtdXAtNz4uY29sdW1uOm50aC1vZi10eXBlKDduKzEpLC5sYXJnZS11cC03Pi5jb2x1bW5zOm50aC1vZi10eXBlKDduKzEpe2NsZWFyOmJvdGh9LmxhcmdlLXVwLTc+LmNvbHVtbjpsYXN0LWNoaWxkLC5sYXJnZS11cC03Pi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubGFyZ2UtdXAtOD4uY29sdW1uLC5sYXJnZS11cC04Pi5jb2x1bW5ze3dpZHRoOjEyLjUlO2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTg+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLmxhcmdlLXVwLTg+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LmxhcmdlLXVwLTg+LmNvbHVtbjpudGgtb2YtdHlwZSg4bisxKSwubGFyZ2UtdXAtOD4uY29sdW1uczpudGgtb2YtdHlwZSg4bisxKXtjbGVhcjpib3RofS5sYXJnZS11cC04Pi5jb2x1bW46bGFzdC1jaGlsZCwubGFyZ2UtdXAtOD4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LmxhcmdlLWNvbGxhcHNlPi5jb2x1bW4sLmxhcmdlLWNvbGxhcHNlPi5jb2x1bW5ze3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6MH0ubGFyZ2UtY29sbGFwc2UgLnJvd3ttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowfS5sYXJnZS11bmNvbGxhcHNlPi5jb2x1bW4sLmxhcmdlLXVuY29sbGFwc2U+LmNvbHVtbnN7cGFkZGluZy1sZWZ0Oi45Mzc1cmVtO3BhZGRpbmctcmlnaHQ6LjkzNzVyZW19LmxhcmdlLWNlbnRlcmVke2Zsb2F0Om5vbmU7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6YXV0b30ubGFyZ2UtcHVsbC0wLC5sYXJnZS1wdXNoLTAsLmxhcmdlLXVuY2VudGVyZWR7cG9zaXRpb246c3RhdGljO21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjA7ZmxvYXQ6bGVmdH19YmxvY2txdW90ZSxkZCxkaXYsZGwsZHQsZm9ybSxoMSxoMixoMyxoNCxoNSxoNixsaSxvbCxwLHByZSx0ZCx0aCx1bHttYXJnaW46MDtwYWRkaW5nOjB9cHtmb250LXNpemU6aW5oZXJpdDtsaW5lLWhlaWdodDoxLjY7bWFyZ2luLWJvdHRvbToxcmVtO3RleHQtcmVuZGVyaW5nOm9wdGltaXplTGVnaWJpbGl0eX1lbSxpe2ZvbnQtc3R5bGU6aXRhbGljfWIsZW0saSxzdHJvbmd7bGluZS1oZWlnaHQ6aW5oZXJpdH1iLHN0cm9uZ3tmb250LXdlaWdodDo3MDB9c21hbGx7Zm9udC1zaXplOjgwJTtsaW5lLWhlaWdodDppbmhlcml0fWgxLGgyLGgzLGg0LGg1LGg2e2ZvbnQtZmFtaWx5OkhlbHZldGljYSBOZXVlLEhlbHZldGljYSxSb2JvdG8sQXJpYWwsc2Fucy1zZXJpZjtmb250LXdlaWdodDo0MDA7Zm9udC1zdHlsZTpub3JtYWw7Y29sb3I6aW5oZXJpdDt0ZXh0LXJlbmRlcmluZzpvcHRpbWl6ZUxlZ2liaWxpdHk7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206LjVyZW07bGluZS1oZWlnaHQ6MS40fWgxIHNtYWxsLGgyIHNtYWxsLGgzIHNtYWxsLGg0IHNtYWxsLGg1IHNtYWxsLGg2IHNtYWxse2NvbG9yOiNjYWNhY2E7bGluZS1oZWlnaHQ6MH1oMXtmb250LXNpemU6MS41cmVtfWgye2ZvbnQtc2l6ZToxLjI1cmVtfWgze2ZvbnQtc2l6ZToxLjE4NzVyZW19aDR7Zm9udC1zaXplOjEuMTI1cmVtfWg1e2ZvbnQtc2l6ZToxLjA2MjVyZW19aDZ7Zm9udC1zaXplOjFyZW19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXtoMXtmb250LXNpemU6M3JlbX1oMntmb250LXNpemU6Mi41cmVtfWgze2ZvbnQtc2l6ZToxLjkzNzVyZW19aDR7Zm9udC1zaXplOjEuNTYyNXJlbX1oNXtmb250LXNpemU6MS4yNXJlbX1oNntmb250LXNpemU6MXJlbX19YXtjb2xvcjojMjE5OWU4O3RleHQtZGVjb3JhdGlvbjpub25lO2xpbmUtaGVpZ2h0OmluaGVyaXQ7Y3Vyc29yOnBvaW50ZXJ9YTpmb2N1cyxhOmhvdmVye2NvbG9yOiMxNTg1Y2Z9YSBpbWd7Ym9yZGVyOjB9aHJ7bWF4LXdpZHRoOjc1cmVtO2hlaWdodDowO2JvcmRlci1yaWdodDowO2JvcmRlci10b3A6MDtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjY2FjYWNhO2JvcmRlci1sZWZ0OjA7bWFyZ2luOjEuMjVyZW0gYXV0bztjbGVhcjpib3RofWRsLG9sLHVse2xpbmUtaGVpZ2h0OjEuNjttYXJnaW4tYm90dG9tOjFyZW07bGlzdC1zdHlsZS1wb3NpdGlvbjpvdXRzaWRlfWxpe2ZvbnQtc2l6ZTppbmhlcml0fXVse2xpc3Qtc3R5bGUtdHlwZTpkaXNjfW9sLHVse21hcmdpbi1sZWZ0OjEuMjVyZW19b2wgb2wsb2wgdWwsdWwgb2wsdWwgdWx7bWFyZ2luLWxlZnQ6MS4yNXJlbTttYXJnaW4tYm90dG9tOjB9ZGx7bWFyZ2luLWJvdHRvbToxcmVtfWRsIGR0e21hcmdpbi1ib3R0b206LjNyZW07Zm9udC13ZWlnaHQ6NzAwfWJsb2NrcXVvdGV7bWFyZ2luOjAgMCAxcmVtO3BhZGRpbmc6LjU2MjVyZW0gMS4yNXJlbSAwIDEuMTg3NXJlbTtib3JkZXItbGVmdDoxcHggc29saWQgI2NhY2FjYX1ibG9ja3F1b3RlLGJsb2NrcXVvdGUgcHtsaW5lLWhlaWdodDoxLjY7Y29sb3I6IzhhOGE4YX1jaXRle2Rpc3BsYXk6YmxvY2s7Zm9udC1zaXplOi44MTI1cmVtO2NvbG9yOiM4YThhOGF9Y2l0ZTpiZWZvcmV7Y29udGVudDonXFxcXDIwMTQgICAgJ31hYmJye2NvbG9yOiMwYTBhMGE7Y3Vyc29yOmhlbHA7Ym9yZGVyLWJvdHRvbToxcHggZG90dGVkICMwYTBhMGF9Y29kZXtmb250LXdlaWdodDo0MDA7Ym9yZGVyOjFweCBzb2xpZCAjY2FjYWNhO3BhZGRpbmc6LjEyNXJlbSAuMzEyNXJlbSAuMDYyNXJlbX1jb2RlLGtiZHtmb250LWZhbWlseTpDb25zb2xhcyxMaWJlcmF0aW9uIE1vbm8sQ291cmllcixtb25vc3BhY2U7Y29sb3I6IzBhMGEwYTtiYWNrZ3JvdW5kLWNvbG9yOiNlNmU2ZTZ9a2Jke3BhZGRpbmc6LjEyNXJlbSAuMjVyZW0gMDttYXJnaW46MH0uc3ViaGVhZGVye21hcmdpbi10b3A6LjJyZW07bWFyZ2luLWJvdHRvbTouNXJlbTtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6MS40O2NvbG9yOiM4YThhOGF9LmxlYWR7Zm9udC1zaXplOjEyNSU7bGluZS1oZWlnaHQ6MS42fS5zdGF0e2ZvbnQtc2l6ZToyLjVyZW07bGluZS1oZWlnaHQ6MX1wKy5zdGF0e21hcmdpbi10b3A6LTFyZW19Lm5vLWJ1bGxldHttYXJnaW4tbGVmdDowO2xpc3Qtc3R5bGU6bm9uZX0udGV4dC1sZWZ0e3RleHQtYWxpZ246bGVmdH0udGV4dC1yaWdodHt0ZXh0LWFsaWduOnJpZ2h0fS50ZXh0LWNlbnRlcnt0ZXh0LWFsaWduOmNlbnRlcn0udGV4dC1qdXN0aWZ5e3RleHQtYWxpZ246anVzdGlmeX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pey5tZWRpdW0tdGV4dC1sZWZ0e3RleHQtYWxpZ246bGVmdH0ubWVkaXVtLXRleHQtcmlnaHR7dGV4dC1hbGlnbjpyaWdodH0ubWVkaXVtLXRleHQtY2VudGVye3RleHQtYWxpZ246Y2VudGVyfS5tZWRpdW0tdGV4dC1qdXN0aWZ5e3RleHQtYWxpZ246anVzdGlmeX19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo2NGVtKXsubGFyZ2UtdGV4dC1sZWZ0e3RleHQtYWxpZ246bGVmdH0ubGFyZ2UtdGV4dC1yaWdodHt0ZXh0LWFsaWduOnJpZ2h0fS5sYXJnZS10ZXh0LWNlbnRlcnt0ZXh0LWFsaWduOmNlbnRlcn0ubGFyZ2UtdGV4dC1qdXN0aWZ5e3RleHQtYWxpZ246anVzdGlmeX19LnNob3ctZm9yLXByaW50e2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9QG1lZGlhIHByaW50eyp7YmFja2dyb3VuZDp0cmFuc3BhcmVudCFpbXBvcnRhbnQ7Y29sb3I6IzAwMCFpbXBvcnRhbnQ7Ym94LXNoYWRvdzpub25lIWltcG9ydGFudDt0ZXh0LXNoYWRvdzpub25lIWltcG9ydGFudH0uc2hvdy1mb3ItcHJpbnR7ZGlzcGxheTpibG9jayFpbXBvcnRhbnR9LmhpZGUtZm9yLXByaW50e2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9dGFibGUuc2hvdy1mb3ItcHJpbnR7ZGlzcGxheTp0YWJsZSFpbXBvcnRhbnR9dGhlYWQuc2hvdy1mb3ItcHJpbnR7ZGlzcGxheTp0YWJsZS1oZWFkZXItZ3JvdXAhaW1wb3J0YW50fXRib2R5LnNob3ctZm9yLXByaW50e2Rpc3BsYXk6dGFibGUtcm93LWdyb3VwIWltcG9ydGFudH10ci5zaG93LWZvci1wcmludHtkaXNwbGF5OnRhYmxlLXJvdyFpbXBvcnRhbnR9dGQuc2hvdy1mb3ItcHJpbnQsdGguc2hvdy1mb3ItcHJpbnR7ZGlzcGxheTp0YWJsZS1jZWxsIWltcG9ydGFudH1hLGE6dmlzaXRlZHt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lfWFbaHJlZl06YWZ0ZXJ7Y29udGVudDpcXFwiIChcXFwiIGF0dHIoaHJlZikgXFxcIilcXFwifS5pciBhOmFmdGVyLGFbaHJlZl49JyMnXTphZnRlcixhW2hyZWZePSdqYXZhc2NyaXB0OiddOmFmdGVye2NvbnRlbnQ6Jyd9YWJiclt0aXRsZV06YWZ0ZXJ7Y29udGVudDpcXFwiIChcXFwiIGF0dHIodGl0bGUpIFxcXCIpXFxcIn1ibG9ja3F1b3RlLHByZXtib3JkZXI6MXB4IHNvbGlkICM4YThhOGE7cGFnZS1icmVhay1pbnNpZGU6YXZvaWR9dGhlYWR7ZGlzcGxheTp0YWJsZS1oZWFkZXItZ3JvdXB9aW1nLHRye3BhZ2UtYnJlYWstaW5zaWRlOmF2b2lkfWltZ3ttYXgtd2lkdGg6MTAwJSFpbXBvcnRhbnR9QHBhZ2V7bWFyZ2luOi41Y219aDIsaDMscHtvcnBoYW5zOjM7d2lkb3dzOjN9aDIsaDN7cGFnZS1icmVhay1hZnRlcjphdm9pZH19W3R5cGU9Y29sb3JdLFt0eXBlPWRhdGVdLFt0eXBlPWRhdGV0aW1lLWxvY2FsXSxbdHlwZT1kYXRldGltZV0sW3R5cGU9ZW1haWxdLFt0eXBlPW1vbnRoXSxbdHlwZT1udW1iZXJdLFt0eXBlPXBhc3N3b3JkXSxbdHlwZT1zZWFyY2hdLFt0eXBlPXRlbF0sW3R5cGU9dGV4dF0sW3R5cGU9dGltZV0sW3R5cGU9dXJsXSxbdHlwZT13ZWVrXSx0ZXh0YXJlYXtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDt3aWR0aDoxMDAlO2hlaWdodDoyLjQzNzVyZW07cGFkZGluZzouNXJlbTtib3JkZXI6MXB4IHNvbGlkICNjYWNhY2E7bWFyZ2luOjAgMCAxcmVtO2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOjFyZW07Y29sb3I6IzBhMGEwYTtiYWNrZ3JvdW5kLWNvbG9yOiNmZWZlZmU7Ym94LXNoYWRvdzppbnNldCAwIDFweCAycHggaHNsYSgwLDAlLDQlLC4xKTtib3JkZXItcmFkaXVzOjA7dHJhbnNpdGlvbjpib3gtc2hhZG93IC41cyxib3JkZXItY29sb3IgLjI1cyBlYXNlLWluLW91dDstd2Via2l0LWFwcGVhcmFuY2U6bm9uZTstbW96LWFwcGVhcmFuY2U6bm9uZX1bdHlwZT1jb2xvcl06Zm9jdXMsW3R5cGU9ZGF0ZV06Zm9jdXMsW3R5cGU9ZGF0ZXRpbWUtbG9jYWxdOmZvY3VzLFt0eXBlPWRhdGV0aW1lXTpmb2N1cyxbdHlwZT1lbWFpbF06Zm9jdXMsW3R5cGU9bW9udGhdOmZvY3VzLFt0eXBlPW51bWJlcl06Zm9jdXMsW3R5cGU9cGFzc3dvcmRdOmZvY3VzLFt0eXBlPXNlYXJjaF06Zm9jdXMsW3R5cGU9dGVsXTpmb2N1cyxbdHlwZT10ZXh0XTpmb2N1cyxbdHlwZT10aW1lXTpmb2N1cyxbdHlwZT11cmxdOmZvY3VzLFt0eXBlPXdlZWtdOmZvY3VzLHRleHRhcmVhOmZvY3Vze2JvcmRlcjoxcHggc29saWQgIzhhOGE4YTtiYWNrZ3JvdW5kLWNvbG9yOiNmZWZlZmU7b3V0bGluZTpub25lO2JveC1zaGFkb3c6MCAwIDVweCAjY2FjYWNhO3RyYW5zaXRpb246Ym94LXNoYWRvdyAuNXMsYm9yZGVyLWNvbG9yIC4yNXMgZWFzZS1pbi1vdXR9dGV4dGFyZWF7bWF4LXdpZHRoOjEwMCV9dGV4dGFyZWFbcm93c117aGVpZ2h0OmF1dG99aW5wdXQ6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXIsdGV4dGFyZWE6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6I2NhY2FjYX1pbnB1dDo6LW1vei1wbGFjZWhvbGRlcix0ZXh0YXJlYTo6LW1vei1wbGFjZWhvbGRlcntjb2xvcjojY2FjYWNhfWlucHV0Oi1tcy1pbnB1dC1wbGFjZWhvbGRlcix0ZXh0YXJlYTotbXMtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6I2NhY2FjYX1pbnB1dDo6cGxhY2Vob2xkZXIsdGV4dGFyZWE6OnBsYWNlaG9sZGVye2NvbG9yOiNjYWNhY2F9aW5wdXQ6ZGlzYWJsZWQsaW5wdXRbcmVhZG9ubHldLHRleHRhcmVhOmRpc2FibGVkLHRleHRhcmVhW3JlYWRvbmx5XXtiYWNrZ3JvdW5kLWNvbG9yOiNlNmU2ZTY7Y3Vyc29yOmRlZmF1bHR9W3R5cGU9YnV0dG9uXSxbdHlwZT1zdWJtaXRde2JvcmRlci1yYWRpdXM6MDstd2Via2l0LWFwcGVhcmFuY2U6bm9uZTstbW96LWFwcGVhcmFuY2U6bm9uZX1pbnB1dFt0eXBlPXNlYXJjaF17Ym94LXNpemluZzpib3JkZXItYm94fVt0eXBlPWNoZWNrYm94XSxbdHlwZT1maWxlXSxbdHlwZT1yYWRpb117bWFyZ2luOjAgMCAxcmVtfVt0eXBlPWNoZWNrYm94XStsYWJlbCxbdHlwZT1yYWRpb10rbGFiZWx7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLWxlZnQ6LjVyZW07bWFyZ2luLXJpZ2h0OjFyZW07bWFyZ2luLWJvdHRvbTowO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfWxhYmVsPlt0eXBlPWNoZWNrYm94XSxsYWJlbD5bdHlwZT1yYWRpb117bWFyZ2luLXJpZ2h0Oi41cmVtfVt0eXBlPWZpbGVde3dpZHRoOjEwMCV9bGFiZWx7ZGlzcGxheTpibG9jazttYXJnaW46MDtmb250LXNpemU6Ljg3NXJlbTtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6MS44O2NvbG9yOiMwYTBhMGF9bGFiZWwubWlkZGxle21hcmdpbjowIDAgMXJlbTtwYWRkaW5nOi41NjI1cmVtIDB9LmhlbHAtdGV4dHttYXJnaW4tdG9wOi0uNXJlbTtmb250LXNpemU6LjgxMjVyZW07Zm9udC1zdHlsZTppdGFsaWM7Y29sb3I6IzBhMGEwYX0uaW5wdXQtZ3JvdXB7ZGlzcGxheTp0YWJsZTt3aWR0aDoxMDAlO21hcmdpbi1ib3R0b206MXJlbX0uaW5wdXQtZ3JvdXA+OmZpcnN0LWNoaWxkLC5pbnB1dC1ncm91cD46bGFzdC1jaGlsZD4qe2JvcmRlci1yYWRpdXM6MCAwIDAgMH0uaW5wdXQtZ3JvdXAtYnV0dG9uLC5pbnB1dC1ncm91cC1maWVsZCwuaW5wdXQtZ3JvdXAtbGFiZWx7bWFyZ2luOjA7ZGlzcGxheTp0YWJsZS1jZWxsO3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0uaW5wdXQtZ3JvdXAtbGFiZWx7dGV4dC1hbGlnbjpjZW50ZXI7cGFkZGluZzowIDFyZW07YmFja2dyb3VuZDojZTZlNmU2O2NvbG9yOiMwYTBhMGE7Ym9yZGVyOjFweCBzb2xpZCAjY2FjYWNhO3doaXRlLXNwYWNlOm5vd3JhcDt3aWR0aDoxJTtoZWlnaHQ6MTAwJX0uaW5wdXQtZ3JvdXAtbGFiZWw6Zmlyc3QtY2hpbGR7Ym9yZGVyLXJpZ2h0OjB9LmlucHV0LWdyb3VwLWxhYmVsOmxhc3QtY2hpbGR7Ym9yZGVyLWxlZnQ6MH0uaW5wdXQtZ3JvdXAtZmllbGR7Ym9yZGVyLXJhZGl1czowO2hlaWdodDoyLjVyZW19LmlucHV0LWdyb3VwLWJ1dHRvbntwYWRkaW5nLXRvcDowO3BhZGRpbmctYm90dG9tOjA7dGV4dC1hbGlnbjpjZW50ZXI7aGVpZ2h0OjEwMCU7d2lkdGg6MSV9LmlucHV0LWdyb3VwLWJ1dHRvbiBhLC5pbnB1dC1ncm91cC1idXR0b24gYnV0dG9uLC5pbnB1dC1ncm91cC1idXR0b24gaW5wdXR7bWFyZ2luOjB9LmlucHV0LWdyb3VwIC5pbnB1dC1ncm91cC1idXR0b257ZGlzcGxheTp0YWJsZS1jZWxsfWZpZWxkc2V0e2JvcmRlcjowO3BhZGRpbmc6MDttYXJnaW46MH1sZWdlbmR7bWFyZ2luLWJvdHRvbTouNXJlbTttYXgtd2lkdGg6MTAwJX0uZmllbGRzZXR7Ym9yZGVyOjFweCBzb2xpZCAjY2FjYWNhO3BhZGRpbmc6MS4yNXJlbTttYXJnaW46MS4xMjVyZW0gMH0uZmllbGRzZXQgbGVnZW5ke2JhY2tncm91bmQ6I2ZlZmVmZTtwYWRkaW5nOjAgLjE4NzVyZW07bWFyZ2luOjA7bWFyZ2luLWxlZnQ6LS4xODc1cmVtfXNlbGVjdHtoZWlnaHQ6Mi40Mzc1cmVtO3BhZGRpbmc6LjVyZW07Ym9yZGVyOjFweCBzb2xpZCAjY2FjYWNhO21hcmdpbjowIDAgMXJlbTtmb250LXNpemU6MXJlbTtmb250LWZhbWlseTppbmhlcml0O2xpbmUtaGVpZ2h0Om5vcm1hbDtjb2xvcjojMGEwYTBhO2JhY2tncm91bmQtY29sb3I6I2ZlZmVmZTtib3JkZXItcmFkaXVzOjA7LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7LW1vei1hcHBlYXJhbmNlOm5vbmU7YmFja2dyb3VuZC1pbWFnZTp1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2ZXJzaW9uPVxcXCIxLjFcXFwiIHdpZHRoPVxcXCIzMlxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDMyIDI0XFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjAsMCAzMiwwIDE2LDI0XFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiJTI4MTM4LCAxMzgsIDEzOCUyOVxcXCI+PC9wb2x5Z29uPjwvc3ZnPicpO2JhY2tncm91bmQtc2l6ZTo5cHggNnB4O2JhY2tncm91bmQtcG9zaXRpb246MTAwJTtiYWNrZ3JvdW5kLW9yaWdpbjpjb250ZW50LWJveDtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXR9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDowXFxcXDApe3NlbGVjdHtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFZQ0FZQUFBQ2JVLzgwQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFJcEpSRUZVZU5yRWtja05nREFNQkJmUmtFdDBPYlJCQmRzR1hVRGdtUWZLNFhoSDJtOGN6UUFBeTI3UjN0c3c0UWZlMng4dU9PNm9ZTGI2R2xPb3IzR0Yrc3dVUkFPbVVKK1J3dEVKczlXdlRHRVl4QlhxSTFNUUFaaENmVVFLUnpETVZqK1R3ckFJVjZqdlNVRWtZQXIxTFNrY3lUQmIvVitLWWZYN3hBZXVzcTNzTER0R0gza0VHQUNQV0lmbE5aZmhSUUFBQUFCSlJVNUVya0pnZ2c9PVxcXCIpfX1zZWxlY3Q6ZGlzYWJsZWR7YmFja2dyb3VuZC1jb2xvcjojZTZlNmU2O2N1cnNvcjpkZWZhdWx0fXNlbGVjdDo6LW1zLWV4cGFuZHtkaXNwbGF5Om5vbmV9c2VsZWN0W211bHRpcGxlXXtoZWlnaHQ6YXV0b30uaXMtaW52YWxpZC1pbnB1dDpub3QoOmZvY3VzKXtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjM2LDg4LDY0LC4xKTtib3JkZXItY29sb3I6I2VjNTg0MH0uZm9ybS1lcnJvciwuaXMtaW52YWxpZC1sYWJlbHtjb2xvcjojZWM1ODQwfS5mb3JtLWVycm9ye2Rpc3BsYXk6bm9uZTttYXJnaW4tdG9wOi0uNXJlbTttYXJnaW4tYm90dG9tOjFyZW07Zm9udC1zaXplOi43NXJlbTtmb250LXdlaWdodDo3MDB9LmZvcm0tZXJyb3IuaXMtdmlzaWJsZXtkaXNwbGF5OmJsb2NrfS5idXR0b257ZGlzcGxheTppbmxpbmUtYmxvY2s7dGV4dC1hbGlnbjpjZW50ZXI7bGluZS1oZWlnaHQ6MTtjdXJzb3I6cG9pbnRlcjstd2Via2l0LWFwcGVhcmFuY2U6bm9uZTt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjI1cyBlYXNlLW91dCxjb2xvciAuMjVzIGVhc2Utb3V0O3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yYWRpdXM6MDtwYWRkaW5nOi44NWVtIDFlbTttYXJnaW46MCAwIDFyZW07Zm9udC1zaXplOi45cmVtO2JhY2tncm91bmQtY29sb3I6IzIxOTllODtjb2xvcjojZmVmZWZlfVtkYXRhLXdoYXRpbnB1dD1tb3VzZV0gLmJ1dHRvbntvdXRsaW5lOjB9LmJ1dHRvbjpmb2N1cywuYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzE1ODNjYztjb2xvcjojZmVmZWZlfS5idXR0b24udGlueXtmb250LXNpemU6LjZyZW19LmJ1dHRvbi5zbWFsbHtmb250LXNpemU6Ljc1cmVtfS5idXR0b24ubGFyZ2V7Zm9udC1zaXplOjEuMjVyZW19LmJ1dHRvbi5leHBhbmRlZHtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MH0uYnV0dG9uLnByaW1hcnl7YmFja2dyb3VuZC1jb2xvcjojMjE5OWU4O2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi5wcmltYXJ5OmZvY3VzLC5idXR0b24ucHJpbWFyeTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxNDdjYzA7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLnNlY29uZGFyeXtiYWNrZ3JvdW5kLWNvbG9yOiM3Nzc7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLnNlY29uZGFyeTpmb2N1cywuYnV0dG9uLnNlY29uZGFyeTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiM1ZjVmNWY7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLnN1Y2Nlc3N7YmFja2dyb3VuZC1jb2xvcjojM2FkYjc2O2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi5zdWNjZXNzOmZvY3VzLC5idXR0b24uc3VjY2Vzczpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMyMmJiNWI7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLndhcm5pbmd7YmFja2dyb3VuZC1jb2xvcjojZmZhZTAwO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi53YXJuaW5nOmZvY3VzLC5idXR0b24ud2FybmluZzpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNjYzhiMDA7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLmFsZXJ0e2JhY2tncm91bmQtY29sb3I6I2VjNTg0MDtjb2xvcjojZmVmZWZlfS5idXR0b24uYWxlcnQ6Zm9jdXMsLmJ1dHRvbi5hbGVydDpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNkYTMxMTY7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLmhvbGxvd3tib3JkZXI6MXB4IHNvbGlkICMyMTk5ZTg7Y29sb3I6IzIxOTllOH0uYnV0dG9uLmhvbGxvdywuYnV0dG9uLmhvbGxvdzpmb2N1cywuYnV0dG9uLmhvbGxvdzpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fS5idXR0b24uaG9sbG93OmZvY3VzLC5idXR0b24uaG9sbG93OmhvdmVye2JvcmRlci1jb2xvcjojMGM0ZDc4O2NvbG9yOiMwYzRkNzh9LmJ1dHRvbi5ob2xsb3cucHJpbWFyeXtib3JkZXI6MXB4IHNvbGlkICMyMTk5ZTg7Y29sb3I6IzIxOTllOH0uYnV0dG9uLmhvbGxvdy5wcmltYXJ5OmZvY3VzLC5idXR0b24uaG9sbG93LnByaW1hcnk6aG92ZXJ7Ym9yZGVyLWNvbG9yOiMwYzRkNzg7Y29sb3I6IzBjNGQ3OH0uYnV0dG9uLmhvbGxvdy5zZWNvbmRhcnl7Ym9yZGVyOjFweCBzb2xpZCAjNzc3O2NvbG9yOiM3Nzd9LmJ1dHRvbi5ob2xsb3cuc2Vjb25kYXJ5OmZvY3VzLC5idXR0b24uaG9sbG93LnNlY29uZGFyeTpob3Zlcntib3JkZXItY29sb3I6IzNjM2MzYztjb2xvcjojM2MzYzNjfS5idXR0b24uaG9sbG93LnN1Y2Nlc3N7Ym9yZGVyOjFweCBzb2xpZCAjM2FkYjc2O2NvbG9yOiMzYWRiNzZ9LmJ1dHRvbi5ob2xsb3cuc3VjY2Vzczpmb2N1cywuYnV0dG9uLmhvbGxvdy5zdWNjZXNzOmhvdmVye2JvcmRlci1jb2xvcjojMTU3NTM5O2NvbG9yOiMxNTc1Mzl9LmJ1dHRvbi5ob2xsb3cud2FybmluZ3tib3JkZXI6MXB4IHNvbGlkICNmZmFlMDA7Y29sb3I6I2ZmYWUwMH0uYnV0dG9uLmhvbGxvdy53YXJuaW5nOmZvY3VzLC5idXR0b24uaG9sbG93Lndhcm5pbmc6aG92ZXJ7Ym9yZGVyLWNvbG9yOiM4MDU3MDA7Y29sb3I6IzgwNTcwMH0uYnV0dG9uLmhvbGxvdy5hbGVydHtib3JkZXI6MXB4IHNvbGlkICNlYzU4NDA7Y29sb3I6I2VjNTg0MH0uYnV0dG9uLmhvbGxvdy5hbGVydDpmb2N1cywuYnV0dG9uLmhvbGxvdy5hbGVydDpob3Zlcntib3JkZXItY29sb3I6Izg4MWYwZTtjb2xvcjojODgxZjBlfS5idXR0b24uZGlzYWJsZWQsLmJ1dHRvbltkaXNhYmxlZF17b3BhY2l0eTouMjU7Y3Vyc29yOm5vdC1hbGxvd2VkO3BvaW50ZXItZXZlbnRzOm5vbmV9LmJ1dHRvbi5kcm9wZG93bjphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6LjRlbSBpbnNldDtib3JkZXItY29sb3I6I2ZlZmVmZSB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItdG9wLXN0eWxlOnNvbGlkO2JvcmRlci1ib3R0b20td2lkdGg6MDtwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6LjRlbTtmbG9hdDpyaWdodDttYXJnaW4tbGVmdDoxZW07ZGlzcGxheTppbmxpbmUtYmxvY2t9LmJ1dHRvbi5hcnJvdy1vbmx5OmFmdGVye21hcmdpbi1sZWZ0OjA7ZmxvYXQ6bm9uZTt0b3A6LS4xZW19LmFjY29yZGlvbntsaXN0LXN0eWxlLXR5cGU6bm9uZTtiYWNrZ3JvdW5kOiNmZWZlZmU7Ym9yZGVyOjFweCBzb2xpZCAjZTZlNmU2O2JvcmRlci1ib3R0b206MDtib3JkZXItcmFkaXVzOjA7bWFyZ2luLWxlZnQ6MH0uYWNjb3JkaW9uLXRpdGxle2Rpc3BsYXk6YmxvY2s7cGFkZGluZzoxLjI1cmVtIDFyZW07bGluZS1oZWlnaHQ6MTtmb250LXNpemU6Ljc1cmVtO2NvbG9yOiMyMTk5ZTg7cG9zaXRpb246cmVsYXRpdmU7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2U2ZTZlNn0uYWNjb3JkaW9uLXRpdGxlOmZvY3VzLC5hY2NvcmRpb24tdGl0bGU6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZTZlNmU2fS5hY2NvcmRpb24tdGl0bGU6YmVmb3Jle2NvbnRlbnQ6JysnO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjFyZW07dG9wOjUwJTttYXJnaW4tdG9wOi0uNXJlbX0uaXMtYWN0aXZlPi5hY2NvcmRpb24tdGl0bGU6YmVmb3Jle2NvbnRlbnQ6J1xcXFwyMDEzJ30uYWNjb3JkaW9uLWNvbnRlbnR7cGFkZGluZzoxcmVtO2Rpc3BsYXk6bm9uZTtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZTZlNmU2O2JhY2tncm91bmQtY29sb3I6I2ZlZmVmZX0uaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50PmF7cG9zaXRpb246cmVsYXRpdmV9LmlzLWFjY29yZGlvbi1zdWJtZW51LXBhcmVudD5hOmFmdGVye2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlcjo2cHggaW5zZXQ7Ym9yZGVyLWNvbG9yOiMyMTk5ZTggdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXRvcC1zdHlsZTpzb2xpZDtib3JkZXItYm90dG9tLXdpZHRoOjA7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTttYXJnaW4tdG9wOi00cHg7cmlnaHQ6MXJlbX0uaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50W2FyaWEtZXhwYW5kZWQ9dHJ1ZV0+YTphZnRlcnstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46NTAlIDUwJTt0cmFuc2Zvcm0tb3JpZ2luOjUwJSA1MCU7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGVZKC0xKTt0cmFuc2Zvcm06c2NhbGVZKC0xKX0uYmFkZ2V7ZGlzcGxheTppbmxpbmUtYmxvY2s7cGFkZGluZzouM2VtO21pbi13aWR0aDoyLjFlbTtmb250LXNpemU6LjZyZW07dGV4dC1hbGlnbjpjZW50ZXI7Ym9yZGVyLXJhZGl1czo1MCU7YmFja2dyb3VuZDojMjE5OWU4O2NvbG9yOiNmZWZlZmV9LmJhZGdlLnNlY29uZGFyeXtiYWNrZ3JvdW5kOiM3Nzc7Y29sb3I6I2ZlZmVmZX0uYmFkZ2Uuc3VjY2Vzc3tiYWNrZ3JvdW5kOiMzYWRiNzY7Y29sb3I6I2ZlZmVmZX0uYmFkZ2Uud2FybmluZ3tiYWNrZ3JvdW5kOiNmZmFlMDA7Y29sb3I6I2ZlZmVmZX0uYmFkZ2UuYWxlcnR7YmFja2dyb3VuZDojZWM1ODQwO2NvbG9yOiNmZWZlZmV9LmJyZWFkY3J1bWJze2xpc3Qtc3R5bGU6bm9uZTttYXJnaW46MCAwIDFyZW19LmJyZWFkY3J1bWJzOmFmdGVyLC5icmVhZGNydW1iczpiZWZvcmV7Y29udGVudDonICc7ZGlzcGxheTp0YWJsZTstd2Via2l0LWZsZXgtYmFzaXM6MDstbXMtZmxleC1wcmVmZXJyZWQtc2l6ZTowO2ZsZXgtYmFzaXM6MDstd2Via2l0LW9yZGVyOjE7LW1zLWZsZXgtb3JkZXI6MTtvcmRlcjoxfS5icmVhZGNydW1iczphZnRlcntjbGVhcjpib3RofS5icmVhZGNydW1icyBsaXtmbG9hdDpsZWZ0O2NvbG9yOiMwYTBhMGE7Zm9udC1zaXplOi42ODc1cmVtO2N1cnNvcjpkZWZhdWx0O3RleHQtdHJhbnNmb3JtOnVwcGVyY2FzZX0uYnJlYWRjcnVtYnMgbGk6bm90KDpsYXN0LWNoaWxkKTphZnRlcntjb2xvcjojY2FjYWNhO2NvbnRlbnQ6XFxcIi9cXFwiO21hcmdpbjowIC43NXJlbTtwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6MXB4O29wYWNpdHk6MX0uYnJlYWRjcnVtYnMgYXtjb2xvcjojMjE5OWU4fS5icmVhZGNydW1icyBhOmhvdmVye3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9LmJyZWFkY3J1bWJzIC5kaXNhYmxlZHtjb2xvcjojY2FjYWNhfS5idXR0b24tZ3JvdXB7bWFyZ2luLWJvdHRvbToxcmVtO2ZvbnQtc2l6ZTowfS5idXR0b24tZ3JvdXA6YWZ0ZXIsLmJ1dHRvbi1ncm91cDpiZWZvcmV7Y29udGVudDonICc7ZGlzcGxheTp0YWJsZTstd2Via2l0LWZsZXgtYmFzaXM6MDstbXMtZmxleC1wcmVmZXJyZWQtc2l6ZTowO2ZsZXgtYmFzaXM6MDstd2Via2l0LW9yZGVyOjE7LW1zLWZsZXgtb3JkZXI6MTtvcmRlcjoxfS5idXR0b24tZ3JvdXA6YWZ0ZXJ7Y2xlYXI6Ym90aH0uYnV0dG9uLWdyb3VwIC5idXR0b257bWFyZ2luOjA7Zm9udC1zaXplOi45cmVtO2Zsb2F0OmxlZnR9LmJ1dHRvbi1ncm91cCAuYnV0dG9uOm5vdCg6bGFzdC1jaGlsZCl7Ym9yZGVyLXJpZ2h0OjFweCBzb2xpZCAjZmVmZWZlfS5idXR0b24tZ3JvdXAudGlueSAuYnV0dG9ue2ZvbnQtc2l6ZTouNnJlbX0uYnV0dG9uLWdyb3VwLnNtYWxsIC5idXR0b257Zm9udC1zaXplOi43NXJlbX0uYnV0dG9uLWdyb3VwLmxhcmdlIC5idXR0b257Zm9udC1zaXplOjEuMjVyZW19LmJ1dHRvbi1ncm91cC5leHBhbmRlZHttYXJnaW4tcmlnaHQ6LTFweH0uYnV0dG9uLWdyb3VwLmV4cGFuZGVkOmFmdGVyLC5idXR0b24tZ3JvdXAuZXhwYW5kZWQ6YmVmb3Jle2Rpc3BsYXk6bm9uZX0uYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoMiksLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDIpOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDIpfi5idXR0b257ZGlzcGxheTppbmxpbmUtYmxvY2s7d2lkdGg6Y2FsYyg1MCUgLSAxcHgpO21hcmdpbi1yaWdodDoxcHh9LmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDMpLC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgzKTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgzKX4uYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOmNhbGMoMzMuMzMzMzMlIC0gMXB4KTttYXJnaW4tcmlnaHQ6MXB4fS5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg0KSwuYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoNCk6Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoNCl+LmJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDpjYWxjKDI1JSAtIDFweCk7bWFyZ2luLXJpZ2h0OjFweH0uYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoNSksLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDUpOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDUpfi5idXR0b257ZGlzcGxheTppbmxpbmUtYmxvY2s7d2lkdGg6Y2FsYygyMCUgLSAxcHgpO21hcmdpbi1yaWdodDoxcHh9LmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDYpLC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg2KTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg2KX4uYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOmNhbGMoMTYuNjY2NjclIC0gMXB4KTttYXJnaW4tcmlnaHQ6MXB4fS5idXR0b24tZ3JvdXAucHJpbWFyeSAuYnV0dG9ue2JhY2tncm91bmQtY29sb3I6IzIxOTllODtjb2xvcjojZmVmZWZlfS5idXR0b24tZ3JvdXAucHJpbWFyeSAuYnV0dG9uOmZvY3VzLC5idXR0b24tZ3JvdXAucHJpbWFyeSAuYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzE0N2NjMDtjb2xvcjojZmVmZWZlfS5idXR0b24tZ3JvdXAuc2Vjb25kYXJ5IC5idXR0b257YmFja2dyb3VuZC1jb2xvcjojNzc3O2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi1ncm91cC5zZWNvbmRhcnkgLmJ1dHRvbjpmb2N1cywuYnV0dG9uLWdyb3VwLnNlY29uZGFyeSAuYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzVmNWY1Zjtjb2xvcjojZmVmZWZlfS5idXR0b24tZ3JvdXAuc3VjY2VzcyAuYnV0dG9ue2JhY2tncm91bmQtY29sb3I6IzNhZGI3Njtjb2xvcjojZmVmZWZlfS5idXR0b24tZ3JvdXAuc3VjY2VzcyAuYnV0dG9uOmZvY3VzLC5idXR0b24tZ3JvdXAuc3VjY2VzcyAuYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzIyYmI1Yjtjb2xvcjojZmVmZWZlfS5idXR0b24tZ3JvdXAud2FybmluZyAuYnV0dG9ue2JhY2tncm91bmQtY29sb3I6I2ZmYWUwMDtjb2xvcjojZmVmZWZlfS5idXR0b24tZ3JvdXAud2FybmluZyAuYnV0dG9uOmZvY3VzLC5idXR0b24tZ3JvdXAud2FybmluZyAuYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2NjOGIwMDtjb2xvcjojZmVmZWZlfS5idXR0b24tZ3JvdXAuYWxlcnQgLmJ1dHRvbntiYWNrZ3JvdW5kLWNvbG9yOiNlYzU4NDA7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLWdyb3VwLmFsZXJ0IC5idXR0b246Zm9jdXMsLmJ1dHRvbi1ncm91cC5hbGVydCAuYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2RhMzExNjtjb2xvcjojZmVmZWZlfS5idXR0b24tZ3JvdXAuc3RhY2tlZC1mb3ItbWVkaXVtIC5idXR0b24sLmJ1dHRvbi1ncm91cC5zdGFja2VkLWZvci1zbWFsbCAuYnV0dG9uLC5idXR0b24tZ3JvdXAuc3RhY2tlZCAuYnV0dG9ue3dpZHRoOjEwMCV9LmJ1dHRvbi1ncm91cC5zdGFja2VkLWZvci1tZWRpdW0gLmJ1dHRvbjpub3QoOmxhc3QtY2hpbGQpLC5idXR0b24tZ3JvdXAuc3RhY2tlZC1mb3Itc21hbGwgLmJ1dHRvbjpub3QoOmxhc3QtY2hpbGQpLC5idXR0b24tZ3JvdXAuc3RhY2tlZCAuYnV0dG9uOm5vdCg6bGFzdC1jaGlsZCl7bWFyZ2luLXJpZ2h0OjB9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsuYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLXNtYWxsIC5idXR0b257d2lkdGg6YXV0b30uYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLXNtYWxsIC5idXR0b246bm90KDpsYXN0LWNoaWxkKXttYXJnaW4tcmlnaHQ6MXB4fX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjY0ZW0pey5idXR0b24tZ3JvdXAuc3RhY2tlZC1mb3ItbWVkaXVtIC5idXR0b257d2lkdGg6YXV0b30uYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLW1lZGl1bSAuYnV0dG9uOm5vdCg6bGFzdC1jaGlsZCl7bWFyZ2luLXJpZ2h0OjFweH19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDozOS45Mzc1ZW0pey5idXR0b24tZ3JvdXAuc3RhY2tlZC1mb3Itc21hbGwuZXhwYW5kZWR7ZGlzcGxheTpibG9ja30uYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLXNtYWxsLmV4cGFuZGVkIC5idXR0b257ZGlzcGxheTpibG9jazttYXJnaW4tcmlnaHQ6MH19LmNhbGxvdXR7bWFyZ2luOjAgMCAxcmVtO3BhZGRpbmc6MXJlbTtib3JkZXI6MXB4IHNvbGlkIGhzbGEoMCwwJSw0JSwuMjUpO2JvcmRlci1yYWRpdXM6MDtwb3NpdGlvbjpyZWxhdGl2ZTtjb2xvcjojMGEwYTBhO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uY2FsbG91dD46Zmlyc3QtY2hpbGR7bWFyZ2luLXRvcDowfS5jYWxsb3V0PjpsYXN0LWNoaWxke21hcmdpbi1ib3R0b206MH0uY2FsbG91dC5wcmltYXJ5e2JhY2tncm91bmQtY29sb3I6I2RlZjBmY30uY2FsbG91dC5zZWNvbmRhcnl7YmFja2dyb3VuZC1jb2xvcjojZWJlYmVifS5jYWxsb3V0LnN1Y2Nlc3N7YmFja2dyb3VuZC1jb2xvcjojZTFmYWVhfS5jYWxsb3V0Lndhcm5pbmd7YmFja2dyb3VuZC1jb2xvcjojZmZmM2Q5fS5jYWxsb3V0LmFsZXJ0e2JhY2tncm91bmQtY29sb3I6I2ZjZTZlMn0uY2FsbG91dC5zbWFsbHtwYWRkaW5nOi41cmVtfS5jYWxsb3V0Lmxhcmdle3BhZGRpbmc6M3JlbX0uY2xvc2UtYnV0dG9ue3Bvc2l0aW9uOmFic29sdXRlO2NvbG9yOiM4YThhOGE7cmlnaHQ6MXJlbTt0b3A6LjVyZW07Zm9udC1zaXplOjJlbTtsaW5lLWhlaWdodDoxO2N1cnNvcjpwb2ludGVyfVtkYXRhLXdoYXRpbnB1dD1tb3VzZV0gLmNsb3NlLWJ1dHRvbntvdXRsaW5lOjB9LmNsb3NlLWJ1dHRvbjpmb2N1cywuY2xvc2UtYnV0dG9uOmhvdmVye2NvbG9yOiMwYTBhMGF9Lm1lbnV7bWFyZ2luOjA7bGlzdC1zdHlsZS10eXBlOm5vbmV9Lm1lbnU+bGl7ZGlzcGxheTp0YWJsZS1jZWxsO3ZlcnRpY2FsLWFsaWduOm1pZGRsZX1bZGF0YS13aGF0aW5wdXQ9bW91c2VdIC5tZW51Pmxpe291dGxpbmU6MH0ubWVudT5saT5he2Rpc3BsYXk6YmxvY2s7cGFkZGluZzouN3JlbSAxcmVtO2xpbmUtaGVpZ2h0OjF9Lm1lbnUgYSwubWVudSBidXR0b24sLm1lbnUgaW5wdXR7bWFyZ2luLWJvdHRvbTowfS5tZW51PmxpPmEgaSwubWVudT5saT5hIGkrc3BhbiwubWVudT5saT5hIGltZywubWVudT5saT5hIGltZytzcGFue3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0ubWVudT5saT5hIGksLm1lbnU+bGk+YSBpbWd7bWFyZ2luLXJpZ2h0Oi4yNXJlbTtkaXNwbGF5OmlubGluZS1ibG9ja30ubWVudT5saXtkaXNwbGF5OnRhYmxlLWNlbGx9Lm1lbnUudmVydGljYWw+bGl7ZGlzcGxheTpibG9ja31AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pey5tZW51Lm1lZGl1bS1ob3Jpem9udGFsPmxpe2Rpc3BsYXk6dGFibGUtY2VsbH0ubWVudS5tZWRpdW0tdmVydGljYWw+bGl7ZGlzcGxheTpibG9ja319QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo2NGVtKXsubWVudS5sYXJnZS1ob3Jpem9udGFsPmxpe2Rpc3BsYXk6dGFibGUtY2VsbH0ubWVudS5sYXJnZS12ZXJ0aWNhbD5saXtkaXNwbGF5OmJsb2NrfX0ubWVudS5zaW1wbGUgbGl7bGluZS1oZWlnaHQ6MTtkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tcmlnaHQ6MXJlbX0ubWVudS5zaW1wbGUgYXtwYWRkaW5nOjB9Lm1lbnUuYWxpZ24tcmlnaHQ6YWZ0ZXIsLm1lbnUuYWxpZ24tcmlnaHQ6YmVmb3Jle2NvbnRlbnQ6JyAnO2Rpc3BsYXk6dGFibGU7LXdlYmtpdC1mbGV4LWJhc2lzOjA7LW1zLWZsZXgtcHJlZmVycmVkLXNpemU6MDtmbGV4LWJhc2lzOjA7LXdlYmtpdC1vcmRlcjoxOy1tcy1mbGV4LW9yZGVyOjE7b3JkZXI6MX0ubWVudS5hbGlnbi1yaWdodDphZnRlcntjbGVhcjpib3RofS5tZW51LmFsaWduLXJpZ2h0Pmxpe2Zsb2F0OnJpZ2h0fS5tZW51LmV4cGFuZGVke3dpZHRoOjEwMCU7ZGlzcGxheTp0YWJsZTt0YWJsZS1sYXlvdXQ6Zml4ZWR9Lm1lbnUuZXhwYW5kZWQ+bGk6Zmlyc3QtY2hpbGQ6bGFzdC1jaGlsZHt3aWR0aDoxMDAlfS5tZW51Lmljb24tdG9wPmxpPmF7dGV4dC1hbGlnbjpjZW50ZXJ9Lm1lbnUuaWNvbi10b3A+bGk+YSBpLC5tZW51Lmljb24tdG9wPmxpPmEgaW1ne2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjAgYXV0byAuMjVyZW19Lm1lbnUubmVzdGVke21hcmdpbi1sZWZ0OjFyZW19Lm1lbnUgLmFjdGl2ZT5he2NvbG9yOiNmZWZlZmU7YmFja2dyb3VuZDojMjE5OWU4fS5tZW51LXRleHR7Zm9udC13ZWlnaHQ6NzAwO2NvbG9yOmluaGVyaXQ7bGluZS1oZWlnaHQ6MTtwYWRkaW5nLXRvcDowO3BhZGRpbmctYm90dG9tOjA7cGFkZGluZzouN3JlbSAxcmVtfS5tZW51LWNlbnRlcmVke3RleHQtYWxpZ246Y2VudGVyfS5tZW51LWNlbnRlcmVkPi5tZW51e2Rpc3BsYXk6aW5saW5lLWJsb2NrfS5uby1qcyBbZGF0YS1yZXNwb25zaXZlLW1lbnVdIHVse2Rpc3BsYXk6bm9uZX0ubWVudS1pY29ue3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtjdXJzb3I6cG9pbnRlcjt3aWR0aDoyMHB4O2hlaWdodDoxNnB4fS5tZW51LWljb246YWZ0ZXJ7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7aGVpZ2h0OjJweDtiYWNrZ3JvdW5kOiNmZWZlZmU7dG9wOjA7bGVmdDowO2JveC1zaGFkb3c6MCA3cHggMCAjZmVmZWZlLDAgMTRweCAwICNmZWZlZmV9Lm1lbnUtaWNvbjpob3ZlcjphZnRlcntiYWNrZ3JvdW5kOiNjYWNhY2E7Ym94LXNoYWRvdzowIDdweCAwICNjYWNhY2EsMCAxNHB4IDAgI2NhY2FjYX0uaXMtZHJpbGxkb3due3Bvc2l0aW9uOnJlbGF0aXZlO292ZXJmbG93OmhpZGRlbn0uaXMtZHJpbGxkb3duIGxpe2Rpc3BsYXk6YmxvY2shaW1wb3J0YW50fS5pcy1kcmlsbGRvd24tc3VibWVudXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjEwMCU7ei1pbmRleDotMTtoZWlnaHQ6MTAwJTt3aWR0aDoxMDAlO2JhY2tncm91bmQ6I2ZlZmVmZTt0cmFuc2l0aW9uOi13ZWJraXQtdHJhbnNmb3JtIC4xNXMgbGluZWFyO3RyYW5zaXRpb246dHJhbnNmb3JtIC4xNXMgbGluZWFyfS5pcy1kcmlsbGRvd24tc3VibWVudS5pcy1hY3RpdmV7ei1pbmRleDoxO2Rpc3BsYXk6YmxvY2s7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTAwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpfS5pcy1kcmlsbGRvd24tc3VibWVudS5pcy1jbG9zaW5ney13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTAwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTAwJSl9LmlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudD5he3Bvc2l0aW9uOnJlbGF0aXZlfS5pcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NnB4IGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCAjMjE5OWU4O2JvcmRlci1sZWZ0LXN0eWxlOnNvbGlkO2JvcmRlci1yaWdodC13aWR0aDowO3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7bWFyZ2luLXRvcDotNnB4O3JpZ2h0OjFyZW19LmpzLWRyaWxsZG93bi1iYWNrPmE6YmVmb3Jle2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlcjo2cHggaW5zZXQ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50ICMyMTk5ZTggdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0LXN0eWxlOnNvbGlkO2JvcmRlci1sZWZ0LXdpZHRoOjA7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246bWlkZGxlO21hcmdpbi1yaWdodDouNzVyZW19LmRyb3Bkb3duLXBhbmV7YmFja2dyb3VuZC1jb2xvcjojZmVmZWZlO2JvcmRlcjoxcHggc29saWQgI2NhY2FjYTtib3JkZXItcmFkaXVzOjA7ZGlzcGxheTpibG9jaztmb250LXNpemU6MXJlbTtwYWRkaW5nOjFyZW07cG9zaXRpb246YWJzb2x1dGU7dmlzaWJpbGl0eTpoaWRkZW47d2lkdGg6MzAwcHg7ei1pbmRleDozfS5kcm9wZG93bi1wYW5lLmlzLW9wZW57dmlzaWJpbGl0eTp2aXNpYmxlfS5kcm9wZG93bi1wYW5lLnRpbnl7d2lkdGg6MTAwcHh9LmRyb3Bkb3duLXBhbmUuc21hbGx7d2lkdGg6MjAwcHh9LmRyb3Bkb3duLXBhbmUubGFyZ2V7d2lkdGg6NDAwcHh9LmRyb3Bkb3duLm1lbnU+bGkub3BlbnMtbGVmdD4uaXMtZHJvcGRvd24tc3VibWVudXtsZWZ0OmF1dG87cmlnaHQ6MDt0b3A6MTAwJX0uZHJvcGRvd24ubWVudT5saS5vcGVucy1yaWdodD4uaXMtZHJvcGRvd24tc3VibWVudXtyaWdodDphdXRvO2xlZnQ6MDt0b3A6MTAwJX0uZHJvcGRvd24ubWVudT5saS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudD5he3BhZGRpbmctcmlnaHQ6MS41cmVtO3Bvc2l0aW9uOnJlbGF0aXZlfS5kcm9wZG93bi5tZW51PmxpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50PmE6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjVweCBpbnNldDtib3JkZXItY29sb3I6IzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItdG9wLXN0eWxlOnNvbGlkO2JvcmRlci1ib3R0b20td2lkdGg6MDtyaWdodDo1cHg7bWFyZ2luLXRvcDotMnB4fVtkYXRhLXdoYXRpbnB1dD1tb3VzZV0gLmRyb3Bkb3duLm1lbnUgYXtvdXRsaW5lOjB9Lm5vLWpzIC5kcm9wZG93bi5tZW51IHVse2Rpc3BsYXk6bm9uZX0uZHJvcGRvd24ubWVudS52ZXJ0aWNhbD5saSAuaXMtZHJvcGRvd24tc3VibWVudXt0b3A6MH0uZHJvcGRvd24ubWVudS52ZXJ0aWNhbD5saS5vcGVucy1sZWZ0IC5pcy1kcm9wZG93bi1zdWJtZW51e2xlZnQ6YXV0bztyaWdodDoxMDAlfS5kcm9wZG93bi5tZW51LnZlcnRpY2FsPmxpLm9wZW5zLXJpZ2h0IC5pcy1kcm9wZG93bi1zdWJtZW51e3JpZ2h0OmF1dG87bGVmdDoxMDAlfS5kcm9wZG93bi5tZW51LnZlcnRpY2FsPmxpPmE6YWZ0ZXJ7cmlnaHQ6MTRweDttYXJnaW4tdG9wOi0zcHh9LmRyb3Bkb3duLm1lbnUudmVydGljYWw+bGkub3BlbnMtbGVmdD5hOmFmdGVye2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlcjo1cHggaW5zZXQ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50ICMyMTk5ZTggdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0LXN0eWxlOnNvbGlkO2JvcmRlci1sZWZ0LXdpZHRoOjB9LmRyb3Bkb3duLm1lbnUudmVydGljYWw+bGkub3BlbnMtcmlnaHQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NXB4IGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCAjMjE5OWU4O2JvcmRlci1sZWZ0LXN0eWxlOnNvbGlkO2JvcmRlci1yaWdodC13aWR0aDowfUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7LmRyb3Bkb3duLm1lbnUubWVkaXVtLWhvcml6b250YWw+bGkub3BlbnMtbGVmdD4uaXMtZHJvcGRvd24tc3VibWVudXtsZWZ0OmF1dG87cmlnaHQ6MDt0b3A6MTAwJX0uZHJvcGRvd24ubWVudS5tZWRpdW0taG9yaXpvbnRhbD5saS5vcGVucy1yaWdodD4uaXMtZHJvcGRvd24tc3VibWVudXtyaWdodDphdXRvO2xlZnQ6MDt0b3A6MTAwJX0uZHJvcGRvd24ubWVudS5tZWRpdW0taG9yaXpvbnRhbD5saS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudD5he3BhZGRpbmctcmlnaHQ6MS41cmVtO3Bvc2l0aW9uOnJlbGF0aXZlfS5kcm9wZG93bi5tZW51Lm1lZGl1bS1ob3Jpem9udGFsPmxpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50PmE6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjVweCBpbnNldDtib3JkZXItY29sb3I6IzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItdG9wLXN0eWxlOnNvbGlkO2JvcmRlci1ib3R0b20td2lkdGg6MDtyaWdodDo1cHg7bWFyZ2luLXRvcDotMnB4fS5kcm9wZG93bi5tZW51Lm1lZGl1bS12ZXJ0aWNhbD5saSAuaXMtZHJvcGRvd24tc3VibWVudXt0b3A6MH0uZHJvcGRvd24ubWVudS5tZWRpdW0tdmVydGljYWw+bGkub3BlbnMtbGVmdCAuaXMtZHJvcGRvd24tc3VibWVudXtsZWZ0OmF1dG87cmlnaHQ6MTAwJX0uZHJvcGRvd24ubWVudS5tZWRpdW0tdmVydGljYWw+bGkub3BlbnMtcmlnaHQgLmlzLWRyb3Bkb3duLXN1Ym1lbnV7cmlnaHQ6YXV0bztsZWZ0OjEwMCV9LmRyb3Bkb3duLm1lbnUubWVkaXVtLXZlcnRpY2FsPmxpPmE6YWZ0ZXJ7cmlnaHQ6MTRweDttYXJnaW4tdG9wOi0zcHh9LmRyb3Bkb3duLm1lbnUubWVkaXVtLXZlcnRpY2FsPmxpLm9wZW5zLWxlZnQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NXB4IGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCAjMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O2JvcmRlci1yaWdodC1zdHlsZTpzb2xpZDtib3JkZXItbGVmdC13aWR0aDowfS5kcm9wZG93bi5tZW51Lm1lZGl1bS12ZXJ0aWNhbD5saS5vcGVucy1yaWdodD5hOmFmdGVye2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlcjo1cHggaW5zZXQ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICMyMTk5ZTg7Ym9yZGVyLWxlZnQtc3R5bGU6c29saWQ7Ym9yZGVyLXJpZ2h0LXdpZHRoOjB9fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NjRlbSl7LmRyb3Bkb3duLm1lbnUubGFyZ2UtaG9yaXpvbnRhbD5saS5vcGVucy1sZWZ0Pi5pcy1kcm9wZG93bi1zdWJtZW51e2xlZnQ6YXV0bztyaWdodDowO3RvcDoxMDAlfS5kcm9wZG93bi5tZW51LmxhcmdlLWhvcml6b250YWw+bGkub3BlbnMtcmlnaHQ+LmlzLWRyb3Bkb3duLXN1Ym1lbnV7cmlnaHQ6YXV0bztsZWZ0OjA7dG9wOjEwMCV9LmRyb3Bkb3duLm1lbnUubGFyZ2UtaG9yaXpvbnRhbD5saS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudD5he3BhZGRpbmctcmlnaHQ6MS41cmVtO3Bvc2l0aW9uOnJlbGF0aXZlfS5kcm9wZG93bi5tZW51LmxhcmdlLWhvcml6b250YWw+bGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NXB4IGluc2V0O2JvcmRlci1jb2xvcjojMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O2JvcmRlci10b3Atc3R5bGU6c29saWQ7Ym9yZGVyLWJvdHRvbS13aWR0aDowO3JpZ2h0OjVweDttYXJnaW4tdG9wOi0ycHh9LmRyb3Bkb3duLm1lbnUubGFyZ2UtdmVydGljYWw+bGkgLmlzLWRyb3Bkb3duLXN1Ym1lbnV7dG9wOjB9LmRyb3Bkb3duLm1lbnUubGFyZ2UtdmVydGljYWw+bGkub3BlbnMtbGVmdCAuaXMtZHJvcGRvd24tc3VibWVudXtsZWZ0OmF1dG87cmlnaHQ6MTAwJX0uZHJvcGRvd24ubWVudS5sYXJnZS12ZXJ0aWNhbD5saS5vcGVucy1yaWdodCAuaXMtZHJvcGRvd24tc3VibWVudXtyaWdodDphdXRvO2xlZnQ6MTAwJX0uZHJvcGRvd24ubWVudS5sYXJnZS12ZXJ0aWNhbD5saT5hOmFmdGVye3JpZ2h0OjE0cHg7bWFyZ2luLXRvcDotM3B4fS5kcm9wZG93bi5tZW51LmxhcmdlLXZlcnRpY2FsPmxpLm9wZW5zLWxlZnQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NXB4IGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCAjMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O2JvcmRlci1yaWdodC1zdHlsZTpzb2xpZDtib3JkZXItbGVmdC13aWR0aDowfS5kcm9wZG93bi5tZW51LmxhcmdlLXZlcnRpY2FsPmxpLm9wZW5zLXJpZ2h0PmE6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjVweCBpbnNldDtib3JkZXItY29sb3I6dHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzIxOTllODtib3JkZXItbGVmdC1zdHlsZTpzb2xpZDtib3JkZXItcmlnaHQtd2lkdGg6MH19LmRyb3Bkb3duLm1lbnUuYWxpZ24tcmlnaHQgLmlzLWRyb3Bkb3duLXN1Ym1lbnUuZmlyc3Qtc3Vie3RvcDoxMDAlO2xlZnQ6YXV0bztyaWdodDowfS5pcy1kcm9wZG93bi1tZW51LnZlcnRpY2Fse3dpZHRoOjEwMHB4fS5pcy1kcm9wZG93bi1tZW51LnZlcnRpY2FsLmFsaWduLXJpZ2h0e2Zsb2F0OnJpZ2h0fS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudHtwb3NpdGlvbjpyZWxhdGl2ZX0uaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQgYTphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO3JpZ2h0OjVweDttYXJnaW4tdG9wOi0ycHh9LmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Lm9wZW5zLWlubmVyIC5pcy1kcm9wZG93bi1zdWJtZW51e3RvcDoxMDAlfS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudC5vcGVucy1sZWZ0IC5pcy1kcm9wZG93bi1zdWJtZW51e2xlZnQ6YXV0bztyaWdodDowO3RvcDoxMDAlfS5pcy1kcm9wZG93bi1zdWJtZW51e2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjEwMCU7bWluLXdpZHRoOjIwMHB4O3otaW5kZXg6MTtiYWNrZ3JvdW5kOiNmZWZlZmU7Ym9yZGVyOjFweCBzb2xpZCAjY2FjYWNhfS5pcy1kcm9wZG93bi1zdWJtZW51IC5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudD5hOmFmdGVye3JpZ2h0OjE0cHg7bWFyZ2luLXRvcDotM3B4fS5pcy1kcm9wZG93bi1zdWJtZW51IC5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudC5vcGVucy1sZWZ0PmE6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjVweCBpbnNldDtib3JkZXItY29sb3I6dHJhbnNwYXJlbnQgIzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQtc3R5bGU6c29saWQ7Ym9yZGVyLWxlZnQtd2lkdGg6MH0uaXMtZHJvcGRvd24tc3VibWVudSAuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQub3BlbnMtcmlnaHQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NXB4IGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCAjMjE5OWU4O2JvcmRlci1sZWZ0LXN0eWxlOnNvbGlkO2JvcmRlci1yaWdodC13aWR0aDowfS5pcy1kcm9wZG93bi1zdWJtZW51IC5pcy1kcm9wZG93bi1zdWJtZW51e21hcmdpbi10b3A6LTFweH0uaXMtZHJvcGRvd24tc3VibWVudT5saXt3aWR0aDoxMDAlfS5pcy1kcm9wZG93bi1zdWJtZW51LmpzLWRyb3Bkb3duLWFjdGl2ZSwuaXMtZHJvcGRvd24tc3VibWVudTpub3QoLmpzLWRyb3Bkb3duLW5vaG92ZXIpPi5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudDpob3Zlcj4uaXMtZHJvcGRvd24tc3VibWVudXtkaXNwbGF5OmJsb2NrfS5mbGV4LXZpZGVve3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDowO3BhZGRpbmctYm90dG9tOjc1JTttYXJnaW4tYm90dG9tOjFyZW07b3ZlcmZsb3c6aGlkZGVufS5mbGV4LXZpZGVvIGVtYmVkLC5mbGV4LXZpZGVvIGlmcmFtZSwuZmxleC12aWRlbyBvYmplY3QsLmZsZXgtdmlkZW8gdmlkZW97cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCV9LmZsZXgtdmlkZW8ud2lkZXNjcmVlbntwYWRkaW5nLWJvdHRvbTo1Ni4yNSV9LmZsZXgtdmlkZW8udmltZW97cGFkZGluZy10b3A6MH0ubGFiZWx7ZGlzcGxheTppbmxpbmUtYmxvY2s7cGFkZGluZzouMzMzMzNyZW0gLjVyZW07Zm9udC1zaXplOi44cmVtO2xpbmUtaGVpZ2h0OjE7d2hpdGUtc3BhY2U6bm93cmFwO2N1cnNvcjpkZWZhdWx0O2JvcmRlci1yYWRpdXM6MDtiYWNrZ3JvdW5kOiMyMTk5ZTg7Y29sb3I6I2ZlZmVmZX0ubGFiZWwuc2Vjb25kYXJ5e2JhY2tncm91bmQ6Izc3Nztjb2xvcjojZmVmZWZlfS5sYWJlbC5zdWNjZXNze2JhY2tncm91bmQ6IzNhZGI3Njtjb2xvcjojZmVmZWZlfS5sYWJlbC53YXJuaW5ne2JhY2tncm91bmQ6I2ZmYWUwMDtjb2xvcjojZmVmZWZlfS5sYWJlbC5hbGVydHtiYWNrZ3JvdW5kOiNlYzU4NDA7Y29sb3I6I2ZlZmVmZX0ubWVkaWEtb2JqZWN0e21hcmdpbi1ib3R0b206MXJlbTtkaXNwbGF5OmJsb2NrfS5tZWRpYS1vYmplY3QgaW1ne21heC13aWR0aDpub25lfUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6MzkuOTM3NWVtKXsubWVkaWEtb2JqZWN0LnN0YWNrLWZvci1zbWFsbCAubWVkaWEtb2JqZWN0LXNlY3Rpb257cGFkZGluZzowO3BhZGRpbmctYm90dG9tOjFyZW07ZGlzcGxheTpibG9ja30ubWVkaWEtb2JqZWN0LnN0YWNrLWZvci1zbWFsbCAubWVkaWEtb2JqZWN0LXNlY3Rpb24gaW1ne3dpZHRoOjEwMCV9fS5tZWRpYS1vYmplY3Qtc2VjdGlvbntkaXNwbGF5OnRhYmxlLWNlbGw7dmVydGljYWwtYWxpZ246dG9wfS5tZWRpYS1vYmplY3Qtc2VjdGlvbjpmaXJzdC1jaGlsZHtwYWRkaW5nLXJpZ2h0OjFyZW19Lm1lZGlhLW9iamVjdC1zZWN0aW9uOmxhc3QtY2hpbGQ6bm90KDpudGgtY2hpbGQoMikpe3BhZGRpbmctbGVmdDoxcmVtfS5tZWRpYS1vYmplY3Qtc2VjdGlvbi5taWRkbGV7dmVydGljYWwtYWxpZ246bWlkZGxlfS5tZWRpYS1vYmplY3Qtc2VjdGlvbi5ib3R0b217dmVydGljYWwtYWxpZ246Ym90dG9tfWJvZHksaHRtbHtoZWlnaHQ6MTAwJX0ub2ZmLWNhbnZhcy13cmFwcGVye3dpZHRoOjEwMCU7b3ZlcmZsb3cteDpoaWRkZW47cG9zaXRpb246cmVsYXRpdmU7LXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjtiYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjstd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzphdXRvfS5vZmYtY2FudmFzLXdyYXBwZXItaW5uZXJ7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MTAwJTt0cmFuc2l0aW9uOi13ZWJraXQtdHJhbnNmb3JtIC41cyBlYXNlO3RyYW5zaXRpb246dHJhbnNmb3JtIC41cyBlYXNlfS5vZmYtY2FudmFzLXdyYXBwZXItaW5uZXI6YWZ0ZXIsLm9mZi1jYW52YXMtd3JhcHBlci1pbm5lcjpiZWZvcmV7Y29udGVudDonICc7ZGlzcGxheTp0YWJsZTstd2Via2l0LWZsZXgtYmFzaXM6MDstbXMtZmxleC1wcmVmZXJyZWQtc2l6ZTowO2ZsZXgtYmFzaXM6MDstd2Via2l0LW9yZGVyOjE7LW1zLWZsZXgtb3JkZXI6MTtvcmRlcjoxfS5vZmYtY2FudmFzLXdyYXBwZXItaW5uZXI6YWZ0ZXJ7Y2xlYXI6Ym90aH0ub2ZmLWNhbnZhcy1jb250ZW50e21pbi1oZWlnaHQ6MTAwJTtiYWNrZ3JvdW5kOiNmZWZlZmU7dHJhbnNpdGlvbjotd2Via2l0LXRyYW5zZm9ybSAuNXMgZWFzZTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNXMgZWFzZTstd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6aGlkZGVuO2JhY2tmYWNlLXZpc2liaWxpdHk6aGlkZGVuO3otaW5kZXg6MTtwYWRkaW5nLWJvdHRvbTouMXB4O2JveC1zaGFkb3c6MCAwIDEwcHggaHNsYSgwLDAlLDQlLC41KX0uanMtb2ZmLWNhbnZhcy1leGl0e2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtiYWNrZ3JvdW5kOmhzbGEoMCwwJSwxMDAlLC4yNSk7Y3Vyc29yOnBvaW50ZXI7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kIC41cyBlYXNlfS5vZmYtY2FudmFze3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQ6I2U2ZTZlNjt6LWluZGV4Oi0xO21heC1oZWlnaHQ6MTAwJTtvdmVyZmxvdy15OmF1dG87LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgwKX1bZGF0YS13aGF0aW5wdXQ9bW91c2VdIC5vZmYtY2FudmFze291dGxpbmU6MH0ub2ZmLWNhbnZhcy5wb3NpdGlvbi1sZWZ0e2xlZnQ6LTI1MHB4O3RvcDowO3dpZHRoOjI1MHB4fS5pcy1vcGVuLWxlZnR7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgyNTBweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMjUwcHgpfS5vZmYtY2FudmFzLnBvc2l0aW9uLXJpZ2h0e3JpZ2h0Oi0yNTBweDt0b3A6MDt3aWR0aDoyNTBweH0uaXMtb3Blbi1yaWdodHstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0yNTBweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTI1MHB4KX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pey5wb3NpdGlvbi1sZWZ0LnJldmVhbC1mb3ItbWVkaXVte2xlZnQ6MDt6LWluZGV4OmF1dG87cG9zaXRpb246Zml4ZWR9LnBvc2l0aW9uLWxlZnQucmV2ZWFsLWZvci1tZWRpdW1+Lm9mZi1jYW52YXMtY29udGVudHttYXJnaW4tbGVmdDoyNTBweH0ucG9zaXRpb24tcmlnaHQucmV2ZWFsLWZvci1tZWRpdW17cmlnaHQ6MDt6LWluZGV4OmF1dG87cG9zaXRpb246Zml4ZWR9LnBvc2l0aW9uLXJpZ2h0LnJldmVhbC1mb3ItbWVkaXVtfi5vZmYtY2FudmFzLWNvbnRlbnR7bWFyZ2luLXJpZ2h0OjI1MHB4fX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjY0ZW0pey5wb3NpdGlvbi1sZWZ0LnJldmVhbC1mb3ItbGFyZ2V7bGVmdDowO3otaW5kZXg6YXV0bztwb3NpdGlvbjpmaXhlZH0ucG9zaXRpb24tbGVmdC5yZXZlYWwtZm9yLWxhcmdlfi5vZmYtY2FudmFzLWNvbnRlbnR7bWFyZ2luLWxlZnQ6MjUwcHh9LnBvc2l0aW9uLXJpZ2h0LnJldmVhbC1mb3ItbGFyZ2V7cmlnaHQ6MDt6LWluZGV4OmF1dG87cG9zaXRpb246Zml4ZWR9LnBvc2l0aW9uLXJpZ2h0LnJldmVhbC1mb3ItbGFyZ2V+Lm9mZi1jYW52YXMtY29udGVudHttYXJnaW4tcmlnaHQ6MjUwcHh9fS5vcmJpdCwub3JiaXQtY29udGFpbmVye3Bvc2l0aW9uOnJlbGF0aXZlfS5vcmJpdC1jb250YWluZXJ7bWFyZ2luOjA7b3ZlcmZsb3c6aGlkZGVuO2xpc3Qtc3R5bGU6bm9uZX0ub3JiaXQtc2xpZGV7d2lkdGg6MTAwJTttYXgtaGVpZ2h0OjEwMCV9Lm9yYml0LXNsaWRlLm5vLW1vdGlvbnVpLmlzLWFjdGl2ZXt0b3A6MDtsZWZ0OjB9Lm9yYml0LWZpZ3VyZXttYXJnaW46MH0ub3JiaXQtaW1hZ2V7bWFyZ2luOjA7d2lkdGg6MTAwJTttYXgtd2lkdGg6MTAwJX0ub3JiaXQtY2FwdGlvbntib3R0b206MDt3aWR0aDoxMDAlO21hcmdpbi1ib3R0b206MDtiYWNrZ3JvdW5kLWNvbG9yOmhzbGEoMCwwJSw0JSwuNSl9Lm9yYml0LWNhcHRpb24sLm9yYml0LW5leHQsLm9yYml0LXByZXZpb3Vze3Bvc2l0aW9uOmFic29sdXRlO3BhZGRpbmc6MXJlbTtjb2xvcjojZmVmZWZlfS5vcmJpdC1uZXh0LC5vcmJpdC1wcmV2aW91c3t0b3A6NTAlOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSk7ei1pbmRleDozfVtkYXRhLXdoYXRpbnB1dD1tb3VzZV0gLm9yYml0LW5leHQsW2RhdGEtd2hhdGlucHV0PW1vdXNlXSAub3JiaXQtcHJldmlvdXN7b3V0bGluZTowfS5vcmJpdC1uZXh0OmFjdGl2ZSwub3JiaXQtbmV4dDpmb2N1cywub3JiaXQtbmV4dDpob3Zlciwub3JiaXQtcHJldmlvdXM6YWN0aXZlLC5vcmJpdC1wcmV2aW91czpmb2N1cywub3JiaXQtcHJldmlvdXM6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjpoc2xhKDAsMCUsNCUsLjUpfS5vcmJpdC1wcmV2aW91c3tsZWZ0OjB9Lm9yYml0LW5leHR7bGVmdDphdXRvO3JpZ2h0OjB9Lm9yYml0LWJ1bGxldHN7cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luLXRvcDouOHJlbTttYXJnaW4tYm90dG9tOi44cmVtO3RleHQtYWxpZ246Y2VudGVyfVtkYXRhLXdoYXRpbnB1dD1tb3VzZV0gLm9yYml0LWJ1bGxldHN7b3V0bGluZTowfS5vcmJpdC1idWxsZXRzIGJ1dHRvbnt3aWR0aDoxLjJyZW07aGVpZ2h0OjEuMnJlbTttYXJnaW46LjFyZW07YmFja2dyb3VuZC1jb2xvcjojY2FjYWNhO2JvcmRlci1yYWRpdXM6NTAlfS5vcmJpdC1idWxsZXRzIGJ1dHRvbi5pcy1hY3RpdmUsLm9yYml0LWJ1bGxldHMgYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzhhOGE4YX0ucGFnaW5hdGlvbnttYXJnaW4tbGVmdDowO21hcmdpbi1ib3R0b206MXJlbX0ucGFnaW5hdGlvbjphZnRlciwucGFnaW5hdGlvbjpiZWZvcmV7Y29udGVudDonICc7ZGlzcGxheTp0YWJsZTstd2Via2l0LWZsZXgtYmFzaXM6MDstbXMtZmxleC1wcmVmZXJyZWQtc2l6ZTowO2ZsZXgtYmFzaXM6MDstd2Via2l0LW9yZGVyOjE7LW1zLWZsZXgtb3JkZXI6MTtvcmRlcjoxfS5wYWdpbmF0aW9uOmFmdGVye2NsZWFyOmJvdGh9LnBhZ2luYXRpb24gbGl7Zm9udC1zaXplOi44NzVyZW07bWFyZ2luLXJpZ2h0Oi4wNjI1cmVtO2JvcmRlci1yYWRpdXM6MDtkaXNwbGF5Om5vbmV9LnBhZ2luYXRpb24gbGk6Zmlyc3QtY2hpbGQsLnBhZ2luYXRpb24gbGk6bGFzdC1jaGlsZHtkaXNwbGF5OmlubGluZS1ibG9ja31AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pey5wYWdpbmF0aW9uIGxpe2Rpc3BsYXk6aW5saW5lLWJsb2NrfX0ucGFnaW5hdGlvbiBhLC5wYWdpbmF0aW9uIGJ1dHRvbntjb2xvcjojMGEwYTBhO2Rpc3BsYXk6YmxvY2s7cGFkZGluZzouMTg3NXJlbSAuNjI1cmVtO2JvcmRlci1yYWRpdXM6MH0ucGFnaW5hdGlvbiBhOmhvdmVyLC5wYWdpbmF0aW9uIGJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kOiNlNmU2ZTZ9LnBhZ2luYXRpb24gLmN1cnJlbnR7cGFkZGluZzouMTg3NXJlbSAuNjI1cmVtO2JhY2tncm91bmQ6IzIxOTllODtjb2xvcjojZmVmZWZlO2N1cnNvcjpkZWZhdWx0fS5wYWdpbmF0aW9uIC5kaXNhYmxlZHtwYWRkaW5nOi4xODc1cmVtIC42MjVyZW07Y29sb3I6I2NhY2FjYTtjdXJzb3I6ZGVmYXVsdH0ucGFnaW5hdGlvbiAuZGlzYWJsZWQ6aG92ZXJ7YmFja2dyb3VuZDp0cmFuc3BhcmVudH0ucGFnaW5hdGlvbiAuZWxsaXBzaXM6YWZ0ZXJ7Y29udGVudDonXFxcXDIwMjYnO3BhZGRpbmc6LjE4NzVyZW0gLjYyNXJlbTtjb2xvcjojMGEwYTBhfS5wYWdpbmF0aW9uLXByZXZpb3VzLmRpc2FibGVkOmJlZm9yZSwucGFnaW5hdGlvbi1wcmV2aW91cyBhOmJlZm9yZXtjb250ZW50OidcXFxcQUInO2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbi1yaWdodDouNXJlbX0ucGFnaW5hdGlvbi1uZXh0LmRpc2FibGVkOmFmdGVyLC5wYWdpbmF0aW9uLW5leHQgYTphZnRlcntjb250ZW50OidcXFxcQkInO2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbi1sZWZ0Oi41cmVtfS5wcm9ncmVzc3tiYWNrZ3JvdW5kLWNvbG9yOiNjYWNhY2E7aGVpZ2h0OjFyZW07bWFyZ2luLWJvdHRvbToxcmVtO2JvcmRlci1yYWRpdXM6MH0ucHJvZ3Jlc3MucHJpbWFyeSAucHJvZ3Jlc3MtbWV0ZXJ7YmFja2dyb3VuZC1jb2xvcjojMjE5OWU4fS5wcm9ncmVzcy5zZWNvbmRhcnkgLnByb2dyZXNzLW1ldGVye2JhY2tncm91bmQtY29sb3I6Izc3N30ucHJvZ3Jlc3Muc3VjY2VzcyAucHJvZ3Jlc3MtbWV0ZXJ7YmFja2dyb3VuZC1jb2xvcjojM2FkYjc2fS5wcm9ncmVzcy53YXJuaW5nIC5wcm9ncmVzcy1tZXRlcntiYWNrZ3JvdW5kLWNvbG9yOiNmZmFlMDB9LnByb2dyZXNzLmFsZXJ0IC5wcm9ncmVzcy1tZXRlcntiYWNrZ3JvdW5kLWNvbG9yOiNlYzU4NDB9LnByb2dyZXNzLW1ldGVye3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MTAwJTtiYWNrZ3JvdW5kLWNvbG9yOiMyMTk5ZTh9LnByb2dyZXNzLW1ldGVyLXRleHR7dG9wOjUwJTtsZWZ0OjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSwtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsLTUwJSk7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luOjA7Zm9udC1zaXplOi43NXJlbTtmb250LXdlaWdodDo3MDA7Y29sb3I6I2ZlZmVmZTt3aGl0ZS1zcGFjZTpub3dyYXB9LnNsaWRlcntwb3NpdGlvbjpyZWxhdGl2ZTtoZWlnaHQ6LjVyZW07bWFyZ2luLXRvcDoxLjI1cmVtO21hcmdpbi1ib3R0b206Mi4yNXJlbTtiYWNrZ3JvdW5kLWNvbG9yOiNlNmU2ZTY7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lOy1tcy10b3VjaC1hY3Rpb246bm9uZTt0b3VjaC1hY3Rpb246bm9uZX0uc2xpZGVyLWZpbGx7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO2Rpc3BsYXk6aW5saW5lLWJsb2NrO21heC13aWR0aDoxMDAlO2hlaWdodDouNXJlbTtiYWNrZ3JvdW5kLWNvbG9yOiNjYWNhY2E7dHJhbnNpdGlvbjphbGwgLjJzIGVhc2UtaW4tb3V0fS5zbGlkZXItZmlsbC5pcy1kcmFnZ2luZ3t0cmFuc2l0aW9uOmFsbCAwcyBsaW5lYXJ9LnNsaWRlci1oYW5kbGV7dG9wOjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt6LWluZGV4OjE7ZGlzcGxheTppbmxpbmUtYmxvY2s7d2lkdGg6MS40cmVtO2hlaWdodDoxLjRyZW07YmFja2dyb3VuZC1jb2xvcjojMjE5OWU4O3RyYW5zaXRpb246YWxsIC4ycyBlYXNlLWluLW91dDstbXMtdG91Y2gtYWN0aW9uOm1hbmlwdWxhdGlvbjt0b3VjaC1hY3Rpb246bWFuaXB1bGF0aW9uO2JvcmRlci1yYWRpdXM6MH1bZGF0YS13aGF0aW5wdXQ9bW91c2VdIC5zbGlkZXItaGFuZGxle291dGxpbmU6MH0uc2xpZGVyLWhhbmRsZTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxNTgzY2N9LnNsaWRlci1oYW5kbGUuaXMtZHJhZ2dpbmd7dHJhbnNpdGlvbjphbGwgMHMgbGluZWFyfS5zbGlkZXIuZGlzYWJsZWQsLnNsaWRlcltkaXNhYmxlZF17b3BhY2l0eTouMjU7Y3Vyc29yOm5vdC1hbGxvd2VkfS5zbGlkZXIudmVydGljYWx7ZGlzcGxheTppbmxpbmUtYmxvY2s7d2lkdGg6LjVyZW07aGVpZ2h0OjEyLjVyZW07bWFyZ2luOjAgMS4yNXJlbTstd2Via2l0LXRyYW5zZm9ybTpzY2FsZVkoLTEpO3RyYW5zZm9ybTpzY2FsZVkoLTEpfS5zbGlkZXIudmVydGljYWwgLnNsaWRlci1maWxse3RvcDowO3dpZHRoOi41cmVtO21heC1oZWlnaHQ6MTAwJX0uc2xpZGVyLnZlcnRpY2FsIC5zbGlkZXItaGFuZGxle3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6NTAlO3dpZHRoOjEuNHJlbTtoZWlnaHQ6MS40cmVtOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSl9LnN0aWNreS1jb250YWluZXJ7cG9zaXRpb246cmVsYXRpdmV9LnN0aWNreXtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWigwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKX0uc3RpY2t5LmlzLXN0dWNre3Bvc2l0aW9uOmZpeGVkO3otaW5kZXg6Mn0uc3RpY2t5LmlzLXN0dWNrLmlzLWF0LXRvcHt0b3A6MH0uc3RpY2t5LmlzLXN0dWNrLmlzLWF0LWJvdHRvbXtib3R0b206MH0uc3RpY2t5LmlzLWFuY2hvcmVke3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6YXV0bztyaWdodDphdXRvfS5zdGlja3kuaXMtYW5jaG9yZWQuaXMtYXQtYm90dG9te2JvdHRvbTowfWJvZHkuaXMtcmV2ZWFsLW9wZW57b3ZlcmZsb3c6aGlkZGVufS5yZXZlYWwtb3ZlcmxheXtkaXNwbGF5Om5vbmU7cG9zaXRpb246Zml4ZWQ7dG9wOjA7Ym90dG9tOjA7bGVmdDowO3JpZ2h0OjA7ei1pbmRleDo0O2JhY2tncm91bmQtY29sb3I6aHNsYSgwLDAlLDQlLC40NSk7b3ZlcmZsb3cteTpzY3JvbGx9LnJldmVhbHtkaXNwbGF5Om5vbmU7ei1pbmRleDo1O3BhZGRpbmc6MXJlbTtib3JkZXI6MXB4IHNvbGlkICNjYWNhY2E7YmFja2dyb3VuZC1jb2xvcjojZmVmZWZlO2JvcmRlci1yYWRpdXM6MDtwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6MTAwcHg7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6YXV0bztvdmVyZmxvdy15OmF1dG99W2RhdGEtd2hhdGlucHV0PW1vdXNlXSAucmV2ZWFse291dGxpbmU6MH1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pey5yZXZlYWx7bWluLWhlaWdodDowfX0ucmV2ZWFsIC5jb2x1bW4sLnJldmVhbCAuY29sdW1uc3ttaW4td2lkdGg6MH0ucmV2ZWFsPjpsYXN0LWNoaWxke21hcmdpbi1ib3R0b206MH1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pey5yZXZlYWx7d2lkdGg6NjAwcHg7bWF4LXdpZHRoOjc1cmVtfX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pey5yZXZlYWwgLnJldmVhbHtsZWZ0OmF1dG87cmlnaHQ6YXV0bzttYXJnaW46MCBhdXRvfX0ucmV2ZWFsLmNvbGxhcHNle3BhZGRpbmc6MH1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pey5yZXZlYWwudGlueXt3aWR0aDozMCU7bWF4LXdpZHRoOjc1cmVtfX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pey5yZXZlYWwuc21hbGx7d2lkdGg6NTAlO21heC13aWR0aDo3NXJlbX19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucmV2ZWFsLmxhcmdle3dpZHRoOjkwJTttYXgtd2lkdGg6NzVyZW19fS5yZXZlYWwuZnVsbHt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtoZWlnaHQ6MTAwdmg7bWluLWhlaWdodDoxMDB2aDttYXgtd2lkdGg6bm9uZTttYXJnaW4tbGVmdDowO2JvcmRlcjowfUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6MzkuOTM3NWVtKXsucmV2ZWFse3RvcDowO2xlZnQ6MDt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2hlaWdodDoxMDB2aDttaW4taGVpZ2h0OjEwMHZoO21heC13aWR0aDpub25lO21hcmdpbi1sZWZ0OjA7Ym9yZGVyOjB9fS5yZXZlYWwud2l0aG91dC1vdmVybGF5e3Bvc2l0aW9uOmZpeGVkfS5zd2l0Y2h7bWFyZ2luLWJvdHRvbToxcmVtO291dGxpbmU6MDtwb3NpdGlvbjpyZWxhdGl2ZTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7Y29sb3I6I2ZlZmVmZTtmb250LXdlaWdodDo3MDA7Zm9udC1zaXplOi44NzVyZW19LnN3aXRjaC1pbnB1dHtvcGFjaXR5OjA7cG9zaXRpb246YWJzb2x1dGV9LnN3aXRjaC1wYWRkbGV7YmFja2dyb3VuZDojY2FjYWNhO2N1cnNvcjpwb2ludGVyO2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6NHJlbTtoZWlnaHQ6MnJlbTt0cmFuc2l0aW9uOmFsbCAuMjVzIGVhc2Utb3V0O2JvcmRlci1yYWRpdXM6MDtjb2xvcjppbmhlcml0O2ZvbnQtd2VpZ2h0OmluaGVyaXR9aW5wdXQrLnN3aXRjaC1wYWRkbGV7bWFyZ2luOjB9LnN3aXRjaC1wYWRkbGU6YWZ0ZXJ7YmFja2dyb3VuZDojZmVmZWZlO2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTtoZWlnaHQ6MS41cmVtO2xlZnQ6LjI1cmVtO3RvcDouMjVyZW07d2lkdGg6MS41cmVtO3RyYW5zaXRpb246YWxsIC4yNXMgZWFzZS1vdXQ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWigwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKTtib3JkZXItcmFkaXVzOjB9aW5wdXQ6Y2hlY2tlZH4uc3dpdGNoLXBhZGRsZXtiYWNrZ3JvdW5kOiMyMTk5ZTh9aW5wdXQ6Y2hlY2tlZH4uc3dpdGNoLXBhZGRsZTphZnRlcntsZWZ0OjIuMjVyZW19W2RhdGEtd2hhdGlucHV0PW1vdXNlXSBpbnB1dDpmb2N1c34uc3dpdGNoLXBhZGRsZXtvdXRsaW5lOjB9LnN3aXRjaC1hY3RpdmUsLnN3aXRjaC1pbmFjdGl2ZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSl9LnN3aXRjaC1hY3RpdmV7bGVmdDo4JTtkaXNwbGF5Om5vbmV9aW5wdXQ6Y2hlY2tlZCtsYWJlbD4uc3dpdGNoLWFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5zd2l0Y2gtaW5hY3RpdmV7cmlnaHQ6MTUlfWlucHV0OmNoZWNrZWQrbGFiZWw+LnN3aXRjaC1pbmFjdGl2ZXtkaXNwbGF5Om5vbmV9LnN3aXRjaC50aW55IC5zd2l0Y2gtcGFkZGxle3dpZHRoOjNyZW07aGVpZ2h0OjEuNXJlbTtmb250LXNpemU6LjYyNXJlbX0uc3dpdGNoLnRpbnkgLnN3aXRjaC1wYWRkbGU6YWZ0ZXJ7d2lkdGg6MXJlbTtoZWlnaHQ6MXJlbX0uc3dpdGNoLnRpbnkgaW5wdXQ6Y2hlY2tlZH4uc3dpdGNoLXBhZGRsZTphZnRlcntsZWZ0OjEuNzVyZW19LnN3aXRjaC5zbWFsbCAuc3dpdGNoLXBhZGRsZXt3aWR0aDozLjVyZW07aGVpZ2h0OjEuNzVyZW07Zm9udC1zaXplOi43NXJlbX0uc3dpdGNoLnNtYWxsIC5zd2l0Y2gtcGFkZGxlOmFmdGVye3dpZHRoOjEuMjVyZW07aGVpZ2h0OjEuMjVyZW19LnN3aXRjaC5zbWFsbCBpbnB1dDpjaGVja2Vkfi5zd2l0Y2gtcGFkZGxlOmFmdGVye2xlZnQ6MnJlbX0uc3dpdGNoLmxhcmdlIC5zd2l0Y2gtcGFkZGxle3dpZHRoOjVyZW07aGVpZ2h0OjIuNXJlbTtmb250LXNpemU6MXJlbX0uc3dpdGNoLmxhcmdlIC5zd2l0Y2gtcGFkZGxlOmFmdGVye3dpZHRoOjJyZW07aGVpZ2h0OjJyZW19LnN3aXRjaC5sYXJnZSBpbnB1dDpjaGVja2Vkfi5zd2l0Y2gtcGFkZGxlOmFmdGVye2xlZnQ6Mi43NXJlbX10YWJsZXt3aWR0aDoxMDAlO21hcmdpbi1ib3R0b206MXJlbTtib3JkZXItcmFkaXVzOjB9dGFibGUgdGJvZHksdGFibGUgdGZvb3QsdGFibGUgdGhlYWR7Ym9yZGVyOjFweCBzb2xpZCAjZjFmMWYxO2JhY2tncm91bmQtY29sb3I6I2ZlZmVmZX10YWJsZSBjYXB0aW9ue2ZvbnQtd2VpZ2h0OjcwMDtwYWRkaW5nOi41cmVtIC42MjVyZW0gLjYyNXJlbX10YWJsZSB0Zm9vdCx0YWJsZSB0aGVhZHtiYWNrZ3JvdW5kOiNmOGY4Zjg7Y29sb3I6IzBhMGEwYX10YWJsZSB0Zm9vdCB0cix0YWJsZSB0aGVhZCB0cntiYWNrZ3JvdW5kOnRyYW5zcGFyZW50fXRhYmxlIHRmb290IHRkLHRhYmxlIHRmb290IHRoLHRhYmxlIHRoZWFkIHRkLHRhYmxlIHRoZWFkIHRoe3BhZGRpbmc6LjVyZW0gLjYyNXJlbSAuNjI1cmVtO2ZvbnQtd2VpZ2h0OjcwMDt0ZXh0LWFsaWduOmxlZnR9dGFibGUgdGJvZHkgdHI6bnRoLWNoaWxkKGV2ZW4pe2JhY2tncm91bmQtY29sb3I6I2YxZjFmMX10YWJsZSB0Ym9keSB0ZCx0YWJsZSB0Ym9keSB0aHtwYWRkaW5nOi41cmVtIC42MjVyZW0gLjYyNXJlbX1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjYzLjkzNzVlbSl7dGFibGUuc3RhY2sgdGZvb3QsdGFibGUuc3RhY2sgdGhlYWR7ZGlzcGxheTpub25lfXRhYmxlLnN0YWNrIHRkLHRhYmxlLnN0YWNrIHRoLHRhYmxlLnN0YWNrIHRye2Rpc3BsYXk6YmxvY2t9dGFibGUuc3RhY2sgdGR7Ym9yZGVyLXRvcDowfX10YWJsZS5zY3JvbGx7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlO292ZXJmbG93LXg6YXV0b310YWJsZS5ob3ZlciB0cjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmOWY5Zjl9dGFibGUuaG92ZXIgdHI6bnRoLW9mLXR5cGUoZXZlbik6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZWNlY2VjfS50YWJsZS1zY3JvbGx7b3ZlcmZsb3cteDphdXRvfS50YWJsZS1zY3JvbGwgdGFibGV7d2lkdGg6YXV0b30udGFic3ttYXJnaW46MDtsaXN0LXN0eWxlLXR5cGU6bm9uZTtiYWNrZ3JvdW5kOiNmZWZlZmU7Ym9yZGVyOjFweCBzb2xpZCAjZTZlNmU2fS50YWJzOmFmdGVyLC50YWJzOmJlZm9yZXtjb250ZW50OicgJztkaXNwbGF5OnRhYmxlOy13ZWJraXQtZmxleC1iYXNpczowOy1tcy1mbGV4LXByZWZlcnJlZC1zaXplOjA7ZmxleC1iYXNpczowOy13ZWJraXQtb3JkZXI6MTstbXMtZmxleC1vcmRlcjoxO29yZGVyOjF9LnRhYnM6YWZ0ZXJ7Y2xlYXI6Ym90aH0udGFicy52ZXJ0aWNhbD5saXt3aWR0aDphdXRvO2Zsb2F0Om5vbmU7ZGlzcGxheTpibG9ja30udGFicy5zaW1wbGU+bGk+YXtwYWRkaW5nOjB9LnRhYnMuc2ltcGxlPmxpPmE6aG92ZXJ7YmFja2dyb3VuZDp0cmFuc3BhcmVudH0udGFicy5wcmltYXJ5e2JhY2tncm91bmQ6IzIxOTllOH0udGFicy5wcmltYXJ5PmxpPmF7Y29sb3I6I2ZlZmVmZX0udGFicy5wcmltYXJ5PmxpPmE6Zm9jdXMsLnRhYnMucHJpbWFyeT5saT5hOmhvdmVye2JhY2tncm91bmQ6IzE4OTNlNH0udGFicy10aXRsZXtmbG9hdDpsZWZ0fS50YWJzLXRpdGxlPmF7ZGlzcGxheTpibG9jaztwYWRkaW5nOjEuMjVyZW0gMS41cmVtO2xpbmUtaGVpZ2h0OjE7Zm9udC1zaXplOi43NXJlbX0udGFicy10aXRsZT5hOmhvdmVye2JhY2tncm91bmQ6I2ZlZmVmZX0udGFicy10aXRsZT5hOmZvY3VzLC50YWJzLXRpdGxlPmFbYXJpYS1zZWxlY3RlZD10cnVlXXtiYWNrZ3JvdW5kOiNlNmU2ZTZ9LnRhYnMtY29udGVudHtiYWNrZ3JvdW5kOiNmZWZlZmU7dHJhbnNpdGlvbjphbGwgLjVzIGVhc2U7Ym9yZGVyOjFweCBzb2xpZCAjZTZlNmU2O2JvcmRlci10b3A6MH0udGFicy1jb250ZW50LnZlcnRpY2Fse2JvcmRlcjoxcHggc29saWQgI2U2ZTZlNjtib3JkZXItbGVmdDowfS50YWJzLXBhbmVse2Rpc3BsYXk6bm9uZTtwYWRkaW5nOjFyZW19LnRhYnMtcGFuZWwuaXMtYWN0aXZle2Rpc3BsYXk6YmxvY2t9LnRodW1ibmFpbHtib3JkZXI6NHB4IHNvbGlkICNmZWZlZmU7Ym94LXNoYWRvdzowIDAgMCAxcHggaHNsYSgwLDAlLDQlLC4yKTtkaXNwbGF5OmlubGluZS1ibG9jaztsaW5lLWhlaWdodDowO21heC13aWR0aDoxMDAlO3RyYW5zaXRpb246Ym94LXNoYWRvdyAuMnMgZWFzZS1vdXQ7Ym9yZGVyLXJhZGl1czowO21hcmdpbi1ib3R0b206MXJlbX0udGh1bWJuYWlsOmZvY3VzLC50aHVtYm5haWw6aG92ZXJ7Ym94LXNoYWRvdzowIDAgNnB4IDFweCByZ2JhKDMzLDE1MywyMzIsLjUpfS50aXRsZS1iYXJ7YmFja2dyb3VuZDojMGEwYTBhO2NvbG9yOiNmZWZlZmU7cGFkZGluZzouNXJlbX0udGl0bGUtYmFyOmFmdGVyLC50aXRsZS1iYXI6YmVmb3Jle2NvbnRlbnQ6JyAnO2Rpc3BsYXk6dGFibGU7LXdlYmtpdC1mbGV4LWJhc2lzOjA7LW1zLWZsZXgtcHJlZmVycmVkLXNpemU6MDtmbGV4LWJhc2lzOjA7LXdlYmtpdC1vcmRlcjoxOy1tcy1mbGV4LW9yZGVyOjE7b3JkZXI6MX0udGl0bGUtYmFyOmFmdGVye2NsZWFyOmJvdGh9LnRpdGxlLWJhciAubWVudS1pY29ue21hcmdpbi1sZWZ0Oi4yNXJlbTttYXJnaW4tcmlnaHQ6LjVyZW19LnRpdGxlLWJhci1sZWZ0e2Zsb2F0OmxlZnR9LnRpdGxlLWJhci1yaWdodHtmbG9hdDpyaWdodDt0ZXh0LWFsaWduOnJpZ2h0fS50aXRsZS1iYXItdGl0bGV7Zm9udC13ZWlnaHQ6NzAwfS5tZW51LWljb24uZGFyaywudGl0bGUtYmFyLXRpdGxle3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtkaXNwbGF5OmlubGluZS1ibG9ja30ubWVudS1pY29uLmRhcmt7cG9zaXRpb246cmVsYXRpdmU7Y3Vyc29yOnBvaW50ZXI7d2lkdGg6MjBweDtoZWlnaHQ6MTZweH0ubWVudS1pY29uLmRhcms6YWZ0ZXJ7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7aGVpZ2h0OjJweDtiYWNrZ3JvdW5kOiMwYTBhMGE7dG9wOjA7bGVmdDowO2JveC1zaGFkb3c6MCA3cHggMCAjMGEwYTBhLDAgMTRweCAwICMwYTBhMGF9Lm1lbnUtaWNvbi5kYXJrOmhvdmVyOmFmdGVye2JhY2tncm91bmQ6IzhhOGE4YTtib3gtc2hhZG93OjAgN3B4IDAgIzhhOGE4YSwwIDE0cHggMCAjOGE4YThhfS5oYXMtdGlwe2JvcmRlci1ib3R0b206MXB4IGRvdHRlZCAjOGE4YThhO2ZvbnQtd2VpZ2h0OjcwMDtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmlubGluZS1ibG9jaztjdXJzb3I6aGVscH0udG9vbHRpcHtiYWNrZ3JvdW5kLWNvbG9yOiMwYTBhMGE7Y29sb3I6I2ZlZmVmZTtmb250LXNpemU6ODAlO3BhZGRpbmc6Ljc1cmVtO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6Mzt0b3A6Y2FsYygxMDAlICsgLjY0OTVyZW0pO21heC13aWR0aDoxMHJlbSFpbXBvcnRhbnQ7Ym9yZGVyLXJhZGl1czowfS50b29sdGlwOmJlZm9yZXtib3JkZXItY29sb3I6dHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzBhMGEwYTtib3JkZXItYm90dG9tLXN0eWxlOnNvbGlkO2JvcmRlci10b3Atd2lkdGg6MDtib3R0b206MTAwJTtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpfS50b29sdGlwLnRvcDpiZWZvcmUsLnRvb2x0aXA6YmVmb3Jle2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlcjouNzVyZW0gaW5zZXR9LnRvb2x0aXAudG9wOmJlZm9yZXtib3JkZXItY29sb3I6IzBhMGEwYSB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItdG9wLXN0eWxlOnNvbGlkO2JvcmRlci1ib3R0b20td2lkdGg6MDt0b3A6MTAwJTtib3R0b206YXV0b30udG9vbHRpcC5sZWZ0OmJlZm9yZXtib3JkZXItY29sb3I6dHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzBhMGEwYTtib3JkZXItbGVmdC1zdHlsZTpzb2xpZDtib3JkZXItcmlnaHQtd2lkdGg6MDtsZWZ0OjEwMCV9LnRvb2x0aXAubGVmdDpiZWZvcmUsLnRvb2x0aXAucmlnaHQ6YmVmb3Jle2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlcjouNzVyZW0gaW5zZXQ7Ym90dG9tOmF1dG87dG9wOjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpfS50b29sdGlwLnJpZ2h0OmJlZm9yZXtib3JkZXItY29sb3I6dHJhbnNwYXJlbnQgIzBhMGEwYSB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQtc3R5bGU6c29saWQ7Ym9yZGVyLWxlZnQtd2lkdGg6MDtsZWZ0OmF1dG87cmlnaHQ6MTAwJX0udG9wLWJhcntwYWRkaW5nOi41cmVtfS50b3AtYmFyOmFmdGVyLC50b3AtYmFyOmJlZm9yZXtjb250ZW50OicgJztkaXNwbGF5OnRhYmxlOy13ZWJraXQtZmxleC1iYXNpczowOy1tcy1mbGV4LXByZWZlcnJlZC1zaXplOjA7ZmxleC1iYXNpczowOy13ZWJraXQtb3JkZXI6MTstbXMtZmxleC1vcmRlcjoxO29yZGVyOjF9LnRvcC1iYXI6YWZ0ZXJ7Y2xlYXI6Ym90aH0udG9wLWJhciwudG9wLWJhciB1bHtiYWNrZ3JvdW5kLWNvbG9yOiNlNmU2ZTZ9LnRvcC1iYXIgaW5wdXR7d2lkdGg6MjAwcHg7bWFyZ2luLXJpZ2h0OjFyZW19LnRvcC1iYXIgLmlucHV0LWdyb3VwLWZpZWxke3dpZHRoOjEwMCU7bWFyZ2luLXJpZ2h0OjB9LnRvcC1iYXIgaW5wdXQuYnV0dG9ue3dpZHRoOmF1dG99QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDozOS45Mzc1ZW0pey5zdGFja2VkLWZvci1zbWFsbCAudG9wLWJhci1sZWZ0LC5zdGFja2VkLWZvci1zbWFsbCAudG9wLWJhci1yaWdodHt3aWR0aDoxMDAlfX1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjYzLjkzNzVlbSl7LnN0YWNrZWQtZm9yLW1lZGl1bSAudG9wLWJhci1sZWZ0LC5zdGFja2VkLWZvci1tZWRpdW0gLnRvcC1iYXItcmlnaHR7d2lkdGg6MTAwJX19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDo3NC45Mzc1ZW0pey5zdGFja2VkLWZvci1sYXJnZSAudG9wLWJhci1sZWZ0LC5zdGFja2VkLWZvci1sYXJnZSAudG9wLWJhci1yaWdodHt3aWR0aDoxMDAlfX0udG9wLWJhci1sZWZ0LC50b3AtYmFyLXJpZ2h0e3dpZHRoOjEwMCV9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsudG9wLWJhci1sZWZ0LC50b3AtYmFyLXJpZ2h0e3dpZHRoOmF1dG99fS50b3AtYmFyLXRpdGxle2Zsb2F0OmxlZnQ7bWFyZ2luLXJpZ2h0OjFyZW19LnRvcC1iYXItbGVmdHtmbG9hdDpsZWZ0fS50b3AtYmFyLXJpZ2h0e2Zsb2F0OnJpZ2h0fS5oaWRle2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9LmludmlzaWJsZXt2aXNpYmlsaXR5OmhpZGRlbn1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjM5LjkzNzVlbSl7LmhpZGUtZm9yLXNtYWxsLW9ubHl7ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDowZW0pLHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsuc2hvdy1mb3Itc21hbGwtb25seXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pey5oaWRlLWZvci1tZWRpdW17ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDozOS45Mzc1ZW0pey5zaG93LWZvci1tZWRpdW17ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKSBhbmQgKG1heC13aWR0aDo2My45Mzc1ZW0pey5oaWRlLWZvci1tZWRpdW0tb25seXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fX1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjM5LjkzNzVlbSksc2NyZWVuIGFuZCAobWluLXdpZHRoOjY0ZW0pey5zaG93LWZvci1tZWRpdW0tb25seXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjY0ZW0pey5oaWRlLWZvci1sYXJnZXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fX1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjYzLjkzNzVlbSl7LnNob3ctZm9yLWxhcmdle2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NjRlbSkgYW5kIChtYXgtd2lkdGg6NzQuOTM3NWVtKXsuaGlkZS1mb3ItbGFyZ2Utb25seXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fX1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjYzLjkzNzVlbSksc2NyZWVuIGFuZCAobWluLXdpZHRoOjc1ZW0pey5zaG93LWZvci1sYXJnZS1vbmx5e2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9fS5zaG93LWZvci1zciwuc2hvdy1vbi1mb2N1c3twb3NpdGlvbjphYnNvbHV0ZSFpbXBvcnRhbnQ7d2lkdGg6MXB4O2hlaWdodDoxcHg7b3ZlcmZsb3c6aGlkZGVuO2NsaXA6cmVjdCgwLDAsMCwwKX0uc2hvdy1vbi1mb2N1czphY3RpdmUsLnNob3ctb24tZm9jdXM6Zm9jdXN7cG9zaXRpb246c3RhdGljIWltcG9ydGFudDtoZWlnaHQ6YXV0bzt3aWR0aDphdXRvO292ZXJmbG93OnZpc2libGU7Y2xpcDphdXRvfS5oaWRlLWZvci1wb3J0cmFpdCwuc2hvdy1mb3ItbGFuZHNjYXBle2Rpc3BsYXk6YmxvY2shaW1wb3J0YW50fUBtZWRpYSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjpsYW5kc2NhcGUpey5oaWRlLWZvci1wb3J0cmFpdCwuc2hvdy1mb3ItbGFuZHNjYXBle2Rpc3BsYXk6YmxvY2shaW1wb3J0YW50fX1AbWVkaWEgc2NyZWVuIGFuZCAob3JpZW50YXRpb246cG9ydHJhaXQpey5oaWRlLWZvci1wb3J0cmFpdCwuc2hvdy1mb3ItbGFuZHNjYXBle2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9fS5oaWRlLWZvci1sYW5kc2NhcGUsLnNob3ctZm9yLXBvcnRyYWl0e2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9QG1lZGlhIHNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOmxhbmRzY2FwZSl7LmhpZGUtZm9yLWxhbmRzY2FwZSwuc2hvdy1mb3ItcG9ydHJhaXR7ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOnBvcnRyYWl0KXsuaGlkZS1mb3ItbGFuZHNjYXBlLC5zaG93LWZvci1wb3J0cmFpdHtkaXNwbGF5OmJsb2NrIWltcG9ydGFudH19LmZsb2F0LWxlZnR7ZmxvYXQ6bGVmdCFpbXBvcnRhbnR9LmZsb2F0LXJpZ2h0e2Zsb2F0OnJpZ2h0IWltcG9ydGFudH0uZmxvYXQtY2VudGVye2Rpc3BsYXk6YmxvY2s7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6YXV0b30uY2xlYXJmaXg6YWZ0ZXIsLmNsZWFyZml4OmJlZm9yZXtjb250ZW50OicgJztkaXNwbGF5OnRhYmxlOy13ZWJraXQtZmxleC1iYXNpczowOy1tcy1mbGV4LXByZWZlcnJlZC1zaXplOjA7ZmxleC1iYXNpczowOy13ZWJraXQtb3JkZXI6MTstbXMtZmxleC1vcmRlcjoxO29yZGVyOjF9LmNsZWFyZml4OmFmdGVye2NsZWFyOmJvdGh9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLm1pbi5jc3Ncbi8vIG1vZHVsZSBpZCA9IDI3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblxyXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHRoaXNbaV07XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGl0ZW1bMV0gKyBcIn1cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcclxuXHR9O1xyXG5cclxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxyXG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcclxuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XHJcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcclxuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxyXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xyXG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXHJcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXHJcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXHJcblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXHJcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XHJcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRyZXR1cm4gbGlzdDtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBzdHlsZXNJbkRvbSA9IHt9LFxyXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xyXG5cdFx0dmFyIG1lbW87XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRyZXR1cm4gbWVtbztcclxuXHRcdH07XHJcblx0fSxcclxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAvbXNpZSBbNi05XVxcYi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcclxuXHR9KSxcclxuXHRnZXRIZWFkRWxlbWVudCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xyXG5cdH0pLFxyXG5cdHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsLFxyXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxyXG5cdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW107XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcclxuXHRpZih0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcclxuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xyXG5cdH1cclxuXHJcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XHJcblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xyXG5cclxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgPGhlYWQ+LlxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XHJcblxyXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XHJcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XHJcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xyXG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XHJcblx0XHR9XHJcblx0XHRpZihuZXdMaXN0KSB7XHJcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XHJcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcclxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xyXG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcclxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XHJcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRpZihkb21TdHlsZSkge1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzKGxpc3QpIHtcclxuXHR2YXIgc3R5bGVzID0gW107XHJcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XHJcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xyXG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XHJcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xyXG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XHJcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XHJcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcclxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcclxuXHRcdGVsc2VcclxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xyXG5cdH1cclxuXHRyZXR1cm4gc3R5bGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KSB7XHJcblx0dmFyIGhlYWQgPSBnZXRIZWFkRWxlbWVudCgpO1xyXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xyXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XHJcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBoZWFkLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIGlmKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XHJcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xyXG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xyXG5cdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XHJcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHR2YXIgaWR4ID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZUVsZW1lbnQpO1xyXG5cdGlmKGlkeCA+PSAwKSB7XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuXHRzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KTtcclxuXHRyZXR1cm4gc3R5bGVFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKSB7XHJcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XHJcblx0bGlua0VsZW1lbnQucmVsID0gXCJzdHlsZXNoZWV0XCI7XHJcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmtFbGVtZW50KTtcclxuXHRyZXR1cm4gbGlua0VsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQsIHVwZGF0ZSwgcmVtb3ZlO1xyXG5cclxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcclxuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XHJcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKTtcclxuXHR9IGVsc2UgaWYob2JqLnNvdXJjZU1hcCAmJlxyXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcclxuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcclxuXHRcdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlRWxlbWVudC5ocmVmKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZShvYmopO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XHJcblx0XHRpZihuZXdPYmopIHtcclxuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZW1vdmUoKTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcclxuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcclxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xyXG5cclxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xyXG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2RlcztcclxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKG1lZGlhKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXHJcblx0fVxyXG5cclxuXHRpZihzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcclxuXHR9IGVsc2Uge1xyXG5cdFx0d2hpbGUoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcclxuXHRcdH1cclxuXHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUxpbmsobGlua0VsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcclxuXHJcblx0aWYoc291cmNlTWFwKSB7XHJcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxyXG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xyXG5cdH1cclxuXHJcblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XHJcblxyXG5cdHZhciBvbGRTcmMgPSBsaW5rRWxlbWVudC5ocmVmO1xyXG5cclxuXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuXHJcblx0aWYob2xkU3JjKVxyXG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanMhLi9hcHAuc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanMhLi9hcHAuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcyEuL2FwcC5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3R5bGUtbG9hZGVyIS4vfi9jc3MtbG9hZGVyIS4vfi9zYXNzLWxvYWRlciEuL2FwcC9zdHlsZXMvYXBwLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDI3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5wYWdlLXRpdGxlIHtcXG4gIG1hcmdpbi10b3A6IDIuNXJlbTtcXG4gIG1hcmdpbi1ib3R0b206IDIuNXJlbTtcXG4gIGNvbG9yOiAjNTU1OyB9XFxuXFxuaW5wdXRbdHlwZT1zZWFyY2hdIHtcXG4gIGJveC1zaGFkb3c6IG5vbmU7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vc2Fzcy1sb2FkZXIhLi9hcHAvc3R5bGVzL2FwcC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAyNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==